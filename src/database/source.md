# actioncomponents

## ActionComponent

`ActionComponents` are derived from [Actions](actions/Action.md). They are meant to facilitate the setup of
complex simulations by splitting the definition of each part of the spatial systems involved. They should be focused
on describing the geometry of the system, with [Physics](Physics/index.md) taking care of defining the equations.

`ActionComponent` is a base class for all `ActionComponents`.

It provides several public APIs to interact with other systems such as:

- `blocks()` to return the subdomains the component comprises
- `meshGeneratorName()` to return the name of the last mesh generator (if any) creating the mesh for this component

Some of these APIs are not implemented by default. They must be implemented by derived classes in order to
be used. For example:

- `volume()` should return the volume of the component
- `outerSurfaceBoundaries()` should return the boundaries on surface of the component
- `outerSurfaceArea()` should return the total outer surface area of the component.

Components will likely create other objects, for example for generating a mesh or for postprocessing purposes.
The following protected APIs should be overriden. This list is intended to grow as the uses for `ActionComponents` expand.

- `addMeshGenerators()` to add [MeshGenerators](syntax/Mesh/index.md) that create the mesh for the component. An example is the [CylinderComponent.md].
  Not all components will use mesh generators to describe their mesh.
- `addUserObjects()` to add [UserObjects](syntax/UserObjects/index.md) related to the component. For example, a [LayeredSideAverageFunctor.md] that
  aligns with the component for postprocessing or field transfer use.
- `addPositionsObjects()` to add [Positions](syntax/Positions/index.md) object that describe the location of the component

Additionally the following routines may be overriden:

- `setupComponent()` for any component-specific initialization that does not consist of adding an object
- `actOnAdditionalTasks()` to any component-specific initialization that requires a task that is not currently
  present in `ActionComponent::act()`.


`ActionComponents` are not compatible with [Components](Components/index.md optional=True). `ActionComponents` are intended
to be a rework on `Components` that does not hard-code the equations to be defined on the components and
can co-exist with the `[Mesh]` block.

Because tasks cannot be inherited by derived [Actions](Action.md), every component should be registered to every task it requires, including
all its parent classes' tasks. We recommend using the `addRequiredTask(task_name)` routine to make sure any derived `ActionComponent` class
is registered properly to its parent classes' tasks.

## CylinderComponent


The `CylinderComponent` is a simple [ActionComponent.md] which adds a cylinder to
the mesh. The user selects the dimensionality of the cylinder using the [!param](/ActionComponents/CylinderComponent/dimension) parameter.

- 0D is currently unsupported
- 1D makes the cylinder a simple 1D line, with attributes to keep track of its true radius and volume
- 2D makes the cylinder a rectangle within a local 2D RZ frame of reference
- 3D is not implemented, and would create a 3D cylindrical mesh.


[Physics](Physics/index.md) can be created on this component using the [!param](/ActionComponents/CylinderComponent/physics)
parameter. This parameter accepts a vector of names of `Physics`. The name of the `Physics` is generally
found in the innermost block. For example, in the snippet below, the diffusion `Physics` is called `added_from_component`.


The cylinder component on which the `component_with_physics` [DiffusionCG.md] is active is then
created as shown below:





## MeshGeneratorComponent

The `MeshGeneratorComponent` is a geometrical component which lives on the mesh output by a mesh generator.
The component's block restriction is set to the blocks of mesh generated by this mesh generator.

### Using saved meshes

When using the 'saved_mesh' option for the [!param](/ActionComponents/MeshGeneratorComponent/mesh_generator_type) parameter,

- the final mesh generator should be specified in the `[Mesh]` block, as explained in [this paragraph](syntax/Mesh/index.md#final)
- the mesh used by a `MeshGeneratorComponent` should be a saved mesh, using the [!param](/Mesh/CartesianMeshGenerator/save_with_name) parameter of mesh generators
- the mesh used should *likely* not be present in the `[Mesh]` block final mesh, as they would overlap with the `MeshGeneratorComponent` mesh.
  The saved mesh is added to the final mesh.
- the blocks on the saved mesh must have different block IDs and names from the other parts of the simulation
  mesh, as the spatial definition of the component is based on the saved mesh's blocks.
  We strongly recommend using a prefix to distinguish the component's blocks' names. A [RenameBlockGenerator.md]
  can be used for that purpose.

### Using the final mesh generator

When using the 'final_generator' option for the [!param](/ActionComponents/MeshGeneratorComponent/mesh_generator_type) parameter,
the mesh will not be duplicated; the final mesh from the [Mesh](syntax/Mesh/index.md) block will be used.




## PhysicsComponentBase

The `PhysicsComponentBase` is a base class designed to facilitate the use of [Physics](Physics/index.md)
by an [ActionComponent.md]. It offers:

- a [!param](/ActionComponents/CylinderComponent/physics) parameter in which the user lists the [Physics](Physics/index.md)
  active on the component.
- a default implementation of `initializeComponentPhysics()`, which simply adds the component to the `Physics`.
  This implementation may be overriden in derived classes.

An [ActionComponent.md] inheriting `PhysicsComponentBase` must be registered to the `init_component_physics`
task. For example,


This helper leverages virtual inheritance: it inherits the [ActionComponent.md] class virtually.
This offers some simplicity in its definition, but components leveraging this helper must also inherit
the `ActionComponent` class virtually.

# actions

## MOOSE Action System

MOOSE *Actions* are used to execute *tasks*. Each application registers
numerous *actions*, *tasks*, and *syntax*. Each task is associated with one or more
actions, and each action may perform one or more tasks. Syntax is used by the
input file parser to generate actions.

Common uses for actions are to perform setup and create MOOSE objects.

### Creating Actions

To create a new action, first derive from the appropriate base class: if the new action
is to correspond to creating MOOSE objects from an input file, then derive
from `MooseObjectAction`; else, derive from `Action`.

The `act()` method must be implemented to perform the associated task(s). If the
action will be registered to multiple tasks, then the variable `_current_task`
can be queried to determine the current task, for example,

``` language=cpp
void
ExampleAction::act()
{
  if (_current_task == "example_task_a")
  {
    // "example_task_a" execution
  }
  else if (_current_task == "example_task_b")
  {
    // "example_task_b" execution
  }
}
```

`MooseObjectAction`s, have the member variables `_type` and `_moose_object_pars`,
which correspond to the type and [InputParameters.md] of the MOOSE object to
be created, respectively. For example, the action to create a BC object has
the following `act()` method:


The action should be registered to one or more tasks using the `registerMooseAction`
macro (conventionally in the action source file), for example,

``` language=cpp
registerMooseAction("ExampleApp", ExampleAction, "example_task_a");
registerMooseAction("ExampleApp", ExampleAction, "example_task_b");
```

### Registering Tasks id=registering_tasks

Like MOOSE objects, tasks and syntax are registered in an application's constructor,
conventionally from a static method called `registerAll`. MOOSE's tasks, actions,
and syntax are defined in [Moose.C](framework/src/base/Moose.C), for example.

Several macros are relevant for registration of tasks and syntax.

Tasks must be registered using the `registerTask` macro:

``` language=cpp
registerTask("task_name", is_required)
```

where `task_name` is the name of the new task, and `is_required` should be set
to `true` if the task is required by the application. A required task always
has all of its associated actions executed, even if no syntax triggers it.

Tasks may have dependencies between them. The macro `addTaskDependency` is
used to declare that a task depends on another, for example,

``` language=cpp
addTaskDependency("secondary_task", "primary_task")
```

Here a task called "secondary_task" will be executed sometime after the task
called "primary_task".

### Registering Syntax id=registering_syntax

There are two macros associated with registering syntax to an action/task:
`registerSyntax` and `registerSyntaxTask`:

``` language=cpp
registerSyntax(action, syntax);
registerSyntaxTask(action, syntax, task);
```

The difference between these is only apparent when the action has more than one
task registered to it; in this case, the additional argument in
`registerSyntaxTask` specifies which task of the specified action to execute.

For example, the [AddKernelAction.md] is registered to tasks for adding kernels
and aux kernels:

``` language=cpp
registerSyntaxTask("AddKernelAction", "Kernels/*", "add_kernel");
registerSyntaxTask("AddKernelAction", "AuxKernels/*", "add_aux_kernel");
```

The syntax need not be associated only to sub-blocks in the input file. For example,
the existence of a `Mesh` block triggers [SetupMeshCompleteAction.md]:

``` language=cpp
registerSyntax("SetupMeshCompleteAction", "Mesh");
```

Also, note that actions do not necessarily require registration of any associated
syntax to execute a task: if that task is registered as required, then the action
always will be built:

``` language=cpp
registerTask("task_name", true);
```

### How Actions Are Built

The input file parser creates actions by finding actions/tasks that are associated to
a given syntax via the syntax registration calls (see [#registering_syntax]).
After these actions are created, other actions may be "auto-built" to satisfy
unsatisfied *required* (see [#registering_tasks]) tasks: the tasks are sorted
via the dependency resolver, using the registered dependencies between them, and
then for each unsatisfied, required task, a loop over all of the actions registered
to that task is performed:

[!for!begin condition=each unsatisfied, required task $T$]
[!for!begin condition=each action $A$ registered to $T$]
[!ifthen!if condition=all required parameters of $A$ are valid]
[!state text=build $A$]
[!ifthen!end]
[!for!end]
[!for!end]

Note that there is no "break" statement after "build $A$"; that is, the auto-building
of actions does not stop after the first action has been built.

### Relationship Managers and Actions

If adding any `MooseObjects` in a custom action and those objects have
associated relationship managers, then the
`addRelationshipManagers(Moose::RelationshipManagerType input_rm_type)` must be
overridden. Both
the `ContactAction` in the contact module, and `PorousFlowActionBase` in the
porous flow module provide examples of overriding this method. For the reasons
behind why this must be done in the action system, please see [RelationshipManager.md#rm_action].

### Controlling Action Parameters

Action parameters can be controlled like other MOOSE object parameters. See
[syntax/Controls/index.md#controllable_params_added_by_actions] for more
information.

### Troubleshooting Actions

There are two debugging flags that are particularly useful for troubleshooting
actions/tasks:

- `show_actions`: show the list of actions as they execute (in order).
- `show_action_dependencies`: show the action dependency sets generated by the
  task dependency resolution, with the groups ordered by execution.

These flags are used in a `Debug` block:

```
[Debug]
  show_actions = true
  show_action_dependencies = true
[]
```

### Additional Notes

The following is a list of miscellaneous notes that may be useful to advanced
developers:

- The lifetime of actions is the entire simulation.
- Actions can be obtained via the `ActionWarehouse` with methods such as `getAction`,
  `getActions`, etc.
- Actions may be added by other actions, but the added action will only execute
  for tasks occurring after the task in which the action is added.

## AdaptivityAction


An `Adaptivity` object may be specified inside the `[Adaptivity]` block.
`Markers` and `Indicators` for adaptivity are specified within nested sub-blocks.

This action adds the algebraic and geometric [relationship managers](RelationshipManager.md),
sets the parameters of the adaptivity object and initializes it.

More information about adaptivity can be found on the [Adaptivity syntax page](syntax/Adaptivity/index.md).


## AddActionComponentAction


This is a meta-action, which means it is an [Action.md] adding other `Actions` to
the simulation.




## AddAuxKernelAction

This action serves as a shortcut to add an AuxKernel nested within an AuxVariable block in the input file syntax.

The syntax is

```python
[AuxVariables]
  [foo]
    order = SECOND
    [AuxKernel]
      type = bar
    []
  []
[]
```

See [AuxKernel](source/auxkernels/AuxKernel.md) for more information about AuxKernels.

## AddAuxVariableAction


This action derives from the [AddVariableAction.md]. It checks the auxiliary variable family and type before
adding it to the [Problem](syntax/Problem/index.md).

Auxiliary variables, which are not directly being solved for in the nonlinear system,
are specified as an object inside the `[AuxVariables]` block.

More information about auxiliary variables can be found on the [AuxVariables syntax page](syntax/AuxVariables/index.md).


## AddBCAction


Boundary conditions are specified as an object inside the `[BCs]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about boundary conditions can be found on the [BCs syntax page](syntax/BCs/index.md).

Please note that finite volume boundary conditions `FVBCs` are specified in the `[FVBCs]` block handled
by the [AddFVBCAction.md] action.


## AddBoundAction


Additional documentation may be found on the [syntax page](syntax/Bounds/index.md) and
in each `Bounds` object's individual documentation.


## AddBoundsVectorsAction


Bounds vectors are specified as an object inside the `[Bounds]` block.
This action adds them to the [nonlinear system](NonlinearSystem.md).

More information about adding vectors to the linear system using the `[Bounds]` block
may be found on the [Bounds syntax page](syntax/Bounds/index.md).


## AddChainControlAction

This action adds a [ChainControl](syntax/ChainControls/index.md) to the `ControlWarehouse`.


## AddConstraintAction


Constraints are specified as an object inside the `[Constraints]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about `Constraints` may be found on the
[Constraints syntax documentation](syntax/Constraints/index.md).


## AddControlAction


Input file blocks and parameters may be controlled (enabled/disabled/modified)
using `Controls` specified in the `[Controls]` block.
This action adds them to the `ControlWarehouse`.

More information about the Control system may be found on the
[Controls syntax page](syntax/Controls/index.md).


## AddConvergenceAction

Adds a [Convergence](syntax/Convergence/index.md) object to the `Problem`.


## AddCorrectorAction

Adds `Corrector` objects to the simulation that are listed under `Correctors/` in the input file.
This action adds them to the [Problem](FEProblem.md).


## AddDamperAction


`Dampers` are specified as an object inside the `[Dampers]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about `Dampers` may be found on the
[Dampers syntax documentation](syntax/Dampers/index.md).


## AddDefaultConvergenceAction

This action adds a default [Convergence](syntax/Convergence/index.md) object if requested
by the `Problem`.

## AddDGKernelAction


`DGKernels` are specified as an object inside the `[DGKernels]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about discontinuous Galerkin kernels (`DGKernels`) may be
found on the [DGKernels syntax page](syntax/DGKernels/index.md).


## AddDiracKernelAction


`DiracKernels` are specified as an object inside the `[DiracKernels]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about Dirac kernels may be found on the
[Dirac Kernels syntax page](syntax/DiracKernels/index.md).


## AddDistributionAction


`Distributions` are specified as an object inside the `[Distributions]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about `Distributions` may be found on the
[Distribution syntax page](syntax/Distributions/index.md).


## AddElementalFieldAction


The MOOSE adaptivity system relies on error calculations that inform a marker that dictates
if an element should be refined or coarsened. The error and the markers rely on auxiliary
field variables, this actions creates those field variables. Please refer to
[syntax/Adaptivity/index.md] for details regarding the adaptivity system.



## AddFieldSplitAction


Field splits are specified as an object inside the `[FSP]` block, nested in the `[Preconditioning]`
block. This action adds them to the [Problem](syntax/Problem/index.md).

MOOSE can use field [splits](source/splits/Split.md) with Schur decomposition to
[precondition](syntax/Preconditioning/index.md) nonlinear systems.


## AddFunctionAction


`Functions` are specified as an object inside the `[Functions]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about `Functions` may be found on the
[Functions syntax documentation](syntax/Functions/index.md).


## AddFunctorMaterialAction


`FunctorMaterials` are specified as an object inside the `[FunctorMaterials]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about `FunctorMaterials` and their parameters can be found on the
[FunctorMaterials syntax documentation](syntax/FunctorMaterials/index.md).


## AddFVBCAction


Finite volume boundary conditions are specified as an object inside the `[FVBCs]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about finite volume boundary conditions can be found on the
[FVBCs syntax page](syntax/FVBCs/index.md).

Please note that finite element boundary conditions `BCs` are specified in the `[BCs]` block
handled by the [AddBCAction.md] action.


## AddFVInitialConditionAction


Initial conditions for finite volume variables are specified as an object inside the `[FVICs]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about setting finite volume variable initial conditions can be found on the
[FVICs syntax documentation](syntax/FVICs/index.md).


## AddFVInterfaceKernelAction


Finite volume interface kernels are specified as an object inside the `[FVInterfaceKernels]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about finite volume interface kernels can be found on the
[FVInterfaceKernels syntax page](syntax/FVInterfaceKernels/index.md).


## AddFVKernelAction


Finite volume kernels are specified as an object inside the `[FVKernels]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about finite volume kernels can be found on the
[FVKernels syntax documentation](syntax/FVKernels/index.md).


## AddHDGBCAction

This action adds `HDGBCs` to the
[finite element problem](syntax/Problem/index.md).
`HDGBCs` are specified as objects inside the `[HDGBCs]` block.

More information about kernels can be found on the
[HDG BCs syntax page](syntax/HDGBCs/index.md).


## AddHDGKernelAction

This action adds `HDGKernels` to the
[finite element problem](syntax/Problem/index.md).
`HDGKernels` are specified as objects inside the `[HDGKernels]` block.

More information about kernels can be found on the
[HDG Kernels syntax page](syntax/HDGKernels/index.md).


## AddIndicatorAction

The AddIndicatorAction is a [MooseObjectAction.md] that creates the specified Indicator object for
each block of the `[Adaptivity/Indicators]` block of an input file. This action adds this object to
the [Problem](syntax/Problem/index.md). See [syntax/Adaptivity/index.md] for more information.


## AddInitialConditionAction


Initial conditions are specified as an object inside the `[ICs]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about setting variable initial conditions can be found on the
[ICs syntax documentation](syntax/ICs/index.md).


## AddInterfaceKernelAction


Interface kernels are specified as an object inside the `[InterfaceKernels]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about interface kernels can be found on the
[InterfaceKernels syntax page](syntax/InterfaceKernels/index.md).


## AddKernelAction


This action handles both `Kernels` and `AuxKernels`.
`Kernels` are specified as an object inside the `[Kernels]` block, while `AuxKernels` are specified
as an object inside the `[AuxKernels]` block. This action adds them to the
[Problem](syntax/Problem/index.md).

More information about kernels can be found on the
[Kernels syntax documentation](syntax/Kernels/index.md).


## AddLinearFVBCAction


Linear finite volume boundary conditions are specified as objects inside the `[LinearFVBCs]` block.
This action adds them to the [Problem](syntax/Problem/index.md). The main responsibility of these boundary conditions is to compute contributions to the [linear system matrix and right hand side](LinearSystem.md),
which are then used by [Linear FV kernels](syntax/LinearFVKernels/index.md).

More information about linear finite volume boundary conditions can be found on the
[Linear FVBCs syntax page](syntax/LinearFVBCs/index.md).


## AddLinearFVKernelAction


Linear finite volume kernels are specified as objects inside the `[LinearFVKernels]` block.
This action adds them to the [Problem](syntax/Problem/index.md). The main responsibility of
these kernels is to add contributions to the [linear system matrix and right hand side](LinearSystem.md).

More information about linear finite volume kernels can be found on the
[LinearFVKernels syntax documentation](syntax/LinearFVKernels/index.md).


## AddMarkerAction

The AddMarkerAction is a [MooseObjectAction.md] that creates the specified Marker object for
each block of the `[Adaptivity/Markers]` block of an input file, then adds them to the
[Problem](syntax/Problem/index.md). See [syntax/Adaptivity/index.md] for more information.


## AddMaterialAction


`Materials` are specified as an object inside the `[Materials]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about `Materials` and their parameters can be found on the
[Materials syntax documentation](syntax/Materials/index.md).


## AddMeshDivisionAction


`MeshDivisions` are specified as an object inside the `[MeshDivisions]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about `MeshDivisions` may be found on the
[MeshDivisions syntax documentation](syntax/MeshDivisions/index.md).


## AddMeshGeneratorAction

Adds `MeshGenerator` objects into the system that are listed under `MeshGenerators/` in the input file.
This action adds them to the [application](MooseApp.md).

The preferred syntax for adding `MeshGenerators` is to add them in the `[Mesh]` block.


## AddMeshModifiersAction

Adds `MeshModifier` objects into the system that are listed under `MeshModifiers/` in the input file.
This action adds them to the [application](MooseApp.md).

The preferred syntax for adding `MeshModifiers` is to add them in the `[Mesh]` block.

<!-- !syntax parameters /Mesh/AddMeshModifiersAction -->

## AddMultiAppAction

This Action is responsible for adding all MultiApp objects listed within the `[MultiApps]`
block in a MOOSE input file. This action adds them to the [Problem](syntax/Problem/index.md).
See [syntax/MultiApps/index.md] for more information.


## AddNodalKernelAction


Kernels for nodal variables are specified as an object inside the `[NodalKernels]` block.
This [MooseObjectAction.md] adds them to the [Problem](syntax/Problem/index.md).

More information about `NodalKernels` may be found on the
[NodalKernels syntax documentation](syntax/NodalKernels/index.md).


## AddNodalNormalsAction


Nodal normals can be used to compute the normals of a nodal variable in various locations.
They are specified as an object inside the `[NodalNormals]` block. They are composed of
a `NodalNormalsPreprocessor` and a `NodalNormalsEvaluator`, which this [MooseObjectAction.md]
adds to the [Problem](syntax/Problem/index.md).

This action adds and saves the nodal normals in the `nodal_normal_x`, `nodal_normal_y`
and `nodal_normal_z` auxiliary Lagrange nodal variables of the order specified with the
[!param](/NodalNormals/AddNodalNormalsAction/order) parameter.

More information about `NodalNormals` may be found on the
[NodalNormals syntax documentation](syntax/NodalNormals/index.md).


## AddOutputAction


### Overview

This [MooseObjectAction](MooseObjectAction.md) acts on the `[Outputs]` block
to create Output objects. See [syntax/Outputs/index.md] for more information.


## AddPeriodicBCAction


Periodic boundary conditions are specified as an object inside the `[Periodic]` sub-block of the `[BCs]` block.
This action adds them to the [Problem](syntax/Problem/index.md).

More information about periodic boundary conditions and their parameters can be found on the
[periodic boundary condition syntax documentation](syntax/BCs/Periodic/index.md).

### Example syntax

In this example, periodic boundary conditions are set on variable `u` in the X and Y axis directions.
The boundaries that are matched on all sides of the system are automatically detected, due to using the
[!param](/BCs/Periodic/AddPeriodicBCAction/auto_direction) parameter.



## AddPositionsAction


Additional documentation may be found on the [syntax page](syntax/Positions/index.md) and
in each `Positions` object's individual documentation.


## AddPostprocessorAction


`Postprocessors` are specified as an object inside the `[Postprocessors]` block.
This [MooseObjectAction.md] adds them to the [Problem](syntax/Problem/index.md).

More information about `Postprocessors` may be found on the
[Postprocessors syntax documentation](syntax/Postprocessors/index.md).


## AddReporterAction

This action creates Reporter objects from the `[Reporters]` block then adds them to the
[Problem](syntax/Problem/index.md). For more information about this system, see
[Reporters/index.md].



## AddSamplerAction


`Samplers` are specified as an object inside the `[Samplers]` block.
This [MooseObjectAction.md] adds them to the [Problem](syntax/Problem/index.md).

More information about `Samplers` may be found on the
[Samplers syntax documentation](syntax/Samplers/index.md).


## AddScalarKernelAction


This action handles both `ScalarKernels` and `AuxScalarKernels`.

Kernels for scalar variables are specified as an object inside the `[ScalarKernels]` block,
while auxiliary kernels for scalar variables are specified as an object inside the `[AuxScalarKernels]` block.
This [MooseObjectAction.md] adds them to the [Problem](syntax/Problem/index.md).

More information about `ScalarKernels` may be found on the
[ScalarKernels syntax documentation](syntax/ScalarKernels/index.md).


## AddTimesAction


Additional documentation may be found on the [syntax page](syntax/Times/index.md) and
in each `Times` object's individual documentation.


## AddTimeStepperAction


This action handles both `[TimeStepper]` and `[TimeSteppers]` blocks. It supports the use of the `[TimeStepper]` block where only one time stepper object can be specified and the use of `[TimeSteppers]` block where multiple time stepper objects can be specified to compose a time step size with given composition rules. If multiple time steppers(>1) are provided in `[TimeSteppers]` block, a time stepper object named `CompositionDT` will be added to the Time Stepper System which produces the composed time step size with input time steppers.


More information about Time Stepper System and CompositionDT time stepper may be found on the [Time Stepper System syntax documentation](syntax/Executioner/TimeSteppers/index.md).



## AddTransferAction

The `AddTransferAction` is the general [MooseObjectAction.md] that creates `Transfer` objects when
listed within the `[Transfers]` block of an input file.


## AddUserObjectAction


`UserObjects` are specified as an object inside the `[UserObjects]` block.
This [MooseObjectAction.md] adds them to the [Problem](syntax/Problem/index.md).

More information about `UserObjects` may be found on the
[UserObjects syntax documentation](syntax/UserObjects/index.md).


## AddVariableAction


Finite element and scalar `Variables` are specified as an object inside the `[Variables]` block.
This [MooseObjectAction.md] adds them to the [Problem](syntax/Problem/index.md).

More information about `Variables` may be found on the
[Variables syntax documentation](syntax/Variables/index.md).


## AddVectorPostprocessorAction


Vectors of postprocessors, `VectorPostprocessors`, are specified as an object inside the
`[VectorPostprocessors]` block. This [MooseObjectAction.md] adds them to the
[Problem](syntax/Problem/index.md).


More information about `VectorPostprocessors` may be found on the
[VectorPostprocessors syntax documentation](syntax/VectorPostprocessors/index.md).


## AutoCheckpointAction


### Overview

An action, that acts when the `[Outputs]` block exists. It adds the
[!param](/Outputs/checkpoint) and [!param](/Outputs/wall_time_checkpoint)
short-cut syntax parameters. For example, the following enables time_step_interval
based checkpoints while disabling wall time based checkpoints.

```text
[Outputs]
  checkpoint = true
  wall_time_checkpoint = false
[]
```

Please refer to the [syntax/Outputs/index.md] for more information.


## ChainControlSetupAction

This [Action.md] is responsible for setup and checks that should occur after
all [ChainControls](syntax/ChainControls/index.md) have been added. It does
the following:

- Checks that all requested [/ChainControlData.md] has been declared and throws
  an error if not.
- Calls `init()` on all `ChainControls`.
- Adds dependencies for each `ChainControl` on other `ChainControls` based on
  the dependencies of the `ChainControlData`; if the `ChainControl` depends on
  a `ChainControlData`, then it depends on the `ChainControl` that declared that data.

## CheckFVBCAction


Checking the integrity of finite volume boundary conditions can be requested in the
`[Problem]` block as shown below.


More information about finite volume boundary conditions may be found on the
[FVBCs syntax documentation](syntax/FVBCs/index.md).


## CheckLegacyParamsAction

This action provides an informative error to users when they are using
the legacy input parameter construction method. Said construction method
is no longer supported.

See [2021_11.md#legacy-input-parameter-deprecation optional=true] for more information.

## CombineComponentsMeshes

This [Action.md] serves to combine the meshes of each [ActionComponent.md] into a final simulation mesh.
The mesh from the `[Mesh]` block is combined with the components' meshes as well.

The components' meshes are currently combined with a [CombinerGenerator.md]. This means the
mesh is not stitched at the interfaces. The user must specify the connection between components
using interface conditions. These can for example be set with [boundary conditions](syntax/BCs/index.md) or dedicated [UserObjects](UserObjects/index.md).




## CommonOutputAction


### Overview

An action, that acts when the `[Outputs]` block exists. It adds short-cut syntax options, such as the
[!param](/Outputs/exodus) parameter, as well as common parameters that are applied to all output
objects. For example, the following enables two output objects and sets the output
[!param](/Outputs/time_step_interval) to every 10 timesteps for both objects.

```text
[Outputs]
  exodus = true
  csv = true
  interval = 10
[]
```

Please refer to the [syntax/Outputs/index.md] for more information.


## ComposeTimeStepperAction


This action specifies the [CompositionDT.md] object when multiple time steppers are provided in the `[TimeSteppers]` block. If there are more than one time steppers provided, it will add a CompositionDT in the time stepper system and make the CompositionDT as the final time stepper to use in the transient simulations. An optional parameter [!param](/Executioner/TimeSteppers/ComposeTimeStepperAction/lower_bound) is provided to set a lower bound for the computed time step size. It can be specified with any time stepper(s) in the `[TimeSteppers]` block.

An example of using a growing lower bound to limit the time step size as:


More information about Time Stepper System and [CompositionDT.md] time stepper may be found on the [Time Stepper System syntax documentation](syntax/Executioner/TimeSteppers/index.md).



## CopyNodalVarsAction


This action handles the `initial_from_file_var` [`Variables`](syntax/Variables/index.md) parameter
as used below,


This syntax is restricted to restarting from `Exodus` files. More information about alternative
options to restart simulations may be found in the
[Restart/Recover system](/application_usage/restart_recover.md optional=True).


## CreateApplicationBlockAction


This action is a placeholder for parsing the Application block. Please do not add new parameters to this action. A new capability to support adding new parameters to `Application` block is under development and will be released soon.

More information about the `Application` block can be found on the [Application syntax page](syntax/Application/index.md).


## CreateDisplacedProblemAction


The displaced problem is created by setting the `displacements` variables in the
`[Mesh]` block, unless `use_displaced_mesh = false` is set. More information about
using a displaced problem may be found in the [Mesh syntax documentation](syntax/Mesh/index.md).


## CreateExecutionerAction


This action can add a default preconditioner if none is specified.
This action examines the parameter in the `[Executioner]` block for consistency with the `Problem`.

More information about `Executioners` may be found on the
[Executioners syntax documentation](syntax/Executioner/index.md).


## CreateMeshSetupActionsForComponents


This `Action` creates the [SetupMeshAction.md] and the [SetupMeshCompleteAction.md] when the
`[ActionComponents]` syntax is used. These two actions are normally only created if the `[Mesh]`
syntax is used.

To select specific `Mesh` operations, such as adding a partitioner or selecting the mesh parallel
type, a `[Mesh]` block should be used, in which case, this `Action` does not perform any operation.


## CreateProblemAction


More information about the `Problem` system may be found on the
[Problems syntax documentation](syntax/Problem/index.md).


## DeprecatedBlockAction


Large design changes may require deprecating a `Block` (`[<block_name>]` syntax). This may
be used by developers to let users know they need to update their input files.


## DisplayGhostingAction

The `DisplayGhostingAction` is for outputting the ghosting of your simulation. In MOOSE, we attempt
to ghost only the minimum amount of data for running the simulation. In order to know what ghosting
we need each object can add one or more `RelationshipManager` classes. This object sets up
several `AuxVariables` and `AuxKernels` for outputting both the "Geometric" and "Algebraic" ghosting.

To output ghosting add the following parameter(s) to your Mesh block:
```
[Mesh]
  ...
  output_ghosting = true
  include_local_in_ghosting = true
[]
```

The `include_local_in_ghosting` parameter will also include all of a processors local elements
in the ghosting field to give you a complete view of ghosting.

Example:



## DynamicObjectRegistrationAction


If an object required for a simulation is present in a pre-compiled library that is
not already linked to the application used, it may be dynamically linked using the following
syntax, handled by `DynamicObjectRegistrationAction`,


More information about dynamic loading may be found on [Google](https://lmgtfy.app/?q=dynamic+loading).


## ElementIDOutputAction


This action is triggered when [!param](/Outputs/Exodus/output_extra_element_ids) is set to `true`. AuxVariables and AuxKernels relevant to the extra element ids defined on the mesh are automatically added to the problem, and the resulting element integers are also outputted to the Exodus file.


More information can be found on the [Exodus output documentation page](outputs/Exodus.md).




## GlobalParamsAction


Global parameters are set in their own `[GlobalParams]` block as shown below:


More information about the `GlobalParams` system may be found on the
[GlobalParams syntax documentation](syntax/GlobalParams/index.md).


## MaterialDerivativeTestAction


Sets up

- [MaterialDerivativeTestKernel](/MaterialDerivativeTestKernel.md),
- [MaterialDerivativeRankTwoTestKernel](/MaterialDerivativeRankTwoTestKernel.md)
- [MaterialDerivativeRankFourTestKernel](/MaterialDerivativeRankFourTestKernel.md)

kernels, the corresponding variables they act on, and a sparse coupling matrix that
optimizes the Jacobian test performance.



## MaterialOutputAction


This [Action.md] is used to output the material properties computed by a [Material](syntax/Materials/index.md)
or a [FunctorMaterial](syntax/FunctorMaterials/index.md) to an auxiliary variable.
Vector, tensor, and array-valued properties can be output to variables prefixed with the component or index.


## MooseObjectAction

Base class for all the actions creating a MOOSE object. The `type` of the object is specified
in this class.

Please refer to the `Action` [page](Action.md) for more information about actions.

## PartitionerAction


`Partitioners` are specified as an object inside the `[Partitioner]` block within the `[Mesh]`
block, as shown below


More information about `Partitioners` may be found on the
[Partitioners syntax documentation](syntax/Mesh/Partitioner/index.md).


## ProjectedStatefulMaterialStorageAction

### Description

The `ProjectedStatefulMaterialStorageAction` is the main action in the
[ProjectedStatefulMaterialStorage](/ProjectedStatefulMaterialStorage/index.md)
system which sets up all necessary objects to project material property
components onto nodal or elemental basis functions.

Projected and interpolated old state can be enabled using the
`use_interpolated_state` parameter available in the `MaterialPropertyInterface`.

#### Objects set up by the action

The action will set up aux variables for each scalar component of the projected properties listed in
[!param](/ProjectedStatefulMaterialStorage/ProjectedStatefulMaterialStorageAction/projected_props).
The variables will be marked as hidden and will not appear in any outputs.

The type of each projected material property will be determined automatically and a corresponding
[InterpolatedStatefulMaterial](InterpolatedStatefulMaterial.md) object will be created to
reconstitute a material property of the same type from the old state of the projected variables.

The [!param](/ProjectedStatefulMaterialStorage/ProjectedStatefulMaterialStorageAction/family)
parameter determines whether nodal or elemental basis functions will be used.

##### Elemental basis functions

A [ProjectedStatefulMaterialAux](/ProjectedStatefulMaterialAux.md) aux kernel of the appropriate
type will be added for each scalar material property component (e.g. vector or
tensor components) to perform an elemental projection of the property component.

##### Nodal basis functions

A [ProjectedStatefulMaterialNodalPatchRecovery](/ProjectedStatefulMaterialNodalPatchRecovery.md)
user object of the appropriate type will be created for each material property to prepare data
required for nodal patch recovery of each scalar material property component (e.g. vector or
tensor components).

A [ProjectedMaterialPropertyNodalPatchRecoveryAux](/ProjectedMaterialPropertyNodalPatchRecoveryAux.md)
aux kernel will be added for each scalar material property component to perform nodal patch recovery
using the data collected in the user object.

## ReadExecutorParamsAction


This [MooseObjectAction](MooseObjectAction.md) checks whether a [Preconditioner](syntax/Preconditioning/index.md) has
been specified in the `[Executor]` block, and if not creates a default preconditioner.

The addition of the default preconditioner is similar to what is performed by the [CreateExecutionerAction.md].


## SetAdaptivityOptionsAction

An [Action.md] that sets up the adaptivity for a simulation based on the top-level
`[Adaptivity]` input file block. See [syntax/Adaptivity/index.md] for more information.

## SetupDebugAction


### Overview

This [Action](Action.md) object acts whenever the `[Debug]` block exists in the input file and provides
parameters, as listed below, for creating various Output objects as well a flags for debugging the
action and/or parser system execution. Please refer to the [Debug/index.md] for more details.


## SetupMeshAction


The `SetupMeshAction` is responsible for

- setting the mesh base, which may come from `MeshGenerators`, from the legacy mesh loading (`file` parameter),
  or from a split mesh, a restart or a recovery process

- the uniform refinement parameters

- conversion from first to second order mesh

- the creation of the displaced mesh

- modifications to the mesh generation process when using split meshes

- mesh initialization


More information about the `Mesh` may be found on the
[Mesh syntax documentation](syntax/Mesh/index.md).


## SetupMeshCompleteAction


This action is ran after the mesh has been setup to ensure the mesh is ready for simulation.
It takes care of deleting unnecessary remote elements, of triggering uniform
refinement and general preparation of the mesh (neighbor search, renumbering, partitioning).


## SetupPreconditionerAction


A preconditioner for the nonlinear system is specified as an object inside the `[Preconditioner]` block.
This [Action.md] takes care of adding it to the [NonlinearSystemBase.md].

More information about preconditioners may be found on the
[Preconditioning syntax documentation](syntax/Preconditioning/index.md).


## SetupPredictorAction


A `Predictor` is specified as an object inside the `[Predictor]` block with the `[Executioner]` block.
This action checks the a transient executioner is being used then sets the `Predictor` of the [NonlinearSystemBase.md].

More information about predictors may be found on the
[Predictor syntax documentation](syntax/Executioner/Predictor/index.md).


## SetupQuadratureAction


A `Quadrature` is specified as an object inside the `[Quadrature]` block with the `[Executioner]` block
as shown below.


This action adds the default quadrature rule to the `Problem` then adds custom requested quadratures
in the specified blocks.

More information about quadratures may be found on the
[Quadrature syntax documentation](syntax/Executioner/Quadrature/index.md).


## SetupResidualDebugAction


### Overview

This [Action](Action.md) object acts whenever the `[Debug]` block exists in the input file and provides
parameters, as listed below, for creating the necessary object for computing the residual
for the variables listed in the [!param](/Debug/SetupResidualDebugAction/show_var_residual)
parameter. Please refer to the [Debug/index.md] for more details.



## SetupTimeIntegratorAction


A `TimeIntegrator` is specified as an object inside the `[TimeIntegrator]` block with the `[Executioner]` block
as shown below


This [MooseObjectAction.md] adds them to the [Problem](syntax/Problem/index.md).
More information about TimeIntegrators may be found on the
[TimeIntegrator syntax documentation](syntax/Executioner/TimeIntegrator/index.md).


# auxkernels

## AdvectiveFluxAux


### Description

The `AdvectiveFluxAux` AuxKernel is used to compute a component of an advective flux vector. The flux is computed as

\vec{J} \cdot \vec{n} = \vec{v} u \cdot \vec{n}

where $\vec{J}$ is the advection flux vector, $u$ is the advected quantity, $\vec{v}$ is the velocity, and $\vec{n}$ is the normal for the desired component which can be the x, y, z axis or the normal direction (only near boundaries).

This auxkernel supports CONSTANT and FIRST MONOMIAL AuxVariable types. The advection velocity is required with [!param](/AuxKernels/AdvectiveFluxAux/vel_x) for advection flux calculation. [!param](/Postprocessors/SideAdvectiveFluxIntegral/vel_y) and [!param](/Postprocessors/SideAdvectiveFluxIntegral/vel_z) are needed for 2D and 3D simulations. The advected quantity can be either a variable [!param](/AuxKernels/AdvectiveFluxAux/advected_variable) or material property [!param](/AuxKernels/AdvectiveFluxAux/advected_mat_prop).

The expression of the advective flux in this object is generic, as described, and may differ from the advective flux implemented in your physics implementation. If so, you may not use this object to compute the advective flux.

### Example Input Syntax





## ArrayParsedAux


### Overview

This auxiliary kernel is meant to emulate the behavior and syntax of [ParsedAux.md] for array variables.
Using [!param](/AuxKernels/ArrayParsedAux/expression), one can define a general parsed function dependent on array variables, scalar field variables, mesh coordinates, and time:

u_i = f(v_{1,i}, v_{2,i},..., w_1, w_2,..., x, y, z, t), \quad i=1,...,n,

where $u$ is the array variable specified in [!param](/AuxKernels/ArrayParsedAux/variable) with $n$ components, $i$ is the component index of the variable, $v$ are coupled array variables specified in [!param](/AuxKernels/ArrayParsedAux/coupled_array_variables), $w$ are coupled field variables specified in [!param](/AuxKernels/ArrayParsedAux/coupled_variables), and $x$, $y$, $z$, and $t$ are coordinates used if [!param](/AuxKernels/ArrayParsedAux/use_xyzt) is `true`.

### Example Input File Syntax

This is an example that defines the following expression:

\texttt{sum} = \sum_{i=1}^n\texttt{parsed}_i = \sum_{i=1}^n(\texttt{u}_i^2 + \texttt{v}_i)(x - \texttt{const})\pi





## ArrayVariableComponent

### Description

This auxiliary kernel copies a component of an array variable into a standard auxiliary variable.
It is noted that when the variable family and order are the same, the copy is exact, otherwise projection or prolongation will be involved.
The copied auxiliary variable can be used in all MOOSE objects that operate on standard variables.




## ArrayVarReductionAux


## Description

This auxiliary kernel performs a reduction operation on the values of an array variable $g$ (indexed as $g_i$).
Reduction operations include max, min, sum, and average.
These perform the following operations:

sum:

f = \sum\limits_{i=1}^I g_i.

average:

f = \frac{1}{I}\sum\limits_{i=1}^I g_i.

min:

f = \min\limits_{i=1,I} g_i.

max:

f = \max\limits_{i=1,I} g_i.




## AuxKernel

An `AuxKernel` computes values that are stored in "Auxiliary Variables".  There is an infinite number of ways to generate these values but some common ones are: based on other variables/data in the simulation (i.e. coupled data), read from an external file and interpolated from a Function.  The Auxiliary system is _extremely_ flexible on purpose.  The data values computed by `AuxKernel`s and stored in Auxiliary Variables (AuxVariables) are often used for visualization (i.e. written to output files) but can also be coupled back into other calculations (including in `Kernels`) or provided as the input to other systems such as `Postprocessors`.

When an auxiliary kernel depends on user objects, including postprocessors, those user objects are put in a group of user objects named as *pre_aux*, so that those user objects can be evaluated before the auxiliary kernel. By default, all user objects are evaluated after auxiliary kernel evaluation, i.e. in *post_aux* group. If the depending user objects depend on some other user objects, these indirectly depending user objects for auxiliary kernels are automatically put in the *pre_aux* group.

For more information: see the [documentation for the Auxiliary System](AuxKernels/index.md)

## BuildArrayVariableAux


### Example Syntax







## ConstantAux

The Constant AuxKernel creates a constant field over the domain. Truly constant field variables can likely be replaced with a [Postprocessor](/Postprocessors/index.md).




## ConstantScalarAux


This `AuxKernel` is used to create a constant scalar auxiliary variable.
It is a simpler alternative to the [FunctionScalarAux.md] which provides
similar functionality when used with a [ConstantFunction.md].




## ContainsPointAux


This auxiliary kernel may show multiple elements contain a point. This may
happen if a point lies on a face, edge, or vertex.

### Example syntax





## CopyValueAux


The `CopyValueAux` can be used to make a copy of a field variable, for example to lag them in certain numerical schemes.
Many `AuxKernels` can use variables as arguments, without modifying them, and store the
result in a separate variable. The use of a `CopyValueAux` can often be avoided for that reason.




## DebugResidualAux


This kernel is used for debugging. The `[Debug]` block parameter `show_var_residual_norms`
may be used to identify a problematic variable whose residual does not decrease over
the solve. The spatial dependence of this variable's contribution to the residual may
then be examined.

More information about debugging convergence issues may be found
[here](modules/doc/content/application_usage/failed_solves.md optional=True).




## DiffusionFluxAux


### Description

The `DiffusionFluxAux` AuxKernel is used to compute the components of the flux vector for diffusion problems. The flux is computed as $J=-D\frac{\partial C}{\partial X}$, where $J$ is the diffusion flux vector, $D$ is the diffusivity or diffusion coefficient, $C$ is the concentration variable, and $X$ is the coordinate.

It supports the definition of the diffusivity with and without automatic differentiation (AD).

The expression of the diffusive flux in this object is generic, as described, and may differ from the diffusive flux in your specific physics implementation. If so, you may not use this object to compute the diffusive flux.




## DivergenceAux


Using this `AuxKernel` to compute a term in a nonlinear equation will discard derivatives when using automatic differentiation (AD), and will make it more difficult to write down the Jacobian contributions when not using AD.

### Example input syntax

In this example, the divergence of a finite volume vector field `(u, v)` is computed over a block, and compared to the flux on the sides of the block, verifying the divergence theorem as a sanity check.





## ElementH1ErrorFunctionAux

A class for computing the element-wise $H1$ (Sobolev space) error (actually $W^{1,p}$ error, if you set the value of $p$ to something other than 2.0) of the difference between an exact solution (typically represented by a [ParsedFunction](/MooseParsedFunction.md)) and the specified solution variable.

### Example syntax






## ElementIntegerAux


Additional integer fields may be used to group element separately from the subdomain/block.
The `ElementIntegerAux` allows to visualize this additional information stored on the
mesh.

### Example syntax

In this example, the `ElementIntegerAux` is used to retrieve the `material_id` additional
field and store it in the `id` auxiliary variable.





## ElementL2ErrorFunctionAux

A class for computing the element-wise $L^2$ error (actually $L^p$ error, if you set the value of p to something other than 2) of the difference between an exact solution (typically represented by a [ParsedFunction](/MooseParsedFunction.md)) and the coupled solution variable.  The base class implements the compute() function.

### Example syntax






## ElementLengthAux


### Description

The element "length" is often needed for creating stabilization coefficients or when adapting the mesh. This will compute the minimum or maximum element length and populate an [AuxVariable](/AuxVariables/index.md)
with the result. The element size calculation uses the [libMesh] `hmin()` or `hmax()` method
from the [`Elem`](https://libmesh.github.io/doxygen/classlibMesh_1_1Elem.html) class to compute the length.

### Example Syntax





## ElementLpNormAux


This can be used to average variables on elements, to make a copy that is constant on each
element, a monomial of order 0. The desired Lp-norm is natural conserved in this process.

This is also typically used on a variable representing an error or a difference to a known
solution, to turn an error on each quadrature point to an element-wise error.

### Alternative objects and kernels

To compute the Lp or Hp error directly from a variable and a known reference solution, use
[ElementL2ErrorFunctionAux.md] or [ElementH1ErrorFunctionAux.md] respectively.

For computing a global norm (error) metric, the [NodalL2Norm.md] and the [ElementL2Norm.md]
(respectively [NodalL2Error.md] and the [ElementL2Error.md]) postprocessors may be considered.

### Example syntax

In this example, we display several ways of creating fields computing local element-wise
norms and errors of field variables.





## ElementQualityAux


## Description

Computes per-element quality metrics and puts the value in a field.  An example is shown below using the `SHAPE` metric on
an unstructured mesh.  In this case "perfectly" shaped elements have a value of `1.0` and as the quality degrades so does
the value of the shape metric.



The `SHAPE` metric is a good one to use for quads and tris.  You can see the list of all possible metrics below in the documentation for the `metric` parameter.





## ElementUOAux


### Overview

An aux kernel is used to retrieve values from user objects. For example, it can be
combined with [ElemSideNeighborLayersGeomTester](ElemSideNeighborLayersGeomTester.md)
 or [ElemSideNeighborLayersTester](ElemSideNeighborLayersTester.md) to output
 ghosting information.

### Example syntax

In this example, the `ElementUOAux` is used to examine the ghosting of elements on various ranks, computed by
the three `ElemSideNeighborLayersGeomTester` on each rank.





## ExtraElementIDAux

### Description

This auxiliary kernel copies element integers into an auxiliary variable by setting the variable value on quadrature points of any element with the extra element integer ID of the element.
Elements which do not have the extra element ID requested by [!param](/AuxKernels/ExtraElementIDAux/extra_id_name) will be evaluated as *-1.0* in this auxiliary kernel for better visualization and for consistent handling between 32-bits and 64-bits integer types.




## ForcingFunctionAux


This `AuxKernel` adds a forcing function to the value of an `AuxVariable` from the previous
time step. For each time step $\delta t$, the value of the `AuxVariable` is computed as
\begin{equation}
V(t + \Delta t) = V(t) + f \Delta t
\end{equation}
where $V$ is the `AuxVariable` and $f$ is the forcing function. $f$ is a MOOSE `function`
that is specified as an input parameter.

### Example Input File Syntax

In this example, value of a postprocessor is supplied to the forcing function f used by the `ForcingFunctionAux` `AuxKernel`, which increments the `AuxVariable` T.





## FunctionArrayAux

### Description

`FunctionArrayAux` is used to evaluate an auxiliary array variable with a set of functions.
The number of functions is equal to the number of components of the array variable.
For a nodal array variable, function values at the node points are assigned to the components of the array variable.
For an elemental array variable, element-wise L2 projection is performed for all the components with the function values evaluated on the element quadrature points.




## FunctionAux


The `FunctionAux` helps turn a field defined by a function into a variable. It is generally
helpful when the spatial and temporal dependence of a field is known ahead of time, and the kernels
and other objects needing that field expect a variable rather than a function.

### Example syntax

In this example, the `FunctionAux` is used to store the exact solution of the problem, known
and defined as the function `aux_exact_fn` as an auxiliary variable `aux_u`.





## FunctionScalarAux


The functions will be evaluated at the current time and the system origin (0,0,0).

### Example syntax

In this example, this auxiliary scalar kernel is being used to convert a function output
into a scalar variable, to verify the correctness of another system (parsed functions).





## FunctorAux


### Overview

This object populates an elemental auxiliary variable by evaluating a functor
with a cell-center/elemental or quadrature-point based argument. This
functor may be a material property, a function or another variable. A cell-center/elemental
argument should be used when a cell-averaged quantity (like for finite volume
computations) is desired. Cell-center/elemental vs. quadrature-point based
evaluations are controlled by the `use_qp_arg` boolean parameter. By default the
parameter is `false`.

The version of this auxiliary kernel for automatic differentiation (AD) functors
(in particular AD material properties) is `FunctorAux`.

### Example input syntax

In this example, we use `FunctorAux` to convert some material properties functors, defined by the fluid
properties material, to auxiliary variables, to examine them in an Exodus output.





## FunctorCoordinatesFunctionAux


The `FunctorCoordinatesFunctionAux` lets users pass variables, functions, postprocessors and other [Functors](Functors/index.md) as time/coordinates arguments to a function, in order to set an auxiliary variable. It is generally useful when the function shape is only available as a [Function](Functions/index.md), even
though it would often be more appropriate to use a material property.

If any of the arguments are nonlinear variables or depend on nonlinear variables, you should not
use the `FunctorCoordinatesFunctionAux` when also using [automatic differentiation](automatic_differentiation/index.md) and Newton's method.
Auxiliary variables cannot store derivatives with regards to the nonlinear variables, so the Jacobian for Newton's method
would be incomplete.

If using [auxiliary variables](AuxVariables/index.md) as arguments to the `FunctorCoordinatesFunctionAux`, you must make sure the [AuxKernels](AuxKernels/index.md)
computing these auxiliary variables are executed on an `execute_on` schedule happening before the [!param](/AuxKernels/FunctorCoordinatesFunctionAux/execute_on)
schedule of the `FunctorCoordinatesFunctionAux`. This is because the auxiliary variables are read from the system solution vector, which is only
updated after the execution of all auxiliary kernels on a given `execute_on` schedule. You can check that the ordering of execution of auxiliary
kernels is happening on a previous `execute_on` schedule using the [!param](/Debug/show_execution_order) parameter in the `[Debug]` block.

### Example syntax

In this example, the `FunctorCoordinatesFunctionAux` to evaluate the simple correlation written with
a time `t` dependency in `Function` density_function. The temperature, an auxiliary variable,
is passed as the time functor.





## FunctorElementalGradientAux


### Overview

This `AuxKernel` outputs a vector `AuxVariable` given by scaling the gradient of a functor scaled by a material property and/or another functor.

This `AuxVariable` is used to linearize a nonlinear material property in the adjoint equation.  

### Example Input File Syntax

The use of this `AuxKernel` to compute the adjoint for a temperature dependent material is shown in this example:


where the `AuxVariable` dDdTgradT is defined as a constant monomial vector:


In this example, [!param](/AuxKernels/FunctorElementalGradientAux/factor_matprop) is the tangent modulus of the temperature dependent thermal conductivity.
`FunctorElementalGradientAux` provides an advection velocity in the adjoint problem solved by the `LevelSetAdvection` kernel.
For Hessian based inversion, `FunctorElementalGradientAux` provides the advection velocity to the `ConservativeAdvection` kernel.




## FunctorVectorElementalAux


### Overview

This object populates an elemental auxiliary variable by evaluating a functor vector
(functor material properties only currently) with an element argument, and selecting one of
its component using the [!param](/AuxKernels/FunctorVectorElementalAux/component) parameter.

The version of this auxiliary kernel for automatic differentiation (AD) material properties is
`ADFunctorVectorElementalAux`.




## GapValueAux


This object is typically used in mechanical contact problems to get information about the variable
on the other side of the boundary.

See [GeometricSearchData.md] for more information on the treatment of contact problems.

### Example syntax

In this example, the `GapValueAux` is used to retrieve the value of variable `u` on
boundary `rightleft` across from boundary `leftright`.





## GhostingFromUOAux


## Description

`GhostingFromUOAux` allows you to visualize what the current algebraic and geometric ghosting functors (and RelationshipManagers) are going to do.  This is useful in tracking down both under and over-ghosting.

At any one time it will only show you the ghosted elements for one processor ID.

Normally, this class shouldn't be used directly. Instead set it up through the [DisplayGhostingAction.md].


       id=geometric
       caption=The default geometric ghosting for PID 1



       id=algebraic
       caption=The default algebraic ghosting for PID 1







## HardwareIDAux


### Description

One of the main purposes of this object is to aid in the diagnostic of mesh partitioners.  One metric to look at for mesh partitioners is how well they keep down inter-node (compute node) communication.  `HardwareIDAux` allows you to visually see the mapping of elements to compute nodes in your job.

This is particularly interesting in the case of the [PetscExternalPartitioner](PetscExternalPartitioner.md) which has the capability to do "hierarchical" partitioning.  Hierarchical partitioning makes it possible to partition over compute-nodes first... then within compute nodes, in order to better respect the physical topology of the compute cluster.

One important aspect of that is that how you launch your parallel job can matter quite a bit to partitioning.  In-general, it's better for partitioners if all of the ranks of your job are contiguously assigned to each compute node.  Here are four different ways, and the outcome using `HardwareIDAux`, to launch a job using a 100x100 generated mesh on 16 processes and 4 nodes with two different partitioner...

Top left (METIS):

```
mpiexec -n 16 -host lemhi0002,lemhi0003,lemhi0004,lemhi0005 ../../../moose_test-opt -i hardware_id_aux.i
```

Top right (Hierarchic):

```
mpiexec -n 16 -host lemhi0002,lemhi0003,lemhi0004,lemhi0005 ../../../moose_test-opt -i hardware_id_aux.i -mat_partitioning_hierarchical_nfineparts 4
```

Bottom left (METIS):

```
mpiexec -n 16 -host lemhi0002,lemhi0003,lemhi0004,lemhi0005 -ppn 4 ../../../moose_test-opt -i hardware_id_aux.i
```

Bottom right (Hierarchic):

```
mpiexec -n 16 -host lemhi0002,lemhi0003,lemhi0004,lemhi0005 -ppn 4 ../../../moose_test-opt -i hardware_id_aux.i -mat_partitioning_hierarchical_nfineparts 4
```

It should be immediately apparent that the bottom right partitioning is best (will reduce the amount of inter-node communication).  That result was achieved by using hierarchical partitioning and using `-ppn 4` to tell `mpiexec` to put `4` processes on each compute node... which will cause those four processes to be contiguous on each node.  The top two examples, which omit the `-ppn` option, end up getting "striped" mpi processes (one process is placed on each node and then it wraps around) causing a jumbly mess of partitioning which will increase the communication cost for the job (and decrease scalability).






## InterfaceValueUserObjectAux

### Description

InterfaceValueUserObjectAux is an AuxKernel used to collect values stored in classes derived from
`InterfaceQpUserObjectBase`. An example is [InterfaceQpValueUserObject](/InterfaceQpValueUserObject.md).
InterfaceValueUserObjectAux probes values stored in the provided UserObject and save them into an aux variable at each quadrature point.
It requires three inputs:

* `variable` is the name of the output AuxVariable
* `boundary` = the name of the boundary to which this AuxKernel applies
* `interface_uo_name` = the name of interface UserObject where data are stored

The optional argument `return_side_average` retrieves element side average values from the specified UserObject. 

### Example Input File Syntax

listing test/tests/userobjects/interface_user_object/interface_value_user_object_QP.i block=AuxKernels/interface_avg_qp_aux






## MaterialRankFourTensorAux


Converting a field from the material system, here a component of the gradient of a material property,
to a variable may be desirable for several reasons: to match the format expected by certain
kernels (thus lagging the field between time steps) or for output/testing/debugging.

This is particularly useful to examine anisotropic material properties. For output
purposes only, an alternative is to use the `output_properties` argument of the `Material`
or specify `output_material_properties` in the parameters of the desired output type nested in
the `[Outputs]` block. This auxkernel is added automatically by the `MaterialOutputAction` if an
`outputs` parameter is specified in a Material block and a RankFourTensor
material property is declared by the material.

The AD system currently does not support auxiliary variables. If you convert material properties, which
do support automatic differentiation, to auxiliary variables, the derivatives will be ignored.





## MaterialRankTwoTensorAux


Converting a field from the material system, here a component of the gradient of a material property,
to a variable may be desirable for several reasons: to match the format expected by certain
kernels (thus lagging the field between time steps) or for output/testing/debugging.

This is particularly useful to examine anisotropic material properties. For output
purposes only, an alternative is to use the `output_properties` argument of the `Material`
or specify `output_material_properties` in the parameters of the desired output type nested in
the `[Outputs]` block. This auxkernel is added automatically by the `MaterialOutputAction` if an
`outputs` parameter is specified in a Material block and a RankTwoTensor
material property is declared by the material.

The AD system currently does not support auxiliary variables. If you convert material properties, which
do support automatic differentiation, to auxiliary variables, the derivatives will be ignored.





## MaterialRateRealAux


### Description

The `MaterialRateRealAux` AuxKernel is used to output the rate of change of
material properties as an element-level, variable.
The rate is computed by

rate = \dfrac{\mathrm{property}(t)-\mathrm{property}(t_{old})}{dt}

where $dt=t-t_{old}$ is the time step size and [!param](/AuxKernels/MaterialRateRealAux/property) is the material property being evaluated.
This class derives from the same base class as [MaterialRealAux.md] and therefore also has optional parameters [!param](/AuxKernels/MaterialRateRealAux/factor) and [!param](/AuxKernels/MaterialRateRealAux/offset).  

### Example Input Syntax





## MaterialRealAux


### Description

The `MaterialRealAux` AuxKernel is used to output material properties as an element-level,
variable. When providing a constant monomial variable the computed value will be the
volume-averaged quantity over the element.

The variant `FunctorMaterialRealAux` can output a functor property to either a nodal or an
elemental variable.

Converting a field from the material system, here a component of a matrix material property,
to a variable may be desirable for several reasons: to match the format expected by certain
kernels (thus lagging the field between time steps) or for output/testing/debugging.

The AD system currently does not support auxiliary variables. If you convert material properties
or functors, which do support automatic differentiation, to auxiliary variables, the derivatives
will be ignored.

### Example Input Syntax

#### Material property


#### Functor





## MaterialRealDenseMatrixAux


Converting a field from the material system, here a component of a matrix material property,
to a variable may be desirable for several reasons: to match the format expected by certain
kernels (thus lagging the field between time steps) or for output/testing/debugging.

This is particularly useful to examine anisotropic material properties. For output
purposes only, an alternative is to use the `output_properties` argument of the `Material`
or specify `output_material_properties` in the parameters of the desired output type nested in
the `[Outputs]` block. This `AuxKernel` is used in the back-end by these parameters.

The AD system currently does not support auxiliary variables. If you convert material properties, which
do support automatic differentiation, to auxiliary variables, the derivatives will be ignored.

### Example syntax

In this example, the `MaterialRealDenseMatrixAux` is used to examine the first row, first column element of
a matrix material property.





## MaterialRealTensorValueAux


Converting a field from the material system, here a component of a tensor material property,
to a variable may be desirable for several reasons: to match the format expected by certain
kernels (thus lagging the field between time steps) or for output/testing/debugging.

This is particularly useful to examine anisotropic material properties. For output
purposes only, an alternative is to use the `output_properties` argument of the `Material`
or specify `output_material_properties` in the parameters of the desired output type nested in
the `[Outputs]` block. This `AuxKernel` is used in the back-end by these parameters.

The AD system currently does not support auxiliary variables. If you convert material properties, which
do support automatic differentiation, to auxiliary variables, the derivatives will be ignored.

### Example syntax

In this example, the `MaterialRealTensorValueAux` is used to examine the diagonal of an
anisotropic thermal conductivity in a porous flow simulation.





## MaterialRealVectorValueAux


Converting a field from the material system, here a component of a vector material property
(`MaterialRealVectorValueAux`) or a vector valued functor (`FunctorMaterialRealVectorValueAux`),
to a variable may be desirable for several reasons: to match the format expected by certain
kernels, for lagging the field between time steps or for output/testing/debugging.

This is particularly useful to examine anisotropic material properties. For output
purposes only, an alternative is to use the `output_properties` argument of the `Material`
or specify `output_material_properties` in the parameters of the desired output type nested in
the `[Outputs]` block.

The AD system currently does not support auxiliary variables. If you convert material properties
or functors, which do support automatic differentiation, to auxiliary variables, the derivatives
will be ignored.

### Example syntax

In this example, the `MaterialRealVectorValueAux` is being used to examine different cracking criteria
for a smear cracking model.





## MaterialStdVectorAux


Converting a field from the material system, here a component of a vector material property,
to a variable may be desirable for several reasons: to match the format expected by certain
kernels (thus lagging the field between time steps) or for output/testing/debugging.

This is particularly useful to examine anisotropic material properties. For output
purposes only, an alternative is to use the `output_properties` argument of the `Material`
or specify `output_material_properties` in the parameters of the desired output type nested in
the `[Outputs]` block. This `AuxKernel` is used in the back-end by these parameters.

The [MaterialRealVectorValueAux.md] provides similar functionality.

The AD system currently does not support auxiliary variables. If you convert material properties, which
do support automatic differentiation, to auxiliary variables, the derivatives will be ignored.

### Example syntax

In this example, the `MaterialStdVectorAux` is being used to examine the first component
of an anisotropic permeability.





## MaterialStdVectorRealGradientAux


Converting a field from the material system, here a component of the gradient of a material property,
to a variable may be desirable for several reasons: to match the format expected by certain
kernels (thus lagging the field between time steps) or for output/testing/debugging.

This is particularly useful to examine anisotropic material properties. For output
purposes only, an alternative is to use the `output_properties` argument of the `Material`
or specify `output_material_properties` in the parameters of the desired output type nested in
the `[Outputs]` block. This `AuxKernel` is used in the back-end by these parameters.

The AD system currently does not support auxiliary variables. If you convert material properties, which
do support automatic differentiation, to auxiliary variables, the derivatives will be ignored.

### Example syntax

In this example, the `MaterialStdVectorRealGradientAux` is used to examine gradients of the
force densities between particles in a phase field simulation.





## MeshDivisionAux


This AuxKernel can be helpful to test a new [MeshDivision](syntax/MeshDivisions/index.md) object by visualizing the division.
It could also be used to form conditional logic based on the location of the element, and its indexing in the
MeshDivision, in a [ParsedAux.md].




## NearestNodeDistanceAux

The NearestNodeDistanceAux uses the geometric search system to find the shortest distance
from a node where the AuxVariable is defined to a node on a different boundary. Normally,
this object is used to find distances between two boundaries but can be used to find the distance
from all nodes in one body to some boundary.


### Description and Syntax





## NearestNodeValueAux

The NearestNodeValueAux uses the geometric search system to find the shortest distance
from a node where the AuxVariable is defined to a node on a different boundary. The value
of a field variable is then retrieved from the corresponding node. You can use this AuxKernel
to copy the value of a solution field located on one body to another.

### Description and Syntax





## Nodal Patch Recovery AuxKernel





## NormalizationAux


The formula for the normalization is

\dfrac{\text{variable * normal factor}}{\text{normalization}} - \text{shift}

### Example syntax

In this example, the `NormalizationAux` is used to normalize the output of an eigenproblem.
This is a common use case in reactor physics where the neutron flux output by
the numerical solve may not be normalized, and has to be normalized to obtain the desired
power level. The power, used for normalization, is stored in `unorm`, an
`ElementIntegralVariablePostprocessor`.





## ParsedAux


The parsed expression may contain:

- variables (`coupled_variables` parameter)

- real-valued material properties ([!param](/AuxKernels/ParsedAux/material_properties) parameter)

- automatic differentiation (AD) real-valued material properties ([!param](/AuxKernels/ParsedAux/ad_material_properties) parameter)

- functors (`functor_names` or `functor_symbols` parameter)

- coordinates in space and time (`use_xyzt` parameter)

- constants (`constant_names` for their name in the expression and `constant_expressions` for their values)


### Example syntax

In this example, the `ParsedAux` is being used to compute the multiplication of the simulation variable, `u`, by 2.





## ParsedVectorAux


The parsed expressions, `expression_x`/`y`/`z` for each component of the vector, may contain:

- variables ([!param](/AuxKernels/ParsedVectorAux/coupled_variables) parameter)

- vector variables ([!param](/AuxKernels/ParsedVectorAux/coupled_vector_variables) parameter)

- coordinates in space and time ([!param](/AuxKernels/ParsedVectorAux/use_xyzt) parameter then add to `expression_x`/`y`/`z`)

- constants ([!param](/AuxKernels/ParsedVectorAux/constant_names) for their name in the expression and [!param](/AuxKernels/ParsedVectorAux/constant_expressions) for their values)


Material properties are currently not supported, but it would be really easy to add it so feel free to contact us.




## PenetrationAux

Auxiliary Kernel for computing several geometry related quantities between two different bodies in or near contact.

### Gap offset parameters

Gap offset can be provided to offset the gap distance between in or near contact bodies. It can be either `secondary_gap_offset` (gap offset from secondary side) or `mapped_primary_gap_offset` (gap offset from primary side but mapped to secondary side). Use of these gap offset parameters treats the surfaces as if they were virtually extended (positive offset value) or narrowed (negative offset value) by the specified amount, so that the surfaces are treated as if they are closer or further away than they actually are. There is no deformation or resistance to heat transfer within the material in this gap offset region.





## ProcessorIDAux

Auxiliary kernel for displaying mesh partitioning. Each node or element can display its corresponding processor ID.


This AuxKernel should be used with care in regression tests. Partitioning is often different between
different platforms and clearly running on a different numbers of processors will change this field
substantially.





## ProjectedMaterialPropertyNodalPatchRecoveryAux

This AuxKernel performs nodal patch recovery of a material property component with data prepared by a [ProjectedStatefulMaterialNodalPatchRecovery](ProjectedStatefulMaterialNodalPatchRecovery.md) object with the purpose of projecting the property onto a nodal basis function (e.g. first order Lagrange).

This object is set up by the [ProjectedStatefulMaterialStorageAction](ProjectedStatefulMaterialStorageAction.md).

See also [ProjectedStatefulMaterialAux](ProjectedStatefulMaterialAux.md) for the AuxKernel that projects onto elemental basis functions.





## ProjectedStatefulMaterial...Aux

This AuxKernel simply returns the value of a given material property (or component of the property value) at a quadrature point with the purpose of projecting the property onto an elemental basis function (e.g. first order monomial).

Variants include:

- `ProjectedStatefulMaterialRealAux`
- `ProjectedStatefulMaterialRealVectorValueAux`
- `ProjectedStatefulMaterialRankTwoTensorAux`
- `ProjectedStatefulMaterialRankFourTensorAux`
- `ADProjectedStatefulMaterialRealAux`
- `ADProjectedStatefulMaterialRealVectorValueAux`
- `ADProjectedStatefulMaterialRankTwoTensorAux`
- `ADProjectedStatefulMaterialRankFourTensorAux`

At step zero this object will compute the material QP values by explicitly calling `initStatefulProperties` in order to project the state that will correspond to the *old state* in the first timestep.

This object is set up by the [ProjectedStatefulMaterialStorageAction](ProjectedStatefulMaterialStorageAction.md).

See also [ProjectedMaterialPropertyNodalPatchRecoveryAux](ProjectedMaterialPropertyNodalPatchRecoveryAux.md) for the AuxKernel that projects onto nodal basis functions.





## ProjectionAux


The `ProjectionAux` can be used to make a copy of a field variable, for example to lag them in certain numerical schemes.
Many `AuxKernels` can use variables as arguments, without modifying them, and store the
result in a separate variable. The use of a `ProjectionAux` can often be avoided for that reason.

The `ProjectionAux` can also be used to project between different finite element variable families and order.
The [!param](/AuxKernels/ProjectionAux/v) parameter is then the source variable.

The default projection method will attempt to enforce that the two variables have the same value on every quadrature point.
If the shape of the source cannot be reproduced by the target variable finite element family and order,
the modeler is invited to measure the projection error using a [ElementL2Difference.md] postprocessor.

Elemental variables that are discontinuous at nodes are projected to nodal variables by computing nodal values as element-volume-weighted
averages of the centroid values of neighbor elements.

The block restriction of the auxkernel, specified using the [!param](/AuxKernels/ProjectionAux/block) parameter, is used to select the
source variable value as well using the [!param](/AuxKernels/ProjectionAux/use_block_restriction_for_source) parameter.

Lower dimensional elements are currently not supported. If you require using lower dimensional elements for projections,
please reach out on the [MOOSE Discussions forum](https://github.com/idaholab/moose/discussions).




## QuotientAux

Divides one field by another field on a node by node or element by element basis.

This AuxKernel does not check for division by zero.





## QuotientScalarAux


### Example syntax





## ScalarTagMatrixAux

The diagonal value of the matrix (associated with a tag) is retrieved for a given node
for scalar kernels, and the diagonal value is saved as an AuxVariable.
The AuxVariable can then be visualized using the Exodus file output.




## ScalarTagVectorAux

The value of a tagged vector (for scalar kernels) for a given node and a given variable is coupled to
the current AuxVariable. ScalarTagVectorAux returns the coupled value. The AuxVariable can then
be visualized using the Exodus file output.




## SecondTimeDerivativeAux


The [!param](/AuxKernels/SecondTimeDerivativeAux/factor) multiplies the output of the second time derivative operation.
The time derivative of the [!param](/AuxKernels/SecondTimeDerivativeAux/factor) is +not+ computed.

The `SecondTimeDerivativeAux` can only output a non-zero time derivative when the [time integrator](syntax/Executioner/TimeIntegrator/index.md) has implemented the second time derivative. Only [CentralDifference.md] and [NewmarkBeta.md] have as of early 2023, but contributions are welcome!

### Example input syntax

In this example, the `SecondTimeDerivativeAux` is used to output to auxiliary variables the second time derivatives
of variables during a time dependent diffusion problem.





## SolutionAux

This AuxKernel works in conjunction with a [SolutionUserObject](/SolutionUserObject.md) to produce fields. If the solution was created on an equivalent mesh, the direct option can be used to read using DOF information. Otherwise, a point locator is used to find the nearest node or element and the corresponding value. Finally, these values can be scaled and/or added by utilizing the *scale_factor* or *add_factor* parameters.





## SolutionScalarAux

This AuxScalarKernel works in conjunction with a [SolutionUserObject](/SolutionUserObject.md) to set
scalar variable values. These values can be scaled and/or added by utilizing the *scale_factor*
or *add_factor* parameters.





## SpatialUserObjectAux


User objects are generally more flexible than auxiliary kernels, and this object creates
allows to connect them to the [`Variables` system](syntax/Variables/index.md).

The `UserObject` *must* implement the `spatialValue()` virtual function. In the framework,
the following objects can currently be used:

- [PostprocessorSpatialUserObject.md]

- [NearestPointIntegralVariablePostprocessor.md]

- LayeredIntegral-derived objects such as [LayeredAverage.md] and [LayeredIntegral.md]

- LayeredSideIntegral-derived objects such as [LayeredSideAverage.md] and [LayeredSideIntegral.md]

- NearestPointBase-derived objects such as [NearestPointLayeredAverage.md]

- [LineValueSampler.md]

- [FXIntegralBaseUserObject](FXIntegralBaseUserObject.md optional=True)


Additional objects may be implemented in an application.

### Example syntax

In this example, a `SpatialUserObjectAux` is being used to store in an auxiliary variable the
averages of another variable, u, on multiple layers along the `right` boundary in the `y` direction.


Automatic differentiation is not supported in the auxiliary variable system, so using a `SpatialUserObjectAux`
will not propagate derivatives.




## TagMatrixAux

The diagonal value of the matrix (associated with a tag) is retrieved for a given node.
And the diagonal value is used as the nodal value for the AuxVariable that will be
written out in an exodus file for visualization.

Setting the [!param](/AuxKernels/TagMatrixAux/scaled) parameter to false makes
the kernel return values unaffected by variable scaling and automatic scaling.
Note, however, that nodal boundary conditions and strong constraints are
setting Jacobian entries independent of scaling and can lead to unexpected
unscaled results.






## TagVectorArrayVariableAux

Creates an auxiliary field representing the value of a tagged vector for a given
array variable (specified through the `v` parameter), and given array component
(specified through the `component` parameter). The family and order of the
auxiliary variable that this object populates must match the family and order of
the array variable specified through `v`. Note that the only allowed execute-on
option for this object is `timestep_end` since residual evaluation must be
completed before reliable indexing of the tagged vector can be performed.





## TagVectorArrayVariableValueAux

The value of a tagged vector for a given array variable is coupled to the current AuxVariable. `TagVectorArrayVariableValueAux` return the coupled array value.





## TagVectorAux

The value of a tagged vector for a given node and a given variable is coupled to
the current AuxVariable. TagVectorAux return the coupled nodal value. AuxVariable
then is written out in an exodus file. 






## TimeDerivativeAux


The [!param](/AuxKernels/TimeDerivativeAux/factor) multiplies the output of the time derivative operation.
The time derivative of the [!param](/AuxKernels/TimeDerivativeAux/factor) is +not+ computed.

The `TimeDerivativeAux` is restricted to constructs for which the time derivative is computed by MOOSE. Time derivative
functions have not been implemented for all functor types.

### Example input syntax

In this example, the `TimeDerivativeAux` is used to output to auxiliary variables the time derivatives
of variables and functions during a time dependent diffusion problem.





## VariableGradientComponent


The result of this operation is stored in an auxiliary variable: `variable`. The analysis of gradients is useful to examine a solution or
the adequacy of a mesh discretization.

AuxVariables currently do not contain the Automatic Differentiation information about the derivatives. Using this object in the solve, to compute a material property for example, will lead to an imperfect Jacobian which can impact convergence.

VariableGradientComponent may only be applied to elemental variables, and only considers the gradient within an element. For example, the reported gradient of a `CONSTANT` `MONOMIAL` is identically zero.

### Example Input File Syntax

In this example, u is the (linear) solution of a 2D diffusion equation with no source term. We compute the two gradient
components using the AuxKernels below, which each store a gradient component in a separate auxiliary variable. We can
then examine the gradient of u, for example to decide to use a finer mesh in a given direction if the corresponding
gradient is not well resolved.





## VariableTimeIntegrationAux


The integration over time is lead over every quadrature point.

### Example syntax

In this example, the `VariableTimeIntegrationAux` computes the time integral of variable
`u` with a first, second and third order scheme respectively.





## VectorFunctionAux


The `VectorFunctionAux` helps turn a vector field defined by a function into a vector variable. It is generally
helpful when the spatial and temporal dependence of a field is known ahead of time, and the kernels
and other objects needing that field expect a vector variable rather than a function.

### Example syntax

In this example, the `VectorFunctionAux` is used to set the vector variable `vec` to the
values computed by the aptly named `ParsedVectorFunction` `function`.





## VectorMagnitudeAux


### Example syntax

We retrieve in this input file the magnitude of the fluid velocity in
a cavity problem. The components of the velocity vector are the problem variables.





## VectorMaterialRealVectorValueAux


### Description

The `VectorMaterialRealVectorValueAux` AuxKernel is used to output
vector-quantity material properties to a vector finite element variable, e.g. a
variable with `family = MONOMIAL_VEC` since the auxiliary kernel has to be
executed on elements due to the elemental nature of material properties.




## VectorPostprocessorVisualizationAux

### Short Description


### Description

This object is intended to let you view VectorPostprocessor vectors that are of length `num_procs` (meaning there is one value per MPI process).  This object will take those values and fill up an Auxiliary field with them so the values can be visualized.

### Important Notes

Note: the VectorPostprocessor must be syncing the vectors it's computing to all processors.  By default many just compute to processor 0 (because that's where output occurs).

For instance: this is the case for [WorkBalance](WorkBalance.md).  By default it only syncs to processor 0, but it has a parameter (`sync_to_all_procs`) to tell it to create copies of the vectors on all processors.





## VectorVariableComponentAux

The `VectorVariableComponentAux` class takes a vector variable, specified
through the `vector_variable` parameter, and generates an auxiliary variable
corresponding to one of the vector variable's components; the component is
specified through the `component` parameter. This object is only meant to be
used with `LAGRANGE_VEC` vector variables, and hence the auxiliary variable
should be of type `LAGRANGE`.





## VectorVariableMagnitudeAux

The `VectorVariableMagnitudeAux` class takes a vector variable, specified
through the `vector_variable` parameter, and generates an auxiliary variable
corresponding to the Euclidean norm of the vector variable's components.
This object is
only meant to be used with `LAGRANGE_VEC` vector variables, and hence the
auxiliary variable should be of type `LAGRANGE`.

### Example Input Syntax






## VolumeAux


`VolumeAux` samples element or side volumes and stores them in an [AuxVariable.md].

It requires that the supplied [!param](/AuxKernels/VolumeAux/variable) be of type `CONSTANT` `MONOMIAL`.

### Example syntax

In this example, the `VolumeAux` object `volume_aux` samples the elemental volumes into the variable `volume`.





## WeightedGapAux


### Overview

This object computes a discrete weighted gap $\tilde{g}_i$ in a mortar context according to

\begin{equation}
\tilde{g}_i = \frac{\int_{\Gamma_c^{(1)}} \psi_i g_h dA}{\int_{\Gamma_c^{(1)}} dA}
\end{equation}

where $\Gamma_c^{(1)}$ denotes the secondary contact interface, $\psi_i$ is the $i$th
shape function associated with the auxiliary variable this aux kernel is
computing the value for and $g_h$ is the discretized version of the gap
function, computed in this aux kernel as the difference in quadrature point
location between primary and secondary faces times the normal vector.




# base

## Adaptivity

The Adaptivity object encapsulates all of the interfaces and methods for working with
[Adaptivity System](syntax/Adaptivity/index.md) in MOOSE.

## Assembly

The `Assembly` class holds most routines and objects related to assembling the numerical
system, such as the ones listed below. In the non-exhaustive list below, we refer to as
`local` the current element, face, quadrature points and neighbor values of each quantity.

- the current element

- the neighbor element

- the local volumes

- the Jacobian weights

- the local quadrature rules and points

- the local values of current variable, its spatial derivatives at first and second order,
  its curl on the element


It also contains these quantities for the mortar cases, on quadrature points.

This system is in charge of:

- reinitializing these quantities, through the `reinit...` methods,
  such as `reinit(Elem* elem)` for the current element, `reinitAtPhysical(...)` for a given vector of points
  or `reinitFVFace(face_info)` for the current face.

- getting the shape function values and its derivatives at the quadrature points, as well as the locations of the
  quadrature points from libMesh in the `buildFE...` routines for various locations.

- preparing the vectors for storing the local contributions to
  the Jacobian and the residual, by sizing and zeroing them, through the `prepare...` methods.

- caching contributions to the Jacobian and residual through the `cache...` methods.
  This can reduce the frequency of access to those global quantities, and is especially useful
  when using threads in the shared memory parallelism paradigm to be able to consider local
  contributions without locking the global vector.

- adding those local contributions to the global Jacobian and residual through the `add...` methods,
  for example `addResidual` for the local element residual or `addJacobianNeighbor` for the
  Jacobian on the neighbor element.

## ChainControlDataSystem

The `ChainControlDataSystem` manages [/ChainControlData.md] objects and provides
interfaces to do the following:

- Check if control data exists (and if it has a certain type).
- Get control data
- Declare control data

This object is owned by [/MooseApp.md], which provides a `getChainControlDataSystem()`
method to get it.

## Moose.C

The Moose.C file is an core framework file containing several useful global variables,
task list, utilities, typedefs, and other core-internal code. One of the most commonly
consulted blocks of code in Moose.C is the task list ordering. This list dictates
the task order in which MOOSE assembles complete simulations.

## MooseApp

The `MooseApp` object is the base class for [!ac](MOOSE) based applications and serves as the
entry point for running all aspects of a simulation.

### Specifying Application to Use

It can be useful, when running a large "combined" application like `blue_crab`,
to specify a specific application type to run an input file with. For instance
one may want to run `griffin` as the main application and `pronghorn` as a
sub-application. Just as the application type for the sub-application is
specified in the main input file using `app_type = PronghornApp` the application
type for running the main input file can be specified on the command line
via `<blue_crab_root_dir>/blue_crab-* -i foo.i --app GriffinApp`. This allows
any special actions and setup specific to the application to be used.

### Nonzero reallocation behavior

The MOOSE framework and libMesh work together to supply a sparsity pattern to
PETSc which informs how much memory is allocated for the system matrix. If the
sparsity pattern is too small, then PETSc will be forced to allocate new memory
during matrix assembly if user code tries to add/set a matrix entry that wasn't
preallocated by the sparsity pattern. This allocation at matrix assembly time
can significantly slow down a simulation. MOOSE and libMesh are known to
generate accurate sparsity patterns in most cases; however, for complex
multi-body problems like mechanical and thermal contact, the sparsity pattern
may be incorrect. Because of this, by default MOOSE does not error if PETSc is
forced to do new nonzero allocations during matrix assembly. However, if an
application developer expects their physics to have accurate sparsity patterns,
they may override the default MOOSE behavior and error on new nonzero
allocations. This can give the application developer peace-of-mind that their
applications will not produce quiet nonzero allocations at run-time.

Overriding the default nonzero allocation behavior can be accomplished by
overriding the virtual function `bool
MooseApp::errorOnJacobianNonzeroReallocation() const`. The `MooseApp` default is
`false`, although this will hopefully be changed in the not-too-distant
future. Note that the application level code setting can always be overridden at
the input-file level by specifying a value for `Problem/error_on_jacobian_nonzero_reallocation`.

## MooseException

`MooseException` is a class that derives from the standard C++ `exception` class. Its purpose is to give developers
an opportunity to terminate a solve, while informing MOOSE that it should perform the
necessary steps to clean up the current stack, notify other threads/processors of the error
and communicate with the solver that the current solve has failed. When applicable and possible,
the solver will allow MOOSE to cut the time step and make another attempt at a solve.

This exception should be used directly in user code when non-fatal situations are encountered
such as the inability to converge a local Newton solve in a material, or if a interpolated value
from a variable or lookup table ends up out-of-range.

MOOSE is set up to catch a `MooseException` within several user defined callbacks that occur during
the solver's `computeResidual` and `computeJacobian` callbacks. Note that these callbacks also include
the evaluation of several other objects such as `Materials`, `Constraints`, and occasionally objects
such as `Postprocessors` (when requested). This makes it possible to cut the time step and retry
the solve by throwing a `MooseException` from most user-defined objects within MOOSE.

### How it works

MOOSE Wraps several threaded sections in `PARALLEL_TRY`/`PARALLEL_CATCH` macros (See `SystemBase.h`).
`PARALLEL_TRY` does nothing (but provide scope). `PARALLEL_CATCH` invokes the
`FEProblemBase::checkExceptionAndStopSolve()` (See `FEProblemBase.h`) routine after the threaded section
has terminated and all threads on the same processor agree on the error status.
checkExceptionAndStopSolve() then does parallel communication of the exception to ensure that
the same exception exists on all processors. If there is an exception, that method sets
a variable that results in the solver being notified that the solution has diverged due to not-a-number
(NaN) entries in the residual vector during the next residual evaluation. This in turn results
in the time step being cut and the solution being attempted again, in the same manner that other failed
solutions of a time step are handled.

## MooseObject

The `MooseObject` is the [top level base class](https://mooseframework.inl.gov/docs/doxygen/moose/classMooseObject.html)
for all non-action MOOSE objects (such as Kernels, Materials, Postprocessors,
etc.).

This class holds the main convenience functions, such as

- `getParam<T>(param)` template as a shortcut to `parameters().get<T>(param)` to get an input parameter `param` of type `T`
- `isParamValid(param)` to check if the input parameter `param` has a value that can be obtained with `getParam`
- `getMooseApp()` to get a reference to the [`MooseApp`](MooseApp.md) this object is associated with
- `type()` to get the registered class object name of the current object
- `name()` to get the name the object appears under in the input file
- `parameters()` to get a reference to the [`InputParameters`](InputParameters.md) of the current object
- `paramError`, `paramWarning`, and `paramInfo` to output status messages regarding specific parameters that are annotated with the input file location of the parameter

### Parameter vector pairs

```C++
  template <typename T1, typename T2>
  std::vector<std::pair<T1, T2>> getParam(const std::string & param1,
                                          const std::string & param2) const;
```

Can be used to fetch two input parameters of type `std::vector<T1>` and
`std::vector<T2>` into a single `std::vector<std::pair<T1, T2>>`. This is useful
for pairs of vectors that have a one to one correspondence, such as
[!param](/Executioner/Steady/petsc_options_iname) and
[!param](/Executioner/Steady/petsc_options_value).

# bcs

## ADConservativeAdvectionBC

### Description

The `ADConservativeAdvectionBC` boundary condition pairs with the
[ADConservativeAdvection.md] kernel. It can be used for both Dirichlet and
"implicit" boundary conditions which use only information from the equation
systems solution vectors. Velocity must be provided, either through the
`velocity_mat_prop` parameter (implicit information) or through the
`velocity_function` parameter (Dirichlet information). Similarly, for Dirichlet
conditions, a `primal_dirichlet_value` should be supplied. Otherwise the
advected quantity will be determined from implicit information either through
the supplied `advected_quantity` or if that is not supplied, the `variable`
solution. If `primal_dirichlet_value` is supplied, then a `primal_coefficient`
material property name may be supplied which will multiply the
`primal_dirichlet_value`.

An example of this boundary condition's use is shown in the listing below for
both an inlet and outlet condition. At the inlet (`boundary = left`) both the velocity and primal
value (the `variable` `u` in this case) are prescribed. At the outlet
(`boundary= right`) due to the absence of `primal_dirichlet_value`, the current
solution value of `u` is used. Additionally, the velocity is also determined
implicitly through `velocity_mat_prop`.





## ADDirichletBC


### Description

`ADDirichletBC` is the simplest type of `NodalBC`, and is used for
imposing so-called "essential" boundary conditions on systems of
partial differential equations (PDEs).  Such boundary conditions force
a particular set of degrees of freedom (DOFs) defined by the
`boundary` parameter to take on a single, controllable value. This
class is appropriate to use for PDEs of the form

\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= h && \quad \in \partial \Omega_N,
\end{aligned}
\end{equation}

where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary. In
this case, a `ADDirichletBC` object is used to impose the condition (2)
on the subset of the boundary denoted by $\partial \Omega_D$. In this case, the
`value` corresponds to the constant $g$, and the user must define one
or more sidesets corresponding to the boundary subset $\partial \Omega_D$.

Note that `ADDirichletBC` computes its Jacobian using automatic differentiation.

### Preset boundary conditions

With the parameter `preset = true`, the value of the boundary condition is applied
before the solve begins. With `preset = false`, the boundary condition is
only enforced as the solve progresses. In most situations, presetting the boundary
condition is better.

### Example Input Syntax





## ADFunctionDirichletBC


### Description

`ADFunctionDirichletBC` is a generalization of [`DirichletBC`](/DirichletBC.md) which
imposes a possibly temporally- and spatially-dependent value defined
by a MOOSE [`Function`](/Functions/index.md) object on a particular set of degrees of freedom
(DOFs) defined by the `boundary` parameter. That is, for a
PDE of the form

\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g(t,\vec{x}) && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= h(t,\vec{x}) && \quad \in \partial \Omega_N
\end{aligned}
\end{equation}

where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary,
a `ADFunctionDirichletBC` object can be used to impose the
condition (2) if the function is well-defined for $\vec{x} \in
\partial \Omega_D$. In this case, the `function` parameter corresponds to a
MOOSE `Function` object which represents the mathematical function
$g(t,\vec{x})$, and the user must define one or more sidesets
corresponding to the boundary subset $\partial \Omega_D$ via the
`boundary` parameter.

Note that `ADFunctionDirichletBC` computes its Jacobian using automatic differentiation.

### Preset boundary conditions

With the parameter `preset = true`, the value of the boundary condition is applied
before the solve begins. With `preset = false`, the boundary condition is
only enforced as the solve progresses. In most situations, presetting the boundary
condition is better.

### Example Input Syntax





## ADFunctionNeumannBC


### Description

`ADFunctionNeumannBC` is a generalization of [`ADNeumannBC`](/ADNeumannBC.md) which is used
for imposing flux boundary conditions on systems of partial
differential equations (PDEs) where the flux is represented by a
spatially- and temporally-varying MOOSE [`Function`](/Functions/index.md).  That is, for a
PDE of the form
\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g(t,\vec{x}) && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= h(t,\vec{x}) && \quad \in \partial \Omega_N,
\end{aligned}
\end{equation}
where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary, a
`ADFunctionNeumannBC` object can be used to impose condition (3) if the
function is well-defined for all relevant times and $\vec{x} \in
\partial \Omega_N$. In this case, the `function` parameter corresponds
to a MOOSE `Function` object which represents the mathematical
function $h(t,\vec{x})$, and the user must define one or more sidesets
corresponding to the boundary subset $\partial \Omega_N$ via the
`boundary` parameter.

### Example Input Syntax





## ADFunctionPenaltyDirichletBC


### Description

`ADFunctionPenaltyDirichletBC` is a generalization of [`ADPenaltyDirichletBC`](/ADPenaltyDirichletBC.md) which
imposes a possibly temporally- and spatially-dependent value defined
by a MOOSE [`Function`](/Functions/index.md) object on a particular set of degrees of freedom
(DOFs) defined by the `boundary` parameter. That is, for a
PDE of the form

\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g(t,\vec{x}) && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= h(t,\vec{x}) && \quad \in \partial \Omega_N
\end{aligned}
\end{equation}

where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary,
a `ADFunctionPenaltyDirichletBC` object can be used to impose the
condition (2) if the function is well-defined for $\vec{x} \in
\partial \Omega_D$. In this case, the `function` parameter corresponds to a
MOOSE `Function` object which represents the mathematical function
$g(t,\vec{x})$, and the user must define one or more sidesets
corresponding to the boundary subset $\partial \Omega_D$ via the
`boundary` parameter.

Instead of imposing the Dirichlet condition directly on the basis by replacing the
equations associated with those degrees of freedom (DOFs) by the auxiliary equation
$u-g(t,\vec{x})=0$, the `ADFunctionPenaltyDirichletBC` is based on the variational statement:
find $u \in H^1(\Omega)$ such that
\begin{equation}
  \label{weakform}
  \int_{\Omega} \left( \nabla u \cdot \nabla v - fv \right) \,\text{d}x
  -\int_{\partial \Omega_N} hv \,\text{d}s
  +\int_{\partial \Omega_D} \frac{1}{\epsilon} (u-g(t,\vec{x}))v \,\text{d}s = 0
\end{equation}
holds for every $v \in H^1(\Omega)$. In [weakform], $\epsilon
\ll 1$ is a user-selected parameter which must be taken small enough
to ensure that $u \approx g(t,\vec{x})$ on $\partial \Omega_D$. The
user-selectable class parameter `penalty` corresponds to
$\frac{1}{\epsilon}$, and must be chosen large enough to ensure
good agreement with the Dirichlet data, but not so large that the
resulting Jacobian becomes ill-conditioned, resulting in failed solves
and overall accuracy losses.

Benefits of the penalty-based approach include simplified Dirichlet
boundary condition enforcement for non-Lagrange finite element bases,
maintaining the symmetry (if any) of the original problem, and
avoiding the need to zero out contributions from other rows in a
special post-assembly step. Integrating by parts "in reverse"
from [weakform], one obtains

\begin{equation}
  \label{weakform2}
  \int_{\Omega} \left( -\nabla^2 u  - f \right) v \,\text{d}x
  +\int_{\partial \Omega_N} \left( \frac{\partial u}{\partial n} - h(t,\vec{x}) \right) v \,\text{d}s
  +\int_{\partial \Omega_D} \left[ \frac{\partial u}{\partial n} + \frac{1}{\epsilon} (u-g(t,\vec{x})) \right] v \,\text{d}s = 0
\end{equation}

We therefore recover a "perturbed" version of the original problem with the flux
boundary condition

\begin{equation}
  \frac{\partial u}{\partial n} = -\frac{1}{\epsilon} (u-g(t,\vec{x})) \, \in \partial \Omega_D
\end{equation}

replacing the original Dirichlet boundary condition. It has been shown
[!cite](juntunen2009nitsche) that in order for the solution to this perturbed
problem to converge to the solution of the original problem in the
limit as $\epsilon \rightarrow 0$, the penalty parameter must depend
on the mesh size, and that as we refine the mesh, the problem becomes
increasingly ill-conditioned.  A related method for imposing Dirichlet boundary
conditions, known as Nitsche's method [!cite](juntunen2009nitsche), does not
suffer from the same ill-conditioning issues, and is slated for inclusion
in MOOSE some time in the future.


### Example Input Syntax





## ADMatchedValueBC


### Description

`ADMatchedValueBC` is a `ADNodalBC` which applies to systems of two or more variables,
and can be used to impose equality of two solutions along a given `boundary`.
This class is appropriate for systems of partial differential equations (PDEs) of
the form
\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f_1 && \quad \in \Omega \\
  -\nabla^2 v &= f_2 && \quad \in \Omega \\
  \frac{\partial u}{\partial n} &= h_1 && \quad \in \partial \Omega_N \\
  \frac{\partial v}{\partial n} &= h_2 && \quad \in \partial \Omega_N \\
  u &= v && \quad \in \partial \Omega_D,
\end{aligned}
\end{equation}
where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary,
$u$, $v$ are the unknowns, $f_1$, $f_2$ are forcing functions (which
may depend on both $u$ and $v$), and $h_1$ and $h_2$ are given
fluxes. The `v` parameter is used to specify the variable whose value
is tied to $u$. In the example below, the other variable's name
happens to be `v` as well.

### Example Input Syntax





## ADNeumannBC


### Description

`ADNeumannBC` is the simplest type of `ADIntegratedBC`, and is used for
imposing flux boundary conditions on systems of partial differential
equations (PDEs). This class is appropriate to use for PDEs of the
form
\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= h && \quad \in \partial \Omega_N,
\end{aligned}
\end{equation}
where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary. In
this case, a `ADNeumannBC` object is used to impose the condition (3) on
the subset of the boundary denoted by $\partial \Omega_N$. The `value`
parameter corresponds to the constant $h$, and the user must define
one or more sidesets corresponding to the boundary subset $\partial
\Omega_N$.  The normal derivative notation is $\frac{\partial
u}{\partial n} \equiv \nabla u \cdot \hat{n}$, where $\hat{n}$ is the
outward unit normal to $\partial \Omega_N$.

### Example Input Syntax





## ADPenaltyDirichletBC


### Description

`ADPenaltyDirichletBC` is a `ADIntegratedBC` used for enforcing Dirichlet boundary conditions
which differs from the [`ADDirichletBC`](/ADDirichletBC.md) class in the way in which it handles the enforcement.
It is appropriate for partial differential equations (PDEs) in the form

\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= h && \quad \in \partial \Omega_N
\end{aligned}
\end{equation}

Instead of imposing the Dirichlet condition directly on the basis by replacing the
equations associated with those degrees of freedom (DOFs) by the auxiliary equation
$u-g=0$, the `ADPenaltyDirichletBC` is based on the variational statement:
find $u \in H^1(\Omega)$ such that
\begin{equation}
  \label{weakform}
  \int_{\Omega} \left( \nabla u \cdot \nabla v - fv \right) \,\text{d}x
  -\int_{\partial \Omega_N} hv \,\text{d}s
  +\int_{\partial \Omega_D} \frac{1}{\epsilon} (u-g)v \,\text{d}s = 0
\end{equation}
holds for every $v \in H^1(\Omega)$. In [weakform], $\epsilon
\ll 1$ is a user-selected parameter which must be taken small enough
to ensure that $u \approx g$ on $\partial \Omega_D$. The
user-selectable class parameter `penalty` corresponds to
$\frac{1}{\epsilon}$, and must be chosen large enough to ensure
good agreement with the Dirichlet data, but not so large that the
resulting Jacobian becomes ill-conditioned, resulting in failed solves
and overall accuracy losses.

Benefits of the penalty-based approach include simplified Dirichlet
boundary condition enforcement for non-Lagrange finite element bases,
maintaining the symmetry (if any) of the original problem, and
avoiding the need to zero out contributions from other rows in a
special post-assembly step. Integrating by parts "in reverse"
from [weakform], one obtains

\begin{equation}
  \label{weakform2}
  \int_{\Omega} \left( -\nabla^2 u  - f \right) v \,\text{d}x
  +\int_{\partial \Omega_N} \left( \frac{\partial u}{\partial n} - h \right) v \,\text{d}s
  +\int_{\partial \Omega_D} \left[ \frac{\partial u}{\partial n} + \frac{1}{\epsilon} (u-g) \right] v \,\text{d}s = 0
\end{equation}

We therefore recover a "perturbed" version of the original problem with the flux
boundary condition

\begin{equation}
  \frac{\partial u}{\partial n} = -\frac{1}{\epsilon} (u-g) \, \in \partial \Omega_D
\end{equation}

replacing the original Dirichlet boundary condition. It has been shown
[!cite](juntunen2009nitsche) that in order for the solution to this perturbed
problem to converge to the solution of the original problem in the
limit as $\epsilon \rightarrow 0$, the penalty parameter must depend
on the mesh size, and that as we refine the mesh, the problem becomes
increasingly ill-conditioned.  A related method for imposing Dirichlet boundary
conditions, known as Nitsche's method [!cite](juntunen2009nitsche), does not
suffer from the same ill-conditioning issues, and is slated for inclusion
in MOOSE some time in the future.






### Example Input Syntax





## ADRobinBC


### Description

`ADRobinBC` imposes a Robin boundary condition on a boundary. `ADRobinBC` is
an integrated boundary condition similar to a [NeumannBC.md], but the derivative is
set to a function of the variable instead of a constant.

Note that `ADRobinBC` computes its Jacobian using automatic differentiation.

### Example Input Syntax





## ADVectorFunctionDirichletBC


### Description

`ADVectorFunctionDirichletBC` is the extension of [`FunctionDirichletBC`](bcs/DirichletBC) to
Lagrange vector variables and is used for
imposing so-called "essential" boundary conditions on systems of
partial differential equations (PDEs).  Such boundary conditions force
a particular set of degrees of freedom (DOFs) defined by the
`boundary` parameter to take on controllable values. This
class is appropriate to use for PDEs of the form
\begin{equation}
\begin{aligned}
  -\nabla^2 \vec{u} &= \vec{f} && \quad \in \Omega \\
  \vec{u} &= \vec{g} && \quad \in \partial \Omega_D \\
  \frac{\partial \vec{u}}{\partial n} &= \vec{h} && \quad \in \partial \Omega_N
\end{aligned}
\end{equation}

where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary. In
this case, a `VectorFunctionDirichletBC` object is used to impose the condition (2)
on the subset of the boundary denoted by $\partial \Omega_D$. In this case,
$\vec{g}$ is supplied through the `Function` parameters `function_x`, `function_y`, and
`function_z`. If any of those parameters are not supplied by the user, they
take a default value of $0$. The user must define one
or more sidesets corresponding to the boundary subset $\partial \Omega_D$.

Note that this BC computes its Jacobian using automatic differentiation




## ADVectorFunctionNeumannBC


### Description

`ADVectorFunctionNeumannBC` is similar to [`ADFunctionNeumannBC`](bcs/ADFunctionNeumannBC) for
vector variables and is used for
imposing flux boundary conditions on systems of
partial differential equations (PDEs). This
class is appropriate to use for PDEs of the form
\begin{equation}
\begin{aligned}
  -\nabla^2 \vec{u} &= \vec{f} && \quad \in \Omega \\
  \vec{u} &= \vec{g} && \quad \in \partial \Omega_D \\
  \frac{\partial \vec{u}}{\partial n} &= \vec{h} && \quad \in \partial \Omega_N
\end{aligned}
\end{equation}

where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary. In
this case, a `ADVectorFunctionNeumannBC` object is used to impose the condition (3)
on the subset of the boundary denoted by $\partial \Omega_N$. In this case,
$\vec{h}$ is supplied through the [`Function`](Functions/index.md) parameters [!param](/BCs/ADVectorFunctionNeumannBC/function_x), [!param](/BCs/ADVectorFunctionNeumannBC/function_y), and
[!param](/BCs/ADVectorFunctionNeumannBC/function_z). If any of those parameters are not supplied by the user, they
take a default value of $0$. The user must define one
or more sidesets corresponding to the boundary subset $\partial \Omega_N$.

Note that this BC computes its Jacobian using the automatic differentiation system.




## ADVectorMatchedValueBC


### Description

`ADVectorMatchedValueBC` is a `ADVectorNodalBC` which applies to systems of two or more variables,
and can be used to impose equality of two solutions along a given `boundary`.
This class is appropriate for systems of partial differential equations (PDEs) of
the form
\begin{equation}
\begin{aligned}
  -\nabla^2 \vec{u} &= \vec{f}_1 && \quad \in \Omega \\
  -\nabla^2 \vec{v} &= \vec{f}_2 && \quad \in \Omega \\
  \frac{\partial \vec{u}}{\partial n} &= \vec{h}_1 && \quad \in \partial \Omega_N \\
  \frac{\partial \vec{v|}{\partial n} &= \vec{h}_2 && \quad \in \partial \Omega_N \\
  \vec{u} &= \vec{v} && \quad \in \partial \Omega_D,
\end{aligned}
\end{equation}
where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary,
$\vec{u}$, $\vec{v}$ are the unknowns, $\vec{f}_1$, $\vec{f}_2$ are forcing functions (which
may depend on both $\vec{u}$ and $\vec{v}$), and $\vec{h}_1$ and $\vec{h}_2$ are given
fluxes. The `v` parameter is used to specify the variable whose value
is tied to $\vec{u}$. In the example below, the other variable's name
happens to be `v` as well.

### Example Input Syntax





## ADVectorRobinBC


### Description

`ADVectorRobinBC` imposes a Robin boundary condition on a boundary.
`ADVectorRobinBC` is
a vector integrated boundary condition that allows for the combination of
Dirichlet and Neumann boundary conditions.

Note that `ADVectorRobinBC` computes its Jacobian using automatic differentiation.

### Example Input Syntax





## ArrayDirichletBC

### Description

This boundary condition applies Dirichlet boundary conditions to all components of an array variable.
Its standard variable version is [DirichletBC.md].
Different boundary values for components can be assigned.

### Example Input Syntax





## ArrayHFEMDirichletBC

### Description

This boundary condition applies Dirichlet boundary conditions with HFEM (hybrid finite element method) to all components of an array variable.
Its standard variable version is [HFEMDirichletBC.md].
Different boundary values for components can be assigned.

### Example Input Syntax





## ArrayNeumannBC

### Description

This boundary condition applies Neumann boundary conditions to all components of an array variable.
Its standard variable version is [NeumannBC.md].
Different current values for components can be assigned.

### Example Input Syntax




## ArrayPenaltyDirichletBC

### Description

Its standard variable version is [PenaltyDirichletBC.md].





## ArrayVacuumBC

### Description


Its standard variable version is [VacuumBC.md].
Currently $\alpha$ is implemented in the boundary condition as an array with the same size of the number of components of the array variable. We do not made it a full matrix that allows all components are coupled with this boundary condition.





## ConvectiveFluxBC


### Description

The `ConvectiveFluxBC` boundary condition determines the value on a boundary based upon
the initial and final values, the flux through the boundary and the duration of exposure.

### Example Input Syntax





## CoupledVarNeumannBC


### Description

`CoupledVarNeumannBC` is a generalization of the `NeumannBC`. Instead of
coupling a single real value through the `value` parameter, a coupled variable
is provided for the `v` parameter.

Parameter $scale$ can be used to scale the boundary condition value. By default, it is $1.$ (i.e. no scaling).
Note that $scale$ is actually a field variable, so spatially dependent scaling is possible.
This can be used to locally turn the BC on or off.

### Example Input Syntax





## DGFunctionDiffusionDirichletBC


Note that these boundary conditions are specific to DG and to a diffusion problem. Using a [syntax/Functions/index.md]
for the Dirichlet boundary conditions means that the spatial and time dependence is either known or imposed.

More information about Dirichlet boundary conditions and their mathematical meaning may be found in the
[DirichletBC.md] documentation, and more information may be found about the discontinuous Galerkin
discretization in the [DGKernels documentation](syntax/DGKernels/index.md)

### Example input syntax

In this example, a 2D diffusion problem is solved with DG. A Dirichlet boundary condition is imposed
on all boundaries using the `exact_fn` function. The `epsilon` and `sigma` parameters are DG parameters.





## DiffusionFluxBC


### Description

`DiffusionFluxBC` is a `FluxBC` which is appropriate for use with the boundary terms arising from the
[`Diffusion`](/Diffusion.md) [`Kernel`](syntax/Kernels/index.md). `DiffusionFluxBC` does not
"enforce" a boundary condition per-se (see, e.g. [`DirichletBC`](/DirichletBC.md),
[`NeumannBC`](/NeumannBC.md), and related classes for that).  Instead, this class is responsible for
computing the residual (and Jacobian) contributions due to the boundary contribution arising from
integration by parts on the [`Diffusion`](/Diffusion.md) [`Kernel`](syntax/Kernels/index.md).

The standard theory of elliptic operators requires the specification of boundary conditions on all
parts of the boundary, so "implicitly" computing a residual contribution in this manner (instead of
replacing it with the correct "data") falls outside of this theory. That said, there are instances
where such an approach gives reasonable results in practice, see, for example, the paper by
[!cite](griffiths1997noboundary).

As an example, consider the Poisson problem with mixed
boundary conditions:
\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= h && \quad \in \partial \Omega_N,
\end{aligned}
\end{equation}
where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N \cup \partial \Omega_F$ is its boundary,
and no boundary conditions are specified on $\partial \Omega_F$.
The weak formulation of this problem is: find $u$ satisfying the Dirichlet
boundary conditions and such that
\begin{equation}
  \label{weakform}
  \int_{\Omega} \left( \nabla u \cdot \nabla v - fv \right) \,\text{d}x
  -\int_{\partial \Omega_N} hv \,\text{d}s
  -\underbrace{\int_{\partial \Omega_F} \frac{\partial u}{\partial n} v \,\text{d}s}_{\texttt{DiffusionFluxBC}} = 0
\end{equation}
holds for every
$v \in \mathcal{V} = \{v : v \in H^1(\Omega), v=0 \text{ on } \partial \Omega_D \}$,
i.e. test functions that vanish on the Dirichlet boundary. The `DiffusionFluxBC`
class would then be used to compute the last term in [weakform].



### Example Input Syntax





## DirectionalNeumannBC


### Description

`DirectionalNeumannBC` is an `IntegratedBC` which weakly imposes the flux boundary condition
$\frac{\partial u}{\partial n} = \vec{V}\cdot\hat{n}$, where the user specifies the vector $\vec{V}$
and the unit normal vector $\hat{n}$ is determined by the geometry of the domain $\Omega$. This class
is appropriate to use in systems of partial differential equations (PDEs) of the form
\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= \vec{V} \cdot \hat{n} && \quad \in \partial \Omega_N
\end{aligned}
\end{equation}

There is not a 1:1 correspondence between the choice of$\vec{V}$ and the resulting solution, since
the component of $\vec{V}$which is orthogonal to the outward normal vector will not have any effect
on the result.

This class exists mainly for convenience: if the true solution has a constant flux, then it is easier
to specify Neumann boundary conditions on parts of the boundary with different outward normal vectors
by simply specifying the true constant flux vector, and allowing MOOSE to dot it with the appropriate
outward normals as necessary.

### Example Input Syntax





## DirichletBC


### Description

`DirichletBC` is the simplest type of `NodalBC`, and is used for
imposing so-called "essential" boundary conditions on systems of
partial differential equations (PDEs).  Such boundary conditions force
a particular set of degrees of freedom (DOFs) defined by the
`boundary` parameter to take on a single, controllable value. This
class is appropriate to use for PDEs of the form

\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= h && \quad \in \partial \Omega_N,
\end{aligned}
\end{equation}

where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary. In
this case, a `DirichletBC` object is used to impose the condition (2)
on the subset of the boundary denoted by $\partial \Omega_D$. In this case, the
`value` corresponds to the constant $g$, and the user must define one
or more sidesets corresponding to the boundary subset $\partial \Omega_D$.

### Preset boundary conditions

With the parameter `preset = true`, the value of the boundary condition is applied
before the solve begins. With `preset = false`, the boundary condition is
only enforced as the solve progresses. In most situations, presetting the boundary
condition is better.

### Similar Dirichlet BCs

- To use a Function instead of a constant value : [FunctionDirichletBC.md]
- To impose a Dirichlet BC using a penalty method or on an elemental variable : [PenaltyDirichletBC.md]
- To use a another variable instead of a constant value : [MatchedValueBC.md]

### Example Input Syntax





## EigenArrayDirichletBC

It is an array version of EigenDirichletBC provided for Eigenvalue solvers to
handle Dirichlet boundary conditions for the right-hand side. It is different
from regular DirichletBC. EigenArrayDirichletBC will always return 0
regardless of the residual. The corresponding rows of the matrix are zeroed
out without adding ones to the diagonal.





## EigenDirichletBC

EigenDirichletBC is provided for Eigenvalue solvers to handle Dirichlet boundary
conditions for the right hand side. It is different from the regular Dirichlet BC.
EigenDirichletBC will always return 0 regardless of the residual, and for the
Jacobian matrix, the corresponding rows are totally zeroed out without adding one
to the matrix diagonal.






## FunctionDirichletBC


### Description

`FunctionDirichletBC` is a generalization of [`DirichletBC`](/DirichletBC.md) which
imposes a possibly temporally- and spatially-dependent value defined
by a MOOSE [`Function`](/Functions/index.md) object on a particular set of degrees of freedom
(DOFs) defined by the `boundary` parameter. That is, for a
PDE of the form

\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g(t,\vec{x}) && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= h(t,\vec{x}) && \quad \in \partial \Omega_N
\end{aligned}
\end{equation}

where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary,
a `FunctionDirichletBC` object can be used to impose the
condition (2) if the function is well-defined for $\vec{x} \in
\partial \Omega_D$. In this case, the `function` parameter corresponds to a
MOOSE `Function` object which represents the mathematical function
$g(t,\vec{x})$, and the user must define one or more sidesets
corresponding to the boundary subset $\partial \Omega_D$ via the
`boundary` parameter.

### Preset boundary conditions

With the parameter `preset = true`, the value of the boundary condition is applied
before the solve begins. With `preset = false`, the boundary condition is
only enforced as the solve progresses. In most situations, presetting the boundary
condition is better.

### Example Input Syntax





## FunctionGradientNeumannBC

`FunctionGradientNeumannBC` adds the weak form contribution:
$\langle -\psi_i, \vec{n} \cdot k \nabla f \rangle$ where $\vec{n}$ is the
unit normal vector at the boundary, $k$ is a coefficient (corresponding to
thermal conductivity or diffusivity), and $f$ is a function of space and time
that is specified in the input file through the parameter `exact_solution`. As
the parameter name suggests, the `FunctionGradientNeumannBC` object can be
useful for specifying a Neumann condition when the exact solution to the PDE is
known.





## FunctionNeumannBC


### Description

`FunctionNeumannBC` is a generalization of [`NeumannBC`](/NeumannBC.md) which is used
for imposing flux boundary conditions on systems of partial
differential equations (PDEs) where the flux is represented by a
spatially- and temporally-varying MOOSE [`Function`](/Functions/index.md).  That is, for a
PDE of the form
\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g(t,\vec{x}) && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= h(t,\vec{x}) && \quad \in \partial \Omega_N,
\end{aligned}
\end{equation}
where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary, a
`FunctionNeumannBC` object can be used to impose condition (3) if the
function is well-defined for all relevant times and $\vec{x} \in
\partial \Omega_N$. In this case, the `function` parameter corresponds
to a MOOSE `Function` object which represents the mathematical
function $h(t,\vec{x})$, and the user must define one or more sidesets
corresponding to the boundary subset $\partial \Omega_N$ via the
`boundary` parameter.

### Example Input Syntax





## FunctionPenaltyDirichletBC


### Description

`FunctionPenaltyDirichletBC` is a generalization of [`PenaltyDirichletBC`](/PenaltyDirichletBC.md) which
imposes a possibly temporally- and spatially-dependent value defined
by a MOOSE [`Function`](/Functions/index.md) object on a particular set of degrees of freedom
(DOFs) defined by the `boundary` parameter. That is, for a
PDE of the form

\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g(t,\vec{x}) && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= h(t,\vec{x}) && \quad \in \partial \Omega_N
\end{aligned}
\end{equation}

where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary,
a `FunctionPenaltyDirichletBC` object can be used to impose the
condition (2) if the function is well-defined for $\vec{x} \in
\partial \Omega_D$. In this case, the `function` parameter corresponds to a
MOOSE `Function` object which represents the mathematical function
$g(t,\vec{x})$, and the user must define one or more sidesets
corresponding to the boundary subset $\partial \Omega_D$ via the
`boundary` parameter.

Instead of imposing the Dirichlet condition directly on the basis by replacing the
equations associated with those degrees of freedom (DOFs) by the auxiliary equation
$u-g(t,\vec{x})=0$, the `FunctionPenaltyDirichletBC` is based on the variational statement:
find $u \in H^1(\Omega)$ such that
\begin{equation}
  \label{weakform}
  \int_{\Omega} \left( \nabla u \cdot \nabla v - fv \right) \,\text{d}x
  -\int_{\partial \Omega_N} hv \,\text{d}s
  +\int_{\partial \Omega_D} \frac{1}{\epsilon} (u-g(t,\vec{x}))v \,\text{d}s = 0
\end{equation}
holds for every $v \in H^1(\Omega)$. In [weakform], $\epsilon
\ll 1$ is a user-selected parameter which must be taken small enough
to ensure that $u \approx g(t,\vec{x})$ on $\partial \Omega_D$. The
user-selectable class parameter `penalty` corresponds to
$\frac{1}{\epsilon}$, and must be chosen large enough to ensure
good agreement with the Dirichlet data, but not so large that the
resulting Jacobian becomes ill-conditioned, resulting in failed solves
and overall accuracy losses.

Benefits of the penalty-based approach include simplified Dirichlet
boundary condition enforcement for non-Lagrange finite element bases,
maintaining the symmetry (if any) of the original problem, and
avoiding the need to zero out contributions from other rows in a
special post-assembly step. Integrating by parts "in reverse"
from [weakform], one obtains

\begin{equation}
  \label{weakform2}
  \int_{\Omega} \left( -\nabla^2 u  - f \right) v \,\text{d}x
  +\int_{\partial \Omega_N} \left( \frac{\partial u}{\partial n} - h(t,\vec{x}) \right) v \,\text{d}s
  +\int_{\partial \Omega_D} \left[ \frac{\partial u}{\partial n} + \frac{1}{\epsilon} (u-g(t,\vec{x})) \right] v \,\text{d}s = 0
\end{equation}

We therefore recover a "perturbed" version of the original problem with the flux
boundary condition

\begin{equation}
  \frac{\partial u}{\partial n} = -\frac{1}{\epsilon} (u-g(t,\vec{x})) \, \in \partial \Omega_D
\end{equation}

replacing the original Dirichlet boundary condition. It has been shown
[!cite](juntunen2009nitsche) that in order for the solution to this perturbed
problem to converge to the solution of the original problem in the
limit as $\epsilon \rightarrow 0$, the penalty parameter must depend
on the mesh size, and that as we refine the mesh, the problem becomes
increasingly ill-conditioned.  A related method for imposing Dirichlet boundary
conditions, known as Nitsche's method [!cite](juntunen2009nitsche), does not
suffer from the same ill-conditioning issues, and is slated for inclusion
in MOOSE some time in the future.


### Example Input Syntax





## FunctorDirichletBC


### Description

`FunctorDirichletBC` is a generalization of [`DirichletBC`](/DirichletBC.md) which
imposes a possibly temporally- and spatially-dependent, possibly coupled to other variables/functors,
value defined by a MOOSE [`Functor`](/Functors/index.md) object on a particular set of degrees of freedom
(DOFs) defined by the `boundary` parameter. That is, for a
PDE of the form

\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g(t,\vec{x}) && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= c(t,,\vec{x},...) h(t,\vec{x}, ...) && \quad \in \partial \Omega_N
\end{aligned}
\end{equation}

where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary,
a `FunctorDirichletBC` object can be used to impose the
condition (2) if the Functor is well-defined for $\vec{x} \in
\partial \Omega_D$. In this case, the [!param](/BCs/FunctorDirichletBC/functor)
parameter corresponds to a MOOSE [Functor](Functors/index.md) object and `h` in the equation
for the boundary condition. Similarly `c` corresponds to a functor
[!param](/BCs/FunctorDirichletBC/coefficient) parameter. Both the functor and the coefficient
can have arbitrary dependencies on other functors, which can include variables, functions,
postprocessors, etc.

The user must define one or more sidesets
corresponding to the boundary subset $\partial \Omega_D$ via the
`boundary` parameter and it is the user's responsibility to ensure
the functor and the coefficient are defined there.

### Preset boundary conditions

With the parameter `preset = true`, the value of the boundary condition is applied
before the solve begins. With `preset = false`, the boundary condition is
only enforced as the solve progresses. In most situations, presetting the boundary
condition is better.

### Example Input Syntax





## FunctorNeumannBC


### Description

`FunctorNeumannBC` is a generalization of [`ADNeumannBC`](/ADNeumannBC.md) which is used
for imposing flux boundary conditions on systems of partial
differential equations (PDEs) where the flux is represented by a
spatially- and temporally-varying MOOSE [`Function`](/Functions/index.md).  That is, for a
PDE of the form
\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g(t,\vec{x}) && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= h(t,\vec{x}) && \quad \in \partial \Omega_N,
\end{aligned}
\end{equation}
where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary, a
`FunctorNeumannBC` object can be used to impose the third condition if the
function is well-defined for all relevant times and $\vec{x} \in
\partial \Omega_N$. In this case, the parameters [!param](/BCs/FunctorNeumannBC/functor)
and [!param](/BCs/FunctorNeumannBC/coefficient) are [functors](Functors/index.md),
whose product represents the mathematical function $h(t,\vec{x})$
(or $-h(t,\vec{x})$ if [!param](/BCs/FunctorNeumannBC/flux_is_inward) is set to `false`),
and the user must define one or more sidesets corresponding to the boundary
subset $\partial \Omega_N$ via the [!param](/BCs/FunctorNeumannBC/boundary) parameter.




## HFEMDirichletBC


### Description

`HFEMDirichletBC` is used for imposing the Dirichlet boundary with HFEM (hybrid finite element method).
A `HFEMDirichletBC` object is for $\left( u^\ast, \lambda_D \right)_{\partial \Omega_D} + \left( \lambda_D^\ast, u - g \right)_{\partial \Omega_D}$ on the subset of the boundary denoted by $\partial \Omega_D$.
Thus it requires the [!param](/BCs/HFEMDirichletBC/variable) parameter for $u$, the [!param](/BCs/HFEMDirichletBC/lowerd_variable) parameter for $\lambda_D$
and the [!param](/BCs/HFEMDirichletBC/value) corresponds to $g$. Refer to [DGKernels/index.md] for the full HFEM weak form for Poisson's equation.

### Example Input Syntax





## MatchedValueBC


### Description

`MatchedValueBC` is a `NodalBC` which applies to systems of two or more variables,
and can be used to impose equality of two solutions along a given `boundary`.
This class is appropriate for systems of partial differential equations (PDEs) of
the form
\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f_1 && \quad \in \Omega \\
  -\nabla^2 v &= f_2 && \quad \in \Omega \\
  \frac{\partial u}{\partial n} &= h_1 && \quad \in \partial \Omega_N \\
  \frac{\partial v}{\partial n} &= h_2 && \quad \in \partial \Omega_N \\
  u &= v && \quad \in \partial \Omega_D,
\end{aligned}
\end{equation}
where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary,
$u$, $v$ are the unknowns, $f_1$, $f_2$ are forcing functions (which
may depend on both $u$ and $v$), and $h_1$ and $h_2$ are given
fluxes. The `v` parameter is used to specify the variable whose value
is tied to $u$. In the example below, the other variable's name
happens to be `v` as well.

### Example Input Syntax





## MatNeumannBC


### Description

`MatNeumannBC` is a generalization of [`NeumannBC`](/NeumannBC.md) which is used
for imposing flux boundary conditions on systems of partial
differential equations (PDEs) where the flux is represented by the product
of a constant and a MOOSE Material [`Material`](/Materials/index.md).  That is, for a
PDE of the form
\begin{equation}
\begin{aligned}
  -\nabla \cdot C (\nabla u) &= f && \quad \in \Omega \\
  u &= g(t,\vec{x}) && \quad \in \partial \Omega_D \\
  C \frac{\partial u}{\partial n} &= hM(t,\vec{x}) && \quad \in \partial \Omega_N,
\end{aligned}
\end{equation}
where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary, a
`MatNeumannBC` object can be used to impose condition (3) if the
material is well-defined for all relevant times and $\vec{x} \in
\partial \Omega_N$. In this case, the `boundary_material` parameter corresponds
to a MOOSE `Material` object, and the user must define one or more sidesets
corresponding to the boundary subset $\partial \Omega_N$ via the
`boundary` parameter.

### Example Input Syntax





## NeumannBC


### Description

`NeumannBC` is the simplest type of `IntegratedBC`, and is used for
imposing flux boundary conditions on systems of partial differential
equations (PDEs). This class is appropriate to use for PDEs of the
form
\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= h && \quad \in \partial \Omega_N,
\end{aligned}
\end{equation}
where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary. In
this case, a `NeumannBC` object is used to impose the condition (3) on
the subset of the boundary denoted by $\partial \Omega_N$. The `value`
parameter corresponds to the constant $h$, and the user must define
one or more sidesets corresponding to the boundary subset $\partial
\Omega_N$.  The normal derivative notation is $\frac{\partial
u}{\partial n} \equiv \nabla u \cdot \hat{n}$, where $\hat{n}$ is the
outward unit normal to $\partial \Omega_N$.

### Example Input Syntax





## OneDEqualValueConstraintBC


The constraint is imposed using a Lagrange multiplier, a scalar variable.

More information about the mortar method may be found in the
[`Constraints documentation`](syntax/Constraints/index.md).

### Example input syntax

In this example, two 1D lines are connected using the `OneDEqualValueConstraintBC` as a mortar constraint.
The sign to impose on the variable value on the boundary nodes is specified with the [!param](/BCs/OneDEqualValueConstraintBC/vg) parameter.
The Lagrange multiplier, `lm`, is also subjected to a `NodalEqualValueConstraint` to achieve the continuity
at the interface.





## PenaltyDirichletBC


### Description

`PenaltyDirichletBC` is a `IntegratedBC` used for enforcing Dirichlet boundary conditions
which differs from the [`DirichletBC`](/DirichletBC.md) class in the way in which it handles the enforcement.
It is appropriate for partial differential equations (PDEs) in the form

\begin{equation}
\begin{aligned}
  -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g && \quad \in \partial \Omega_D \\
  \frac{\partial u}{\partial n} &= h && \quad \in \partial \Omega_N
\end{aligned}
\end{equation}

Instead of imposing the Dirichlet condition directly on the basis by replacing the
equations associated with those degrees of freedom (DOFs) by the auxiliary equation
$u-g=0$, the `PenaltyDirichletBC` is based on the variational statement:
find $u \in H^1(\Omega)$ such that
\begin{equation}
  \label{weakform}
  \int_{\Omega} \left( \nabla u \cdot \nabla v - fv \right) \,\text{d}x
  -\int_{\partial \Omega_N} hv \,\text{d}s
  +\int_{\partial \Omega_D} \frac{1}{\epsilon} (u-g)v \,\text{d}s = 0
\end{equation}
holds for every $v \in H^1(\Omega)$. In [weakform], $\epsilon
\ll 1$ is a user-selected parameter which must be taken small enough
to ensure that $u \approx g$ on $\partial \Omega_D$. The
user-selectable class parameter `penalty` corresponds to
$\frac{1}{\epsilon}$, and must be chosen large enough to ensure
good agreement with the Dirichlet data, but not so large that the
resulting Jacobian becomes ill-conditioned, resulting in failed solves
and overall accuracy losses.

Benefits of the penalty-based approach include simplified Dirichlet
boundary condition enforcement for non-Lagrange finite element bases,
maintaining the symmetry (if any) of the original problem, and
avoiding the need to zero out contributions from other rows in a
special post-assembly step. Integrating by parts "in reverse"
from [weakform], one obtains

\begin{equation}
  \label{weakform2}
  \int_{\Omega} \left( -\nabla^2 u  - f \right) v \,\text{d}x
  +\int_{\partial \Omega_N} \left( \frac{\partial u}{\partial n} - h \right) v \,\text{d}s
  +\int_{\partial \Omega_D} \left[ \frac{\partial u}{\partial n} + \frac{1}{\epsilon} (u-g) \right] v \,\text{d}s = 0
\end{equation}

We therefore recover a "perturbed" version of the original problem with the flux
boundary condition

\begin{equation}
  \frac{\partial u}{\partial n} = -\frac{1}{\epsilon} (u-g) \, \in \partial \Omega_D
\end{equation}

replacing the original Dirichlet boundary condition. It has been shown
[!cite](juntunen2009nitsche) that in order for the solution to this perturbed
problem to converge to the solution of the original problem in the
limit as $\epsilon \rightarrow 0$, the penalty parameter must depend
on the mesh size, and that as we refine the mesh, the problem becomes
increasingly ill-conditioned.  A related method for imposing Dirichlet boundary
conditions, known as Nitsche's method [!cite](juntunen2009nitsche), does not
suffer from the same ill-conditioning issues, and is slated for inclusion
in MOOSE some time in the future.






### Example Input Syntax





## PostprocessorDirichletBC


More information about Dirichlet boundary conditions and their mathematical meaning may be found in the
[DirichletBC.md] documentation.

A common postprocessor input for the `PostprocessorDirichletBC` is the [Receiver.md] postprocessor,
which is populated by a transfer from a [syntax/MultiApps/index.md]. The two simulations are then coupled through
this boundary condition, by setting the value of a variable on a boundary.

### Example Input Syntax

This example demonstrates the use case outlined above with `PostprocessorDirichletBC` on the `right` boundary
for variables `x` and `y`. The postprocessor input to the boundary conditions are `incoming_x` and `incoming_y`
respectively.





## PostprocessorNeumannBC


More information about Neumann boundary conditions and their mathematical meaning may be found in the
[NeumannBC.md] documentation.

A common postprocessor input for the `PostprocessorNeumannBC` is the [Receiver.md] postprocessor,
which is populated by a transfer from a [syntax/MultiApps/index.md]. The two simulations are then coupled through
this boundary condition, by a numerical flux on a boundary.

### Example Input Syntax

In this example, the value of variable `aux` is sampled using a `PointValue` postprocessor then
reused as a Neumann boundary condition for the nonlinear variable `u` using a `PostprocessorNeumannBC`.





## SinDirichletBC


### Description

`SinDirichletBC` is a `NodalBC` which imposes a time-varying boundary value of the form

\begin{equation}
  g(t) = \left\{
  \begin{array}{ll}
    g_0 + (g_T - g_0) \sin \left( \frac{\pi t}{2T} \right), & 0 < t \leq T \\
    g_T, & t \geq T
  \end{array}
  \right.
\end{equation}

where $g_0$ and $g_T$ are the initial and final values of $g$, respectively,
and $T$ is the final time. These values are controlled by the
`initial`, `final`, and `duration` parameters, respectively.
The value is applied on one or more sidesets specified
by the `boundary` parameter and does not vary in space. This type of boundary
condition is applicable to time-varying PDEs, for example:

\begin{equation}
\begin{aligned}
  \frac{\partial u}{\partial t} -\nabla^2 u &= f && \quad \in \Omega \\
  u &= g(t) && \quad \in \partial \Omega
\end{aligned}
\end{equation}

and is frequently used to "ramp" a difficult boundary condition to its
final value over a short time interval, rather than imposing it
instantaneously at time $t=0$.  This approach can make nonlinear
solvers more robust by improving the initial guess used by the Newton
iterations, as well as preventing the solver from converging to
non-physical solutions in nonlinear PDEs.

### Example Input Syntax





## SinNeumannBC


### Description

`SinNeumannBC` is an `IntegratedBC` which imposes a time-varying flux of the form

\begin{equation}
  g(t) = \left\{
  \begin{array}{ll}
    g_0 + (g_T - g_0) \sin \left( \frac{\pi t}{2T} \right), & 0 < t \leq T \\
    g_T, & t \geq T
  \end{array}
  \right.
\end{equation}

where $g_0$ and $g_T$ are the initial and final values of $g$, respectively,
and $T$ is the final time. These values are controlled by the
`initial`, `final`, and `duration` parameters, respectively.
The value is applied on one or more sidesets specified
by the `boundary` parameter and does not vary in space. This type of boundary
condition is applicable to time-varying PDEs, for example:

\begin{equation}
\begin{aligned}
  \frac{\partial u}{\partial t} -\nabla^2 u &= f && \quad \in \Omega \\
  \frac{\partial u}{\partial n} &= g(t) && \quad \in \partial \Omega
\end{aligned}
\end{equation}

and is frequently used to "ramp" a difficult boundary condition to its
final value over a short time interval, rather than imposing it
instantaneously at time $t=0$.  This approach can make nonlinear
solvers more robust by improving the initial guess used by the Newton
iterations, as well as preventing the solver from converging to
non-physical solutions in nonlinear PDEs.


### Example Input Syntax





## VacuumBC


Vacuum is defined as no incoming flux from outside the boundary. This is a
common approximation in reactor physics where beyond a certain distance from a
nuclear system, we assume that while neutrons may still leave the system, they will
not come back.

The contribution to the residual is:

\int_{\partial \Omega} \alpha u(\vec{r}) \psi_t(\vec{r}) / 2. dS

where $\partial \Omega$ is the domain definition and $\psi_t$ is the test function.

### Example input syntax

In this input, a `VacuumBC` is used to impose a 0 incoming flux boundary condition in
a diffusion problem in a RZ geometry problem on the `top` boundary for variable `u`.





## VectorCurlPenaltyDirichletBC


### Overview

`VectorCurlPenaltyDirichletBC` enforces a weak sense of the Dirichlet boundary
condition of the curl of the nonlinear variable by setting the boundary as a
penalty times the inner product of the test function crossed with the surface
normal and the difference between the current solution and the Dirichlet data,
also crossed with the surface normal. This is given by

\begin{equation}
  p(\vec{u}^\ast \times \hat{n}, (\vec{u} - \vec{u}_0) \times \hat{n})
\end{equation}

where $p$ is a scalar defining the penalty value, $\vec{u}^\ast$ is the test
function, and $\vec{u} - \vec{u}_0$ is the vector difference between the current
solution and Dirichlet data.

This boundary condition can be useful for problems where the mesh is not as
refined and could potentially smooth out the problem data on a coarser mesh. It,
however, has problems on refined meshes and leads to an ill-conditioned problem,
which can be difficult to solve.

Users should instead use [VectorPenaltyDirichletBC.md] or
[VectorDivPenaltyDirichletBC.md] if they wish to set a Dirichlet boundary
condition via the penalty method on the vector variable itself or its
divergence, respectively.

### Example Input File Syntax





## VectorDirichletBC


### Description

`VectorDirichletBC` is the extension of [`DirichletBC`](bcs/DirichletBC) to
Lagrange vector variables and is used for
imposing so-called "essential" boundary conditions on systems of
partial differential equations (PDEs).  Such boundary conditions force
a particular set of degrees of freedom (DOFs) defined by the
`boundary` parameter to take on controllable values. This
class is appropriate to use for PDEs of the form
\begin{equation}
\begin{aligned}
  -\nabla^2 \vec{u} &= \vec{f} && \quad \in \Omega \\
  \vec{u} &= \vec{g} && \quad \in \partial \Omega_D \\
  \frac{\partial \vec{u}}{\partial n} &= \vec{h} && \quad \in \partial \Omega_N
\end{aligned}
\end{equation}

where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary. In
this case, a `VectorDirichletBC` object is used to impose the condition (2)
on the subset of the boundary denoted by $\partial \Omega_D$. In this case, the
`values` correspond to the constant components of $\vec{g}$, and the user must define one
or more sidesets corresponding to the boundary subset $\partial \Omega_D$.




## VectorDivPenaltyDirichletBC


### Overview

`VectorDivPenaltyDirichletBC` enforces, in a weak sense, a Dirichlet boundary
condition on the divergence of a nonlinear vector variable $\vec{u}$ by setting

\begin{equation}
  R_i(\vec{u}) = p(\vec{\psi_i} \cdot \hat{n}, (\vec{u} - \vec{u}_0) \cdot \hat{n})
\end{equation}

where $p$ is a scalar defining the penalty value, $\vec{\psi_i}$ the test
functions, and $\vec{u} - \vec{u}_0$ is the vector difference between the
current solution and the Dirichlet data.

Users should instead use [VectorPenaltyDirichletBC.md] or
[VectorCurlPenaltyDirichletBC.md] if they wish to set a Dirichlet boundary
condition via the penalty method on the vector variable itself or its
curl, respectively.

### Example Input File Syntax





## VectorFunctionDirichletBC


### Description

`VectorFunctionDirichletBC` is a generalization of [`VectorDirichletBC`](/VectorDirichletBC.md) which
imposes possibly temporally- and spatially-dependent values for the Lagrange
vector components through
MOOSE [`Function`](/Functions/index.md) objects on degrees of freedom
that fall on the boundary defined by the `boundary` parameter. That is, for a
PDE of the form

\begin{equation}
\begin{aligned}
  -\nabla^2 \vec{u} &= \vec{f} && \quad \in \Omega \\
  \vec{u} &= \vec{g(t,\vec{x})} && \quad \in \partial \Omega_D \\
  \frac{\partial \vec{u}}{\partial n} &= \vec{h(t,\vec{x})} && \quad \in \partial \Omega_N
\end{aligned}
\end{equation}

where $\Omega \subset \mathbb{R}^n$ is the domain, and $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary.
A `VectorFunctionDirichletBC` object can be used to impose the
condition (2) if the function is well-defined for $\vec{x} \in
\partial \Omega_D$. In this case, the `function_x`, `function_y`, and `function_z` parameters correspond to a
set of MOOSE `Function` objects which represent the mathematical function
$\vec{g(t,\vec{x})}$, and the user must define one or more sidesets
corresponding to the boundary subset $\partial \Omega_D$ via the
`boundary` parameter.




## VectorPenaltyDirichletBC


### Description

`VectorPenaltyDirichletBC` implements a vector form of [`PenaltyDirichletBC`](/PenaltyDirichletBC.md),
which enforces a weak sense of the Dirichlet boundary
condition by setting the boundary as a penalty times the inner product of the
test function and the difference between the current solution and Dirichlet
data. This is given by $p(\vec{u}^\ast, \vec{u} - \vec{u}_0)$, where $p$ is a
scalar defining the penalty value, $\vec{u}^\ast$ is the test function, and
$\vec{u} - \vec{u}_0$ is the vector difference between the current solution and
Dirichlet data.

This boundary condition can be useful for problems where the mesh is not as
refined and could potentially smooth out the problem data on a coarser mesh. It,
however, has problems on refined meshes and leads to an ill-conditioned problem,
which can be difficult to solve.

### Example Input Syntax





## WeakGradientBC


### Description

`WeakGradientBC` is an `IntegratedBC` which is appropriate for use with the boundary terms arising
from the [`Diffusion`](/Diffusion.md) [`Kernel`](syntax/Kernels/index.md). `WeakGradientBC` does not
"enforce" a boundary condition per-se (see, e.g. [`DirichletBC`](/DirichletBC.md),
[`NeumannBC`](/NeumannBC.md), and related classes for that).  Instead, this class is responsible for
computing the residual (and Jacobian) contributions due to the boundary contribution arising from
integration by parts on the [`Diffusion`](/Diffusion.md) [`Kernel`](syntax/Kernels/index.md).

This class computes a residual contribution identical to that of the
[DiffusionFluxBC](/DiffusionFluxBC.md) class. Please see
that class' documentation for more detailed information.

### Example Input Syntax





# bounds

## ConstantBounds


### Description

`ConstantBounds` is used for setting bounds on a nonlinear variable specified
through the parameter `bounded_variable`. The bound type of `upper` or `lower` is set with `bound_type` parameter. The `bound_value` is used to specify the value of a bound. `ConstantBounds` expects a `variable` parameter to be set (as do all `AuxKernels`). This can be a dummy
`AuxVariable`; the `ConstantBounds` actually operates on `NumericVectors` held by the
nonlinear system and does nothing but return 0 for the value of the specified
`variable`.

Note that in order for these bounds to have an effect, the user has to specify the
PETSc options `-snes_type vinewtonssls` or `-snes_type vinewtonrsls`. A warning will be generated if neither options are specified. The PETSc manual pages for the `vinewtonssls` algorithm
can be found
[here](https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/SNES/SNESVINEWTONSSLS.html)
while the manual page for `vinewtonrsls` can be found
[here](https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/SNES/SNESVINEWTONRSLS.html#SNESVINEWTONRSLS).

MOOSE users can also enforce constraints through MOOSE using
[`UpperBoundNodalKernel`](/UpperBoundNodalKernel.md) and
[`LowerBoundNodalKernel`](/LowerBoundNodalKernel.md). However, using these
objects requires introduction of Lagrange multiplier variables that increase the
size of the nonlinear system as well as render some preconditioning methods
like algebraic multi-grid ineffective. The number of nonlinear iterations
required to solve a constrained PDE defined by
[this input file](/upper-and-lower-bound.i) with the various constraint
algorithms is summarized below:

- `vinewtonrsls` and `ConstantBounds`:                      22
- `vinewtonssls` and `ConstantBounds`:                      53
- `UpperBoundNodalKernel` and `LowerBoundNodalKernel`: 25

### Example Syntax





## VariableOldValueBounds


### Description

`VariableOldValueBounds` is used to set the bound for `bounded_variable` to be its old value. The bound type of `upper` or `lower` is set with `bound_type` parameter. `VariableOldValueBounds` expects a `variable` parameter to be set (as do all `AuxKernels`). This can be a dummy
`AuxVariable`; the `VariableOldValueBounds` actually operates on `NumericVectors` held by the
nonlinear system and does nothing but return 0 for the value of the specified
`variable`.

Note that in order for these bounds to have an effect, the user has to specify the
PETSc options `-snes_type vinewtonssls` or `-snes_type vinewtonrsls`. A warning will be generated if neither option is specified. MOOSE users can also specify bound with a constant using [`ConstantBounds`](/ConstantBounds.md).

### Example Syntax





# chaincontrols

## ChainControlData

`ChainControlData` is used in the [ChainControls system](syntax/ChainControls/index.md).
Each `ChainControlData` has a unique name and some type.

## GetFunctionValueChainControl

This [ChainControl](syntax/ChainControls/index.md) creates a new [/ChainControlData.md]
named `<control>:value`, where `<control>` is the user-given name of the `GetFunctionValueChainControl`,
and it computes its value by evaluating a given [Function](syntax/Functions/index.md)
at the current time and a given point in space.




## GetPostprocessorChainControl

This [ChainControl](syntax/ChainControls/index.md) copies the current value of a
[Postprocessor](syntax/Postprocessors/index.md) into a [/ChainControlData.md] of
type `Real`. This data will be named as `<control>:value`, where `<control>`
is the user-given name of the `GetPostprocessorChainControl`, unless
[!param](/ChainControls/GetPostprocessorChainControl/name_data_same_as_postprocessor)
is set to `true`, in which case the data is named the same as the post-processor.

Note that modification
of this `ChainControlData` does not modify the value of the original post-processor.




## LimitChainControl

This [ChainControl](syntax/ChainControls/index.md) allows the user to apply
a minimum and maximum value to a [chain control value](/ChainControlData.md).
The resulting value is named `<control>:value`, where `<control>` is the
user-given name of the `LimitChainControl`.




## ParsedChainControl

This [ChainControl](syntax/ChainControls/index.md) allows the user to specify
a function expression to be parsed and evaluated to populate a new [/ChainControlData.md]
named `<control>:value`, where `<control>` is the user-given name of the `ParsedChainControl`.

See [ChainControlParsedFunctionWrapper.md] for a list of acceptable types of
values for the entries in [!param](/ChainControls/ParsedChainControl/symbol_values)
and acceptable syntax for [!param](/ChainControls/ParsedChainControl/expression).




## PIDChainControl

This [ChainControl](syntax/ChainControls/index.md) implements the classic PID controller, which takes as its input
a value $x$ and the set point for that value, $\bar{x}$. It produces an output
signal $y$, which should be used as the input for some controllable device that
impacts the measured quantity $x$. For example, in a thermal system, $x$ may
be the temperature of a fluid at some location, and $y$ may be the power sent
to the heaters in the system, with the goal to heat the fluid such that the
temperature at some location is $\bar{x}$.

"PID" stands for its three components:

- P: Proportional
- I: Integral
- D: Derivative

The output signal $y$ at time $t_n$ is computed as follows:

y_n = K_p e_n + K_i \sum\limits_{m=1}^n e_m \Delta t_m + K_d \frac{e_n - e_{n-1}}{\Delta t_n} \,,

where $\Delta t_n \equiv t_n - t_{n-1}$ is the time step size and
$e_n$ is the error:

e_n \equiv \bar{x}_n - x_n \,.

The implementation assumes that the control will only be executed once per
time step, so you should set [!param](/ChainControls/PIDChainControl/execute_on) accordingly,
such as `execute_on = 'INITIAL TIMESTEP_END'`, which is the default.

The inputs and outputs are retrieved and named as follows, respectively:

- $x$ is set with [!param](/ChainControls/PIDChainControl/input).
- $\bar{x}$ is set with [!param](/ChainControls/PIDChainControl/set_point).
- $y$ is declared with the name `<control_name>:value`, where `<control_name>`
  is the user-given name of the `PIDChainControl`.

If you are unsure on how to select the PID coefficients $K_p$, $K_i$, and $K_d$,
you may try the following strategy, which involves some trial and error. First,
set $K_i$ and $K_d$ to zero. Then, set $K_p$ to some arbitrary (positive) value.
Run a simulation with $x_0 \neq \bar{x}$ and examine the transient response of $x$
to the set point value $\bar{x}$. The goal should be to maximize $K_p$ without
causing an unstable response, where $x$ oscillates indefinitely around $\bar{x}$.
Some initial overshoot and subsequent diminishing oscillations are acceptable.
After this acceptable value of $K_p$ is found, you'll likely find that $x$ appears
to be nearly constant in time, but at the wrong value. At this point, you should
start increasing $K_i$ from zero until you get an acceptable response time to
get the initial response (largely driven by $K_p$) to bridge the gap to $\bar{x}$,
without introducing oscillatory behavior. Lastly, $K_d$ can be used to fine-tune
the response, but it is not necessary, and it risks some oscillatory behavior
if the inputs have any noise, so it should only be used for relatively smooth
inputs.

To control a controllable value directly instead of using a [ChainControlData.md], use [PIDTransientControl.md].




## RealToBoolChainControl

This [ChainControl](syntax/ChainControls/index.md) converts a `Real`-valued
[chain control data](/ChainControlData.md) to a `bool` data, with the name
`<control>:value`, where `<control>` is the user-given name of the `RealToBoolChainControl`:

- A value of 1 converts to `true`.
- A value of 0 converts to `false`.
- Other values result in an error.

Note that the tolerance on the value is 1e-12 in a double-precision MOOSE build.




## ScaleOldChainControl

This [ChainControl](syntax/ChainControls/index.md) allows the user to scale
the previous time value for a [chain control data](/ChainControlData.md)
by another chain control data.
The resulting value is named `<control>:value`, where `<control>` is the
user-given name of the `ScaleOldChainControl`.
The chain control data to scale may be the
same chain control data created by this `ChainControl`, or it may be another.

This `ChainControl` is useful for applying corrections to simulation quantities.
For example, suppose the objective is to tune a heat transfer coefficient such
that the resulting cooling power, which we calculate using a [Postprocessor](Postprocessors/index.md) `simulated_power`,
matches an experimentally measured power, given in a `Postprocessor` `experiment_power`.
One provides an initial guess for the heat transfer coefficient [!param](/ChainControls/ScaleOldChainControl/initial_value).
The heat transfer coefficient in the boundary condition is controlled using a
[SetValueChainControl.md]. The `Postprocessor` `simulated_power` is computed
using a numerical integral over the boundary, and then a [GetPostprocessorChainControl.md]
is used to copy each of `simulated_power` and `experiment_power`. A
[ParsedChainControl.md] is used to compute a scaling factor as `experiment_power / simulated_power`.
This value is then used in [!param](/ChainControls/ScaleOldChainControl/scale_factor).
To keep the scaled value in a physical range (for instance, the heat transfer
coefficient should be a positive value), one may use a [LimitChainControl.md].
This is important, for example, because often there is noise in experimental data,
and the response time of the controlled quantity may vary. This limited
heat transfer coefficient chain control data is the one that should be used with
the `SetValueChainControl`, so it should also be the one used in
[!param](/ChainControls/ScaleOldChainControl/control_data). If there were no
limitation step, then this parameter would be set to `<control>:value`.




## SetValueChainControl

### SetRealValueChainControl

This [ChainControl](syntax/ChainControls/index.md) sets the value of one or
more parameters of type `Real` from a `Real`-valued [/ChainControlData.md].




### SetBoolValueChainControl

This [ChainControl](syntax/ChainControls/index.md) sets the value of one or
more parameters of type `bool` from a `bool`-valued [/ChainControlData.md].




## SmootherChainControl

This [ChainControl](syntax/ChainControls/index.md) smooths an input signal using a moving average.
The $n$ most recent values are used to compute the average $\bar{y}$ of the input
values $y$:

\bar{y}_i = \frac{1}{n} \Sigma\limits_{k=i-n+1}^i y_i

where $i$ represents the time index.

The resulting value is named `<control>:value`, where `<control>` is the
user-given name of the `SmootherChainControl`.
The number of points to average, $n$, is provided with [!param](/ChainControls/SmootherChainControl/n_points).




## TerminateChainControl

This [ChainControl](syntax/ChainControls/index.md) terminates the simulation
when a boolean [chain control data](/ChainControlData.md) has a given value.
The simulation may be terminated either by throwing an error or by signalling
to the [problem](/FEProblemBase.md) to terminate. This behavior is controlled
with the parameter [!param](/ChainControls/TerminateChainControl/throw_error).

An alternative way to terminate a simulation is to use a [Terminator.md] user object,
but `Terminator` works with [Postprocessors](Postprocessors/index.md) for the criterion
instead of a boolean chain control data.

This object requires the input data to have type `bool`. If you have a data of
type `Real`, you can convert using [RealToBoolChainControl.md].




## UnitTripChainControl

This [ChainControl](syntax/ChainControls/index.md) produces a boolean trip
[chain control data](/ChainControlData.md), which is initially `false` but
upon being triggered, becomes `true` for the remainder of the simulation.
This trip value is named `<control>:tripped`, where `<control>` is the
user-given name of the `UnitTripChainControl`.
The trip is determined by the value of the input boolean value given by
[!param](/ChainControls/UnitTripChainControl/input) and
[!param](/ChainControls/UnitTripChainControl/trip_on_true). If `trip_on_true`
is set to `true`, then the trip occurs when the input value is `true`; else
it occurs when the input value is `false`.

This object requires the input data to have type `bool`. If you have a data of
type `Real`, you can convert using [RealToBoolChainControl.md].




# constraints

## ADPenaltyEqualValueConstraint

The `ADPenaltyEqualValueConstraint` is the automatic differentiation version of [`PenaltyEqualValueConstraint`](PenaltyEqualValueConstraint.md).





## ADPenaltyPeriodicSegmentalConstraint

The `ADPenaltyPeriodicSegmentalConstraint` is the automatic differentiation version of [`PenaltyPeriodicSegmentalConstraint`](PenaltyPeriodicSegmentalConstraint.md).





## ADPeriodicSegmentalConstraint

The `ADPeriodicSegmentalConstraint` is the automatic differentiation version of [`PeriodicSegmentalConstraint`](PeriodicSegmentalConstraint.md).





## AutomaticMortarGeneration

The `AutomaticMortarGeneration` class is used to define mortar segment meshes to properly integrate discontinuities caused by normal projections of non-matching, faceted meshes.

### 2D

Generation of the 2D mortar segment mesh is outlined in [!cite](osti_1468630). In short, a nodal-normal projection is used to map points from the primary interface to the secondary interface; secondary interface elements are then split by the projected nodes to form mortar segment mesh elements.

### 3D

Generation of mortar segment meshes in 3D is more challenging and various approaches exist. In MOOSE we follow the approach suggested in [!cite](puso20043d), defining mortar segments on local linearizations of the secondary interface. When the secondary interface is composed entirely of TRI3 faces (which are already linear), generating the mortar segment mesh reduces to projecting the primary face elements onto secondary face elements (along the secondary face normal) and performing a polygon clipping (and subsequent triangularization). The mortar segment mesh is therefore simply a sub-mesh of the secondary mesh in this case.

The definition is more delicate for quadrilateral faces and second order geometries:

#### QUAD4 faces

While first-order, QUAD4 faces are (in general) not linear. The 'twisting' or 'potato-chipping' of QUAD4 elements complicates the simple projection and polygon clipping defined for TRI3 faces. To circumvent this problem, mortar segment meshes are defined on local linearizations of QUAD4 elements (see below). The linearization of QUAD4 face elements allows the same polygon clipping algorithm used for TRI3 face elements, but the mortar segment mesh elements produced do not coincide with the secondary mesh and the mortar segment mesh is disconnected between secondary elements.


#### Second Order Geometries (TRI6 and QUAD9 faces)

Elements defined on second order geometries are curvilinear so to simplify the 'clipping' procedure both secondary and primary face elements are subdivided into first-order face elements then subsequently linearized (illustrated below). The same clipping and triangularization routine is then applied on the linearized sub-elements to create the mortar segments. See [!cite](puso2008segment).


Quadrature points defined on mortar segments (which live on linearized elements) are mapped back to second order elements following an analogous but reverse procedure to the one illustrated above; points are mapped from linearized elements to first order sub-elements then subsequently transformed to the original second order elements.


## CoupledTiedValueConstraint


The constraint is imposed strongly on both sides of the interface, contributing to the residual.

### Example input syntax

In this example, the value of variable `u` and `v`, defined in the left and right domains,
is tied between the left and right boundaries of the two disconnected domains using a
`CoupledTiedValueConstraint`.





## EqualGradientConstraint

The `EqualGradientConstraint` class is used to enforce continuity of a component
of a variable gradient across a mortar interface or in a periodic boundary
condition. The gradient component to be matched is specified using the unsigned
parameter `component`. The variable is specified using the `primary_variable`
parameter. If the gradients to be matched are between different variables, the
`secondary_variable` parameter can also be supplied. Lagrange multipliers are used
to perform the constraint enforcement.






## EqualValueBoundaryConstraint


The difference between the two variables (or a single variable) values on the primary node and the
secondary node (or boundary) is simply multiplied by a penalty factor then added to the
residual.

### Example input syntax

In this example, the variable `diffused` is constrained to be equal on node `45` and the `top` boundary, using
a 10e6 penalty factor.





## EqualValueConstraint

The `EqualValueConstraint` class is used to enforce continuity of a
variable across a mortar interface or in a periodic boundary
condition. The variable is specified using the `primary_variable`
parameter. If the solution values to be matched are between different variables, the
`secondary_variable` parameter can also be supplied. Lagrange multipliers are used
to perform the constraint enforcement.

See [PenaltyEqualValueConstraint](/PenaltyEqualValueConstraint.md) for penalty-based enforcement of analogous constraints.






## EqualValueEmbeddedConstraint


This is a constraint acting upon overlapping portions of two blocks, a secondary block and a primary block. The constraint enforces the secondary variable on the secondary block and the primary variable on the primary block to have the same values. The mesh dimensions of the two blocks do not have to match.

The constraint iterates through all the nodes on the secondary block and searches for a primary element that contains each secondary node. If a secondary node is located within an element, then a constraint is applied to force the secondary node to have the same value as the solution variable in the primary element, evaluated at the location of the secondary point.

This can be used for a number of applications. For example, in mechanics problems, it can be used to connect lower dimensional elements such as 1D truss elements to 2D or 3D continuum elements. This can be used to model reinforcement in a way that does not require the reinforcement and continuum meshes to have coincident nodes.

### Mathematical Formulation

Options are available to control how this constraint is applied:

#### Kinematic

This option strictly enforces value of the solution at the secondary nodes to be equal to the value in the primary element at that point. The constraint is enforced by updating the secondary residual $r_s$ and primary residual $r_m$ as:
\begin{equation}
\begin{aligned}
r_s &= r_s + f_c + k_p(u_{secondary} - u_{primary})\\
r_m &= r_m + \phi_i r_{s,copy}
\end{aligned}
\end{equation}
where $r_{s,copy}$ is a copy of the residual of the secondary node before the constraint is applied and $k_p$ is the user-specified penalty parameter. This formulation uses the penalty parameter only to penalize the error, and the converged solution has no error due the penalty. The penalty factor must be specified, and should be consistent with the scaling for the solution variable to which this is applied.

#### Penalty

This option uses a penalty formulation in which the error in the solution is proportional to a user-specified penalty parameter $k_p$. The constraint is enforced by modifying the secondary and primary residual
The constraint is enforced by updating the secondary residual $r_s$ and primary residual $r_m$ as:
\begin{equation}
\begin{aligned}
r_s &= r_s + k_p(u_{secondary} - u_{primary})\\
r_m &= r_m - \phi_i k_p(u_{secondary} - u_{primary})
\end{aligned}
\end{equation}
where $r_{s,copy}$ is the ghosted residual. The penalty parameter must be selected carefully, as small values lead to large differences between the secondary node's solution and the solution in the primary element, while large values may lead to poor convergence.




## LinearNodalConstraint


The LinearNodalConstraint class constrains the secondary node to move as a linear combination of primary nodes. Primary node ids and corresponding weights are taken as input along with the secondary node set or secondary node ids. This nodal constraint can be enforced either using the penalty formulation or the kinematic formulation.





## MortarScalarBase

The `MortarScalarBase` is part of the scalar augmentation system to complement the [ScalarKernel](syntax/ScalarKernels/index.md) class. Its principal purpose is to add standard
quadrature loops and assembly routines to handle the contributions from a single added
scalar variable to a [Mortar Constraint](syntax/Constraints/index.md) class, including the entire row
of the Jacobian.
These routines will assist with representing weak form terms in a partial differential equation involving
scalar variables integrated over the surface of a non-conforming interface (mortar surface). As usual,
this piece of physics is referred to
as the "residual" and is evaluated at integration quadrature points along that interface.
To implement your own physics in MOOSE, you create your own mortar constraint by subclassing the MOOSE `MortarScalarBase` class.

The mortar scalar augmentation system supports the use of [!ac](AD) for residual calculations, as such
there are two options for creating field-scalar coupling objects:
`MortarScalarBase` and `ADMortarScalarBase`. To further understand
automatic differentiation, please refer to the [automatic_differentiation/index.md] page for more
information.

Developers should read all sections; users can find [#MSB-parameters] described at the bottom.

### Creation of Mortar Constraint Scalar Coupling Classes id=MSB-coupling

`MortarConstraint` objects are designed to handle weak-form contributions from both surface-based
lower-dimensional (Lagrange multiplier) variables and domain-based (primary and secondary) spatial
variables. For these three +focus+ spatial variables, its job is to contribute to the associated rows
of the residual and the Jacobian matrix. Herein, as in the source code of `MortarConstraints`, these
spatial variables will be called (see Mortar [syntax/Constraints/index.md#MC-parameters] for the analogous
input parameter names):

- `_var`: Corresponds to a Lagrange Multiplier variable that lives on the
  lower dimensional block on the secondary face
- `_secondary_var`: Primal variable on the secondary side of the mortar interface
  (lives on the interior elements)
- `_primary_var`: Primal variable on the primary side of the mortar interface
  (lives on the interior elements).

The three focus spatial variables `_var`, `_secondary_var`, and `_primary_var` are each indicated by the
name `var` below, and are differentiated by the `mortar_type` flag as one of "Primary". "Secondary", or
"Lower". In a coupled (multi-physics) weak form, all interface integral terms containing the test function
of one of these three variables are potential candidates for `MortarConstraint` contributions.

The philosophy of the scalar augmentation class `MortarScalarBase` is to add a single focus scalar variable
referred to as `_kappa` to the `MortarConstraint` object so that all terms in the coupled weak form that
involve the spatial variables, scalar variable, and/or their test functions can be assembled in one
or multiple class instances.
This philosophy is similar to how the lower dimensional variable `_lambda` is added to the element faces
of `DGKernel` and `IntegratedBC` objects associated with the hybrid finite element method (HFEM). Documentation for that approach can be found [HFEMDiffusion](source/dgkernels/HFEMDiffusion.md) and [HFEMDirichletBC](source/bcs/HFEMDirichletBC.md) along with the base classes `DGLowerDKernel` and `LowerDIntegratedBC`.

In a `MortarScalarBase` subclass, a naming scheme is established for the quadrature point methods of the two
variable types: methods contributing to the test function of `_kappa` have "Scalar" near the front
and methods contributing to the trial function of scalar variables in the Jacobian have "Scalar"
at the end. The `computeScalarQpResidual()` function +should+ be overridden (see [#MSB-parameters]
for cases where the scalar should be suppressed). The `computeQpResidual(mortar_type)` function +must+ be
overridden as usual for `MortarConstraint`, although it may return zero.

For non-AD objects, several contributions to the Jacobian matrix can be optionally overridden for use in
Newton-type nonlinear solvers. As mentioned later, the developer should choose and document which terms
(rows) of the residual and terms (rows and columns) of the Jacobian will be attributed to an instance of
the developed class. These choices can be motivated by whether some terms in the weak form can be or have
already been implemented within other MOOSE classes.

- `computeQpJacobian(jacobian_type, jvar_num)`: Jacobian component d-`var`-residual / d-`jvar`
- `computeQpOffDiagJacobianScalar(mortar_type, svar_num)`: Jacobian component d-`var`-residual / d-`svar`
- `computeScalarQpJacobian()`: Jacobian component d-`_kappa`-residual / d-`_kappa`
- `computeScalarQpOffDiagJacobian(mortar_type, jvar_num)`: Jacobian component d-`_kappa`-residual / d-`jvar`
- `computeScalarQpOffDiagJacobianScalar(svar_num)`: Jacobian component d-`_kappa`-residual / d-`svar`

Similar to the `mortar_type` flag
mentioned above, the `jacobian_type` flag is used to distinguish the couplings between the test and trial
functions of the three focus spatial variables. For example, `jacobian_type = LowerSecondary` indicates
that the linearized weak form term from the `_var` test function and `_secondary_var` trial function should
be evaluated. All nine combinations from the three focus variables are visited during the loops that call
`computeQpJacobian(jacobian_type, jvar_num)`. Also, loops over the coupled variables wrap around these quadrature loops: the integer for the spatial variable is `jvar_num` and the integer for the
scalar variable is `svar_num`. Note that the `jvar_num` integer is different for `_var` and `_secondary_var`
and for any other spatial variables coupled by the developer through derived classes of `MortarScalarBase`,
so consult the examples of these methods below in [#MSB-examples] for how to query the current target
using logical tests.

Also, there are some pre-calculation routines that are called
within the quadrature loop once before the loop over spatial variable test and shape functions as well as
before the loop over scalar components. These methods are useful for material or stabilization calculations.

- `initScalarQpResidual()`: evaluations depending on qp but independent of test functions
- `initScalarQpJacobian(jvar_num)`: evaluations depending on qp but independent of test and shape functions
- `initScalarQpOffDiagJacobian(jsvar)`: evaluations depending on qp but independent of test and shape functions

In addition to those mentioned in the [MortarConstraints](syntax/Constraints/index.md) documentation,
you have access to several member variables inside your `MortarScalarBase` class for computing the
residual and Jacobian values in the above mentioned functions:

- `_h`, `_l`: indices for the current test and trial scalar component respectively.
- `_kappa`: value of the scalar variable this `MortarConstraint` operates on; indexed by `_h` (i.e. `_kappa[_h]`).
- `_kappa_var`: ID number of this scalar variable; useful to differentiate from others.
- `_k_order`: order (number of components) of the scalar variable.

Since the test and trial "shape" functions of a scalar are "1", variables are not required for that
value. Examples of the source codes below demonstrate this fact.

`ADMortarScalarBase` only works with MOOSE configured with global AD indexing (the default).

### Examples from Source Code id=MSB-examples

As mentioned, the `computeScalarQpResidual` method +should+ be overridden for both flavors of
mortar constraints, non-AD and AD. As an example, consider the scalar residual weak form terms of the
[`PeriodicSegmentalConstraint`](/PeriodicSegmentalConstraint.md) class:

\begin{equation}
  \langle \vec{\kappa} \cdot \llbracket \vec{x} \rrbracket, \lambda \rangle _{\Gamma^+} - \langle \vec{\kappa} \cdot \llbracket \vec{x} \rrbracket, \vec{\sigma} \cdot \hat{n} \rangle _{\Gamma^+} \label{eq:eq1}
\end{equation}

The `computeScalarQpResidual` method for the non-AD version of this class is
provided in [PSC-non-ad-residual], where `_kappa_aux` is equal to $\sigma$.

         re=Real\nPeriodicSegmentalConstraint::computeScalarQpResidual.*?}
         caption=The C++ weak-form residual statement of [eq:eq1].

Meanwhile, the contribution to the lower spatial variable residual of this object is associated with [eq:eq2]
and implemented in [lower-non-ad-residual] (note that the scalar variable `_kappa` is termed as
$\vec{\epsilon}$ in this weak form).

\begin{equation}
    \langle \mu , \vec{\epsilon} \cdot \llbracket \vec{x} \rrbracket \rangle _{\Gamma^+} \label{eq:eq2}
\end{equation}

         re=Real\nPeriodicSegmentalConstraint::computeQpResidual.*?}
         caption=The C++ weak-form residual statement of [eq:eq2].

The other contributions to the lower spatial variable residual of this object is associated with [eq:eq3]
and implemented in [EVC-non-ad-residual] within the [`EqualValueConstraint`](/EqualValueConstraint.md) class.

\begin{equation}
     -\langle \mu , \llbracket u \rrbracket \rangle _{\Gamma^+} \label{eq:eq3}
\end{equation}

         re=case Moose::MortarType::Lower.*?}
         caption=The C++ weak-form residual statement of [eq:eq3].

For an example of the contributions to `_primary_var` and `_secondary_var` residuals, consider the
penalty version of the periodic constraint associated with [eq:eq4]
and implemented in [PPSC-non-ad-residual] within the [`PenaltyPeriodicSegmentalConstraint`](/PenaltyPeriodicSegmentalConstraint.md) class.

\begin{equation}
 - \langle \llbracket w \rrbracket,\tau \vec{\epsilon} \cdot \llbracket \vec{x} \rrbracket \rangle _{\Gamma^+} \label{eq:eq4}
\end{equation}

         re=Real\nPenaltyPeriodicSegmentalConstraint::computeQpResidual.*?}
         caption=The C++ weak-form residual statement of [eq:eq4].

The `PeriodicSegmentalConstraint` class also overrides the `computeScalarQpOffDiagJacobian` method
to define the Jacobian term related to [eq:eq1] as shown in [non-ad-PSC-s-v-jacobian].

         re=Real\nPeriodicSegmentalConstraint::computeScalarQpOffDiagJacobian.*?}
         caption=The C++ weak-form Jacobian for d-`_kappa`-residual / d-`jvar`.

Notice that there is a conditional to confirm that the coupled `jvar` is the focus lower variable `_var`, otherwise it returns zero.

Similarly, it also overrides the `computeQpOffDiagJacobianScalar` method to define the Jacobian term related
to [eq:eq2] as shown in [non-ad-PSC-v-s-jacobian].

         re=Real\nPeriodicSegmentalConstraint::computeQpOffDiagJacobianScalar.*?}
         caption=The C++ weak-form Jacobian for d-`_var`-residual / d-`svar`.

Also notice the conditional that confirms the coupled `svar` is the focus scalar `_kappa`, otherwise it returns zero.

The AD version of this object, [`ADPeriodicSegmentalConstraint`](/ADPeriodicSegmentalConstraint.md),
only requires the residual implementation; as such it overrides `computeScalarQpResidual`
and `computeQpResidual` as follows.

         re=ADPeriodicSegmentalConstraint::computeScalarQpResidual.*?}
         caption=The C++ AD weak-form residual statement of [eq:eq1].

         re=ADPeriodicSegmentalConstraint::computeQpResidual.*?}
         caption=The C++ AD weak-form residual statement of [eq:eq2].

Depending upon the weak form and its coupling terms between spatial and scalar variables, not all of the
methods listed in [#MSB-coupling] need to be overridden.

The scalar augmentation system is designed such that multiple scalar variables can be coupled to
an instance of the `MortarConstraint` class, each focusing on one scalar from the list. This approach is
similar to how SolidMechanics module classes operator on one component variable of the displacement vector
field and are coupled to the other components. The developer can decide how to organize the coupling
and off-diagonal Jacobian terms in a logical way and document this for the user.

An example for decomposing the coupling terms and having multiple scalar variables are
contained in the source files of the framework test directory as well as input file
`testperiodicsole.i`, with listings below. The comments within these header and source files
should be consulted to visualize how the rows and columns of the relevant residual and Jacobian
contributions are handled.

         re=/// Test object to illustrate.*?}
         caption=Decomposition of spatial and scalar variable contributions by x and y components.


The displaced mesh features are not yet tested for the scalar augmentation system.

### Parameters id=MSB-parameters

There is one required parameters the user must supply for a mortar constraint derived
from `MortarScalarBase`:

- `scalar_variable`: the focus scalar variable of the mortar constraint, for which assembly
  of the residual and Jacobian contributions will occur. It must be a `MooseScalarVariable`.
  This parameter may be renamed in a derived class to be more physically meaningful.

If the `scalar_variable` parameter is not specified, then the derived class will behave
identically to a regular `MortarConstraint`, namely without any scalar functionality. This feature
is useful if the scalar augmentation in inserted into a class structure with several
levels and not all derived members use scalar variables.

As an example, the parameter listing is shown below for the `PeriodicSegmentalConstraint` object
with the `scalar_variable` parameter renamed to `epsilon`:


Note: to avoid an error message "Variable 'kappa' does not exist in this system", the following
block should be added to the input file:


There is one optional parameters that can be supplied to`MortarScalarBase` classes:

- `compute_scalar_residuals`: Whether to compute scalar residuals. This
  will automatically be set to false if a `scalar_variable` parameter is not
  supplied. Other cases where the user may want to set this to false is during
  testing when the scalar variable is an `AuxVariable` and not a solution variable
  in the system. This parameter has a similar usage as the `compute_lm_residuals`
  and `compute_primal_residuals` for all Mortar objects.

## OldEqualValueConstraint

The `OldEqualValueConstraint` class is used to enforce continuity of a
variable across a mortar interface or in a periodic boundary
condition. The variable is specified using the `primary_variable`
parameter. If the solution values to be matched are between different variables, the
`secondary_variable` parameter can also be supplied. Lagrange multipliers are used
to perform the constraint enforcement.






## PenaltyEqualValueConstraint

The `PenaltyEqualValueConstraint` class is used to enforce continuity of a
variable across a mortar interface or in a periodic boundary
condition. The variable is specified using the `primary_variable`
parameter. If the solution values to be matched are between different variables, the
`secondary_variable` parameter can also be supplied. The enforcement takes place in a penalty sense, 
which eliminates the need to supply Lagrange multipliers.

See [EqualValueConstraint](/EqualValueConstraint.md) for exact enforcement using Lagrange multipliers.







## PenaltyPeriodicSegmentalConstraint


### Description

This `Constraint` demonstrates the usage of the scalar augmentation class described in [MortarScalarBase.md].
The other terms in the weak form are handled using the [PenaltyEqualValueConstraint](/PenaltyEqualValueConstraint.md)
as described below.

In comparison to Dirichlet or Neumann conditions, periodic boundary conditions have been found
to typically be the most accurate (fastest converging) approach for applying macro-to-micro scale
transition constraints.
Several methods for imposing periodic boundary conditions exist, each with pros and cons.
For example, the periodic constraint will only be satisfied approximately by this method.
Alternatively, the periodic condition can be imposed by the Lagrange multiplier method using [PeriodicSegmentalConstraint.md] or one of the other periodic approaches in `MOOSE`.

This class provides the macro-micro coupling terms to implement periodic boundary conditions
using the penalty method, which is a subset of the Discontinuous Galerkin method
proposed within [!cite](aduloju_primal_2020). Alternatively, these
equations impose an average value of the diffusive flux of a spatial variable over a domain
using surface rather than volume integrals.

The strong form is posed over domain $\Omega$ with opposing boundary pairs $\Gamma^+$
and $\Gamma^-$ is written in [PeriodicSegmentalConstraint.md] for the mortar method.
The corresponding weak form is (using inner-product notation):

\begin{aligned}
  (\nabla \psi, D \nabla u)_\Omega + \langle \llbracket \psi \rrbracket,\tau \llbracket u \rrbracket \rangle _{\Gamma^+} - \langle \llbracket \psi \rrbracket,\tau \vec{\epsilon} \cdot \llbracket \vec{x} \rrbracket \rangle _{\Gamma^+} = 0\\
  -\langle \vec{\kappa} \cdot \llbracket \vec{x} \rrbracket, \tau \llbracket u \rrbracket \rangle _{\Gamma^+} +\langle \vec{\kappa} \cdot \llbracket \vec{x} \rrbracket, \tau \vec{\epsilon} \cdot \llbracket \vec{x} \rrbracket \rangle _{\Gamma^+} = \langle \vec{\kappa} \cdot \llbracket \vec{x} \rrbracket, \vec{\sigma} \cdot \hat{n} \rangle _{\Gamma^+}
\end{aligned}

where $\epsilon$ is the average diffusive gradient to be solved for,
and $\sigma$ is the average diffusive flux imposed through the penalty constraint.
Also, $\psi$ is the test function of the diffusive variable $u$,
and $\vec{\kappa}$ is an arbitrary test vector (spatially uniform)
to impose the constraint involving the scalar variable $\vec{\epsilon}$.
The jump operator is defined for a single valued or vector valued field
as $\llbracket u \rrbracket = u^{+} - u^{-}$ and
$\llbracket \vec{x} \rrbracket = \vec{x}^{+} - \vec{x}^{-}$, respectively.
Finally, $\tau$ is a penalty parameter to impose the constraint.

Note: The macro-to-micro constraint $\llbracket u \rrbracket = \vec{\epsilon} \cdot \llbracket \vec{x} \rrbracket$
will only be satisfied approximately by this method, depending on the size of the penalty parameter.

### Input File Parameters

The terms in the weak form [weak-form] are handled by several different classes.
The volume integrals are handled by [`Diffusion`](source/kernels/Diffusion.md) or
[`MatDiffusion`](source/kernels/MatDiffusion.md). The surface term
$\langle \llbracket w \rrbracket,\tau \llbracket u \rrbracket \rangle _{\Gamma^+}$ is computed by
[PenaltyEqualValueConstraint.md]. The remaining four terms are handled by this class.

Two of these objects are shown in the input file below:


The applied macroscale diffusive flux $\sigma$ is applied as the `sigma` vector via an auxiliary
scalar. The computed macroscale diffusive gradient $\epsilon$ is assigned in a scalar variable `epsilon`.
Both of these scalars should have the same number of components as the spatial dimension of $\Omega$.
The volume integral of the gradient of the primary field will be constrained to $\epsilon$
in a weak sense, depending on the size of the penalty parameter `penalty_value`.

Also, the `coupled_scalar` must be assigned the same scalar as `epsilon`.

The microscale diffusion variable is specified using the `primary_variable` parameter.
If the solution values to be matched are between different variables, the
`secondary_variable` parameter can also be supplied.
These same parameters must be used for the micro-micro coupling terms
in the [PenaltyEqualValueConstraint](/EqualValueConstraint.md) object.

The generation of the lower-dimensional mesh surfaces for $\Gamma^+$ and $\Gamma^-$
are described in the [`Mortar Constraint system`](syntax/Constraints/index.md). The
projection between two separated surfaces on opposite sides of the domain are naturally
handled by the system. This is true for both `PenaltyEqualValueConstraint` and
`PenaltyPeriodicSegmentalConstraint`. In fact, the meshes can be nonconforming as long as
the geometry is conforming, although the choice of `penalty_value` becomes
more delicate. Note that the `periodic` parameter is NOT needed, but if it is applied
then it should be the same for BOTH `PenaltyEqualValueConstraint` and
`PenaltyPeriodicSegmentalConstraint`.

Due to current restrictions on `AutomaticMortarGeneration`, the opposing surfaces must be
directly opposite along the unit normal direction.





## PeriodicSegmentalConstraint


### Description

This `Constraint` demonstrates the usage of the scalar augmentation class described in [MortarScalarBase.md].
The other terms in the weak form are handled using the [EqualValueConstraint](/EqualValueConstraint.md)
as described below.

In comparison to Dirichlet or Neumann conditions, periodic boundary conditions have been found
to typically be the most accurate (fastest converging) approach for applying macro-to-micro scale
transition constraints.
Several methods for imposing periodic boundary conditions exist, each with pros and cons.
For example, the mortar approach requires an extra Lagrange multiplier field.
Alternatively, the periodic condition can be imposed by the penalty method using [PenaltyPeriodicSegmentalConstraint.md] or one of the other periodic approaches in `MOOSE`.

This class provides the macro-micro coupling terms to implement periodic boundary conditions
using the mortar method, as proposed within [!cite](reis_mortar_2014). Alternatively, these
equations impose an average value of the diffusive flux of a spatial variable over a domain
using surface rather than volume integrals.

The strong form is posed over domain $\Omega$ with opposing boundary pairs $\Gamma^+$
and $\Gamma^-$:

\begin{aligned}
  \nabla\cdot D \nabla u = 0 \text{ in } \Omega\\
  \llbracket u \rrbracket = \vec{\epsilon} \cdot \llbracket \vec{x} \rrbracket \text{ on } \Gamma^+\\
  D \nabla u(\vec{x}^+) \cdot \hat{n}^+ = \lambda = -D \nabla u(\vec{x}^-) \cdot \hat{n}^- \text{ on } \Gamma^+\\
  \int_{\Gamma^+}{\lambda \llbracket \vec{x} \rrbracket d\Gamma} = V_0 \vec{\sigma}
\end{aligned}

where $\epsilon$ is the average diffusive gradient to be solved for,
$\sigma$ is the imposed average diffusive flux, and $\lambda$ is the
Lagrange multiplier that imposes this average constraint.
The jump operator is defined for a single valued or vector valued field
as $\llbracket u \rrbracket = u^{+} - u^{-}$ and
$\llbracket \vec{x} \rrbracket = \vec{x}^{+} - \vec{x}^{-}$, respectively.

The corresponding weak form is (using inner-product notation):

\begin{aligned}
  (\nabla \psi, D \nabla u)_\Omega - \langle \llbracket \psi \rrbracket,\lambda \rangle _{\Gamma^+} = 0\\
  -\langle \Phi , \llbracket u \rrbracket \rangle _{\Gamma^+} + \langle \Phi , \vec{\epsilon} \cdot \llbracket \vec{x} \rrbracket \rangle _{\Gamma^+} = 0\\
  \langle \vec{\kappa} \cdot \llbracket \vec{x} \rrbracket, \lambda \rangle _{\Gamma^+} = \langle \vec{\kappa} \cdot \llbracket \vec{x} \rrbracket, \vec{\sigma} \cdot \hat{n} \rangle _{\Gamma^+}
\end{aligned}

where $\psi$ is the test function of the diffusive variable $u$, $\Phi$ is the test function
for the Lagrange multiplier $\lambda$, and $\vec{\kappa}$ is an arbitrary test vector (spatially uniform)
to impose the constraint involving the scalar variable $\vec{\epsilon}$.
As is typical for mixed-field problems with Lagrange multipliers, the shape functions for
$u$ and $\lambda$ need to be chosen to satisfy the Babuska-Brezzi inf-sup condition if
stabilization is not added to the system. As discussed in [!cite](reis_mortar_2014),
using quadratic $u$ and piecewise linear $\lambda$ (discontinuous at corners) provides
for stable results. Note that element-discontinuous (e.g. `L2_LAGRANGE` or `MONOMIAL` basis)
does not produce stable results without interpolation. An easy way to make a discontinuous
$\lambda$ field at corners is described below.

### Input File Parameters

The terms in the weak form [weak-form] are handled by several different classes.
The volume integrals are handled by [`Diffusion`](source/kernels/Diffusion.md) or
[`MatDiffusion`](source/kernels/MatDiffusion.md). The surface terms
$\langle \llbracket w \rrbracket,\lambda \rangle _{\Gamma^+}$ and
$\langle \mu , \llbracket u \rrbracket \rangle _{\Gamma^+}$ are computed by
[EqualValueConstraint.md]. The remaining three terms are handled by this class.

Two of these objects are shown in the input file below:


The applied macroscale diffusive flux $\sigma$ is applied as the `sigma` vector via an auxiliary
scalar. The computed macroscale diffusive gradient $\epsilon$ is assigned in a scalar variable `epsilon`.
Both of these scalars should have the same number of components as the spatial dimension of $\Omega$.
The volume integral of the gradient of the primary field will be constrained to $\epsilon$
in a weak sense.

Also, the `coupled_scalar` must be assigned the same scalar as `epsilon`.

The microscale diffusion variable is specified using the `primary_variable` parameter.
If the solution values to be matched are between different variables, the
`secondary_variable` parameter can also be supplied.
The enforcement takes place using Lagrange multipliers assigned to `variable`.
These same parameters must be used for the micro-micro coupling terms
in the [EqualValueConstraint](/EqualValueConstraint.md) object.

The generation of the lower-dimensional mesh surfaces for $\Gamma^+$ and $\Gamma^-$
are described in the [`Mortar Constraint system`](syntax/Constraints/index.md). The
projection between two separated surfaces on opposite sides of the domain are naturally
handled by the system. This is true for both `EqualValueConstraint` and
`PeriodicSegmentalConstraint`. In fact, the meshes can be nonconforming as long as
the geometry is conforming, although the choice of $\lambda$ discretization becomes
more delicate. Note that the `periodic` parameter is NOT needed, but if it is applied
then it should be the same for BOTH `EqualValueConstraint` and
`PeriodicSegmentalConstraint`.

Due to current restrictions on `AutomaticMortarGeneration`, the opposing surfaces must be
directly opposite along the unit normal direction.

As mentioned above, the $\lambda$ discretization needs to be continuous along patches
of element faces (`LAGRANGE`, not `MONOMIAL`) in order to be stable, but must be discontinuous along
corners of the mesh where the outward unit normal $\hat{n}$ is discontinuous since it is
a flux variable (see the third condition [strong-form]). An easy way to do this is to make a
separate `LAGRANGE` variable for each 'face' of the model with different $\hat{n}$, which
usually corresponds with different named side-sets or boundaries used for creating
lower-dimensional mesh surfaces. This approach is demonstrated in many of the test input files.

The `PJFNK` solver does not perform well for discrete systems lacking terms on the diagonal
of the Jacobian matrix, such as this mortar method. Thus, the `NEWTON` solver is recommended.





## TiedValueConstraint


The constraint is imposed strongly on both sides of the interface, contributing to the residual.
Please see the [CoupledTiedValueConstraint.md] for the two variables case.
The `TiedValueConstraint` may also be used with two different variables, however the off diagonal terms
in the Jacobian for the constraint are only implemented in the [CoupledTiedValueConstraint.md].

### Example input syntax

In this example, the value of variable `u` defined in the left and right domains,
is tied between the left and right boundaries of the two disconnected domains using a
`TiedValueConstraint`.





# controls

## BoolFunctionControl

The `BoolFunctionControl` object is designed to control a "bool" parameter with a function rather
than use the value specified in the input file. If the function value equals to zero, the controlled
parameter will be set to `false`, otherwise its value will be set to `true`.

For a discussion on the naming of objects and parameters see
[Object and Parameter Names](syntax/Controls/index.md#object-and-parameter-names) section.




## ConditionalEnableControl

`Control`s deriving from `ConditionalEnableControl` allow MOOSE objects to be enabled or
disabled according to some condition. Nearly all types of MOOSE objects (`Kernel`, `BC`, etc.)
have a parameter `enable` that is controllable.

Two list parameters exist: `enable_objects` and `disable_objects`. The former
is used to specify which objects should be enabled when the specified condition
is met, and the latter is used to specify which objects should be disabled when
the specified condition is met. See the
[Object and Parameter Names](syntax/Controls/index.md#object-and-parameter-names)
section for the syntax of describing object names.

If the parameter `reverse_on_false` is set to true (as it is by default),
the objects in the `enable_objects` list are disabled when the condition is
false, and the objects in the `disable_objects` list are enabled when the
condition is false.

## ConditionalFunctionEnableControl


`ConditionalFunctionEnableControl` objects derive from [ConditionalEnableControl](/ConditionalEnableControl.md).

`ConditionalFunctionEnableControl` objects allow MOOSE objects to be enabled or
disabled according to the value of a [Function](syntax/Functions/index.md).




## PIDTransientControl

The `PIDTransientControl` object is designed to use the principle of Proportional Integral Derivative control to either:
- control a "Real" parameter from the input file rather than use the constant value specified in the input file.

- modify the value of a postprocessor, used in a PostprocessorDirichletBC for example, rather than use the computed/received value


This allows a simple 1D parametric optimization to make the output of a postprocessor match the `target` value.

The parameter $C$ is replaced at every time step $n$, at time $t$, by:
\begin{equation}
C_{n} = C_{n-1} + K_{integral} \int_0^{t} pp(s) - target \mathrm{d}s + K_{proportional} (pp(t) - target) + K_{derivative} \dfrac{pp(t) - target}{dt}
\end{equation}

with $pp(t)$ the value at time $t$ of the postprocessor that we are trying to match to the $target$ value and
$K_{integral/proportional/derivative}$ the coefficients for the integral error, current error, and backward derivative respectively.




## RealFunctionControl

The `RealFunctionControl` object is designed to control a "Real" parameter with a function rather
than use the value specified in the input file. This object is mainly a demonstration of how to
create a Control object and modify a parameter.

### Example

Consider a simulation that solves the diffusion equation, where the Laplacian term has a
coefficient, but the coefficient is defined as a constant input parameter ("coef"). For some
reason, it is desired to control this coefficient and replace the constant value with a function
that varies with space and time; this function is defined in the [Functions] block.

The `RealFunctionControl` object is designed for this purpose as shown in [real_func_ex].


Notice that the "parameter" input parameter is expecting a parameter name which can be defined
in various forms.

For a discussion on the naming of objects and parameters see
[Object and Parameter Names](syntax/Controls/index.md#object-and-parameter-names) section.




## TimePeriod

The `TimePeriod` class derives from [ConditionalEnableControl](/ConditionalEnableControl.md).

`TimePeriod` objects are designed to control the active state of a MOOSE object,
based on whether the time value is in some range.

For example, consider a simulation that contains two [Kernels] "diff0" and "diff1". Initially,
"diff0" is active and after time 0.49 "diff1" becomes active and "diff0" is disabled. The following
code snippet demonstrates how this switching of kernels is achieved with the `TimePeriod` object.





## TimesEnableControl


`TimesEnableControl` objects derive from [ConditionalEnableControl](/ConditionalEnableControl.md).

`TimesEnableControl` objects allow MOOSE objects to be enabled or
disabled according to whether the current simulation time matches or not the times specified in
a [Times](syntax/Times/index.md) object.




## WebServerControl

The `WebServerControl` object is designed to allow an external process to control a MOOSE solve. It works by starting up a webserver which exposes a REST API. As with all REST APIs the input and output are both JSON.

The server can either listen on a port via the [!param](/Controls/WebServerControl/port) parameter, or on a unix file socket via the [!param](/Controls/WebServerControl/file_socket) parameter. One of these two parameters must be provided.

It can then be managed via the [MooseControl](MooseControl/index.md optional=true) python utility.

### API

The `WebServerControl` presents REST endpoints to help control the solve.

For the endpoints that follow, if the HTTP status code received is a non-successful code, there may be a response of type `application/json` of the form:

```language=json
{
  "error": "<ERROR>"
}
```

where `<ERROR>` is a useful error message pertaining to the error that was encountered. The response is not guaranteed to contain `application/json` data, but it will when more context is available.

The REST endpoints are as follows:

#### `check`

Used to determine if the MOOSE webserver is currently listening. This doesn't necessarily mean that it is waiting for input.

Interact with this endpoint by a `GET` request to `/check`. On success, the status code will be 200.

#### `waiting`

Used to determine of MOOSE is currently waiting within the `WebServerControl`, i.e., that `Control` is waiting for external input. The rest of the endpoints that follow require that the control is currently waiting for input.

Interact with this endpoint by a `GET` request to `/waiting` without any data. If the control is currently waiting, the response will be of type `application/json` of the form:

```language=json
{
  "waiting": True
  "execute_on_flag": "<EXEC_ON_FLAG>"
}
```

where `<EXEC_ON_FLAG>` is the current execution flag. If the control is not currently waiting, the response will be a response of type `application/json` of the form:

```language=json
{
  "waiting": False
}
```

This endpoint can be accessed via the [MooseControl](MooseControl/index.md optional=true) python utility via the following methods:

- `wait()`: Waits for the control to be waiting
- `getWaitingFlag()`: Gets the current flag that the control is waiting on, if any
- `isWaiting()`: Whether or not the control is currently waiting

#### `get/postprocessor`

Used to obtain the value of a postprocessor. The control must be waiting in order to access this endpoint.

Interact with this endpoint by a `POST` request to `/get/postprocessor` with the following `application/json` data:

```language=json
{
  "name": "<NAME>"
}
```

where `<NAME>` is the name of the postprocessor whose value you wish to receive. The response will be of the form:

```language=json
{
  "value": <VALUE>
}
```

#### `set/controllable`

Used to change a controllable parameter in the simulation. The control must be waiting in order to access this endpoint.

The following parameter types are currently supported by the endpoint:

- `bool`
- `Real`
- `std::string`
- `std::vector<Real>`
- `std::vector<std::string>`

These types can be extended by the `registerWebServerControl[Scalar/Vector][BoolNumberString]` registration methods in the source for the `WebServerControl`.

Interact with this endpoint by a `POST` request to `/set/controllable` with the following `application/json` data:

```language=json
{
  "name": "<NAME>",
  "type" "<TYPE>",
  "value": <VALUE>
}
```

where `<NAME>` is the string path to the controllable parameter, `<TYPE>` is the string version of the C++ parameter type, and `<VALUE>` is the value to set the parameter to. The type of `<VALUE>` depends on the controllable parameter type.

On success, the response will be empty with a status code of 201.

This endpoint can be accessed via the [MooseControl](MooseControl/index.md optional=true) python utility via the following methods:

- `setControllableBool()`: Sets a controllable `bool` parameter
- `setControllableReal()`: Sets a controllable `Real` parameter
- `setControllableVectorReal()`: Sets a controllable `std::vector<Real>` parameter
- `setControllableString()`: Sets a controllable `std::string` parameter
- `setControllableVectorString()`: Sets a controllable `std::vector<std::string>` parameter

#### `continue`

Tells a waiting control to continue with the execution. The control must be waiting in order to access this endpoint.

Interact with this endpoint by a `GET` request to `/continue`. On success, the response will be empty with a status code of 200.




# convergence

## DefaultNonlinearConvergence

This [Convergence](Convergence/index.md) is the default convergence for
[/FEProblem.md], using a combination of criteria to determine convergence.

This object shares several parameters with the executioner. If one of these
parameters is set by the user in the executioner and not in the convergence
object, then the value is taken from the executioner, rather than the default
value. If a parameter is set by the user in both the executioner and the convergence
object, an error is thrown.

Consider the system of algebraic equations:

\mathbf{r}(\mathbf{u}) = \mathbf{0} \,.

This class reports convergence of the solution to this system if
+any+ of the following conditions are true:

\|\mathbf{r}\|_2 < \tau_\text{abs} \,,

\frac{\|\mathbf{r}\|_2}{\|\mathbf{r}_0\|_2} < \tau_\text{rel} \,,

\frac{\|\mathbf{\delta u}\|_2}{\|\mathbf{u}\|_2} < \tau_{\delta u,\text{rel}} \,.

This class reports divergence if +any+ of the following conditions are true:

\|\mathbf{r}\|_2 = \text{NaN} \,,

n_\text{evals} \geq n_\text{evals,max} \,,

\|\mathbf{r}\|_2 > \tau_\text{div,abs} \,,

\frac{\|\mathbf{r}\|_2}{\|\mathbf{r}_0\|_2} > \tau_\text{div,rel} \,,

n_\text{ping} > n_\text{ping,max} \,,

where

- $\|\cdot\|_2$ is the discrete $L_2$ norm,
- $\mathbf{r}_0$ is the initial (guess) residual vector,
- $\mathbf{\delta u} = \mathbf{u}^{(\ell)} - \mathbf{u}^{(\ell-1)}$ is the solution step vector,
- "NaN" is a not-a-number value,
- $\tau_\text{abs}$ is the absolute residual tolerance, specified with the
  [!param](/Convergence/DefaultNonlinearConvergence/nl_abs_tol) parameter.
- $\tau_\text{rel}$ is the relative residual tolerance, provided by
  [!param](/Convergence/DefaultNonlinearConvergence/nl_rel_tol).
- $\tau_{\delta u,\text{abs}}$ is the relative step tolerance., provided by
  [!param](/Convergence/DefaultNonlinearConvergence/nl_rel_step_tol).
- $\tau_\text{div,abs}$ is the absolute residual divergence tolerance, provided by
  [!param](/Convergence/DefaultNonlinearConvergence/nl_abs_div_tol).
- $\tau_\text{div,rel}$ is the relative residual divergence tolerance, provided by
  [!param](/Convergence/DefaultNonlinearConvergence/nl_div_tol).
- $n_\text{evals}$ is the number of residual evaluations.
- $n_\text{evals,max}$ is the maximum number of residual evaluations, provided by
  [!param](/Convergence/DefaultNonlinearConvergence/nl_max_funcs).
- $n_\text{ping}$ is the number of ping-pong iterations (consecutive iterations in which the residual grows then reduces on every other iteration).
- $n_\text{ping,max}$ is the maximum number of ping-pong iterations, provided by
  [!param](/Convergence/DefaultNonlinearConvergence/n_max_nonlinear_pingpong).




## IterationCountConvergence

This [Convergence](Convergence/index.md) specifies:

- $\ell_\text{max}$, the maximum number of iterations,
  via [!param](/Convergence/IterationCountConvergence/max_iterations), and
- $\ell_\text{min}$, the minimum number of iterations,
  via [!param](/Convergence/IterationCountConvergence/min_iterations).

If [!param](/Convergence/IterationCountConvergence/converge_at_max_iterations)
is set to `true`, then the solve will converge when $\ell = \ell_\text{max}$
instead of diverge.

### Design

Other `Convergence` objects may inherit from this class and override
`checkConvergenceInner(iter)` instead of the usual `checkConvergence(iter)`,
to inherit the iteration bounds. An example is [/PostprocessorConvergence.md].




## ParsedConvergence

This [Convergence](Convergence/index.md) allows the user to specify arbitrary expressions
for convergence and divergence criteria. These expressions
([!param](/Convergence/ParsedConvergence/convergence_expression) and [!param](/Convergence/ParsedConvergence/divergence_expression))
may contain any of the following:

- `Convergence` objects
- [Functions](Functions/index.md)
- [Post-processors](Postprocessors/index.md)
- Constant values

The expressions are parsed using the [Function Parser syntax](http://warp.povusers.org/FunctionParser/fparser.html#functionsyntax).
The full library of mathematical operators is valid in the parsed
expression, but for convenience, we list some of the logical and comparison operators here:

| Syntax | Description |
| :- | :- |
| `()` | Parentheses for order of operations |
| `!A` | *NOT* `A` |
| `A & B` | `A` *AND* `B` |
| `A` I `B` | `A` *OR* `B` |
| `A = B` | `A` *EQUALS* `B` |
| `A != B` | `A` *DOES NOT EQUAL* `B` |
| `A >= B` | `A` *GREATER THAN OR EQUAL TO* `B` |

The expressions must evaluate to either 1 or 0, which correspond to `true` or `false`,
respectively; if the expression returns another value, an error results. Note
the following rules for the `Convergence` object values:

- For the convergence expression, `Convergence` objects evaluate to `true` if they
  are `CONVERGED` and `false` otherwise (`ITERATING` or `DIVERGED`).
- For the divergence expression, `Convergence` objects evaluate to `true` if they
  are `DIVERGED` and `false` otherwise (`ITERATING` or `CONVERGED`).

The divergence expression is optional. If omitted, divergence occurs if any of
the supplied `Convergence` objects return `DIVERGED`, e.g.,

```
divergence_expression = 'conv1 | conv2 | conv3'
```

if [!param](/Convergence/ParsedConvergence/symbol_values) contains `conv1`, `conv2`, and `conv3`.




## PostprocessorConvergence

This [Convergence](Convergence/index.md) derives from [/IterationCountConvergence.md]
and compares a [Postprocessor](Postprocessors/index.md) value $y$ to a tolerance $\tau$:

|y| \leq \tau \,.

For this to work as expected, the `execute_on` parameter of the post-processor
must include values that trigger execution before the desired check. For example, for assessing convergence of the  nonlinear solve, the value `NONLINEAR_CONVERGENCE` should be used.

Typically the post-processor used should attempt to approximate the error in a system,
such as [/AverageVariableChange.md].




## ReferenceResidualConvergence

This [Convergence](Convergence/index.md) is a [/DefaultNonlinearConvergence.md] with a
customized reference residual for its relative convergence checks. See
[ReferenceResidualProblem.md] for more information.




# correctors

## PointwiseRenormalizeVector


This `Corrector` can pointwise renormalize the solution for a set of variables, taking each variable as the component of a vector and scaling the variables to obtain the user specified L2-norm.

### Applications

For example in a micromagnetics simulation the magnetization director field is a vector field that should stay normalized, however the evolution equations might not be strictly norm conserving, requiring a renormalization at the end of each time step to avoid drift on the norm.

### Design

The PointwiseRenormalizeVector corrector is derived from `GeneralUserObject` and iterates over all active local elements. On each element the DOF indices for all coupled variables are obtained. Starting with the first index for each variable we check of the DOF is local to the current processor and assemble the corresponding value from each variable into a vector. The L2-norm is calculated and the vector renormalized for the norm to match [!param](/Correctors/PointwiseRenormalizeVector/norm), unless all solution values are zero. This is repeated for all remaining DOF indices and for the old and older solution states.





# dampers

## BoundingValueElementDamper


The value of the damper is modified at every quadrature point based on
how far out of the defined bounds the variable is there, and in which direction
the variable is 'incremented' between successive iterations, away or closer to the bound.
The damping increases when the variable is moving further away from the prescribed bounds.

More information about dampers may be found on the
[Dampers syntax documentation](syntax/Dampers/index.md).

### Example input syntax

In this example, the variable `u` is being damped with minimum and maximum values of -1.5 and
1.5 respectively, with a minimum damping factor of 0.001.





## BoundingValueNodalDamper


The value of the damper is modified at every quadrature point based on
how far out of the defined bounds the variable is there, and in which direction
the variable is 'incremented' between successive iterations, away or closer to the bound.
The damping increases when the variable is moving further away from the prescribed bounds.

More information about dampers may be found on the
[Dampers syntax documentation](syntax/Dampers/index.md).

### Example input syntax

In this example, the variable `u` is being damped with minimum and maximum values of -1.5 and
1.5 respectively, with a minimum damping factor of 0.001.





## ConstantDamper


A constant damping factor may improve stability but will slow down convergence of the simulation.
More advanced dampers, which taper off through the iterations or which damp less within a certain
domain (such as the [BoundingValueNodalDamper.md]) should impact less convergence properties.

More information about dampers may be found on the
[Dampers syntax documentation](syntax/Dampers/index.md).

### Example input syntax

In this example, a constant damping factor of 0.9 is applied on all variables (just `u` here).





## MaxIncrement


The `MaxIncrement` damper limits the change of a variable from one nonlinear
iteration to the following iteration. A smaller value set as the `max_increment`
will results in more nonlinear steps.

### Example Input Syntax





# dgkernels

## ADDGAdvection


This is the automatic differentiation analog of [DGConvection.md] but with a
couple distinctions:

- The [!param](/DGKernels/ADDGAdvection/velocity) parameter is a material
  property instead of a constant. This allows this object's use in a
  simulation where the velocity is being solved for
  and/or changing spatially. Additionally, the use of a material property as
  opposed to a coupled variable allows more straightforward
  propagation of derivatives for automatic differentiation.
- A [!param](/DGKernels/ADDGAdvection/advected_quantity) parameter is
  available which allows for advecting different quantities than the `variable`
  this object is acting upon

### Example input syntax

In this example, a field `u` is advected from a boundary condition on its left to the right boundary
with a `1 0 0` velocity. In addition to advection, the simulation is governed by
loss of `u` through diffusion out of the top
and bottom boundaries of the domain.





## ADDGDiffusion

Use DG to compute a diffusion term, and AD is adopted for Jacobian calculation.




## ADDGKernel

Base class for all DG kernels making use of automatic differentiation.

This class takes care of accumulating the residual and Jacobian contributions, including
the neighbor and off-diagonal contributions.

## ArrayDGDiffusion

### Description

This array DG (discontinuous Galerkin) kernel implements the following piece of a weak form:

\begin{equation}
\left([\![ {\vec{u}^\ast} ]\!] , [\![ \vec{\kappa}\vec{u} ]\!] \right)_{\Gamma_\text{int}} +
\left([\![ \vec{u}^\ast ]\!], \{\!\!\{ \vec{D}\vec{\nabla}\vec{u}\cdot\vec{n} \}\!\!\}\right)_{\Gamma_\text{int}} +
 \epsilon\left( \{\!\!\{ \vec{D}\vec{\nabla}\vec{u}^\ast\cdot\vec{n} \}\!\!\}, [\![ \vec{u} ]\!]\right)_{\Gamma_\text{int}},
\end{equation}
where $\vec{u}^\ast$ is the test function, $\vec{u}$ is the finite element solution and $\vec{D}$ is the diffusion coefficients for all components of the array variable.
$[\![ \cdot ]\!]$ and $\{\!\!\{ \cdot \}\!\!\}$ are the jump and average of the enclosed quantity on the internal sides.

$\vec{n}(x)$ is a unit norm defined on internal sides denoted by $\Gamma_\text{int}$.
$\epsilon$ can be 1, -1, and 0, corresponding symmetric, asymmetric and incomplete interior penalty methods respectively.
The penalty coefficients $\kappa$ are evaluated with the following formulation:
\begin{equation}
\vec{\kappa} = \sigma \{\!\!\{ p^2\frac{\vec{D}}{h_\bot} \}\!\!\}, \quad  x\in\Gamma_\text{int},
\end{equation}
where $p$ is the polynomial order of the shape functions; $h_\bot$ is the length of the element orthogonal to the side; $\sigma$ is an adjustable constant.




## ArrayHFEMDiffusion


### Overview

This Array kernel applies the constraints on internal sides for diffusion equations with a hybrid finite element method using an array variable.
Its standard variable version is [HFEMDiffusion.md].




## DGConvection


The velocity vector is a constant, so this may not be used for solving for the velocity in fluid
simulations for example. This kernel is only for advecting a field with a known velocity.
The first order upwind scheme used is diffusive and will only provide first order mesh convergence.

More information about the discontinuous Galerkin method may be found in the
[DGKernels syntax page](syntax/DGKernels/index.md).

### Example input syntax

In this example, a field `u` is advected from a boundary condition on its left to the right boundary
with a `1 0 0` velocity using [ADDGAdvection.md], the version of this kernel with automatic differentiation.





## DGDiffusion


More information about the discontinuous Galerkin method, and in particular for the Poisson equation,
may be found in the [DGKernels syntax page](syntax/DGKernels/index.md).

### Example input syntax

This example is a 2D diffusion-reaction-source case using DG. The kernels are taking care of the
volumetric terms in the equation, while the `DGDiffusion` DGKernel is defined on the element sides.





## HFEMDiffusion


### Overview

This kernel applies the constraints on internal sides for diffusion equations with a hybrid finite element method ($\left( \lambda^\ast, [ u ] \right)_\Gamma + \left( [ u^\ast ], \lambda \right)_\Gamma$).
Refer to [DGKernels/index.md] for the full HFEM weak form for Poisson's equation.




## HFEMTestJump


### Overview

This kernel adds a residual with a side-discontinuous variable
"lambda" weighted by inter-element jumps in test functions
corresponding to a discontinuous variable "u":
$\left( [ u^\ast ], \lambda \right)_\Gamma$

This is useful in diffusion equations with a hybrid finite element
method.  Refer to [DGKernels/index.md] for the full HFEM weak form for
Poisson's equation.




## HFEMTrialJump


### Overview

This kernel adds a residual with inter-element jumps in a
discontinuous variable "u" weighted by test functions corresponding to
a side-discontinuous variable "lambda":
$\left( \lambda^\ast, [ u ] \right)_\Gamma$

This is useful in diffusion equations with a hybrid finite element
method.  Refer to [DGKernels/index.md] for the full HFEM weak form for
Poisson's equation.




# dirackernels

## ConstantPointSource


This applies a load in a single location in the mesh. The value field is controllable,
so the [`Control system`](syntax/Controls/index.md) may be leveraged to control the load during the
simulation. Alternatively, a [FunctionDiracSource.md] may be used for spatial and temporal variations
of the point source using a `Function`.

### Example input syntax

In this example, three `ConstantPointSource` are being applied to variable `u` with values 0.1 / -0.1 and -1
at position (0.2 0.3 0.0) / (0.2 0.8 0) and (0.8 0.5 0.8) respectively. `u` is solution to a diffusion equation
with those three sources.





## FunctionDiracSource


This applies a load in a single location in the mesh. The intensity of the source is controlled by a
[`Function`](syntax/Functions/index.md), which can have both spatial and temporal variations.

### Example input syntax

In this example of a time-dependent diffusion problem, the source is provided by a `FunctionDiracSource`
at the point `(0.1 0.2 0)` and its intensity is controlled by the `switch_off` function.





## ReporterPointSource

A `ReporterPointSource` reads in multiple point sources from a `Reporter`.  The point source values and coordinates are updated as the `Reporter` values are changed.

Duplicated points, i.e. points with the same xyz coordinates, are dropped by [DiracKernels](/DiracKernels/index.md) and applied as a single point.  The input parameter [!param](/DiracKernels/ReporterPointSource/combine_duplicates) combines the values and weights of duplicated points when set to `True`.  Reporters containing duplicate points will produce an error when set to `False`.  The parameter `drop_duplicate_points` used by other DiracKernels to handle duplicate points is suppressed for the `ReporterPointSource` because it is expected that every duplicate point in a `ReporterPointSource` will have different value and weight and are not just multiples of the sames value.

An example of a `ReporterPointSource` using a [ConstantReporter](/ConstantReporter.md)
and a `VectorPostprocessor` of type [CSVReaderVectorPostprocessor](/CSVReaderVectorPostprocessor.md) is given by:


The ConstantReporter provides the following data:


The `CSVReaderVectorPostprocessor` is given by:


reading from the following csv file:


The `Reporter` and `VectorPostprocessor` for the above example produce the same `ReporterPointSource` (e.g. same magnitude and location).   

The next example applies a `ReporterPointSource` in a transient simulation given by:


using the following `VectorPostprocessor` to provide x,y,z coordinates and `value_name = u`


In the above input file, the `ReporterPointSource` is applying loads at two different locations.  Note that the `PointValueSampler` has `execute_on = timestep_begin` to force the `VectorPostprocessor` to execute prior to being used by `ReporterPointSource`.

It is important for the `ReporterPointSource` to never use a `VectorPostprocessor` with `contains_complete_history = true`, as this can modify the ordering of the coordinates and points.  In the above input file, two locations have loads applied to them by the `ReporterPointSource`.  The load values are given by the `PointValueSampler`.




## VectorConstantPointSource


This applies a load in a single location in the mesh. The value field is controllable,
so the [Control system](syntax/Controls/index.md) may be leveraged to control the load during the
simulation.

### Example input syntax

In this example, three `VectorConstantPointSource` are being applied to variable
`u` with values (0.1 0.1 0.1) / (-0.1 -0.1 -0.1) and (-1 -1 -1)
at position (0.2 0.3 0.0) / (0.2 0.8 0) and (0.8 0.5 0.8) respectively. `u` is
solution to a vector diffusion equation
with those three sources.





# executioners

## Eigenvalue





## Executioner

The Executioner controls the "execution" behavior of the simulation. MOOSE includes several Executioners but
most simulations will use the [Transient.md] Executioner, which is for simulating that is based on a PDE that
has a time dependence (changes over time).

### Grid Sequencing

Grid sequencing is a method particularly suited for nonlinear problems. It seeks
to create an initial guess that is significantly close to the solution that
Newton's method starts in or quickly enters the quadratic basin of
convergence. The initial guess is generated by solving the finite element problem
on one or a series of coarse grids and then prolonging the coarse grid solution
to form the initial guess for the final fine grid. Grid sequencing can be
conducted by simply specifying `num_grids = n` where `n` is the desired
number of grids to perform the nonlinear solve on. In particular if `num_grids = 2`, there would be one
coarse grid solve and then a fine grid solve, with the "fine grid" having one
level of uniform refinement relative to the coarse grid. Note that in order to
use grid sequencing, the initial mesh should correspond to the coarsest level of
mesh desired because adaptivity in libMesh is incapable of coarsening a mesh
beyond that initially provided by the user.

### Attribute Reporting

The Executioner has a shortcut method that can be used to add an attribute reporting mechanism to the simulation.
The Executioner accomplishes this by adding a special [Postprocessor.md] to the simulation that will report
a potentially changing scalar value over time.

## FEProblemSolve

The `FEProblemSolve` class has two main roles:

- handle a variety of parameters for the [linear and nonlinear solves](systems/NonlinearSystem.md)
- encapsulate the solve function call with a [geometric grid sequencing calls](syntax/Executioner/index.md#Grid Sequencing) for nonlinear problems
- encapsulate each nonlinear system within a multi-system fixed point loop. This loop is nested within the geometric grid sequencing.

The `FEProblemSolve` is a solve executioner nested inside most executioners,
such as [Steady](executioners/Steady.md) and [Transient](executioners/Transient.md) but notably *not* in the [Eigenvalue](executioners/Eigenvalue.md) executioner.

### Multi-system solve capabilities

If using multiple nonlinear systems, the default behavior of the `FEProblemSolve` will be to solve them one by one,
in the order that they were specified, without iterating between systems.

If the [!param](/Executioner/Steady/multi_system_fixed_point) parameter is set to true, this solve will be iterated.
The user must pass a convergence object to the [!param](/Executioner/Steady/multi_system_fixed_point_convergence)
to let the `FEProblemSolve` know when to terminate the fixed point loop.

Options are currently limited for setting a multi-system fixed point convergence. We do not recommend using the
nonlinear residual with a [VariableResidual.md] postprocessor or a [DefaultNonlinearConvergence.md] as these
are not re-computed the end of a multi-system fixed point iteration.

## InversePowerMethod


### Overview

Eigenvalue executioners such as this one intend on solving the eigenvalue problem described by:

Ax = \frac{1}{k}Bx,

where $A$ and $B$ are linear or nonlinear operators represented by kernels. To differentiate the $B$ kernels from the $A$ kernels, we must derive all $B$ kernels from `EigenKernel`. Currently we are only interested in the absolute minimum eigenvalue  $\frac{1}{k}$ and the corresponding eigenvector $x$ of the system. We are also not seeking the solutions of a general nonlinear eigenvalue problem, where the operators have nonlinear dependency on the eigenvalue.

### The inverse power method algorithm

1. Initialization

   \begin{aligned}
   k^{(0)} &= k_0 \\
   x^{(0)} &= x_0
   \end{aligned}

1. Update x and k

   \begin{aligned}
   x^{(n)} &= \frac{1}{k^{(n-1)}} A^{-1}Bx^{(n-1)} \\
   k^{(n)} &= k^{(n-1)} \frac{|Bx^{(n)}|}{|Bx^{(n-1)}|}
   \end{aligned}

1. Check the convergence

   \frac{|x^{(n)}-x^{(n-1)}|}{|x^{(n)}|} < tol_x

   and

   \frac{|k^{(n)}-k^{(n-1)}|}{|k^{(n)}|} < tol_k

   When either of them is not true, return Step 2, otherwise exit.


We notice immediately that $\frac{|Bx|}{k}$ remains constant during the iteration, so if we make $\frac{|Bx^{(0)}|}{k^{(0)}}$ equal to 1, the algorithm can be simplified a little:

1. Initialization

   \begin{aligned}
   k^{(0)} &= k_0 \\
   x^{(0)} &= k_0 \frac{x_0}{|Bx_0|}
   \end{aligned}

1. Update x and k

   \begin{aligned}
   x^{(n)} &= \frac{1}{k^{(n-1)}} A^{-1}Bx^{(n-1)} \\
   k^{(n)} &= |Bx^{(n)}|
   \end{aligned}

1. Check the convergence

   \frac{|x^{(n)}-x^{(n-1)}|}{|x^{(n)}|} < tol_x

   and

   \frac{|k^{(n)}-k^{(n-1)}|}{|k^{(n)}|} < tol_k

   When either of them is not true, return Step 2, otherwise exit.


Also in this simplified algorithm, the solution is automatically normalized making $|Bx|=k$. We can do postprocessing to normalize the solution so that $|x|=c$, where $|.|$ can be any norm and $c$ is a scalar constant.

If the minimum eigenvalue and the second smallest eigenvalue are close, i.e. the dominance ratio is about equal to one, the inverse power iteration converges very slowly. In such a case, we can apply accelerations, such as Chebyshev acceleration, based on the on-the-fly estimation of the dominance ratio.

The inverse power method is appealing because we can apply matrix-free schemes on evaluating $Ax - \frac{1}{k}Bx$. We can use PJFNK for inverting $A$ and we do not have to exactly assemble matrix $A$ for the preconditioning purpose.




## NonlinearEigen


### Overview

Eigenvalue executioners such as this one intend on solving the eigenvalue problem described by:

Ax = \frac{1}{k}Bx,

where $A$ and $B$ are linear or nonlinear operators represented by kernels. To differentiate the $B$ kernels from the $A$ kernels, we must derive all $B$ kernels from `EigenKernel`. Currently we are only interested in the absolute minimum eigenvalue  $\frac{1}{k}$ and the corresponding eigenvector $x$ of the system. We are also not seeking the solutions of a general nonlinear eigenvalue problem, where the operators have nonlinear dependency on the eigenvalue.

### The nonlinear Newton method

From the above section, we can see the eigenvalue problem can be viewed as a nonlinear problem

\begin{aligned}
&Ax = \frac{1}{k}Bx, \\
&k = |Bx|,
\end{aligned}

so we can use the Newton method to solve it. However, to make the solving converge, we need to have a fairly close initial guess to the fundamental mode. This can be achieved with several free power iterations before the Newton iteration. We do not have to have $k$ as part of the solution vector. Instead we can apply the elimination technique and view the equation as

Ax = \frac{Bx}{|Bx|}.

Again we can use PJFNK (preconditioned Jacobian-free Newton Krylov) method to solve this nonlinear problem. The preconditioning matrix can affect the linear convergence in each Newton iteration. If there is a convergence issue, it is suggested to use $A-\frac{B}{|Bx|}$ and gradually reduce its complexity as the preconditioning matrix.




## Steady


### Overview

Steady is a general solver for discrete steady-state nonlinear or linear problem:

\mathbf{R}(\mathbf{u}) = \mathbf{0}.

By default the line-search Newton in PETSc is used with the PJFNK (preconditioned Jacobian-free Newton Krylov) method.
At each Newton iteration the executioner solves

\mathbf{J}(\mathbf{u}^{i-1}) \delta \mathbf{u}^{i} = \mathbf{R}(\mathbf{u}^{i-1}),

where

\mathbf{J}(\mathbf{u}^{i-1}) \equiv \mathbf{R}'(\mathbf{u}=\mathbf{u}^{i-1})

is the Jacobian matrix evaluated at $\mathbf{u}^{i-1}$.
Jacobian matrix depends on $\mathbf{u}^{i-1}$ for general nonlinear problems while it is constant for linear problems.
The right hand side is also typically referred to as the residual at $\mathbf{u}^{i-1}$ of [eq:problem].
The Krylov methods are employed for solving the above linear equation, which requires only the evaluation of the matrix-vector product $\mathbf{J}(\mathbf{u}^{i-1}) \mathbf{y}$.
Within the MOOSE framework, the Jacobian-Free Newton Krylov method is used that approximates matrix vector products by the Finite-Difference like approximation:

\mathbf{J}(\mathbf{u}^{i-1}) \mathbf{y} \approx \frac{\mathbf{R}(\mathbf{u}^{i-1} + \epsilon \mathbf{y}) - \mathbf{R}(\mathbf{u}^{i-1})}{\epsilon},

where the scalar value $\epsilon$ is chosen by PETSc automatically to approximate $\mathbf{J}(\mathbf{u}^{i-1}) \mathbf{y}$ accurately for the linear solve.
It is noted that for a linear problem of which $\mathbf{R}(\mathbf{u})$ can be expressed as $\mathbf{A} \mathbf{u}-\mathbf{b}$, where matrix $\mathbf{A}$ is the Jacobian independent on $\mathbf{u}$ and $\mathbf{b}$ is the right-hand-side vector, the right hand side of [eq:mffd] is independent on $\epsilon$.
Section 5.5 of PETSc user's manual on matrix-free methods details the algorithm for choosing the value of $\epsilon$.
It is actually the PETSc option `-mat_mffd_err` controls the $\epsilon$ but not `-snes_mf_err` unless we set `-snes_mf_version` to 2 other than the default 1.
This could be changed in future PETSc updates.

The Krylov methods typically also require an approximation of the actual Jacobian $\mathbf{M}(\mathbf{u}^{i-1}) \approx \mathbf{J}(\mathbf{u}^{i-1})$ for pre-conditioning the Krylov solution at each linear iteration.
Note, the preconditioning matrix is seldom the exact Jacobian $\mathbf{J}$ because it would require too much computational time and memory to compute, and in some cases is simply impossible to compute.
By default the type of Krylov method in use is GMRES because it does not have assumptions on the underlying Jacobian.
The initial guess for each linear solve is always set to zero, which implies that the initial linear residual is the same of the nonlinear residual.
The residual norm at each linear iteration is evaluated by PETSc, for instance, during updating the Hessenberg matrix if GMRES method is used.
At the conclusion of the nonlinear iteration, the solution is updated as follows

\mathbf{u}^{i} = \mathbf{u}^{i-1} + \alpha \delta \mathbf{u}^{i}

where $\alpha$ is determined by the line-search algorithm.
We can see that at each nonlinear or Newton iteration, we will need to update the preconditioning matrix and evaluate the residual with the updated solution.
At each linear iteration, we simply need a residual evaluation and the operation of the preconditioner built from the preconditioning matrix. In PETSc the preconditioner type refers to the method to obtain an approximation of the inverse of $\mathbf{M}$ and not a means to compute the elements of $\mathbf{M}$.
It is noted that the default preconditioner type depends on the number of processors and also depends on the assembled preconditioning matrix $\mathbf{M}$.
Typically incomplete LU (PCILU) is the default type with one processor and block Jacobi (PCBJACOBI) is the type with multiple processors.
Consequently, you will not see the same convergence with the different number of processors. Note, there are two approximations in play here: (1) the Jacobian $\mathbf{J}$ is approximated by a matrix $\mathbf{M}$ that is easier to compute, and (2) the matrix $\mathbf{M}$ is inverted approximately.
The preconditioning matrix $\mathbf{M}$ can be viewed with the PETSc option `-ksp_view_pmat`.

### Solve Type

The general method in which the nonlinear system is solved is controlled by the [!param](/Executioner/Steady/solve_type) parameter. Below is a description of each of the options:

- `PJFNK` is the default solve type. It makes the executioner perform Jacobian-free linear solves at each Newton iteration with the preconditioner built from the preconditioning matrix $\mathbf{M}$. By default, the preconditioning matrix is block-diagonal with each block corresponding to a single MOOSE variable without custom preconditioning, refer to [Preconditioning](/Preconditioning/index.md). Off-diagonal Jacobian terms are ignored. It essentially activates the matrix-free Jacobian-vector products, and the preconditioning matrix.
- `JFNK` means there is no preconditioning during the Krylov solve. No Jacobian will be assembled. It essentially activates the matrix-free Jacobian-vector products and no preconditioning matrix.
- `LINEAR` will use PETSc control parameter `-snes_type ksponly` to set the type of SNES for solving the linear system. Note that it only works when you have an *exact* Jacobian because it is not activating matrix-free calculations.
- `NEWTON` means PETSc will use the Jacobian provided by kernels (typically not exact) to do the Krylov solve. If the Jacobian is not exact, Newton update in [eq:nonlinear-update] will not reduce the residual effectively and typically results into an unconverged Newton iteration.
- `FD` means the Jacobian is assembled via a finite differencing method. This is costly and should used only for testing purpose.

### Preconditioning

- Krylov methods need preconditioning to be efficient (or even effective!).
- Even though the Jacobian is never formed, JFNK methods still require preconditioning.
- MOOSE's automatic (without user intervention) preconditioning is fairly minimal.
- Many options exist for implementing improved preconditioning in MOOSE.

#### Preconditioned JFNK

- Using right preconditioning, solve

\boldsymbol{R}'(\boldsymbol{u}^{i-1}) \boldsymbol{M}^{-1} (\boldsymbol{M} \delta \boldsymbol{u}^{i}) = -\boldsymbol{R}(\boldsymbol{u}^{i-1})

- $\boldsymbol{M}$ symbolically represents the preconditioning matrix or process
- Inside GMRES, we only apply the action of $\boldsymbol{M}^{-1}$ on a vector
- Right preconditioned matrix free version

\boldsymbol{R}' (\boldsymbol{u}) \boldsymbol{M}^{-1}\boldsymbol{v} \approx \frac{\boldsymbol{R}(\boldsymbol{u} + \epsilon \boldsymbol{M}^{-1}\boldsymbol{v}) - \boldsymbol{R}(\boldsymbol{u})}{\epsilon}

### PETSc Options

PETSc parameters can either be set on the command line or by using the [!param](/Executioner/Steady/petsc_options), [!param](/Executioner/Steady/petsc_options_iname), and [!param](/Executioner/Steady/petsc_options_value) parameters. Several PETSc parameters that users could frequently use are listed below:

| `petsc_options` | Description |
| - | - |
| `-snes_ksp_ew` | Variable linear solve tolerance -- useful for transient solves |
| `-help` | Show PETSc options during the solve |


| `petsc_options_iname` | `petsc_options_value` | Description |
| - | - | - |
| `-pc_type` | `ilu` | Default for serial |
|   | `bjacobi` | Default for parallel with `-sub_pc_type ilu` |
|   | `asm` | Additive Schwartz with `-sub_pc_type ilu` |
|   | `lu` | Full LU, serial only! |
|   | `gamg` | PETSc Geometric AMG Preconditioner |
|   | `hypre` | Hypre, usually used with `boomeramg` |
| `-sub_pc_type` | `ilu, lu, hypre` | Can be used with bjacobi or asm |
| `-pc_hypre_type` | `boomeramg` | Algebraic multigrid |
| `-pc_hypre_boomeramg` (cont.) |   | "Information Threshold" for AMG process |
| `_strong_threshold` | `0.0 - 1.0` | **(0.7 is auto set for 3D) |
| `-ksp_gmres_restart` | `#` | Number of Krylov vectors to store |




## Transient


### Normal Usage

The `Transient` Executioner is the primary workhorse Executioner in MOOSE.  Most simulations will use it.

At its most basic the `Transient` Executioner allows a simulation to step through multiple steps in _time_... doing one nonlinear solve per timestep.  Most of the time this type of execution will utilize one or more [`TimeDerivative`](/TimeDerivative.md) Kernels on the variables to solve for their time evolution.

#### Primary Parameters

The most important parameters for `Transient` (beyond what [`Steady`](/Steady.md) already provides) are:

- [!param](/Executioner/Transient/dt): The initial timestep size
- [!param](/Executioner/Transient/num_steps): Number of steps to do
- [!param](/Executioner/Transient/end_time): Finish time for the simulation
- [!param](/Executioner/Transient/scheme): The TimeIntegrator to use (see below) - defaults to Implicit/Backward Euler.


See down below for the full list of parameters for this class.

#### TimeIntegrators

It's important to note that transient simulations generally use a [TimeIntegrator](TimeIntegrator/index.md).  As mentioned above, there is a `scheme` parameter that is shortcut syntax for selection of that TimeIntegrator.  However, there is also a whole [TimeIntegrator](TimeIntegrator/index.md) system for creating your own or specifying detailed parameters for time integration.

#### TimeSteppers

Similarly, the choice of how to move through time (the choice of timestep size) is important as well.  The default [TimeStepper](/TimeStepper/index.md) is [`ConstantDT`](ConstantDT.m) but many other choices can be made using the [TimeStepper](/TimeStepper/index.md) system.

### Load Steps

`Transient` can also be used for simulations that don't necessarily need _time_.  In this context a "transient" calculation can simply be thought of as a series of nonlinear solves.  The time parameter will move forward - but what you do with it, or what it means is up to you.

One good example of this is doing "load steps" for a solid mechanics calculation.  If the only thing that is desired is the final, steady state, solution, but getting to it is extremely difficult, then you might employ "load steps" to slowly ramp up a boundary condition so you can more easily solve from the initial state (the "initial condition") to the final configuration.  In this case you would use "time" as a parameter to control how much of the force is applied (for instance, by using [`FunctionDirichletBC`](/FunctionDirichletBC.md)).

In this case you don't use any [`TimeDerivative`](/TimeDerivative.md) Kernels.  The "transient" behavior comes from changing a condition based on "time".  What that "time" means is up to you to identify (generally, I like to just step through `time = 1,2,3,4..` and define my functions so that at `time = end_steps` the full load is applied.

### Quasi-Transient

Similarly to Load Steps, you can use `Transient` to do "Quasi-Transient" calculations.  This is where some variables are evolving with time derivatives, while others are solved to steady state each step.

A classic example of this is doing coupled thermo-mechanics.  It's very normal for the heat flow to move much more slowly than the solid mechanics. Therefore, classically, it is normal to have a time derivative for your heat conduction equation but none for the solid mechanics so that at each timestep the solid-mechanics is solved to a full steady state based on the current configuration of heat.

This idea works perfectly in MOOSE with `Transient`: just simply only apply [`TimeDerivative`](/TimeDerivative.md) Kernels to the equations you want and leave them off for the others.

### Solving To Steady State

Another use-case is to use `Transient` to solve to a steady state.  In this case there are a few built-in parameters to help detect steady state and stop the solve when it's reached.  You can see them down below in the "Steady State Detection Parameters" section.

It is important to know that you must turn _on_ steady state detection using `steady_state_detection = true` before the other two parameters will do anything.
The parameter `steady_state_tolerance` corresponds to $\tau$ in the following
steady-state convergence criteria:
\begin{equation}
  \frac{\|u^{n+1} - u^n\|}{\Delta t} < \tau \|u\|^{n+1} \,.
\end{equation}




# executors

## Executor

The Executor controls the "execution" behavior of the simulation. They direct
the flow of solves, stepping, output recording, etc.  Executors are similar to
the original Executioner system in that they have one primary virtual function
that each executor implements that defines its behavior.  However, executors
differ in that they are designed to be composed into arbitrary tree structures
both in-code and by users via input files - similar to how the MeshGenerator
system works.  The Executor system is currently highly experimental and has not
yet stabilized and been fully implemented.  For this reason, MOOSE will only
run in this mode if given the `--executor` flag on the command line.  The system
name may change, input syntax may change, etc.  YOU WERE WARNED!

### Using Executors from input files

When using executors, you must remember to pass in the `--executor` flag on the
cli when you run your application binary.  This allows the Executioner block
to be omitted and causes MOOSE to ignore it if present.  Support for a new
`[Executor]` block has been added to input files.  Users will populate this
block with equivalent content that normally was present in the `[Executioner]` block.
A hypothetical example is this:

```
[Executor]
  [solve]
    type = FooSolver
    max_its = 42
    ...
  []
  [refine]
    type = Refine
    inner = solve
  []
  [init]
    type = Init
    inner = refine
    petsc_options = ...
  []
[]
```

Which might perform the equivalent of something like the current `Steady`
executioner.  In this example, "init" becomes the primary executor which does
some things to set up and tear down the simulation.  Inside its setup and
tear-down, it executes an inner executor that has been set to "refine".  The
"refine" executor does some mesh refinement things and then executes an inner
executor - which here has been set to "solve". This allows refinement to be
wrapped/inserted into arbitrary areas of the simulation execution process.

The new system, is also capable of providing alias-like executors that generate
equivalent executor trees programmatically in order to replicate the current
`Steady` or `Transient` behavior like users currently expect now:

```
[Executor]
  [steady]
    type = FauxSteady
    solve_type = 'PJFNK'
    petsc_options_iname = '-pc_type -pc_hypre_type'
    petsc_options_value = 'hypre boomeramg'
    ...
  []
[]
```

This executor would simply generate the init+solve+refine trio of executors
programmatically - hiding the executor structure from the user.  By default the
last executor listed in the `Executor` block becomes the master/primary executor.
MOOSE only directly executes this executor; all other executors are executed if/when
execution reaches them within the executor tree starting from the master executor.

By default, an executor has automatically generated execute-on flags created for
it.  These flags are executed right before and right after the executor executes
and are named `exec_[obj-name]_begin` and `exec_[obj-name]_end` respectively
where `[obj-name]` is the name given to an object by its block header in an
input file - e.g. `[foo] type = FooExecutor []` has an object name of `foo`.
Other objects (e.g. user objects, materials, etc.) can be assigned to execute at
these execute-on flags/times within the input file.  This behavior is NOT
fully implemented and will almost certainly not work right - so you should
definitely not try to use it (yet).  The names of these flags can also be
modified from within the input file via an executor's `begin_exec_flag` and
`end_exec_flag` input parameters.

### Writing Custom Executors

Executors have one primary function - `virtual Result run()` that must
be implemented.  If an executor has any internal executors, it will call these
executors' `Result exec()` functions - NOT their run functions.

All executors' "exec" and "run" functions return a `Result` value containing
information about how execution turned out within the executor tree.  Each
executor is responsible for recording how convergence/success occurs within it.
This should generally be accomplished using the `Result::pass(msg)` and
`Result::fail(msg)` functions on a result object created and initialized
by calling the `newResult()` member function:

```
Result
FooExecutor::run()
{
  Result & r = newResult(); // MUST catch this return value by reference

  ...
  bool success = ... // do some solve stuff

  if (!success)
    r.fail("the foo didn't work right with the bar");
  else
  {
    // by default, a result is considered successful/converged - so we only need
    // to call fail on failure - and calling pass on success is optional.
    r.pass("runnin' like a well oiled machine");
  }

  ...

  return r;
}
```

Some executors will have internal/sub executors that they need to execute.  They
are both responsible for initiating this execution as well as recording the
result value generated by these executors using the `Result::record` function:

```

InputParameters
Steady2::validParams()
{
  InputParameters params = Executor::validParams();
  // create input parameters for our sub/internal solve executors
  params.addRequiredParam<std::string>("solve1", "the first solve");
  params.addRequiredParam<std::string>("solve2", "the second solve");
  return params;
}

FooExecutor::FooExecutor(InputParameters & params)
  : _inner_solve1(&_fe_problem.getExecutor(getParam<std::string>("solve1"))), // retrieve inner executor objects
    _inner_solve2(&_fe_problem.getExecutor(getParam<std::string>("solve2")))
{
}

Result
FooExecutor::run()
{
  Result & r = newResult();
  ...
  // When we record an inner/sub executor's result, we give it a label - which
  // helps identify its placement/role within the executor hierarchy.
  r.record("solve1", _inner_solve1->exec());
  r.record("solve2", _inner_solve2->exec());
  ...
  return r;
}
```

Result values provide a convenience `bool convergedAll()`function for
recursively determining if *any* single executor result within the currently
executed portion of the tree has failed to converge.  When checking for
convergence within an executor, this is usually the mechanism that should be
used:

```
Result
FooExecutor::run()
{
  Result & r = newResult();
  ...
  // When we record an inner/sub executor's result, we give it a label - which
  // helps identify its placement/role within the executor hierarchy.
  r.record("solve1", _inner_solve1->exec());
  r.record("solve2", _inner_solve2->exec());

  // something inside _inner_solve1 or _inner_solve2 may have failed to converge
  if (!r.convergedAll())
  {
    r.fail("foo iterations didn't work right"); // maybe add additional error msg context
    return r; // maybe you want to bail early
  }

  r.record("solve3", _inner_solve3->exec());
  ...
  return r;
}
```

## NullExecutor


The `NullExecutor` is an object used for testing and for temporarily replacing
a different executor when doing lazy binding. It should not be created by users.




# functions

## Axisymmetric2D3DSolutionFunction


The 2D solution is likely to be the output of a 2D-RZ calculation, which we want to compare
to a full 3D model. This is useful for assessing the validity of the 2D-RZ geometric approximation.

The axis of symmetry for the original 2D axisymmetric calculation and for mapping
this 2D axisymmetric calculation into the 3D space can both be specified.

### Example input syntax

In this example, three `Axisymmetric2D3DSolutionFunction` are used to load results for a 2D
axisymmetric simulation in a 3D mechanics simulation. These results are then used in the `BCs`
block to impose a displacement on a boundary, and in a temperature variable using a [FunctionAux.md].





## BicubicSplineFunction


The `BicubicSplineFunction` defines a 2D spline shape, which can be evaluated everywhere
in the domain by translation. The 2D plane for defining the spline is set by specifying the
`normal` parameter.

The spline is uniquely defined by:

- its values the 2D plane at the (`x1`, `x2`) points, given by the `y` parameter. The points
  form a 2D grid, which each `x1` being the abscissa for a line in this grid, with points
  at each `x2` specified

- its derivatives along `x1` and `x2` at the points on each extremity, given by `yx11`, `yx1n`, `yx21`, `yx2n`

- a functional form for the derivative along both directions, given by `yx1` and `yx2`

From this information the bicubic spline is automatically generated. Both the first and second
order derivatives of the spline are defined.

### Example input syntax

In this example, we define a bicubic spline from a list of points and derivatives. The `z` normal is
assumed by default and the bicubic spline is defined in the XY plane. The grid
for the points has 3 points along the `x` direction and 4 points along the `y` direction.





## ChainControlParsedFunctionWrapper

This class wraps `libMesh::ParsedFunction` for use of various parsed
[ChainControls](syntax/ChainControls/index.md).

For valid syntax for the function expression, see the
[function parser site](http://warp.povusers.org/FunctionParser/).

The user-defined symbols may include the following:

- `bool` or `Real` [/ChainControlData.md]
- [Functions](syntax/Functions/index.md)
- Scalar variables
- Constant values

Pre-defined symbols that may be used in the function expression are `x`, `y`, `z`, and `t`,
representing the corresponding spatial coordinates and time value.

## CoarsenedPiecewiseLinear


### Description

The `CoarsenedPiecewiseLinear` performs preprocessing and linear interpolation
on an x/y data set. The object  acts like
[`PiecewiseLinear`](/PiecewiseLinear.md)  except that it reduces the number of
function point at the start of the simulation. It uses the
[Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)
for data reduction.

### Example Input Syntax





## CompositeFunction


### Description

The `CompositeFunction` type takes an arbitrary set of functions, provided in
the `functions` parameter, evaluates each of them at the appropriate time
and position, and multiplies them together.  The function can optionally be
multiplied by a scale factor, which is specified using the `scale_factor`
parameter.

### Example Input Syntax





## ConstantFunction


The `value` parameter of the `ConstantFunction` is controllable, so it may modified
during the simulation using the [Controls system](syntax/Controls/index.md).

### Example input syntax

This example uses a `ConstantFunction` to feed into vectorized spatial samplers, which
sample the function in specified locations. These samples are then compared using
another postprocessor. The `ConstantFunction` sampled anywhere in time and space will
return its constant value.





## ImageFunction


### Overview

Simulations often require the phase to be initialized or compared to existing micro-structure data,
such as CT or SEM scans as shown in the figure. MOOSE includes a flexible,
[Function](Functions/index.md) based method for accessing this type of data for use in initial
conditions or other calculations. For example, [fig:large_adapt] is a reconstructed image of
snow captured using cryospheric micro-CT scanner at the
[MSU Subzero Research Laboratory](http://www.montana.edu/subzero).

       caption=Mesh of 3D micro-CT data using `ImageFunction`.

### Setup

To utilize the image reading portion of the phase-field module VTK must be enabled when building
libMesh. Please see MOOSE [FAQ](faq.md#libmesh-vtk optional=True) for more information.

### Examples

#### Single Image

Consider the simple image in [fig:small_raw], reading this image is accomplished by
including a `ImageFunction` in your input file.


       style=width:50%;margin-right:auto;margin-left:auto;
       caption=Example image input (stack/test_00.png).


This function may then be used just like any other function within MOOSE, for example, it may be
utilized as an initial condition for a variable.  The following input file syntax would use the
function above as an initial condition for the `u` variable and create an initial mesh as shown in
[fig:small_uniform].


       style=width:50%;margin-right:auto;margin-left:auto;
       caption=Mesh showing initial condition extracted from image in [fig:small_raw].

The example image shown is 20 by 20 pixels as is the mesh (20 by 20 elements) to which the initial
condition is applied. The meshed version looks slightly different than the original image because
the initial condition is applied by sampling the image at each node within the mesh, which in this
case matches with the pixel boundaries, so the value can sampled can easily vary due to floating
point precision limitations.

Matching the mesh to the pixel dimensions +is not+ a requirement, and not recommend. The main reason
for building the `ImageFunction` object was to enable an arbitrary mesh geometry to be able to sample
the image and adapt accordingly.

Beginning with a 2 by 2 element mesh and adding the following an adaptivity block to the input file
results in the mesh shown [fig:small_adapt].


       style=width:50%;margin-right:auto;margin-left:auto;
       caption=Mesh showing initial condition with initial adaptivity extracted from image in
               [fig:small_raw].

#### Image Stacks

Image stacks or 3D images are also supported (see [#file-types]). For example, consider as set of
images named test_00.png, test_01.png, ..., and test_19.png within a directory "stacked". To read
these images the syntax below is used in the `ImageFunction` block.  Again, using this data as an
initial condition and using initial adaptivity, as shown above, results in the mesh shown in
[fig:small_3d].


       style=width:50%;margin-right:auto;margin-left:auto;
       caption=3D Mesh showing initial condition with initial adaptivity extracted from a stack of
               images similar to the image in [fig:small_raw]. The mesh is cropped in the vertical
               direction to show the internal structure.

It is also possible to limit the reader to a set of images using the
[!param](/Functions/ImageFunction/file_range) parameter, which may be set to a single value to read a
single image or a range to read a subset of the images.


### Image Processing

The [VTK](http://www.vtk.org/) library includes a range of image filters and processing tools, some
basic processing tools are included. However, a derivative class could easily be developed to expand
upon these capabilities.

#### Component

By default, the RGB pixel data is converted into a single greyscale value representing the
magnitude. This is accomplished using the
[vtkImageMagnitude](http://www.vtk.org/doc/nightly/html/classvtkImageMagnitude.html) class.

It is possible to select a single component rather than using the magnitude by setting the
[!param](/Functions/ImageFunction/component) parameter in the input file to a valid component number,
which will be 0, 1 or 2 for RGB images.

#### Thresholding

Basic thresholding is accomplished using the
[vtkImageThreshold](http://www.vtk.org/doc/nightly/html/classvtkImageThreshold.html)
class. Thresholding requires three parameters be set in the input file:

- [!param](/Functions/ImageFunction/threshold): The threshold value to consider.
- [!param](/Functions/ImageFunction/upper_value): Image data above the threshold are replaced with
  this value.
- [!param](/Functions/ImageFunction/lower_value): Image data below the threshold are replaced with
  this value.

#### Shift and Scale

It is possible to shift and scale the image data, this is accomplished using the
[vtkImageShiftScale](http://www.vtk.org/doc/nightly/html/classvtkImageShiftScale.html) object. The
[!param](/Functions/ImageFunction/shift) parameter adds the given value to the image data and
[!param](/Functions/ImageFunction/scale) parameter multiplies the image data by the supplied value.

The order of application of the shift and scale are dictated by the VTK object, the documentation
states: "Pixels are shifted (a constant value added) and then scaled (multiplied by a scalar)."

#### Image Flipping

Flipping an image along the major axis directions x, y, or z is performed using
[vtkImageFlip](http://www.vtk.org/doc/nightly/html/classvtkImageFlip.html) object. Three flags
exists---[!param](/Functions/ImageFunction/flip_x), [!param](/Functions/ImageFunction/flip_y), and
[!param](/Functions/ImageFunction/flip_z)---which may be set in any combination.

### Image Dimensions

By default, the image actual physical dimensions are set to the dimensions of the mesh. However, it
is possible to set the dimensions of the image independently from using the `origin` and `dimensions`
input parameters.

This allows for flexibility to how the `ImageFunction` is utilized. For example, a mesh could be
defined to domain that is smaller than the actual image. Thus, if the `ImageFunction` dimensions are
set to the larger domain, the mesh would only sample some portion of the image. Effectively, this
feature can work on a cropped image, without needing to create a separate cropped image.


### Supported File Types id=file-types

Currently, two types of files are supported \*.tif and \*.png. However, \*.tif files often do not
read correctly with VTK, depending on the format of the file. So, if you experience problems reading
\*.tif files it may require changing the format to \*.png. This can easily be done with any number of
tools with [ImageMagick](http://www.imagemagick.org) being one of the most powerful.






## LinearCombinationFunction


### Example input syntax

In this input file, we show how a `LinearCombinationFunction` may be used to combine
a variety of different functions, then compare the results to a manually computed
linear combination.





## ParsedFunction


### Description

The `ParsedFunction` function takes a mathematical expression in [!param](/Functions/ParsedFunction/expression).  The
expression can be a function of time (t) or coordinate (x, y, or z).  The expression
can include common mathematical functions.  Examples include `4e4+1e2*t`,
`sqrt(x*x+y*y+z*z)`, and `if(t<=1.0, 0.1*t, (1.0+0.1)*cos(pi/2*(t-1.0)) - 1.0)`.

Additional variables may be declared in the [!param](/Functions/ParsedFunction/symbol_names) parameter vector. The
corresponding [!param](/Functions/ParsedFunction/symbol_values) parameter vector should list the items these variables are
bound to. Variables can be bound to:

- Constant number literals (for example `symbol_names = kB` and `symbol_values = 8.61733e-5`)
- A PostProcessor name (providing the value from the PP's last execution)
- A Function name (providing an immediate evaluation of the specified function)
- A scalar variable name


Further information can be found at the
[function parser site](http://warp.povusers.org/FunctionParser/).

Note that if this function is used for any residual contribution, inclusion of
scalar variables in the `expression` parameter will result in missing Jacobian
contributions, even if using [Automatic differentiation](automatic differentiation/index.md),
since `Function`s can currently only return `Real` values, not `ADReal` values.

### Example Input Syntax





## ParsedGradFunction


The `ParsedGradFunction` is similar to the [MooseParsedFunction.md], differing only in that
it also defines the gradient of the function. Inputs for defining each component of
the gradient follow the same rules as outlined in [MooseParsedFunction.md].

### Example input syntax

In this input, the `ParsedGradFunction` is used for using the
[Method of Manufactured Solutions](python/mms.md optional=true). This method verifies the
convergence of the finite element method to known analytical solutions of a simple problem.
`u_func` is used in the `PostProcessors` block to compute the H1 error, or the error on both
the solution and its gradient, between `u` and this known solution.





## ParsedVectorFunction


The `ParsedVectorFunction` is a vectorized version of the [MooseParsedFunction.md].
The vector components, the curl and the divergence of the function may be specified.
The inputs for the components of the vector, the curl and the divergence of the
function follow the same rules as outlined for the [MooseParsedFunction.md].

### Example input syntax

In this example, a `ParsedVectorFunction` is used to define a curl boundary condition.
Both x,y component and the z-curl are set for this function.





## PeriodicFunction


### Description

The `PeriodicFunction` takes a user-supplied base function, and periodically
repeats that function in time or any of the three Cartesian coordinate
directions. The function can be repeated in any combination of these directions
or time.

The resulting function repeats the base function's
behavior over the interval from 0 to the specified period in a given dimension.
This is repeated indefinitely, and is also repeated (rather than mirrored)
for negative values of the coordinates or time.

### Example Input Syntax





## PiecewiseBilinear


### Description

The `PiecewiseBilinear` function reads a csv file and interpolates values based on the
data in the file.  The interpolation is based on x-y pairs.  If `axis` is given, time is
used as the y index.  Either `xaxis` or `yaxis` or both may be given.  Time is used as
the other index if one of them is not given.  If `radius` is given, `xaxis` and `yaxis`
are used to orient a cylindrical coordinate system, and the x-y pair used in the query
will be the radial coordinate and time.

The csv file `data_file` format expected is:

- first line holds the `x` values.
- each subsequent line holds the `y` value then the list of `z` values for this `y` and
  all values of `x`.

The csv file `data_file` may be substituted by specifying the `x`, `y` and `z` parameters.

### Example Input Syntax





## PiecewiseConstant


### Description

The `PiecewiseConstant` function defines the data using a set of x-y data pairs.  Instead
of linearly interpolating between the values, however, the `PiecewiseConstant` function
is constant when the abscissa is between the values provided by the user.  The `direction`
parameter controls whether the function takes the value of the abscissa of the
user-provided point to the `right` or `left` value at which the function is evaluated.
Also available is `right_inclusive` and `left_inclusive` options, which will return the value
of the function at the specified abscissa.

                    {'x':[-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10], 'y':[8,8,8,8,6,4,4,4,4,2,2,2,2,2,2,2,4,6,8,8,8], 'name':'left_inclusive', 'marker':{'size':8}, 'mode': 'lines+markers'},
                    {'x':[-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10], 'y':[8,8,8,6,4,2,2,2,2,2,2,2,4,4,4,4,6,8,8,8,8], 'name':'right', 'marker':{'size':6}, 'mode': 'lines+markers'},
                    {'x':[-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10], 'y':[8,8,6,4,4,2,2,2,2,2,2,2,2,4,4,4,6,6,8,8,8], 'name':'right_inclusive', 'marker':{'size':4}, 'mode': 'lines+markers'},
                    {'x':[-8,-7,-5.5,-2,2,5.5,7,8], 'y':[8,6,4,2,2,4,6,8], 'name':'input', 'marker':{'size':12}, 'mode': 'markers'}]
                    layout={'xaxis':{'title':'Time'},
                            'yaxis':{'title':'Function Value'},
                            'title':'PiecewiseConstant Function options'}




### Example Input Syntax





## PiecewiseConstantFromCSV


### Description

The `PiecewiseConstantFromCSV` function is used to load data from a CSV file into a function. The
[PropertyReadFile.md] user object takes care of reading the CSV file, and the function queries
information from it.

It can assume CSV data

- is sorted by element-id, in which case, when the function is evaluated at a point, it will locate the element containing it then return the value for that element in the CSV file
- is sorted by node-id, in which case, when the function is evaluated at a point, it will locate the node at that point then return the value for that node in the CSV file
- is sorted by blocks, in which case, when the function is evaluated at a point, it will locate the element containing it then return the value for that element's block in the CSV file
- defines an interpolation grid, with the voronoi [!param](/Functions/PiecewiseConstantFromCSV/read_type), in which case the function will locate the closest point in that interpolation grid, then return the value for that point in the CSV file


For the latter case, the first three columns of the CSV data must define the coordinates of each point forming the interpolation grid. The [!param](/Functions/PiecewiseConstantFromCSV/column_number) parameter should still match the actual column number in the CSV file, so it likely should be larger than 3 (the number of columns for voronoi centers coordinates).

When use data by block or by element, if there is multiple possibilities for the element to choose from, for example at a node,
the element with the lowest ID will be used.

The [!param](/Functions/PiecewiseConstantFromCSV/column_number) parameter assumes 0-based indexing of the columns in the CSV file. If you want the values from the leftmost column in the file, you must use a column number of `0`.

### Example Input Syntax

In this example, we display four options for using CSV data to compute a function over an unstructured mesh:

- the `element` Function, using the `reader_element` user object, assumes the CSV file is sorted by element ID, and returns the value of the element containing each point
- the `node` Function, using the `reader_node` user object, assumes the CSV file is sorted by node ID, and returns the corresponding value at those nodes. Outside of these nodes, the function is currently set to error.
- the `nearest` Function, using the `reader_nearest` user object, finds the closest point defined in the CSV file, and returns the corresponding value
- the `block` Function, using the `reader_block` user object, assumes the data in the CSV file is sorted by block, and returns the value corresponding to the block containing each point



### Other functions which may read data from CSV

These functions read spatial data from CSV, e.g. data that is sorted by location not node, element or block.

- [PiecewiseConstant.md] (1D or time dependence)
- [PiecewiseLinear.md] and [CoarsenedPiecewiseLinear.md] (1D or time dependence)
- [PiecewiseBilinear.md] (2D)
- [PiecewiseMulticonstant.md] (1D to 4D)
- [PiecewiseMultilinear.md] (1D to 4D)
- [Axisymmetric2D3DSolutionFunction.md]




## PiecewiseLinear


### Description

The `PiecewiseLinear` function performs linear interpolations between user-provided
pairs of x-y data.  The x-y data can be provided in three ways. The first way is through
a combination of the `x` and `y` parameters, which are lists of the x and y coordinates
of the data points that make up the function.  The second way is in the `xy_data`
parameter, which is a list of pairs of x-y data that make up the points of the
function.  This allows for the function data to be specified in columns by inserting line
breaks after each x-y data point.  Finally, the x-y data can be provided in an external
file containing comma-separated values.  The file name is provided in `data_file`,
and the data can be provided in either rows (default) or columns, as specified in the
`format` parameter.

By default, the x-data corresponds to time, but this can be changed to correspond to x, y,
or z coordinate with the `axis` line.  If the function is queried outside of its range of
x data, it returns the y value associated with the closest x data point, unless
the parameter `extrap` is set to `true`, in which case extrapolation is performed instead.

### Example Input Syntax





## PiecewiseLinearFromVectorPostprocessor


### Description

The `PiecewiseLinearFromVectorPostprocessor` function performs linear interpolations between pairs of data generated by a vector post-processor object. The abscissa ([!param](/Functions/PiecewiseLinearFromVectorPostprocessor/argument_column)) and the ordinate ([!param](/Functions/PiecewiseLinearFromVectorPostprocessor/value_column)) values should correspond to the names of member vectors of the object specified for the [!param](/Functions/PiecewiseLinearFromVectorPostprocessor/vectorpostprocessor_name) parameter. By default, the abscissa values correspond to time, and the data will be interpolated at the actual simulation time-step values. However, it is possible to interpolate over spatial (x, y, or z) coordinates by specifying a direction with the [!param](/Functions/PiecewiseLinearFromVectorPostprocessor/component) parameter, where the inputs, `0`, `1`, and `2`, correspond to the `x`, `y`, and `z` directions, respectively.

### Example Input Syntax

In this example, three `PiecewiseLinearFromVectorPostprocessor`s are created and take data from three distinct
vector postprocessors. All three functions use a [!param](/Functions/PiecewiseLinearFromVectorPostprocessor/component)
parameter, which is set so they are functions of space rather than time (y for first two, x for the last one).





## PiecewiseMulticonstant

The `PiecewiseMulticonstant` function provides the capability of multi-dimensional
piecewise constant interpolation. The data is read from file provided in the
`data_file` argument. Interpolation axes can be a selection of one or multiple of
`x`, `y`, `z`, `t`, the number of interpolation axes is referred to as dimension
of the interpolation.

Formatting instructions for the `data_file` (reproduced from `data_file` docstring):
any empty line and any line
beginning with # are ignored, all other lines are assumed to contain relevant information.  
The file must begin with specification of the grid.  This is done through lines containing
the keywords: AXIS X; AXIS Y; AXIS Z; or AXIS T.  Immediately following the keyword line
must be a space-separated line of real numbers which define the grid along the specified
axis.  These data must be monotonically increasing.  After all the axes and their grids
have been specified, there must be a line that is DATA.  Following that line, function
values are given in the correct order (they may be on individual lines, or be
space-separated on a number of lines).  When the function is evaluated, f(i,j,k,l)
corresponds to the i + j*Ni + k*Ni*Nj + l*Ni*Nj*Nk data value.  Here i>=0 corresponding to
the index along the first AXIS, j>=0 corresponding to the index along the second AXIS, etc,
and Ni = number of grid points along the first AXIS, etc.

The `direction` parameter controls whether the function takes the value of the abscissa of the
user-provided point to the right or left of the value at which the function is evaluated.
A `direction` has to be provided for each dimension.






## PiecewiseMultilinear

The `PiecewiseMultilinear` function provides the capability of multi-dimensional
piecewise linear interpolation. The data is read from file provided in the
`data_file` argument. Interpolation axes can be a selection of one or multiple of
`x`, `y`, `z`, `t`, the number of interpolation axes is referred to as dimension
of the interpolation.

Formatting instructions for the `data_file` (reproduced from `data_file` docstring):
any empty line and any line
beginning with # are ignored, all other lines are assumed to contain relevant information.
The file must begin with specification of the grid.  This is done through lines containing
the keywords: AXIS X; AXIS Y; AXIS Z; or AXIS T.  Immediately following the keyword line
must be a space-separated line of real numbers which define the grid along the specified
axis.  These data must be monotonically increasing.  After all the axes and their grids
have been specified, there must be a line that is DATA.  Following that line, function
values are given in the correct order (they may be on individual lines, or be
space-separated on a number of lines).  When the function is evaluated, f(i,j,k,l)
corresponds to the i + j*Ni + k*Ni*Nj + l*Ni*Nj*Nk data value.  Here i>=0 corresponding to
the index along the first AXIS, j>=0 corresponding to the index along the second AXIS, etc,
and Ni = number of grid points along the first AXIS, etc.






## SolutionFunction


The solution is a `variable` in the file but the `SolutionFunction` makes it available
as a function. The [SolutionUserObject.md] specified as the `solution` parameter is used
to compute the variable values.

The accuracy on the evaluation of this variable in various locations may be diminished
by the solution file format. `Exodus` for example does not store higher order variables
accurately.

### Example input syntax

In this input file, we load in `u_xda_func` a reference solution for the problem, previously
computed and stored in `aux_nonlinear_solution_out_0001.xda`, then compare it to the current solution `u`.





## SplineFunction


The `SplineFunction` defines a 1D spline (1D shape, it is defined everywhere in the domain by translation)
along one of the x, y, z directions (specified by the `component` parameter). The spline is defined by

- its value (ordinates, `y`) at several abscissa (`x`) through which the function passes

- its first derivative at the first abscissa

- its first derivative at the last abscissa


From this information the spline is automatically generated. Both the first and second
order derivatives of the spline are defined.

### Example input syntax

In this example, we define a spline going through 4 points defined by the `x` and `y`
parameters.





# functormaterials

## FunctorADConverter


Converting from AD to regular functors or vice versa can both lead to irremediable loss of
derivative information when using the [automatic differentiation system](systems/NonlinearSystem.md#AD).
Missing derivative information (from using a converted regular functor where a true AD functor should have been used)
can lead to an imperfect Jacobian which can impact convergence properties of Newton solves.

Some examples of safe conversions:

- Functions to ADFunctions and vice-versa are safe since functions do not hold derivative data

- AuxVariables to regular functors is safe since auxiliary variables do not hold derivative data


### Example input syntax

An example of some gymnastics with functor conversions is shown in this example. The reader should note
that only the conversion to an AD functor from a regular functor (from a regular Function) was necessary.





## FunctorSmoother


Three heuristics have been implemented for smoothing a functor (or several). These heuristics have
only been implemented for the `ElemArg` functor argument. Functor arguments are explained in
the [Functor documentation](syntax/Functors/index.md).

- face averaging

The elemental value of the smoothed functor is equal to the arithmetic average of the values of the previous
functor on the faces of the element.

- neighbor averaging

The elemental value of the smoothed functor is equal to the arithmetic average of the values of the previous
functor at the neighbors of the element.

- checkerboard removing

The elemental value of the smoothed functor is equal to the average of the current functor element value and the two neighbor values
that are the furthest from the current functor element value.
The logic behind this heuristic is to average neighboring checkerboard values.

The value of the smoothed functor on elements can be visualized using a [FunctorAux.md].

No volume or area weighting is currently implemented in the `FunctorSmoother`. Feel free to experiment
with weighting schemes and make a contribution to MOOSE if they are valuable.




## GenericFunctorGradientMaterial


### Overview

This object creates
[vector functor material properties](Materials/index.md#functor-props) that are gradients of
other functors.

All AD-types of the properties defined in this material must match. Variables are automatically
considered as AD functors, even auxiliary variables. The AD version of this material is `ADGenericFunctorGradientMaterial`.
Its inputs are a vector of AD functors and it creates AD vector functor material properties.

### Example Input File Syntax

In this example, `ADGenericFunctorGradientMaterial` is used to compute the gradient of
the variable `u`, which is then multiplied by a diffusion coefficient to obtain the diffusive
flux. This flux is computed at the element centroids, not one the element faces.





## GenericFunctorMaterial


### Overview

This object creates
[functor material properties](Materials/index.md#functor-props), e.g. properties
that get evaluated on-the-fly, as opposed to traditional "static" material
properties, e.g. material properties that are pre-evaluated.

This class is the functor material property (combined) equivalent of
[GenericConstantMaterial.md], [GenericFunctionMaterial.md] and a `variable material`
(material that converts variables to material properties). It evaluates the functor at the requested location,
which can be the element centroid, an element face centroid, a quadrature point,
or any defined overload of the functor argument.

By default this class caches functor evaluations and clears the cache at the beginning
of every time step. Cache clearing behavior can be controlled by setting the `execute_on` parameter.

All AD-types of the properties defined in this material must match. Variables are automatically
considered as AD functors, even auxiliary variables. The AD version of this material is `ADGenericFunctorMaterial`.
Its inputs are a vector of AD functors and it creates AD functor material properties.

### Example Input File Syntax

In this example, `ADGenericFunctorMaterial` is used to define a linearly varying in space
diffusion coefficient for this finite volume diffusion calculation.
We add the prefix `AD` as this simulation is making use of automatic differentiation to compute the Jacobian exactly.
The diffusion coefficient is retrieved as a `Moose::Functor<ADReal>`, the base class
of `FunctorMaterialProperty<ADReal>`, by the diffusion kernel. The diffusion kernel can
then obtain the diffusion coefficient directly on the faces when evaluating the face flux.





## GenericFunctorTimeDerivativeMaterial


### Overview

This object creates [functor material properties](Materials/index.md#functor-props) that are time derivatives of
other functors.

Not all functors can be used as inputs. Many functors, notably off-the-shelf postprocessors do not compute
their time derivative by default. These time derivatives can be derived and implemented as the `dot` functor routine.
Unless this routine is implemented, these functors should not be used as inputs to this functor material.

Time derivatives are not available at all times during the simulation. Notably, on `INITIAL` and `TIMESTEP_BEGIN`,
the time derivatives are a priori NOT available, and any functor material properties created by this object will return 0.

The time derivative routine used by this functor, namely `functor.dot(spatial_argument, state_argument)`, is not implemented for
all spatial arguments and all state arguments for every single functor. Users must be extremely careful in their use
of the functors created by this functor material.

All AD-types of the properties defined in this material must match. Variables are automatically
considered as AD functors, even auxiliary variables. The AD version of this material is `ADGenericFunctorTimeDerivativeMaterial`.
Its inputs are a vector of AD functors and it creates AD functor material properties.




## GenericVectorFunctorMaterial


The functor system allows for using different functor types, functions, variables and
functor material properties for example, for each component X, Y and Z of the vector functor
material property.

This can be used to quickly create simple constant anisotropic functor material properties,
for testing, for initial survey of a problem or simply because the material
properties do not vary much over the domain explored by the simulation.

The non-functor equivalents of this material are [GenericConstantVectorMaterial.md] for
constant values and [GenericFunctionVectorMaterial.md] for functions.

By default this class caches function evaluations
and clears the cache at the beginning of every time step. Cache clearing behavior can be
controlled by setting the `execute_on` parameter.

Variables are automatically considered as AD functors, even
auxiliary variables. The AD version of this material is `ADGenericVectorFunctorMaterial`.
It creates AD vector functor material properties.

### Example Input File Syntax

In this example, we create a `GenericVectorFunctorMaterial` to generate an
anisotropic vector diffusivity and then compute the integral of the diffusive
flux through a specified boundary on the mesh.


In this example, we create a `GenericVectorFunctorMaterial` for two
anisotropic friction factors in a porous media flow simulation.  Note the syntax
for declaring two material properties and their values in the same material.





## ParsedFunctorMaterial

This [functor material](/FunctorMaterials/index.md) computes a functor material
property using a mathematical expression provided by a string. The expression
may operate on any of the following values:

- the spatial point, provided by `x`, `y`, and `z`,
- the time, provided by `t`, and
- any [functor](/Functors/index.md).

### Usage

This functor material creates a functor material property with the name given
by [!param](/FunctorMaterials/ParsedFunctorMaterial/property_name).

The mathematical expression is provided via [!param](/FunctorMaterials/ParsedFunctorMaterial/expression).

Functors used in this expression are provided via [!param](/FunctorMaterials/ParsedFunctorMaterial/functor_names).
These functors can optionally be assigned alternate (usually simpler) names
for use in the expression by providing [!param](/FunctorMaterials/ParsedFunctorMaterial/functor_symbols).
Otherwise their names are used directly in the expression.

For more information on the mathematical operators that can be used in the
expression, see the [function parser site](http://warp.povusers.org/FunctionParser/).




## PiecewiseByBlockFunctorMaterial ADPiecewiseByBlockFunctorMaterial


### Overview

This object is useful for providing a material property value that is discontinuous from
subdomain to subdomain. [!param](/FunctorMaterials/PiecewiseByBlockFunctorMaterial/prop_name) is
required to specify the name of the material property. The map parameter
[!param](/FunctorMaterials/PiecewiseByBlockFunctorMaterial/subdomain_to_prop_value)
is used for specifying the property value on a subdomain name basis; the first member of each pair should
be a subdomain name while the second member should be a functor.

This material is a shorthand for specifying [GenericFunctorMaterial.md] restricted
to each block.

ADPiecewiseByBlockFunctorMaterial is the version of this object with automatic differentiation
AD functors must be specified as the values on each block.




## PiecewiseByBlockVectorFunctorMaterial ADPiecewiseByBlockVectorFunctorMaterial


### Overview

This object is useful for providing a material property vector value that is discontinuous from
subdomain to subdomain. [!param](/FunctorMaterials/PiecewiseByBlockVectorFunctorMaterial/prop_name) is
required to specify the name of the material vector property. The map parameter
[!param](/FunctorMaterials/PiecewiseByBlockVectorFunctorMaterial/subdomain_to_prop_value)
is used for specifying the property vector value on a subdomain name basis; the first member of each pair should
be a subdomain name while the second member should be a vector functor.

ADPiecewiseByBlockVectorFunctorMaterial is the version of this object with automatic differentiation.
AD vector functors must be specified as the values on each block.




## VectorMagnitudeFunctorMaterial


### Overview

This class either takes 1-3 scalar-valued (e.g. `Real`, `ADReal`) functors or a
single vector functor and creates a functor that returns the Euclidean norm of
the input. For creating a `Real`-returning functor that takes in `Real` input,
use the `VectorMagnitudeFunctorMaterial` type in the input file. For a
`ADReal`-returning functor that takes in `ADReal` input, use
`ADVectorMagnitudeFunctorMaterial`. If using component inputs and the y or
z-component functor parameters are not provided, then they are defaulted to 0.

### Example Input File Syntax

#### Scalar-component inputs

In this example, `ADVectorMagnitudeFunctorMaterial` is used to define the vector
magnitude of the vector component inputs `u` and `v` which happen to be
nonlinear variables in this case. `u` varies from 0 to 1 from bottom to top and
`v` varies from 0 to 1 from left to right, such that the magnitude field is
symmetric about the line y=x with the field value increasing moving to the top-right.


#### Vector input

In this example, the functor provided by `ADVectorMagnitudeFunctorMaterial`
(which we name `mat_mag` to avoid collision with the auxiliary variable `mag`)
computes the norm of the vector functor `u`, which is a nonlinear variable in
this simulation.





# fvbcs

## FVBoundaryIntegralValueConstraint

This object implements the residuals that enforce the constraint

\int_{\partial \Omega} \phi = \int_{\partial \Omega} \phi_0

using a Lagrange multiplier approach. E.g. this object enforces the constraint that the average
value of $\phi$ match $\phi_0$ on the prescribed `boundary` (denoted by $\partial \Omega$ in the
equation above). This object is the boundary version of the volumetric object
[FVIntegralValueConstraint.md].

The contribution to the diagonal of the system of this kernel is null, which introduces a saddle
point. Make sure to use a `NONZERO` shift in your preconditioner.

### Example input syntax

In this example, the average value of the variable `v` is set on the `right`
boundary using a `FVBoundaryIntegralValueConstraint`.
In combination with a single Dirichlet boundary condition on the `left` boundary, this makes the numerical problem accept a
single numerical solution, and be well-posed.





## FVConstantScalarOutflowBC


The scalar field is advected at a constant velocity. This boundary condition is used
in the equation solving for the scalar field. It is only to be defined on boundaries
that are downstream of the advecting velocity.

The order of accuracy of this boundary condition will depend on the interpolation method
for the boundary value chosen for the variable. Currently, second order accuracy may
be obtained by specifying `two_term_boundary_expansion = true` in the variable definition.

This boundary condition assumes a constant velocity, so it may not be used in flow simulations
where the velocity is a variable, such as in the Navier Stokes module.

### Example input syntax

In this example, the `v` field is advected by a `1 0.5 0` velocity in the 2D plane. The
boundary condition for outflow is only defined on the boundaries that are downstream of
this velocity: `right` and `top`.





## FVDirichletBC


### Overview

Dirichlet boundary conditions impose the boundary condition $u=g$, where $g$ is a constant. This boundary condition is imposed weakly, through the value of the
flux.

Note that an upwinding scheme that may be used by flux kernels will affect how the Dirichlet value is applied to the interface. Upwinding schemes can result in the boundary solution being different than the specified Dirichlet value. In order to
obtain the desired boundary value, it is necessary to use a FVNeumannBC to specify
the flux.




## FVFunctionDirichletBC


### Overview

`FVFunctionDirichletBC` is very similar to [/FVDirichletBC.md] except the
parameter `value` is replaced by the `function` parameter, where the latter is a
`FunctionName` or alternatively a direct input of a parsed
function. `FVFunctionDirichletBC` is generally useful; it's critical for
implementing MMS studies.

### Example Input File Syntax





## FVFunctionNeumannBC


### Overview

This object is equivalent to [FVNeumannBC.md] with the exception that the
constant `value` parameter is replaced by the `function` parameter.




## FVFunctorDirichletBC

### Description

`FVFunctorDirichletBC` will specify the value of a field at the boundary.
The value will be determined by a `Functor`.

This boundary condition will only accept regular functors. ADFunctors (such as variables) must be
converted to regular functors using a [FunctorADConverter.md].

### Example Syntax

In this example the functor, a constant value of 10, is defined using a [GenericFunctorMaterial.md].






## FVFunctorNeumannBC


## Description

This object is equivalent to [FVNeumannBC.md] with the exception that the
constant `value` parameter is replaced by the `functor` parameter.
The `functor` may be a variable, a function or a functor material property.





## FVNeumannBC


### Overview

A `FVNeumannBC` may be used to specify a diffusive or an advective flux. For example,
to specify a flux boundary condition in the following diffusion problem,
a `FVNeumannBC` with a constant value of $g$ may be used.

\begin{equation}
\begin{aligned}
  -\nabla^2 u(\mathbf{M}) &= f(\mathbf{M}) && \forall \mathbf{M} \in \Omega & (1)\\
  \frac{\partial u}{\partial n}(\mathbf{M}) &= g && \forall \mathbf{M} \in \partial \Omega_N & (2) \\
  u(\mathbf{M}) &= 1 && \forall \mathbf{M} \in \partial \Omega_D & (3)
\end{aligned}
\end{equation}

where $\Omega \subset \mathbb{R}^n$ is the domain, $\partial
\Omega = \partial \Omega_D \cup \partial \Omega_N$ is its boundary, and $\mathbf{M}$ is
a point on the domain or its boundary. In this case, a `FVNeumannBC` object is used to impose
the condition (2) on the subset of the boundary denoted by $\partial \Omega_D$. In this case, the
`value` field corresponds to the constant $g$, and the user must define one
or more sidesets corresponding to the boundary $\partial \Omega_D$ to pass to the `boundary` argument.
For this particular problem, an additional boundary condition, for example a
`FVDirichletBC` as in (3) would also be necessary to remove the nullspace.

Likewise, to specify an advective flux of constant value $g$ in a 1D advection
problem with an advective velocity $v$:

\begin{equation}
\begin{aligned}
  \frac{\partial u}{\partial t}(\mathbf{M}) + v \frac{\partial u}{\partial x}(\mathbf{M}) &= 0 && \forall \mathbf{M} \in \Omega & (1)\\
  v u(\mathbf{M}) &= g v && \forall \mathbf{M} \in \partial \Omega & (2)
\end{aligned}
\end{equation}

The advective flux, the `value` to specify to the boundary condition (2), is $g v$.


Modeling a multi-dimensional problem will require a `FVNeumannBC` per component.

When using the Navier Stokes module, `FVNeumannBC` may not be available for use with velocity
and pressure, as additional information is required on either the gradient or direction of
these variables to model fully developed flow for example. Specific boundary conditions are
provided, see for example `INSFVOutletPressureBC`.




## FVOrthogonalBoundaryDiffusion


### Overview

This object implements a boundary flux equivalent to

\begin{equation}
-D \frac{u_b - u_C}{\vert \bm{d}_{Cf}\vert}
\end{equation}

where $D$ is a diffusion coefficient, $u_b$ is a boundary value computed through
the provided function parameter `function`, $u_C$ is the value of the diffusing
quantity at the neighboring cell centroid $C$, and $\bm{d}_{Cf}$ is the distance
vector drawn from the cell centroid to the boundary face centroid.




## FVPostprocessorDirichletBC

### Description

`FVPostprocessorDirichletBC` will specify the value of a field at the boundary.
The value will be determined by a `Postprocessor`

### Example Syntax






# fvics

## FVConstantIC


Sets a constant initial condition described by parameter [!param](/FVICs/FVConstantIC/value). It can be restricted to particular blocks using the [!param](/FVICs/FVConstantIC/block) parameter.

### Example input syntax

In this example, a blockwise constant initial condition is set for variable `u`.
Block 1 and 2 are set differently by two `FVConstantIC` objects.





## FVFunctionIC


Sets an initial condition via a [Function](syntax/Functions/index.md) described by parameter [!param](/FVICs/FVFunctionIC/function). It can be restricted to particular blocks using the [!param](/FVICs/FVFunctionIC/block) parameter.

### Example input syntax

In this example, we set the initial value of variable `u` using a [MooseParsedFunction.md].





# fviks

## FVDiffusionInterface


The diffusive flux is obtained from a two point gradient, and the diffusivity is
interpolated to the interface.

This kernel supports interfaces between variables which belong to different nonlinear systems.
For instructions on how to set these cases up, visit the [FVInterfaceKernels syntax page](syntax/FVInterfaceKernels/index.md).

### Example input file syntax

In this example, two diffusion problems with a source terms are solved on each side
of the interface, and heat is exchanged by diffusion at the interface using the average
of the volumetric diffusivities as the interface diffusion coefficient.





## FVOneVarDiffusionInterface


This class is only meant to be used with a single variable, e.g. the `variable1`
parameter should be provided but not `variable2`. `coeff1` should correspond to
the diffusion or conductivity coefficient on the `subdomain1` side of the
`boundary` while `coeff2` corresponds to `subdomain2`. The gradient of
`variable1` is based on Green-Gauss computations of the gradient at the
adjoining element centroids followed by linear interpolation to the face plus a
non-orthogonal correction. The diffusion/conductivity coefficient at the
interface is computed using linear interpolation of the `coeff1` and `coeff2`
values. This discretization scheme is O(h) accurate.

### Example input file syntax





## FVScalarLagrangeMultiplierInterface

This class should be inherited to create interface constraints in finite volume.
A Lagrange multiplier, a scalar variable, is used to enforce the constraint on the interface.

Lagrange multipliers do not contribute to the diagonal of the residual, which can hurt
numerical convergence for some linear solvers. For the `lu` (sub-)preconditioner, make sure to use a
`NONZERO` `(sub_)pc_factor_shift_type`.

`kernel_coverage_check`, a parameter in the `[Problem]` block, should be set to false, as
the Lagrange multiplier variable is a variable that is not found on any block, only on
the interface.

## FVTwoVarContinuityConstraint


The constraint is enforced using a Lagrange multiplier variable.

Lagrange multipliers do not contribute to the diagonal of the residual, which can hurt
numerical convergence for some linear solvers. For the `lu` (sub-)preconditioner, make sure to use a
`NONZERO` `(sub_)pc_factor_shift_type`.

`kernel_coverage_check`, a parameter in the `[Problem]` block, should be set to false, as
the Lagrange multiplier variable is a variable that is not found on any block, only on
the interface.

### Example input file syntax

In this example, we solve two diffusion problems in two adjacent subdomains and force
continuity at the interface, recovering the expected solution of a diffusion problem
spanning the entire domain.





# fvkernels

## FVAdvection


The `FVAdvection` kernel implements an advection term given for the domain ($\Omega$) defined as

\underbrace{\vec{v} \cdot \nabla u} + \sum_{i=1}^n \beta_i = 0 \in \Omega,

where $u$ is the advected quantity, the `variable` for this kernel, $v$ is the constant advecting velocity,
the `velocity` parameter of this kernel, and the $\beta_i$ are the contribution to the residual
of other kernels.

This volumetric term is transformed using the divergence theorem into a surface integral, computed
as a sum over each face of the advective flux. This is preferred over computing a volumetric gradient
as conservative advection is naturally achieved.

\int_{element} \vec{v} \cdot \nabla u = \sum_{elem faces f} u_f \vec{v} \cdot n_f v area_f

The advected quantity is evaluated on the face using an `advected_interp(olation)_method`.
Two methods are available:

- `average` for a geometrically weighted average between the element and neighbor values

- `upwind` for a first order upwind scheme, which uses the value from the centroid of the
  element situated upwind of the face, using velocity as the wind


This kernel leverages the automatic differentiation system, so the Jacobian is
computed at the same time as the residual and need not be defined separately.

### Boundary conditions for pure advection

Advection problems, with a constant advecting velocity, should have two types of boundary conditions: inflow and outflow.
The inflow boundary conditions may be specified as a constant boundary value with a [FVDirichletBC.md] (with caveats, see
documentation)


The outflow boundary conditions may be specified with a [FVConstantScalarOutflowBC.md].


If no boundary conditions are specified, then there is a zero advective flux through the boundary, also
known a no-penetration boundary condition.

The `FVAdvection` kernel may be executed on boundaries using the `force_boundary_execution`
and `boundaries_to_force` parameters, however this is somewhat situational / not for mainstream use.

### Example input syntax

In this example, a simple time-dependent advection problem is solved, with a constant advecting velocity of
`1 0.5 0`.





## FVAnisotropicDiffusion


An anisotropic diffusion term that is discretized using the finite-volume method:

- \nabla \cdot \mathbf{k} \nabla \phi,

where $\mathbf{k}$ is the diagonal tensor diffusion coefficient and $\phi$
is the diffusing variable. The discretized form of the equation above
over en element is the following:

- \sum\limits_f \mathbf{k}_f (\nabla \phi)_f \mathbf{S}_f

where $\mathbf{S}_f$ denotes the surface vector of face $f$ of the element.
Furthermore, the face gradient, (\nabla \phi)_f, is determined using a
central difference scheme combined with non-orthogonal correction.
Lastly, components of the diffusion (diagonal) tensor can be
either interpolated to the face using a geometric arithmetic average:

(k_i)_f = g (k_i)_C + (1 - g) (k_i)_N,

or a harmonic average:

1 / (k_i)_f = g / (k_i)_C + (1 - g) / (k_i)_N,

where $g$ is the interpolation weight, and subscripts $C$ and $N$ represent
element and neighbor values.





## FVBodyForce

### Description

`FVBodyForce` implements a force term in momentum transport or structural
mechanics or a source term in species/mass transport. The strong form, given a
domain $\Omega$ is defined as

\begin{equation}
\underbrace{-f}_{\textrm{FVBodyForce}} + \sum_{i=1}^n \beta_i = 0 \in \Omega
\end{equation}
where $f$ is the source term (negative if a sink) and the second term on the
left hand side represents the strong forms of other kernels.

The Jacobian term for this kernel is zero: $\frac{\partial R_i(u_h)}{\partial u_j} = 0$, since
it is assumed that $f$ +is not+ a function of the unknown $u$.

The force is constructed through a user supplied constant $c$,
[function](/Functions/index.md) value evaluated at the current time and
quadrature point $f$, and/or [postprocessor](/Postprocessors/index.md)
value $p$. The constant $c$, supplied through the parameter `value`, may also be
controlled over the course of a transient simulation with a
[`Controls`](/Controls/index.md) block.  $c$, $f$, $p$ are supplied
through the input parameters `value`, `function`, and `postprocessor`
respectively. Not supplying $c$, $f$, or $p$ through its corresponding
parameter is equivalent to setting its value to unity.

### Example Syntax

The case below demonstrates the use of `FVBodyForce` where the force term is
supplied based upon a function form:





## FVBoundedValueConstraint

This object implements the residuals that enforce the constraint

\phi > \phi_0 \in \Omega

or

\phi < \phi_0 \in \Omega

using a Lagrange multiplier approach. E.g. this object enforces the constraint
that the value of $\phi$ in the domain has to be above or below a certain value.

The contribution to the diagonal of the system of this kernel is null, which introduces a saddle
point. Make sure to use a `NONZERO` shift in your preconditioner.

### Example input syntax

In this example, the value of the variable `v` is forced to be positive using a `FVBoundedValueConstraint`.
This accelerates the convergence to the solution, as the initial condition is negative and the solution
is everywhere positive.





## FVCoupledForce

### Description

`FVCoupledForce` implements a source term within the domain $\Omega$ proportional to a coupled
variable:
\begin{equation}
\underbrace{-\sigma v}_{\textrm{FVCoupledForce}} + \sum_{i=1}^n \beta_i = 0 \in \Omega,
\end{equation}
where $\sigma$ is a known scalar coefficient, $v$ is a coupled unknown value, and the second term on
the left hand side corresponds to the strong forms of other kernels. In a species transport context,
the value $\sigma$ can be regarded as a reaction rate coefficient.

### Example Syntax





## FVDiffusion


The steady-state diffusion equation on a domain $\Omega$ is defined as

-\nabla \cdot D \nabla u = 0 \in \Omega.

with $D$ the diffusion coefficient or diffusivity. $D$ has to be supplied as material property
to this kernel.

The diffusion term is integrated using the divergence theorem, turning it from a volumetric second
order derivative term into a first order derivative integrated over a surface.

\int_{element} -\nabla \cdot D \nabla u = \sum_{elem faces f} -D_f \nabla u_f \cdot \vec{n_f} area_f

where $\vec{n_f}$ is the surface normal on each side of the element considered.

The diffusion coefficient can be interpolated to the surface using two approaches:

- +Simple arithmetic average:+ $D_f = w_1 D_1 + (1-w_1) D_2$ (with $D_1$, $D_2$ being the diffusion
  coefficient in the neighboring cells respectively)
- +Simple harmonic average:+ $D_f = \frac{1}{\frac{w_1}{D_1} + \frac{1 - w_1}{D_2}}$, which yields better results
  if the diffusion coefficients are positive and discontinuous. This is due to the fact that this scheme preserves
  flux continuity in the face-normal direction on orthogonal grids.

The interpolation method can be set using the [!param](/FVKernels/FVDiffusion/coeff_interp_method) parameter,
and is defaulted to `harmonic` due to its superior accuracy for discontinuous diffusion coefficients.
Simple tests cases with discontinuous diffusion coefficients (see below)
indicate that using harmonic interpolation yields a second-order accurate
scheme for orthogonal and 1D meshes and close to second-order accurate scheme for slightly
non-orthogonal meshes. At the same time, using a simple arithmetic average for the interpolation of
discontinuous diffusion coefficients yields a first order scheme.

This kernel leverages the automatic differentiation system, so the Jacobian is
computed at the same time as the residual and need not be defined separately.

### Example input syntax

This example shows a simple 1D diffusion problem with two variables defined on two subdomains.
Because of the limits of the legacy material system, the two material properties have to have different
names, otherwise it is not clear what the boundary value of the diffusion coefficient should be.





## FVDivergence


### Overview

The integral of the divergence operator acting on a vector field $\vec{u}$ in a finite volume
setting can be approximated as follows:

\int_{element} \nabla \cdot \vec{u} \approx \sum_\text{elem faces f} \vec{u}_f \cdot \vec{n_f} area_f

where $\vec{n_f}$ is the surface normal on each side of the element considered.




## FVFunctorTimeKernel


The user may provide the `functor` parameter from which to query the time
derivative. If the `functor` parameter is not provided, then the variable that
this kernel acts on will be the functor used. The time derivative is
automatically computed for nonlinear and auxiliary variables based on the
[time integration scheme selected](syntax/Executioner/TimeIntegrator/index.md). Time
derivatives of `Function/ADFunction` functors are computed using those objects
`timeDerivative` APIs. Time derivatives of functor material properties are not
yet implemented. This class should be used in finite volume simulations which
leverage the
[on-the-fly functor evaluation system](Materials/index.md#functor-props), which
includes incompressible and weakly compressible Navier-Stokes simulations.

When creating a new time derivative kernel, developers should consider inheriting this class
as it provides the matrix/vector time tags. If not, those should be added in the `validParams()`
routine of the new class.

### Example input syntax

In this example, the variable `v` is the solution of a simple time-dependent diffusion
problem. The time derivative term of the equation is added to the numerical system using
a `FVFunctorTimeKernel`.





## FVIntegralValueConstraint

This object implements the residuals that enforce the constraint

\int_{\Omega} \phi = \int_{\Omega} \phi_0

using a Lagrange multiplier approach. E.g. this object enforces the constraint
that the average value of $\phi$ match $\phi_0$.

The detailed description of the derivation for the corresponding finite element
constraint can be found at
[scalar_constraint_kernel](https://github.com/idaholab/large_media/blob/master/framework/scalar_constraint_kernel.pdf). The
finite volume version can be obtained by simply substituting $1$ for
$\varphi$. Note that $\int \phi_0 = V_0$.

The contribution to the diagonal of the system of this kernel is null, which introduces a saddle
point. Make sure to use a `NONZERO` shift in your preconditioner.

### Example input syntax

In this example, the average value of the variable `v` is set using a `FVIntegralValueConstraint`.
In combination with a single Dirichlet boundary condition, this makes the numerical problem accept a
single numerical solution, and be well-posed.





## FVMassMatrix

This object is meant to build mass matrices for preconditioning techniques that
require them. It is only meant for filling matrices, so all vector tag
parameters are suppressed. The [!param](/FVKernels/FVMassMatrix/matrix_tags)
parameter default is cleared such that the user should provide some non-empty
parameter value for [!param](/FVKernels/FVMassMatrix/matrix_tags) or
[!param](/FVKernels/FVMassMatrix/extra_matrix_tags).




## FVMatAdvection


The `FVMatAdvection` kernel is similar to the [FVAdvection.md] kernel except that:

- the velocity is a material property instead of a constant vector, so it may vary throughout the domain

- an advected quantity


In order to solve for the velocity, one needs to add a `VariableMaterial`, such as the
[`INSFVMaterial`](modules/navier_stokes/doc/content/source/materials/INSFVMaterial.md optional=True)
to store a copy of the velocity variable as a material property.

As we are expanding the functor material & variable capability, having the velocity as a material
property will no longer be required.

### Example input syntax

In this example, the kernels are set up for a steady state advection problem of both
momentum and mass. For the former the `advected_quantity` is set to the momentum. This
case uses a constant unit density. Please refer to the Navier Stokes module for more advanced
fluid flow capabilities.





## FVOrthogonalDiffusion


### Overview

This object implements an intercell flux equivalent to

\begin{equation}
-D \frac{u_N - u_E}{\vert \bm{d}_{EN}\vert}
\end{equation}

where $D$ is a diffusion coefficient that is linearly interpolated between the
cell centroids $N$ and $E$ (denoting `neighbor` and `element` respectively),
$u_N$ is the value of the diffusion quantity at the `neighbor` cell centroid,
$u_E$ is the value of the diffusing quantity at the `element` cell
and $\bm{d}_{EN}$ is the distance vector drawn from the `element` centroid to
the `neighbor` centroid.




## FVPointValueConstraint

This object implements the residuals that enforce the constraint

\phi (point P) = \phi_0

using a Lagrange multiplier approach. E.g. this object enforces the constraint
that the value of $\phi$ in the element containing point $P$ match $\phi_0$.

The contribution to the diagonal of the system of this kernel is null, which introduces a saddle
point. Make sure to use a `NONZERO` shift in your preconditioner.

### Example input syntax

In this example, the value of the variable `v` at `0.2 0 0` is set using a `FVPointValueConstraint`.
In combination with a single Dirichlet boundary condition, this makes the numerical problem accept a
single numerical solution, and be well-posed.





## FVReaction

### Description

`FVReaction` implements a simple first-order reaction term where the rate of
reaction is directly proportional $\lambda u$ where $\lambda$ is the rate
coefficient and $u$ is the governing variable.

`FVReaction` can be used to help set-up variations of advection-diffusion-reaction
equations.

### Example Syntax

The syntax for `FVReaction` is simple, only taking the `type` and `variable`
parameters. An example block is shown below for a diffusion-reaction equation:





## FVScalarLagrangeMultiplierConstraint

This object is a base class for implementing variable value constraints using Lagrange multipliers.

The detailed description of the derivation for the corresponding finite element
constraint can be found at
[scalar_constraint_kernel](https://github.com/idaholab/large_media/blob/master/framework/scalar_constraint_kernel.pdf). The
finite volume version can be obtained by simply substituting $1$ for
$\varphi$.

The contribution to the diagonal of the system of this kernel is null, which introduces a saddle
point. Make sure to use a `NONZERO` shift in your preconditioner.

## FVTimeKernel


The time derivative is automatically computed based on the
[time integration scheme selected](syntax/Executioner/TimeIntegrator/index.md). This
class should be used in finite volume simulations which leverage the
quadrature-point pre-initialized paradigm, which includes fully compressible
Navier-Stokes simulations.

When creating a new time derivative kernel, developers should consider inheriting this class
as its provides the matrix/vector time tags. If not, those should be added in the `validParams()`
routine of the new class.

### Example input syntax

In this example, the
[Burger's equation](https://en.wikipedia.org/wiki/Burgers%27_equation) is solved
in one dimension. The time derivative term of the equation is added to the numerical system using
a `FVTimeKernel`.





# geomsearch

## GeometricSearchData

- Sometimes information needs to be exchanged between disconnected pieces of mesh.
- Examples include:
    - Mechanical Contact
    - Gap Heat Conduction
    - Radiation
    - Constraints
    - Mesh Tying
- The Geometric Search system allows an application to track evolving geometric relationships.
- Currently, this entails two main capabilities: [`NearestNodeLocator`](/NearestNodeLocator.md) and [`PenetrationLocator`](/PenetrationLocator.md).
- Both of the capabilities work in parallel and with both Parallel- and Serial-Mesh.
- Locators can be requested using four different methods on the `GeometricSearchData` API:
    - `getQuadraturePenetrationLocator`
    - `getPenetrationLocator`
    - `getQuadratureNearestNodeLocator`
    - `getNearestNodeLocator`
- The `*Quadrature*` based methods should be used within quadrature-point based objects like:
    - [`Materials`](Materials/index.md) e.g. the `HeatConduction` module's `GapConductance` object
    - [`IntegratedBCs`](syntax/BCs/index.md) e.g. the `HeatConduction` module's `GapHeatTransfer` object
    - [Elemental `AuxKernels`](AuxKernels/index.md) e.g. the elemental versions of [`GapValueAux`](/GapValueAux.md), [`NearestNodeDistanceAux`](/NearestNodeDistanceAux.md), and [`PenetrationAux`](/PenetrationAux.md)
- The non-quadrature based methods should be used for nodal objects such as:
    - [`NodeFaceConstraints`](Constraints/index.md) e.g. the `Contact` module's `MechanicalContactConstraint` object
    - [Nodal `AuxKernels`](AuxKernels/index.md) e.g. the nodal versions of [`GapValueAux`](/GapValueAux.md), [`NearestNodeDistanceAux`](/NearestNodeDistanceAux.md), and [`PenetrationAux`](/PenetrationAux.md)
- geometric search objects like [`NearestNodeLocator`](/NearestNodeLocator.md) and [`PenetrationLocator`](/PenetrationLocator.md) should hold to their geometric purpose and +not+ call algebraic APIs like `FEProblemBase::prepare` which will query `libMesh::DofObject` information. This information may or may not have been initialized at the time that geometric search objects are being updated, so any query attempt may result in failed assertions or segmentation faults.

## NearestNodeLocator

- NearestNodeLocator provides the nearest node on a "Primary" boundary for each node on a "Secondary" boundary (and the other way around).
- The distance between the two nodes is also provided.
- It works by generating a "Neighborhood" of nodes on the Primary side that are close to the Secondary node.
- The size of the Neighborhood can be controlled in the input file by setting the `patch_size` parameter in the `Mesh` section.


- To use a NearestNodeLocator
    - `#include "NearestNodeLocator.h"`
    - call `getNearestNodeLocator(primary_id, secondary_id)` to create the object.
- The functions `distance()` and `nearestNode()` both take a node ID and return either the distance to the nearest node or a `Node` pointer for the nearest node respectively.

## PenetrationLocator

- A PenetrationLocator provides the perpendicular distance from a Secondary node to a Primary side and the "contact point" on the Primary side.
- The distance returned is negative if penetration hasn't yet occurred and positive if it has.
- To get a NearestNodeLocator `#include "PenetrationLocator.h"` and call `getPenetrationLocator(primary_id, secondary_id)` to create the object.
- The algorithm in PenetrationLocator utilizes a [`NearestNodeLocator`](/NearestNodeLocator.md) so `patch_size` is still important.


# hdgbcs

## DiffusionHDGDirichletBC

This class has some conceptual similarities to [FunctionDirichletBC.md], however, the
Dirichlet condition described by
[!param](/HDGBCs/DiffusionHDGDirichletBC/functor) is
imposed weakly for a hybridized discontinuous Galerkin discretization instead of
strongly for a continuous Galerkin discretization. This boundary condition
should be paired with a [DiffusionHDGKernel.md].




## DiffusionHDGPrescribedGradientBC

In a hybridized discontinuous Galerkin (HDG) discretization, this class
prescribes the normal gradient

\begin{equation}
\vec{n} \cdot D \nabla u = D q_N
\end{equation}

where $q_N$ is the user-supplied normal gradient through
the [!param](/HDGBCs/DiffusionHDGPrescribedGradientBC/normal_gradient)
parameter. This boundary condition should be paired with a
[DiffusionHDGKernel.md].




# hdgkernels

## DiffusionHDGKernel

This class implements the same physics as [MatDiffusion.md] (see note) but with a
hybridized discontinuous Galerkin (HDG) discretization. For more information on
HDG for a Poisson problem, please see [!citep](cockburn2008superconvergent). The
weak forms implemented are a slight variation on the cited work in order to make
them directly usable in downstream physics such as Navier-Stokes.

\begin{equation}
(\vec{q}, \vec{v})_{\Omega_h} + (u, \nabla \cdot \vec{v})_{\Omega_h} - \langle \hat{u}, \vec{n}\cdot\vec{v}\rangle_{\partial\Omega_h} = 0\\
(D\vec{q}, \nabla\omega)_{\Omega_h} - \langle D\vec{q}\cdot\vec{n}, \omega\rangle_{\partial\Omega_h} + \langle \tau(u - \hat{u}\vec{n}\cdot\vec{n}), \omega\rangle_{\partial\Omega_h} = (f, \omega)_{\Omega_h}\\
-\langle D\vec{q}\cdot\vec{n}, \mu\rangle_{\partial\Omega_h} + \langle \tau(u - \hat{u})\vec{n}\cdot\vec{n}, \mu\rangle_{\partial\Omega_h} = -\langle Dq_N, \mu\rangle_{\partial\Omega_N}
\end{equation}

where $\vec{q}$ is the gradient field, $\vec{v}$ are its associated test
functions, $u$ is the scalar field, $\omega$ are its associated test functions,
$\hat{u}$ is the trace of the scalar field (lives on the mesh skeleton), $\mu$
are its associated test functions, $\tau$ is a stabilization parameter, $f$ is a
forcing function, $D$ is the diffusivity coefficient, and $q_N$ represents a
prescribed gradient on a Neumann boundary, $\partial\Omega_N$. As indicated by
the test functions, the first equation is the equation for the variable
$\vec{q}$, the second is for the variable $u$, and the third is for the trace or
Lagrange multiplier variable $\hat{u}$.

$\vec{q}$ (the gradient) and $u$ (the values) are referred to as the primal
variables. $\hat{u} is often referred to as the dual variable. Its equation is
the only one that requires the use of a linear solver. For more information on
HDG solves, see the [HDGKernels page](HDGKernels/index.md).

$f$ the forcing function can be used for method of manufactured solutions
studies, or as a source term for the diffused quantity.

Unlike MatDiffusion, the dependence of the diffusion coefficient on nonlinear variables is not captured in the construction of the Jacobian.




# ics

## ArrayConstantIC


All the components of the array variable must be specified simultaneously. This constant value may be set for the whole domain, for particular blocks, or on specified boundaries.

### Example input syntax

In this example, constant initial conditions are set for array variable `u` and auxiliary array variable `v` of size 2 and 8 respectively.





## ArrayFunctionIC


All the components of the array variable must be specified simultaneously.

### Example input syntax

In this example, initial conditions are set for array variable `u` and auxiliary array variable `v` of size 2 using two sinusoid functions.





## BoundingBoxIC

BoundingBoxIC allows setting the initial condition of a value inside and outside of a specified
box. The box is aligned with the x, y, z axes and is specified by passing in the x, y, z
coordinates of the bottom left point and the top right point. Each of the coordinates of the
"bottom_left" point MUST be less than those coordinates in the "top_right" point.

When setting the initial condition, if `bottom_left <= Point <= top_right` then the "inside" value is used.
Otherwise the "outside" value is used.

When using this IC, only a single bounding box my be specified within the domain. If multiple bounding
boxes are needed, this capability is implemented in the phase_field module as `MultiBoundingBoxIC`.

### Class Description






## ConstantIC


Sets a constant initial condition described by parameter [!param](/ICs/ConstantIC/value). It can be restricted to particular blocks and boundaries using the [!param](/ICs/ConstantIC/block) and [!param](/ICs/ConstantIC/boundary) parameters, respectively.

### Example input syntax

In this example, constant initial conditions are set for variable `u` and auxiliary array variable `u_aux`. The values of `u_aux` in block 1 and 2 are set differently by two `ConstantIC` objects.





## FunctionIC


Sets an initial condition via a [Function](syntax/Functions/index.md) described by parameter [!param](/ICs/FunctionIC/function). It can be restricted to particular blocks and boundaries using the [!param](/ICs/FunctionIC/block) and [!param](/ICs/FunctionIC/boundary) parameters, respectively.

To set a function initial condition that preserves an integral of that function, such as for setting a volumetric quantity (units/m$^3$) while satisfying a total volume-integral, see the [IntegralPreservingFunctionIC](/ics/IntegralPreservingFunctionIC.md).

### Example input syntax

In this example, we set the initial value of variable `u` using a [MooseParsedFunction.md]. This particular example shows that information about the gradient of the parsed function is kept in initial condition, using further mesh refinement.





## FunctionScalarIC


The function is evaluated at the simulation start time and at the point of coordinate (0, 0, 0).

### Example input syntax

In this example, the scalar variable `n`, solution of a first order ODE, is initialized using function `f`. Since the start time of the simulation is 0, `f` is evaluated to `cos(0)=1`.





## InitialCondition

Base class for defining field initial conditions.

## IntegralPreservingFunctionIC


### Description

Sets an initial condition while preserving an integral.
The [!param](/ICs/IntegralPreservingFunctionIC/function) is used to specify the overall "form" of the initial condition,
such that the applied initial condition is

\begin{equation}
\label{eq:ic1}
u(\vec{r}, t_0) = q_0 f(\vec{r}, t_0)
\end{equation}

where $u$ is the variable, $f$ is the function, and $q_0$ is a scaling
factor used to preserve a total [!param](/ICs/IntegralPreservingFunctionIC/magnitude) upon volume integration:

\begin{equation}
\label{eq:ic2}
q_0=\frac{Q}{\int_\Omega fd\Omega}
\end{equation}

where $Q$ is the total magnitude and $\Omega$ is the domain of integration.

### Example Input Syntax

As an example, below we set a sinusoidal heat source with generic form
$\sin{\left(\frac{\pi z}{H}\right)}$ for a total magnitude of 550 (upon volume
integration). This means that the actual initial condition is
$q_0\sin{\left(\frac{\pi z}{H}\right)}$, where $q_0$ is determined in order to
satisfy the specified total volume integral.

  start=ICs
  end=Executioner




## RandomIC

RandomIC initializes a variable using randomly generated numbers. These can either
follow a uniform distribution over a user-defined range (using the `min` and `max`
parameters), or follow an arbitrary distribution defined by a `Distribution` object
specified using the `distribution` parameter.  An initial seed value may be set with
the "seed" parameter. The RandomIC object produces a parallel agnostic random field.


### Class Description






## ScalarComponentIC


All components of the scalar variable must be set simultaneously.

### Example input syntax

In this example, the initial values of scalar variables `v` and `a`, both of size 2, are set using `ScalarComponentIC`.





## ScalarConstantIC





## ScalarInitialCondition

Base class for defining scalar initial conditions.

## ScalarSolutionIC


Because they are stored the same way in [Exodus.md] files, a postprocessor saved in the file
can also be used to restart a scalar variable.




## SolutionIC


The subdomains in the solution file must at least include all the subdomains this
initial condition is used on. Subdomains are matched using their name.




## VectorConstantIC

The `VectorConstantIC` class is used to set initial values of components of a
vector variable. The x component can be set through the `x_value` parameter, the
y component through `y_value`, and the z component through `z_value`. Note that
`x_value` is required. If `y_value` or `z_value` are not supplied, they are
defaulted to zero.





## VectorFunctionIC

The VectorFunctionIC allows the components of a vector variable to be defined using a
[Function](syntax/Functions/index.md) object. This function supplied requires that the
`vectorValue` method of the supplied function be defined, since this is used to populate the
vector variable.






# indicators

## AnalyticalIndicator


### Description

The AnalyticalIndicator object computes the difference between a solution variable and
a known function. As the name suggests it is designed for computing the analytical error, but in
practice this indicator is used for debugging and verification applications.

### Example Input File Syntax

The following example demonstrates the creation of an AnalyticalIndicator object within an input
file that uses a [MooseParsedFunction.md] object for computing the known solution.





## GradientJumpIndicator


### Description

The GradientJumpIndicator object computes the error as computed by the change in the
gradient of a variable across element interfaces.

### Example Input File Syntax

The following code snippet demonstrates the use of the GradientJumpIndicator object within a
typical input file.





## LaplacianJumpIndicator


### Description

The LaplacianJumpIndicator object computes the error as computed by the change in the
Laplacian of a variable across element interfaces.

The Laplacian ($\nabla^2 u$ or $\nabla\cdot\nabla u$) operator requires second derivatives with
respect to the spacial dimensions. As such, the selected finite elements must be at least
second order for the calculation to be valid.

### Example Input File Syntax

The following code snippet demonstrates the use of the LaplacianJumpIndicator object within a
typical input file.





## ValueJumpIndicator


### Description

`ValueJumpIndicator` is an error indicator which is appropriate for use with
discontinuous finite element discretizations. Similar to the `GradientJumpIndicator`,
it estimates the error on a given element by integrating the jump in the
chosen variable's value across the boundary with each of its face neighbors.




# interfacekernels

## ADMatInterfaceReaction

### Description

Specie M transports between two domains (domain 1 and domain 2), at the interface consider the following reaction is taking place:

\begin{equation}
M(1)\xrightleftharpoons[k_b]{k_f}M(2)
\end{equation}

With the first order reaction rate assuming a quasi-steady-state

\begin{equation}
\textrm{Reaction Rate} = \frac {\partial C_1} {\partial t} = k_f C_1 - k_b C_2 \approx 0
\end{equation}

where $C_1$ is the specie concentration in domain 1, $C_2$ is the specie concentration in domain 2, $k_f$ is the forward reaction coefficient, and $k_b$ is the backward reaction coefficient. `ADMatInterfaceReaction` object is used to impose this condition.

[InterfaceDiffusion.md] is also used in this case to control flux at the interface.

\begin{equation}
D_1 \frac {\partial C_1} {\partial n} = D_2 \frac {\partial C_2} {\partial n}
\end{equation}

However, the flux is not [well-defined](https://en.wikipedia.org/wiki/Well-defined_expression) across the interface. The `ADMatInterfaceReaction` interfacekernel applies a condition to constrain the potential discontinuity across the interface.

Both kernels at the interface work together to give full mathematical and physical meaning of the problem. Together, the implicit equations represented by `ADMatInterfaceReaction` and [InterfaceDiffusion.md] combine to provide the following relationship at the interface.

\begin{equation}
D_1 \frac {\partial C_1} {\partial n} = D_2 \frac {\partial C_2} {\partial n} + k_f C_1 - k_b C_2
\end{equation}

### Example Input Syntax





## InterfaceDiffusion

### Overview

That is a kernel that establishes flux equivalence on an interface as follows:
\begin{equation}
D \frac{\partial u}{ \partial n} = D_{neighbor} \frac{\partial u_{neighbor}}{ \partial n},
\end{equation}
where $D$ and $D_{neighbor}$ are material properties for the current element and the neighbor, respectively, and
$n$ is the outward normal vector from the current element.

This kernel should not be used as a
stand-alone interface condition because it does not enforce variable continuity. Instead, consider
combining this kernel with [MatchedValueBC.md] or other strong interface conditions.

### Example Input File Syntax





## InterfaceReaction

### Description

Specie M transports between two domains (domain 1 and domain 2), at the interface consider the following reaction is taking place:

\begin{equation}
M(1)\xrightleftharpoons[k_b]{k_f}M(2)
\end{equation}

With the first order reaction rate assuming a quasi-steady-state

\begin{equation}
Reaction Rate = \frac {\partial C_1} {\partial t} = k_f C_1 - k_b C_2 \approx 0
\end{equation}

where $C_1$ is the specie concentration in domain 1, $C_2$ is the specie concentration in domain 2, $k_f$ is the forward reaction coefficient, and $k_b$ is the backward reaction coefficient. `InterfaceReaction` object is used to impose this condition. Associated kernel is:

[/InterfaceReaction.C]

[/InterfaceReaction.h]

In addition, fluxes are matched from both domains, this could be achieved by  [`InterfaceDiffusion`](/InterfaceKernels/index.md). 

Both kernels at the interface work together to give full mathematical and physical meaning of the problem.

Two examples (steady-state and transient-state) are shown in the MOOSE test directory, 

[1d_interface/reaction_1D_steady.i]

[1d_interface/reaction_1D_transient.i]


### Example Input Syntax





## PenaltyInterfaceDiffusion

### Overview

`PenaltyInterfaceDiffusion` is an interface condition that forces
the variable equivalence using a penalty. At the same time,
the flux equivalence is implicitly satisfied as long as no other
side (interface) residual objects are present. Mathematically, it is
written as follows:
\begin{equation}
\begin{aligned}
& D \frac{\partial u}{ \partial n} = P (u - u_{neighbor}), \\
& D_{neighbor} \frac{\partial u_{neighbor}}{ \partial n_{neighbor}} = - P (u - u_{neighbor}).
\end{aligned}
\end{equation}
where $D$ and $D_{neighbor}$ are material properties for the current element and
its neighbor, respectively, $n$ and $n_{neighbor}$ are the outward normal vectors
from the element and its neighbor (typically $n = - n_{neighbor})$.
$P$ is the penalty supplied in the parameter [!param](/InterfaceKernels/PenaltyInterfaceDiffusion/penalty).

### Example Input File Syntax





# interfaces

## BlockRestrictable Interface

The BlockRestrictable interface is inherited by every object in MOOSE that supports running on a
subset of the mesh domain corresponding to a subdomain. This interface provides a validParameters
function that also supports a uniform way of handing reading in subdomain restrictions. Specifically,
every object may be restricted to one or more subdomains simultaneously. Subdomains may be specified
either as numeric IDs or strings (when supported by the Mesh format or named entities are used).
Finally, this interface handles queries about the set of subdomains that an object is restricted
to when no restrictions are supplied.

## BoundaryRestrictable Interface

The BoundaryRestrictable interface is inherited by every object in MOOSE that supports running on a subset
of the mesh domain corresponding to a boundary. This interface provides a validParameters function that also
supports a uniform way of handing reading in boundary restrictions. Specifically, every object may be
restricted to one or more boundaries simultaneously. Boundaries may be specified either as numeric IDs
or strings (when supported by the Mesh format or named entities are used). Finally, this interface handles
queries about the set of boundaries that an object is restricted to when no restrictions are supplied.

## Coupleable

This class provides an API for coupling different kinds of variables values into MOOSE systems.
The following tables summarize the methods it provides.

| Methods for scalar field variables | Description |
| :--- | :--- |
`coupledValue`* | Value of a coupled variable at q-points
`coupledGradient`* | Gradient of a coupled variable at q-points
`coupledSecond`* | Second spatial derivatives of a coupled variable at q-points
`coupledDot` | Time derivative of a coupled variable at q-points
`coupledDotDot` | Second time derivative of a coupled variable at q-points
`coupledDotDu` | Derivative with regards to the variable of the time derivative of a coupled variable at q-points
`coupledDotDotDu` | Derivative with regards to the variable of the second time derivative of a coupled variable at q-points
`coupledGradientDot` | Time derivative of the gradient of a coupled variable at q-points
`coupledGradientDotDot` | Second time derivative of the gradient of a coupled variable at q-points

---

| Methods for nodal scalar field variables | Description |
| :--- | :--- |
`coupledNodalValue`* | Value of a coupled variable at nodes
`coupledNodalDot` | Time derivative of a coupled variable at nodes
`coupledNodalDotDot` | Second time derivative of a coupled variable at nodes

---

| Methods for array field variables | Description |
| :--- | :--- |
`coupledArrayValue` | Value of a coupled array variable at q-points
`coupledArrayGradient` | Gradient of a coupled array variable at q-points
`coupledArrayDot` | Time derivative of a coupled array variable at q-points
`coupledArrayDotDot` | Second time derivative of a coupled array variable at q-points
`coupledArrayDotDu` | Derivative with regards to the variable of the time derivative of a coupled array variable at q-points
`coupledArrayGradientDot` | Time derivative of the gradient of a coupled array variable at q-points

---

| Methods for vector field variables | Description |
| :--- | :--- |
`coupledVectorValue` | Value of a coupled vector variable at q-points
`coupledVectorGradient` | Gradient of a coupled vector variable at q-points
`coupledCurl` | Curl of a coupled vector variable at q-points
`coupledDiv` | Divergence of a coupled vector variable at q-points
`coupledVectorDot` | Time derivative of a coupled vector variable at q-points
`coupledVectorDotDot` | Second time derivative of a coupled vector variable at q-points
`coupledVectorDotDu` | Derivative with regards to the variable of the time derivative of a coupled vector variable at q-points
`coupledVectorDotDotDu` | Derivative with regards to the variable of the second time derivative of a coupled vector variable at q-points

---

| Methods for nodal vector field variables | Description |
| :--- | :--- |
`coupledNodalValue`* | Value of a coupled vector variable at nodes
`coupledNodalDot` | Time derivative of a coupled vector variable at nodes

---

*: These methods are also provided with values from the previous Newton iteration
by suffixing their name with `PreviousNL`, e.g. `coupledSecondPreviousNL`.

: These methods are also provided with values from the previous time step of a
transient simulation by suffixing their name with `Old`, e.g. `coupledDotOld`.

: These methods are also provided with values from the previous or second previous
time steps of a transient simulation by suffixing their name with `Old` or `Older`,
respectively, e.g. `coupledDivOld` or `coupledDivOlder`.

: These methods are also provided with automatic differentiation info by prefixing their
name with `ad` and preserving `camelCase`, e.g. `adCoupledValue` or `adCoupledVectorDot`.

Note that all of these prefixes and suffixes are mutually exclusive, i.e. none can be mixed and matched in any way.

Lastly, some methods are only available with automatic differentiation info, e.g.
`adCoupledLowerValue` returns the value of a coupled lower-dimensional variable and `adCoupledVectorSecond` returns the second spatial derivatives of a coupled vector variable.

### Optional Coupling

To determine if a variable was coupled, users can use `isCoupled` method.
The typical use case looks like this:

```
_value(isCoupled("v") ? coupledValue("v") : _zero)
```

However, this use case became obsolete and now it is recommended to use default values for optionally coupled variables, see the following example:

```
InputParameters
Class::validParams()
{
  InputParameters params = BaseClass::validParams();
  params.addCoupledVar("v", 2., "Coupled value");
  ...
  return params;
}

Class::Class(...) : BaseClass(...),
  _v(coupledValue('v'))
```

The advantage here is that users can provide arbitrary default values to their variables.

### Coupling of Vectors of Variables

Users can couple a vector of variables using the following syntax:

```
v = 'a b c'
```

This syntax provides 3 variables coupled as a variable `v` in a MOOSE object using the `Coupleable` interface.
The number of components coupled into can be obtained by `coupledComponents` method.
Then, individual components can be obtained by calling `coupledValue` (or any other method mentioned above) passing in the variable name (as usual) and the component index. See the following example:

Declarations:

```
class B : public A
{
  ...
protected:
  unsigned int _n_vars;
  std::vector<MooseVariable *> _vars;
};
```

Implementation:

```
InputParameters
B::validParams()
{
  InputParameters params = A::validParams();
  params.addRequiredCoupledVar("v", "Coupled value");
  ...
  return params;
}

B::B(...) : A(...),
  _n_vars(coupledComponents("v"))
{
  for (unsigned int i = 0; i < _n_vars; i++)
    _vars.push_back(dynamic_cast<MooseVariable *>(getVar("v", i)));
}
```

### Defaults for Coupling of Vectors of Variables

Vectors of variables can be added using `params.addCoupledVar` as described above. The parameter class allows providing
defaults for vector variables as follows:

```
InputParameters
B::validParams()
{
  InputParameters params = A::validParams();
  params.addCoupledVar("v", {1, 2, 3}, "Coupled value");
  ...
  return params;
}
```

Coupled variable parameters can be set to constant real numbers in the input file using the syntax

```
v = '1'
```

for a single coupled variable or using

```
v = '1 2 3'
```

for a vector of coupled variables. Currently mixing actual variable assignments and defaults like this:

```
v = '1 actual_var 3'
```

is not supported.

### Coupled Solution DOFs

It is possible to retrieve the solution DOFs of an element in an elemental loop. This is different than the
"value" type coupling which holds the interpolated values of the shape functions themselves. Obtaining the raw
DOFs all the user to perform their own integration or other evaluation without going through the interpolation
process. These functions can be found here:


### Coupling of variables through their names

Typically variables are coupled in through calling `params.addCoupledVar` or `params.addRequiredCoupledVar` of the valid parameters of an object.
There are cases where the variable names are provided through parameters in other types with `params.addParam` or `params.addRequiredParam`.
For these cases, this interface provides two functions `coupledValueByName` and `coupledArrayValueByName` that take a variable name directly.
This suffix `ByName` is only available for the two functions currently because they are the only onces needed by MOOSE and MOOSE applications.
More can be added as desired in the future.


### Writing directly to coupled variables

Element- and nodal user objects as well AuxKernels may obtain a writable reference to a MOOSE field variable
through the `Coupleable::writableVariable` function. The returned variable reference provides a `setDofValue` (for FE and FV variables) and `setNodalvalue` (only for FE variables) methods that can be used to set the nodal or elemental DOF value(s) of the variable.

`Coupleable::writableVariable` enforces compatibility between the calling object type and the family of the
requested variable. I.e. nodal user objects and AuxKernels may only obtain references to nodal variables, and
element user objects and elemental AuxKernels may only obtain references to elemental variables.

The block restrictions of the variables are also checked not to exceed the block restrictions of the calling object.
MOOSE keeps track of all variables to which a reference was obtained through `Coupleable::writableVariable`. Each
variable in the system may at most be written to by a single object on any given subdomain.

The user object and aux kernel thread loops check if an executed object has any writable variable references, and
if so, will insert those variables into the aux solution vector. This obviates the need for using the
[`ProjectionAux`](ProjectionAux.md) kernel.

`Coupleable::writableVariable` can let users write to both FE / FV from AuxKernels and UserObjects but one must exercise caution about whether Nodal or Elemental type AuxKernels / UOs are used as the quadrature would depend on this choice and might lead to segfault if a FV variable values are set using `setDofValue` function for non-zero values of `_qp` .

## DataFileInterface

This class provides an API for resolving paths to data files distributed alongside
MOOSE based apps and modules.

| Method | Description |
| - | - |
getDataFilePath | Finds a data file given a relative path

Files located in `<your_app>/data` can be registered as data paths for use in installed and in-tree
builds of applications. The MOOSE framework and MOOSE module data directories
of `moose/framework/data` and `moose/modules/*/data` are already registered. These
data directories (located at the root of an application) are installed automatically using the standard `make install`.

To make your data available for searching with this interface, register it with the following:

- the `registerAppDataFilePath` macro in `Registry.h`, where an applications data in its root `data` directory is registered (ex: `registerAppDataFilePath("foo_bar")` for `FooBarApp`)
- the `registerNonAppDataFilePath` macro in `Registry.h`, where a general data directory is registered

Once a data path is registered, it can be searched using this interface and via `DataFileName`
parameters. This search is consistent between both in-tree and installed builds of an application.

When a parameter is specified as `DataFileName` type, the corresponding value that you get
via `getParam<DataFileName>` is the searched value (the user's input is used for the search). The
search order for these paths is the following:

- if the path is absolute, use the absolute path
- relative to the input file
- if the relative path begins with `./`, break and do not search data
- if the relative path resolves behind `.`, break and do not search data
- relative to the installed or in-tree registered data file directories

You may also utilize the `getDataFilePath()` method within this interface to manually
search for a relative path in the data without the use of a parameter (for hard-coded data). This
search only searches relative to the installed or in-tree registered data file directories.

You can output additional information about the data files with the following comamnd line arguments:

- `--show-data-params`: Output the paths found for all DataFileName parameters in the header
- `--show-data-paths`: Output the registered file paths for searching in the header


## DependencyResolverInterface

## ElementIDInterface

Extra integer IDs for all the elements of a mesh can be useful for handling complicated material assignment, performing specific calculations on groups of elements, etc.
Often times, we do not want to use subdomain IDs for these tasks because subdomains are used by MOOSE for block-restricted operations. Many subdomains could introduce large penalty on run-time performance.
Extra element IDs are identified with extra element ID names.
Extra element IDs are part of the mesh and can be recovered during the mesh recovery.
Please refer to [MeshGenerator](MeshGenerator.md) for how the extra element integer IDs are generated or imported.

The ElementIDInterface is designed for using extra element IDs in the mesh by MOOSE objects such as materials, user objects, aux kernels, DG kernels, interface kernels, IC (initial conditions), kernels, etc.
The following table summarizes the interface functions provided by this interface:

| Method | Description |
| - | - |
getElementIDIndex | Gets index of an element integer with an input parameter of the integer names
getElementIDIndexByName | Gets index of an element integer with its name
getElementID | Gets the constant reference of an element integer of the current element with an input parameter
getElementIDNeighbor | Gets the constant reference of an element integer of the neighbor element with an input parameter
getElementIDByName | Gets the constant reference of an element integer of the current element with the integer name
getElementIDNeighborByName | Gets the constant reference of an element integer of the neighbor element with the integer name
hasElementID | Whether mesh has an element integer with a given name
maxElementID | Gets the maximum element ID for an element integer with its index
minElementID | Gets the minimum element ID for an element integer with its index
areElemIDsIdentical | Whether two element integers are identical for all elements
getAllElemIDs | Gets all the unique element IDs for an element integer with its index on the entire domain
getElemIDsOnBlocks | Gets all the unique element IDs for an extra element integer with its index on a set of subdomains
getElementID | Gets an element integer for an element
getElemIDMapping | Get the mapping from IDs of one extra element integer to another given the two integer names

Because MOOSE creates three copies of materials for the current element, element face and neighboring element face ([Material](syntax/Materials/index.md)), `getElementID` and `getElementIDByName` return the reference to either the current element ID or the neighbor element ID based on whether the current copy of material is for neighboring element or not. Correspondingly, directly calling `getElementIDNeighbor` and `getElementIDNeighborByName` is not allowed in `Material`.


It is noted that the element integer name *subdomain_id* is reserved by MOOSE for accessing subdomain IDs with this interface.

## InterpolatedStatefulMaterialPropertyInterface

The InterpolatedStatefulMaterialPropertyInterface provides the `getInterpolatedMaterialPropertyOld`
and `getInterpolatedMaterialPropertyOldByName` methods. This is likely to get integrated into the `MaterialPropertyInterface`.

## MeshMetaDataInterface

The MeshMetaDataInterface is used for retrieving attributes related to the mesh created during the mesh generation phase.
Attributes can have arbitrary types and names and can be used by other objects to query information that might otherwise
be cumbersome by just inspecting the raw mesh object. Examples include specific feature locations, dimensions, numbers
of elements in a direction, etc. The interface contains templated methods for querying for the existence of specific
attributes as well as retrieving those attributes.

### Availability on "Recover"

One of the most important features of the MeshMetaDataInterface is it's availability during recover
operations. Any system deriving from the interface will have access to attributes created during the initial setup
phase of the simulation. This removes the need to retrieve [MeshGenerator](meshgenerators/MeshGenerator.md),
[UserObject](syntax/UserObjects/index.md), or [MooseMesh](syntax/Mesh/index.md) objects that might contain specific
APIs that store that same information.

### MeshGenerators

The MeshGenerator system is the only system that may set attributes in the mesh meta-data store. Attributes are typically
written during the "act" phase. Here is an example of attributes written by the built-in GeneratedMeshGenerator object:


## NeighborCoupleable

This class provides API for coupling different kinds of variables values into MOOSE systems which
are performing computations on element internal sides.
This class derives from [Coupleable.md] so it includes all the APIs for coupling in
variable values in the local element. It add the following APIs for the variable values in the
neighbor.

| Method | Description |
| - | - |
coupledNeighborValue | Values of a coupled variable at neighbor q-points
coupledNeighborGradient | Gradients of a coupled variable at neighbor q-points
coupledNeighborSecond | Second derivatives of a coupled variable at neighbor q-points
adcoupledNeighborValue | Values of a coupled variable at neighbor q-points with automatic differentiation info
adcoupledNeighborGradient | Gradients of a coupled variable at neighbor q-points with automatic differentiation info
adcoupledNeighborSecond | Second derivatives of a coupled variable at neighbor q-points with automatic differentiation info


For values, gradients and second derivatives, users can request old and older values in case they are running a transient simulation.
In case of old and older values, the methods are called `coupledNeighborValueOld` and `coupledNeighborValueOlder`, respectively.

## Other APIs

See the [Coupleable.md] documentation for:

- checking whether a variable is coupled in
- coupling in vector variables
- accessing degrees-of-freedom values directly
- writing to coupled variables

## OutputInterface

Interface to handle the restriction of output from objects to certain [Outputs](syntax/Outputs/index.md).
Numerous objects inherit this interface to output some of their
attributes and related quantities. An important example are
[Materials](syntax/Materials/index.md) which can output
material properties to a selection of outputs using an `outputs` parameter.

## PostprocessorInterface

The PostprocessorInterface defines the methods used for retrieving PostprocessorValue references. Many objects
in MOOSE support the retrieval of these references for use in calculations. Postprocessors being "post"-processors
generally execute after most other systems in MOOSE so these values are often lagged when being used in another
calculation.


## RandomInterface

MOOSE currently distributes a high-quality efficient Pseudo Random Number Generator package (mtwist)
that is stable across different machine architectures. This random number generator is tied into
MOOSE's random number generator system that can generate consistent spatial random number fields as
parallel discretization changes (e.g. the number of threads/processors does not impact generated
fields). The random number interface is very straightforward to use.

MOOSE does not currently use a forwardable PRNG - this would be a nice enhancement to the framework
and would dramatically improve the performance of random number generators on distributed meshes and
at very large scales.

### Random Number Fields

The objects in MOOSE that produce fields can directly call `getRandomLong()` or `getRandomReal()` to
access the parallel stable random number objects in MOOSE. Generally, the only user parameter that
needs to be called or set is `setRandomResetFrequency()`.  This method controls how often the
individual generators are reset. That is when they are told to replay a set of numbers.  Typically,
if the random field is used in a kernel, boundary condition, or any other object that impacts the
Residual statement, you don't want to be producing new random numbers with each linear iteration as
this can impact the convergence of the solver.  You can avoid this problem If you "reset" the random
number generators every "linear" iteration, meaning that the same random numbers are replayed each
and every linear iteration. Other options are "nonlinear" and "initial" (the latter option is
effectively no resetting).

## ReporterInterface

The ReporterInterface defines the methods used for retrieving references to [Reporter](Reporters/index.md) values. Many objects in MOOSE support the retrieval of these references for use in calculations.


## SetupInterface

Most user-facing objects in MOOSE inherit from the `SetupInterface` class. This class provides two
features to objects:

- The `execute_on` parameter, which, as the name suggests, dictates when the object is to be executed.
- Virtual setup methods that allow derived classes to perform setup applications prior to execution.

### Execute On

Any object inheriting from the SetupInterface, that adds the `SetupInterface::validParams()` within its
own parameters, will have an `execute_on` parameter that can be set to various flags.
The default (and thus most common) flags are listed below:

| Execute Flag | Description |
| :- | :- |
`NONE` | Never executed.
`INITIAL` | Prior to the first time step.
`LINEAR` | Prior to each residual evaluation.
`NONLINEAR` | Prior to each Jacobian evaluation.
`NONLINEAR_CONVERGENCE` | Prior to each nonlinear convergence check. Note that `NONLINEAR` is not appropriate for this purpose since that only executes if it has already been determined that another nonlinear step is to be taken.
`TIMESTEP_END` | After the solve for each time step.
`TIMESTEP_BEGIN` | Prior to the solve for each time step.
`FINAL` | At the end of the entire simulation.
`CUSTOM` | At user specified instants.
`ALWAYS` | Union of all the above flags.

Note that other flags exist, since it is possible for applications to add additional
flags to those added by the core MOOSE framework (see [#creating-custom-execute-flags] below).
Documentation on these custom flags should appear within the associated application documentation;
please contact the application's developers if not found.

The `execute_on` parameter can be set to a single flag or multiple flags. For example, it may be
desirable to only execute an object initially because the state of the auxiliary computation does not
vary. In the input file snippet below, the [ElementLengthAux](/ElementLengthAux.md) computation only
needs to be computed initially, and thus the `execute_on` parameter is set as such.


Alternatively, it is often desirable to run a computation with multiple execute flags. For example,
in the input file snippet below a [TimePeriod](/TimePeriod.md) control object that is responsible for
enabling a [Damper](/Dampers/index.md) object needs to be run initially and prior to each timestep
to guarantee that the damper is enabled when desired.


Depending on the system these options or others will be available, since, as discussed in
[Creating Custom Execute Flags](#creating-custom-execute-flags), custom flags may be added. The
list of execution flags registered by MOOSE are listed in the `registerExecFlags` function:


Each type of MOOSE object can choose its own default value for `execute_on`, which
can be found in their `validParams()` method. Some examples are as follows:

| Object Base Class | Default `execute_on` Values |
| :- | :- |
| `AuxKernel` | `LINEAR`, `TIMESTEP_END` |
| `Postprocessor` | `TIMESTEP_END` |
| `UserObject` | `TIMESTEP_END` |
| `Output` | `INITIAL`, `TIMESTEP_END` |
| `Control` | `INITIAL`, `TIMESTEP_BEGIN` |
| `MultiApp` | `TIMESTEP_BEGIN` |
| `Transfer` | (same as corresponding `MultiApp`) |

### Modifying Execute On

When creating objects that inherit from `SetupInterface` it is possible to set, add, or remove
available execute flags by retrieving and then modifying the `ExecFlagEnum` parameter. For example,
consider the snippet below (see [Output.C](/framework/src/outputs/Output.C)).


First, the `execute_on` parameter is retrieved for modification by using the "set" method. Notice, that a
second boolean argument is passed to "set": this second flag enables "quiet mode". Quiet mode allows
this default modification to not count as a user modification for the purposes of `InputParameters::isParamSetByUser`.

Second, the two new execution flags are added (`EXEC_FINAL` and `EXEC_FAILED`); therefore these
additional options are available to all classes (all `Output` objects in this case) that
inherit from this object.

Third, the default active flags are set to `EXEC_INITIAL` and `EXEC_TIMESTEP_END`, which
are the defaults for all `Output` objects.

Finally, the documentation string for the `execute_on` parameter for the `Output` objects is
updated to reflect the changes made to the parameter. The `ExecFlagEnum` has a convenience function
that generates a documentation string that includes the URL to this page.


### Virtual Setup Methods

The SetupInterface includes virtual methods that correspond to the primary execute flags
with MOOSE, these methods are listed in the header as shown here.

         start=static InputParameters validParams()
         end=customSetup
         include-end=True
         include-start=False
         strip-leading-whitespace=True

In general, these methods should be utilized to perform "setup" procedures prior to the calls to
execute for the corresponding execute flag.

A few of the methods were created prior to the execute flags, thus the names do not correspond but
they remain as is to keep the API consistent: the "jacobianSetup" methods is called prior to the
"NONLINEAR" execute flag and the "residualSetup" is called prior to the "LINEAR" execute flag.

There is also a generic setup function "customSetup" that takes an execute flag as the argument.
This function is called by MOOSE when performing evaluations of objects on the custom execute flags
in [Creating Custom Execute Flags](#creating-custom-execute-flags).

This function is not called on *initial*, *timestep_begin*, *subdomain*, *nonlinear* and *linear*.
Setup operations for those execute flags should be implemented in *initialSetup*, *timestepSetup*,
*subdomainSetup*, *jacobianSetup* and *residualSetup* functions respectively.

### Creating Custom Execute Flags

It is possible to create custom execute flags for an application. To create and utilize a custom
execute flag, the following steps should be followed.

#### 1. Register an Execute Flag

Within your application a new global `const` should be declared in a header file. For example, within
the `LevelSetApp` within MOOSE modules, the header `LevelSetTypes.h` declares the new
flags `EXEC_ADAPT_MESH` and `EXEC_COMPUTE_MARKERS`:


This new global must be registered, which occurs in the corresponding source file using the `registerExecFlag()` macro defined in `ExecFlagRegistry.h`:


#### 2. Add the Execute Flag to InputParameters

After a flag is registered, it must be made available to the object(s) that are desired to be
executed with the custom flag. This is done by adding this new flag to an existing object's valid
parameters. For example, the following adds the `EXEC_ADAPT_MESH` and `EXEC_COMPUTE_MARKERS` flags to a `Transfer` object
and then sets the default to be `{LevelSet::EXEC_COMPUTE_MARKERS, LevelSet::EXEC_ADAPT_MESH}`:



#### 3. Use the Execute Flag

Depending on what type of custom computation is desired, various MOOSE execution calls accept
execution flags, which will spawn calculations. For example, the `LevelSetProblem` contains
a custom method that uses the `EXEC_ADAPT_MESH` and `EXEC_COMPUTE_MARKERS` flags to perform
an additional [`MultiAppTransfer`](Transfers/index.md) execution:


## SolutionInvalidInterface

The SolutionInvalidInterface defines the method used to mark a solution as "invalid".  An invalid solution means that the solution somehow does not satisfy requirements such as a value being out of bounds of a correlation.  Solutions are allowed to be invalid _during_ the nonlinear solve - but are not allowed to invalid once it converges.  A "converged" solution that is marked as invalid will cause MOOSE to behave as if the solution did NOT converge - including cutting back timesteps, etc.

This can be overridden by setting `Problem/allow_invalid_solution=true`.


## TaggingInterface

TaggingInterface stores the basic information used for controlling how to contribute local element
residuals/Jacobians to multiple global vectors/matrices. Regular Kernels, Boundary conditions, Scalar Kernels, DG Kernels etc. should inherit from TaggingInterface.

### Vector tags

By default objects contribute to the `nontime` vector and the `system` matrix.  `TimeKernel` derived objects automatically contribute to the `time` vector.

This behavior can be modified by setting parameters in the object's blocks in the input file:

| Tag           | Description |
|-              |            -|
| vector_tags    | The tag for the vectors this object should fill |
| extra_vector_tags | Add more vectors to fill beyond what is in `vector_tags` - useful for adding without overriding the defaults |
| matrix_tags    | The tag for the matrices this object should fill |
| extra_matrix_tags | Add more matrices to fill beyond what is in `matrix_tags` - useful for adding without overriding the defaults |

## UserObjectInterface

The UserObjectInterface defines the methods used for retrieving const references to the specific types of
UserObjects. This is done with templated methods so that use of the UserObject does not require a dynamic
cast. Many objects in MOOSE support the retrieval of these references so that custom UserObject APIs may
be used in calculations. UserObjects are generally executed after most other systems in MOOSE so these
values are often lagged when being used in another calculation.

### End Use API

Most objects in MOOSE will retrieve UserObjects through special macro functions found here:


Typical usage looks like this:


## VectorPostprocessorInterface

The VectorPostprocessorInterface defines the methods used for retrieving references to [VectorPostprocessor](VectorPostprocessors/index.md) values. Many objects in MOOSE support the retrieval of these references for use in calculations.


# kernels

## ADBodyForce

### Description

`ADBodyForce` implements a force term in momentum transport or structural
mechanics or a source term in species/mass transport. The strong form, given a
domain $\Omega$ is defined as

\begin{equation}
\underbrace{-f}_{\textrm{ADBodyForce}} + \sum_{i=1}^n \beta_i = 0 \in \Omega
\end{equation}
where $f$ is the source term (negative if a sink) and the second term on the
left hand side represents the strong forms of other kernels. The `ADBodyForce`
weak form, in inner-product notation, is defined as

\begin{equation}
R_i(u_h) = (\psi_i, -f) \quad \forall \psi_i,
\end{equation}
where the $\psi_i$ are the test functions, and $u_h$ are the trial solutions in
the finite dimensional space $\mathcal{S}^h$ for the unknown ($u$).

The force is constructed through a user supplied constant $c$,
[function](/Functions/index.md) value evaluated at the current time and
quadrature point $f$, and/or [postprocessor](/Postprocessors/index.md)
value $p$. The constant $c$, supplied through the parameter `value`, may also be
controlled over the course of a transient simulation with a
[`Controls`](/Controls/index.md) block.  $c$, $f$, $p$ are supplied
through the input parameters `value`, `function`, and `postprocessor`
respectively. Not supplying $c$, $f$, or $p$ through its corresponding
parameter is equivalent to setting its value to unity.

### Example Syntax

The case below demonstrates the use of `ADBodyForce` where the force term is
supplied solely through the a function (denoted by `function`):





## ADConservativeAdvection

### Description

The `ADConservativeAdvection` kernel implements the same advection term as
[ConservativeAdvection.md]. A few differences from that object are:

- The [!param](/Kernels/ADConservativeAdvection/velocity) parameter is a material
  property instead of a coupled variable. This allows more straightforward
  propagation of derivatives for automatic differentiation
- No upwinding option is currently implemented. In that vein this object may be
  best used within a discontinuous Galerkin scheme with [ADDGAdvection.md].
- A [!param](/Kernels/ADConservativeAdvection/advected_quantity) parameter is
  available which allows for advecting different quantities than the `variable`
  this object is acting upon




## ADCoupledTimeDerivative

### Description

The `ADCoupledTimeDerivative` kernel is very similar to the
[`TimeDerivative`](/TimeDerivative.md) kernel with the exception that the time
derivative operator is applied to a coupled variable $v$ instead of the kernel
variable $u$ which the `ADCoupledTimeDerivative` residual is assigned to.
Consequently, the strong form on the domain $\Omega$ is

\begin{equation}
\underbrace{\frac{\partial v}{\partial t}}_{\textrm{ADCoupledTimeDerivative}} +
\sum_{i=1}^n \beta_i = 0 \in \Omega
\label{strong}
\end{equation}
where the second term on the left hand side corresponds to the
strong forms of other kernels. The `ADCoupledTimeDerivative` weak form is then

\begin{equation}
R_i(u_h) = \bigg(\psi_i, \frac{\partial v_h}{\partial t}\bigg) \quad \forall
\psi_i,
\label{weak}
\end{equation}
where the $\psi_i$ are test functions and $u_h \in \mathcal{S}^h$ is the finite
element solution of the weak formulation.

The Jacobian contribution is computed using forward mode automatic
differentiation.

### Example Syntax

`ADCoupledTimeDerivative` is used for example in the split Cahn Hilliard
equations for phase field calculations. The syntax is simple, taking its type
(`ADCoupledTimeDerivative`), the kernel variable which the
`ADCoupledTimeDerivative` residual is assigned to, and the coupled variable `v`
that the time derivative operator acts upon. Example syntax can be found in the
kernel block below:





## ADDiffusion

### Description

The steady-state diffusion equation on a domain $\Omega$ is defined as
\begin{equation}
-\nabla \cdot \nabla u = 0 \in \Omega.
\end{equation}

The weak form of this equation, in inner-product notation, is given by:

\begin{equation}
R_i(u_h) = (\nabla \psi_i, \nabla u_h) = 0 \quad \forall  \psi_i,
\end{equation}
where $\psi_i$ are the test functions and $u_h \in \mathcal{S}^h$ is the finite
element solution of the weak formulation.

The Jacobian in `ADDiffusion` is computed using forward automatic
differentiation.




## ADKernelGrad

### Description

This is an optimized [Kernel](/Kernel.md) base class for residuals which allow
the gradient of the test function $\nabla\psi_i$ (`_grad_test[_i][_qp]`) to be
factored out (see [KernelGrad](/KernelGrad.md)).

\begin{equation}
  (\dots,\nabla\psi_i)
\end{equation}

The Jacobian in `ADKernelGrad` is computed using forward automatic
differentiation.

## ADKernelValue

### Description

This is an optimized [Kernel](/Kernel.md) base class for residuals which allow
the test function  $\psi_i$ (`_test[_i][_qp]`) to be factored out (see
[KernelValue](/KernelValue.md)).

\begin{equation}
  (\dots,\psi_i)
\end{equation}

The Jacobian in `ADKernelValue` is computed using forward automatic
differentiation.

## ADMatBodyForce

### Description

`MatBodyForce` implements a force term given via a material property. This kernel leverages
the formation in [ADBodyForce](ADBodyForce.md) by multiplying the residual by a material property.
All other implementation details are the same as [ADBodyForce](ADBodyForce.md).

### Example Syntax





## ADMatCoupledForce


### Example Input File Syntax





## ADMatDiffusion

### Description

`ADMatDiffusion` implements the term
\begin{equation}
\nabla\cdot D(a,b,\dots) \nabla u,
\end{equation}
where the diffusion coefficient $D$ (`diffusivity`) is provided by a `Material` or
`ADMaterial` and $u$ is the nonlinear variable the kernel is operating on.

This kernel can be used in a coupled form if the optional `v` variable is
specified. This allows applying the diffusion operator to a variable $u$ given
by `v`, which is different from the kernel variable.

$D$ can depend on arbitrary nonlinear variables $a,b,\dots$. The complete
Jacobian contributions are provided by automatic differentiation as long as $D$
is given using an `ADMaterial` derived object.





## ADMaterialPropertyValue


This kernel sets the kernel variable $u$ (`variable`) weekly enforced to the
value of a material  property $p$ (`prop`).

\left(\pm(p-u),\psi\right)

The $\pm$ sign is controlled by the `positive` boolean parameter.

This kernel can be used to emulate the action of nodal patch recovery, by finding
a projection of an interior material property onto (nodal) basis function degrees
of freedom. It can be used to generate a smooth field for outputting material
properties.





## ADMatReaction


Implements
\begin{equation}
(-L(v,a,b,\dots) v, \psi),
\end{equation}
where $L$ ([!param](/Kernels/ADMatReaction/reaction_rate)) is a reaction rate, $v$ is either
a coupled variable ([!param](/Kernels/ADMatReaction/v)) or - if not explicitly specified - 
the non-linear variable the kernel is operating on.

Forward automatic differentiation is used to compute all on and off-diagonal
Jacobian contributions.

Note the negative sign, which does *not* appear in [Reaction](/Reaction.md) or
[CoefReaction](/CoefReaction.md).

### Example Input File Syntax





## ADScalarLMKernel

The `ADScalarLMKernel` is the automatic differentiation version of [`ScalarLMKernel`](ScalarLMKernel.md).




## ADTimeDerivative

### Description

The `ADTimeDerivative` kernel implements a simple time derivative for the domain $\Omega$ given by

\begin{equation}
\underbrace{\frac{\partial u}{\partial t}}_{\textrm{ADTimeDerivative}} +
\sum_{i=1}^n \beta_i = 0 \in \Omega.
\end{equation}
where the second term on the left hand side corresponds to the strong forms of
other kernels. The corresponding `ADTimeDerivative` weak form using inner-product notation is

\begin{equation}
R_i(u_h) = (\psi_i, \frac{\partial u_h}{\partial t}) \quad \forall \psi_i,
\end{equation}
where $u_h$ is the approximate solution and $\psi_i$ is a finite element test function.

The Jacobian is computed through automatic differentiation. More information about time kernels can be
found on the Kernels description [page](syntax/Kernels/index.md).

### Example Syntax

Time derivative terms are ubiquitous in any transient simulation. The kernel
block for a transient diffusion problem that demonstrates the
`ADTimeDerivative` syntax is shown below:





## ADVectorDiffusion

### Description

`ADVectorDiffusion` is analogous to [`Diffusion`](/Diffusion.md)
except it is applied to vector finite element variables and the Jacobian is
computed automatically using automatic differentiation.




## ADVectorTimeDerivative

### Description

The `ADVectorTimeDerivative` kernel implements a simple time derivative for the
domain $\Omega$ given by

\begin{equation}
\underbrace{\frac{\partial \vec u}{\partial t}}_{\textrm{ADVectorTimeDerivative}} +
\sum_{i=1}^n \beta_i = 0 \in \Omega.
\end{equation}

where the second term on the left hand side corresponds to the strong forms of
other kernels. The corresponding `ADVectorTimeDerivative` weak form using
inner-product notation is

\begin{equation}
R_i(\vec u_h) = (\vec \psi_i, \frac{\partial \vec u_h}{\partial t}) \quad \forall \psi_i,
\end{equation}

where $\vec u_h$ is the approximate solution and $\vec \psi_i$ is a finite
element test function.

The Jacobian is computed through automatic differentiation. More information
about time kernels can be found on the Kernels description
[page](syntax/Kernels/index.md).

### Example Syntax

Time derivative terms are ubiquitous in any transient simulation. The kernel
block for a transient diffusion problem that demonstrates the
`ADVectorTimeDerivative` syntax is shown below:





## AnisotropicDiffusion

### Description

The `AnisotropicDiffusion` kernel implements anisotropic diffusion term on a domain ($\Omega$) given in its strong form as

\begin{equation}
\nabla\cdot -\widetilde{k} \nabla u = 0 \in \Omega,
\end{equation}
where $\widetilde{k}$ is the anisotropic
diffusion coefficient. Diffusion is anisotropic if the diffusion rate varies with
direction. The corresponding weak form, using inner-product notation, is given by

\begin{equation}
R_i(u_h) = \underbrace{(\nabla \psi_i, \widetilde{k} \nabla
u_h)}_{\textrm{AnisotropicDiffusion}} - \langle\psi_i, \widetilde{k} \nabla u_h
\cdot \vec{n}\rangle\quad \forall \phi_i,
\end{equation}
where the first term denotes the inner product over the domain volume, the latter term denotes the
outward diffusion flux over the volume boundary ($\Gamma$), $\psi_i$ are the test functions, and $u_h
\in \mathcal{S}^h$ is the finite element solution of the weak formulation. The `AnisotropicDiffusion`
kernel implements the first (volume) term.

For a constant diffusion coefficient, the Jacobian is given by
\begin{equation}
\frac{\partial R_i(u_h)}{\partial u_j} =
(\nabla \phi_j, \widetilde{k} \nabla u_h).
\end{equation}

### Example Syntax

The `AnisotropicDiffusion` kernel may be used in a variety of physical models, including steady-state
and time-dependent diffusion, advection-diffusion-reaction, etc. A kernel block demonstrating the
`AnisotropicDiffusion` syntax in a steady-state anisotropic diffusion problem can be found below:


The anisotropic diffusion coefficient $\widetilde{k}$ is a three-dimensional tensor supplied through a
string with nine space separated real values. The entries correspond to $xx$, $xy$, $xz$, $yx$, $yy$,
$yz$, $zx$, $zy$, and $zz$, respectively. Also, this problem is 2-dimensional so the corresponding
$zx$, $zy$, and $zz$ terms are zero.




## ArrayBodyForce

### Description

`ArrayBodyForce` applies body forces specified with functions to an array variable:

\begin{equation}
(\vec{u}^\ast, -\vec{f}),
\end{equation}
where $\vec{u}^\ast$ is the test functions of all the components of the array variable $\vec{u}$, and $\vec{f}$ is the body force functions whose size must agree with the number of components of the array variable.
The Jacobian term for this kernel is zero since it is assumed that $\vec{f}$ +is not+ a function of the unknown $\vec{u}$.

### Example Input Syntax





## ArrayCoupledTimeDerivative

### Description

The `ArrayCoupledTimeDerivative` kernel is very similar to the
[`CoupledTimeDerivative`](/CoupledTimeDerivative.md) kernel with the
exception that it works for array variables rather than scalars.
The strong form on the domain $\Omega$ is

\begin{equation}
\underbrace{\frac{\partial v}{\partial t}}_{\textrm{ArrayCoupledTimeDerivative}} +
\sum_{i=1}^n \beta_i = 0 \in \Omega
\label{strong}
\end{equation}
where the second term on the left hand side corresponds to the
strong forms of other kernels. The `ArrayCoupledTimeDerivative` weak form is then

\begin{equation}
R_i(u_h) = \bigg(\psi_i, \frac{\partial v_h}{\partial t}\bigg) \quad \forall
\psi_i,
\label{weak}
\end{equation}
where the $\psi_i$ are test functions and $u_h \in \mathcal{S}^h$ is the finite
element solution of the weak formulation.

The Jacobian contribution is equal to
\begin{equation}
\frac{\partial R_i(u_h)}{\partial u_j} = (\psi_i, a_v\phi_j).
\end{equation}
where $a_v$ is a constant that depends on the time stepping scheme; $a_v$ is
denoted by `_dv_dot` in the `ArrayCoupledTimeDerivative` class.

### Example Syntax

The syntax is simple, taking its type (`ArrayCoupledTimeDerivative`), the variable
to that the residual the `ArrayCoupledTimeDerivative` contributes, and the coupled
variable `v` that the time derivative operator acts upon. Example syntax can be
found in the kernel block below:





## ArrayDiffusion

### Description

This array kernel implements the following piece of a weak form:

\begin{equation}
(\nabla \vec{u}^\ast, \mathbf{D} \nabla \vec{u}),
\end{equation}
which is expanded as
\begin{equation}
(\nabla \vec{u}^\ast, \mathbf{D} \nabla \vec{u}) = \sum_{p=1}^N w_p \sum_{q=1}^N (\nabla u_p^\ast, D_{p,q} \nabla u_q),
\end{equation}
where $\vec{u}^\ast$ is the test function, $\vec{u}$ is the finite element solution and $\mathbf{D}$ is the diffusion coefficients.
$\vec{u}$ is an array variable that has $N$ number of components.
$w_p, p=1,\cdots,N$ is the scalings of all components of the array variable.
The size of the vector test function $\vec{u}^\ast$ is the same as the size of $\vec{u}$.
The kernel can be further spelled out as
\begin{equation}
\sum_{p=1}^N w_p \sum_{q=1}^N (\nabla u_p^\ast, D_{p,q} \nabla u_q) = \sum_{p=1}^N w_p \sum_{q=1}^N \sum_{e} \int_e D_{p,q}(x) \nabla u_p^\ast (x) \cdot \nabla u_q(x)\,dx = \sum_{p=1}^N w_p \sum_{q=1}^N \sum_{e} \sum_{i=1}^{N_{\text{dof}}} \sum_{j=1}^{N_{\text{dof}}} u_{p,i}^\ast u_{q,j} \sum_{\text{qp}=1}^{N_{qp}} (|J|w)_{\text{qp}} D_{p,q,\text{qp}} \nabla b_{i,\text{qp}} \cdot \nabla b_{j,\text{qp}}, \label{eq:weak-array-diffusion}
\end{equation}
where $e$ denotes elements of the mesh; $N_\text{dof}$ is the number of shape functions on the local element; $N_\text{qp}$ is the number of quadrature points for doing the spatial integration over an element. $u_{p,i}^\ast$ and $u_{p,i}^\ast$ are the expansion coefficients for the test function and the solution respectively, often referred as degrees of freedom. Subscript $\text{qp}$ indicates that the associated quantities are evaluated on a quadrature point. $(|J|w)_\text{qp}$ is the determinant of Jacobian, that transform a physical element to a reference element where the shape functions $b_i(\hat{x}),i=1,\cdots,N_\text{dof}$ are defined, times local quadrature weighting.
It is noted that the test functions of all components are identical because all components of an array variable share the same finite element family and order.

We can rearrange the fully expanded [eq:weak-array-diffusion] into
\begin{equation}
(\nabla \vec{u}^\ast, \mathbf{D} \nabla \vec{u}) = \sum_{e} \sum_{i=1}^{N_{\text{dof}}} \sum_{\text{qp}=1}^{N_{qp}} (|J|w)_{\text{qp}} \vec{w}_p\vec{u}_i^\ast \underline{\mathbf{D}_{\text{qp}} \nabla \vec{u}_{\text{qp}} \cdot \nabla b_{i,\text{qp}}},
\end{equation}
where the underlined term is the array provided by [ArrayDiffusion::computeQpResidual](ArrayDiffusion.C).
The element, shape function and quadrature point summations are taken care of by MOOSE.
It is noted that since test functions are arbitrary, $\vec{u}_i^\ast$ can be viewed as an index indicator with which the local residual goes into the global residual vector.
Note that $\vec{a}\vec{b}$ represents element-wise multiplication, i.e. $\vec{a}\vec{b}$ is equal to vector whose *i*th element is $a_i \times b_i$, where $a$ and $b$ are two generic vectors.

In general, the diffusion coefficient $\mathbf{D}$ is a square matrix with the size of the number of components.
When it is a diagonal matrix, it can be represented by an array.
In such a case, the components are not coupled with this array diffusion kernel.
If all elements of the diffusion coefficient vector are the same, we can use a scalar diffusion coefficient.
Thus this kernel gives users an option to set the type of diffusion coefficient with a parameter named as *diffusion_coefficient_type*.
Users can set it to *scalar*, *array* or *full* corresponding to scalar, diagonal matrix and full matrix respectively.
Its default value is *array*.

With some further transformation, the kernel becomes
\begin{equation}
(\nabla \vec{u}^\ast, \mathbf{D} \nabla \vec{u}) = \sum_{e} \sum_{i=1}^{N_{\text{dof}}} \sum_{j=1}^{N_{\text{dof}}} \sum_{\text{qp}=1}^{N_{qp}} (|J|w)_{\text{qp}} \vec{w}_p\vec{u}_i^\ast \underline{\mathbf{D}_{\text{qp}} \nabla b_{j,\text{qp}} \cdot \nabla b_{i,\text{qp}}} \vec{u}_j,
\end{equation}
where the underlined part is the local Jacobian evaluated by [ArrayDiffusion::computeQpJacobian](ArrayDiffusion.C) and [ArrayDiffusion::computeQpOffDiagJacobian](ArrayDiffusion.C).

### Example Input Syntax





## ArrayReaction

### Description

This array kernel implements the following piece of a weak form:
\begin{equation}
(\vec{u}^\ast, \mathbf{R} \vec{u}),
\end{equation}
where $\vec{u}^\ast$ is the test function, $\vec{u}$ is the finite element solution and $\mathbf{R}$ is the reaction coefficients.

Similarly as showed in [ArrayDiffusion.md], we can rearrange it into
\begin{equation}
(\vec{u}^\ast, \mathbf{R} \vec{u}) = \sum_{e} \sum_{i=1}^{N_{\text{dof}}} \sum_{\text{qp}=1}^{N_{qp}} (|J|w)_{\text{qp}} \vec{w}_p\vec{u}_i^\ast \underline{\mathbf{R}_{\text{qp}} \vec{u}_{\text{qp}} b_{i,\text{qp}}},
\end{equation}
where the underlined term is the vector provided by [ArrayReaction::computeQpResidual](ArrayReaction.C).
Detailed explanations on the notations can be found in [ArrayDiffusion.md].

In general, the reaction coefficient $\mathbf{D}$ is a square matrix with the size of the number of components.
When it is a diagonal matrix, it can be represented by a vector.
In such a case, the components are not coupled with this array reaction kernel.
If all elements of the diffusion coefficient vector are the same, we can use a scalar reaction coefficient.
Thus this kernel gives users an option to set the type of diffusion coefficient with a parameter named as *reaction_coefficient_type*.
Users can set it to *scalar*, *array* or *full* corresponding to scalar, diagonal matrix and full matrix respectively.
Its default value is *array*.

The local Jacobian can be found in the following equation:
\begin{equation}
(\vec{u}^\ast, \mathbf{R} \vec{u}) = \sum_{e} \sum_{i=1}^{N_{\text{dof}}} \sum_{j=1}^{N_{\text{dof}}} \sum_{\text{qp}=1}^{N_{qp}} (|J|w)_{\text{qp}} \vec{w}_p\vec{u}_i^\ast \underline{\mathbf{R}_{\text{qp}} b_{j,\text{qp}} b_{i,\text{qp}}} \vec{u}_j.
\end{equation}
The underlined part is the local Jacobian evaluated by [ArrayReaction::computeQpJacobian](ArrayReaction.C) and [ArrayReaction::computeQpOffDiagJacobian](ArrayReaction.C).




## ArrayTimeDerivative

### Description

This array kernel implements the following piece of a weak form:
\begin{equation}
(\vec{u}^\ast, \mathbf{T} \dot{\vec{u}}),
\end{equation}
where $\vec{u}^\ast$ is the test function, $\dot{\vec{u}}$ is time derivative of the array of finite element solutions ($\dot{\vec{u}} = \left[\frac{\partial u_1}{\partial t},\frac{\partial u_2}{\partial t},...\right]^T$), and $\mathbf{T}$ is a matrix of the time derivative coefficients ($(\mathbf{T})_{n,m} = T_{n,m}$).

Similarly as showed in [ArrayDiffusion.md], we can rearrange it into
\begin{equation}
(\vec{u}^\ast, \mathbf{T} \dot{\vec{u}}) = \sum_{e} \sum_{i=1}^{N_{\text{dof}}} \sum_{\text{qp}=1}^{N_{qp}} (|J|w)_{\text{qp}} \vec{w}_p\vec{u}_i^\ast \underline{\mathbf{T}_{\text{qp}} \dot{\vec{u}}_{\text{qp}} b_{i,\text{qp}}},
\end{equation}
where the underlined term is the vector provided by [ArrayTimeDerivative::computeQpResidual](ArrayTimeDerivative.C).
Detailed explanations on the notations can be found in [ArrayDiffusion.md].

In general, the reaction coefficient $\mathbf{T}$ is a square matrix with the size of the number of components.
When it is a diagonal matrix, it can be represented by a vector.
In such a case, the components are not coupled with this array time derivative kernel.
If all elements of the time derivative coefficient vector are the same, we can use a scalar reaction coefficient.
Thus this kernel gives users an option to set the coefficient to a scalar, vector, or matrix material property, corresponding to scalar, diagonal matrix, and full matrix, respectively.

The local Jacobian can be found in the following equation:
\begin{equation}
J_{n,m,i,j} = \sum_{e} \sum_{i=1}^{N_{\text{dof}}} \sum_{j=1}^{N_{\text{dof}}} \sum_{\text{qp}=1}^{N_{qp}} (|J|w)_{\text{qp}} \vec{w}_p u_{n,i}^\ast \underline{T_{n,m,\text{qp}} b_{j,\text{qp}} b_{i,\text{qp}} \frac{\partial \dot{u}_{m,j}}{\partial u_{m,j}}},
\end{equation}
where $n$ and $m$ are the component row and column, respectively. The underlined part is the local Jacobian evaluated by [ArrayTimeDerivative::computeQpJacobian](ArrayTimeDerivative.C) and [ArrayTimeDerivative::computeQpOffDiagJacobian](ArrayTimeDerivative.C).

### Example Input Syntax





## BodyForce

### Description

`BodyForce` implements a force term, such as a heat generation/sink term for heat
conduction, a momentum source/sink for momentum transport or structural mechanics, or
a source/sink term in species/mass transport. The context of this kernel depends
on the differential equation of interest, but shares the strong form on a domain
$\Omega$ as

\begin{equation}
\underbrace{-f}_{\textrm{BodyForce}} + \text{other kernels} = 0 \in \Omega
\end{equation}
where $f$ is the source term (negative if a sink) and "other kernels"
represent the strong forms of other terms present in the equation. The `BodyForce`
weak form, in inner-product notation, is defined as

\begin{equation}
R_i(u_h) = (\psi_i, -f) \quad \forall \psi_i,
\end{equation}
where the $\psi_i$ are the test functions, and $u_h$ are the trial solutions in
the finite dimensional space $\mathcal{S}^h$ for the unknown ($u$).

The Jacobian term for this kernel is zero: $\frac{\partial R_i(u_h)}{\partial u_j} = 0$, since
it is assumed that $f$ +is not+ a function of the unknown $u$.

The force is constructed through a user supplied constant $c$,
[function](/Functions/index.md) value evaluated at the current time and
quadrature point $f$, and/or [postprocessor](/Postprocessors/index.md)
value $p$. The constant $c$ may also be
controlled over the course of a transient simulation with a
[Controls](/Controls/index.md) block.
Not supplying $c$, $f$, or $p$ through its corresponding
parameter is equivalent to setting its value to unity.

### Example Input File Syntax

The case below demonstrates the use of `BodyForce` where the force term is
supplied based upon a function form:





## CoefReaction / ADCoefReaction


[`Reaction`](/Reaction.md) with a scalar prefactor $\lambda$ (`coef`)
\begin{equation}
(\lambda v, \psi),
\end{equation}
where $v$ (`v`) is a coupled variable.

There is no FV (finite volume) version of `CoefReaction`. If you wish to use FV,
use [/FVCoupledForce.md].





## CoefTimeDerivative

### Description

The `CoefTimeDerivative` kernel implements the time derivative term multiplied by a scalar coefficient.

This class inherits from the `TimeDerivative` class. 

### Example Syntax

A kernel block demonstrating the `CoefTimeDerivative` syntax in a transient diffusion problem can be found below:







## ConservativeAdvection

### Description

The `ConservativeAdvection` kernel implements an advection term given for the domain ($\Omega$) defined as

\begin{equation}
\underbrace{\nabla \cdot \vec{v} u}_{\textrm{ConservativeAdvection}} + \sum_{i=1}^n \beta_i = 0 \in \Omega,
\end{equation}
where $v$ is the advecting velocity and the second term on the left hand side
represents the strong forms of other kernels. `ConservativeAdvection` does not assume
that the velocity is divergence free and instead applies $\nabla$ to the test
function $\psi_i$ in the weak variational form after integrating by parts,
which results in the following (without numerical stabilization)

\begin{equation}
R_i(u_h) = \underbrace{-(\nabla \psi_i, \vec{v} u)}_{\textrm{ConservativeAdvection}} + \langle\psi_i, \vec{v} u
\cdot \vec{n}\rangle \quad \forall \psi_i,
\end{equation}
where $\psi_i$ are the test functions and $u_h \in \mathcal{S}^h$ is the finite
element solution of the weak formulation. The first term is the volumetric term and the second term
is a surface term describing the advective flux out of the
volume. `ConservativeAdvection` corresponds to the former volumetric term, while the surface term is implemented as a BC in MOOSE (see discussion below regarding `OutflowBC` and `InflowBC`).

Without numerical stabilization the corresponding Jacobian is given by

\begin{equation}
\frac{\partial R_i(u_h)}{\partial u_j} = -(\nabla \psi_i, \vec{v} \phi_j).
\end{equation}

### Full upwinding

Advective flow is notoriously prone to physically-incorrect overshoots
and undershoots, so in many simulations some numerical stabilization
is used to reduce or eliminate this spurious behaviour.
Full-upwinding [!cite](dalen1979,adhikary2011) is an example of
numerical stabilization and this essentially adds numerical diffusion
to completely eliminate overshoots and undershoots.  Full-upwinding is
available in `ConservativeAdvection` by setting the `upwinding_type`
appropriately.

Full upwinding only works for continuous FEM

In DE systems describing more than just advection (e.g., in
diffusion-advection problems) full upwinding may be used on the
advection alone.  In practice, it is reasonably common that these more
complicated cases benefit from numerical stabilization on their
other terms too, in which case full upwinding could also be used, but
this is not mandatory and is not implemented in the
`ConservativeAdvection` Kernel.

For each element in the mesh, full upwinding is implemented in the
following way.  For each $i$, the quantity
\begin{equation}
\tilde{R}_{i} = -(\nabla\psi_i, \vec{v}) \ ,
\end{equation}
is evaluated.  If $\tilde{R}_{i}>0$ is positive then mass (or heat, or whatever $u$
represents) is flowing *out* of node $i$, and this is called an
"upwind" node.  If $\tilde{R}_{i}\geq 0$, the residual for node $i$
is set to
\begin{equation}
R_{i} = u_{i}\tilde{R}_{i} \ \ \texttt{ for } \ \ \tilde{R}_{i}\geq 0.
\end{equation}
Here $u_{i}$ is the value of $u$ at the node $i$.  Define the total
mass flowing from the upwind nodes:
\begin{equation}
M_{\mathrm{out}} = \sum_{i\ \mathrm{ with }\ \tilde{R}_{i}\geq 0}
u_{i}\tilde{R}_{i} \ .
\end{equation}
Similarly, define
\begin{equation}
\tilde{M}_{\mathrm{in}} = - \sum_{i \ \mathrm{ with }\  \tilde{R}_{i}< 0}
\tilde{R}_{i} \ .
\end{equation}
Mass is conserved if the residual for the downwind nodes is defined to
be
\begin{equation}
R_{i} = \tilde{R}_{i} M_{\mathrm{out}} / M_{\mathrm{in}}  \ \ \texttt{ for } \ \ \tilde{R}_{i}< 0.
\end{equation}

Full upwinding adds more numerical diffusion than most other numerical
stabilization techniques such as SUPG and TVD.  Another problem is
that steady-state can be hard to achieve in nonlinear problems where
the velocity is not fixed and changes every nonlinear iteration (this
does not occur for `ConservativeAdvection`).  On the other hand, full
upwinding is computationally cheap.



### Example Syntax

`ConservativeAdvection` can be used in a variety of problems, including
advection-diffusion-reaction. The syntax for `ConservativeAdvection` is
demonstrated in this `Kernels` block from a pure advection test case:


The velocity is supplied as a three component vector with order $v_x$,
$v_y$, and  $v_z$.

### Boundary conditions for pure advection

To form the correct equations, the boundary term $\langle\psi_i, \vec{v} u
\cdot \vec{n}\rangle$ needs to be included in the `BCs` block of a
MOOSE input file ($\vec{n}$ is the outward normal to the boundary).  An
`OutflowBC` may be used, for instance


Physically this subtracts $\langle\psi_i, \vec{v} u \cdot
\vec{n}\rangle$ "fluid mass" (or whatever $u$ represents) from the boundary.

For $\vec{v} \cdot \vec{n} > 0$ adding the `OutflowBC` allows "fluid" to flow
freely through the boundary. The advective velocity is "blowing fluid" into this boundary, and the `OutflowBC` is removing it at the correct rate, because the flux through any area is $\langle\psi_i, \vec{v} u \cdot
\vec{n}\rangle$.

On the other hand, including an `OutflowBC` for $\vec{v} \cdot \vec{n}
< 0$ isn't usually desirable.  Adding the
`OutflowBC` in this case fixes $u$ at the boundary to its initial
condition. This is because the `ConservativeAdvection` Kernel is taking
fluid from the boundary to the interior of the model, but at the
same time the `OutflowBC` is removing $\langle\psi_i, \vec{v} u \cdot
\vec{n}\rangle$: note that $\vec{v} \cdot \vec{n} < 0$, so the
`OutflowBC` is actually adding fluid at the same rate the
`ConservativeAdvection` Kernel is removing it. The physical interpretation
is that something external to the model is adding fluid at exactly the
rate specified by the initial conditions at that boundary.

Instead, for $\vec{v} \cdot \vec{n} < 0$ users typically want to specify a particular value for an
injected flux.  This is achieved by using an `InflowBC`.  This adds $\langle\psi_i, \vec{v} u_{B} \cdot
\vec{n}\rangle$, where $u_B$ (kg.m$^{-2}$.s$^{-1}$) is the injection
rate.  For instance


To make impermeable boundaries, either for $\vec{v} \cdot \vec{n} < 0$
or $\vec{v} \cdot \vec{n} > 0$, simply use
no BC at that boundary. Then for $\vec{v} \cdot \vec{n} > 0$ there is no BC to remove fluid
from that boundary so the fluid "piles up" there. For $\vec{v} \cdot \vec{n} < 0$ the
omission of a BC can be thought of setting $u_B=0$ in an
`InflowBC`.

### Comparison of no upwinding and full upwinding

The tests


and


describe the same physical situation: advection from left to right
along a line.  A source at the left boundary introduces $u$ into the
domain at a fixed rate (using an `InflowBC`).  The right boundary is
impermeable (no BC), so when $u$ arrives
there it starts building up at the boundary.  It is clear from the
figures below that no upwinding leads to unphysical overshoots and
undershoots, while full upwinding results in none of that oscillatory
behaviour but instead produces more numerical diffusion.







## CoupledForce / ADCoupledForce

### Description

`CoupledForce` (and the AD version, `ADCoupledForce`) implements a source term
within the domain $\Omega$ proportional to a coupled variable:
\begin{equation}
\underbrace{-\sigma v}_{\textrm{CoupledForce}} + \sum_{i=1}^n \beta_i = 0 \in \Omega,
\end{equation}
where $\sigma$ is a known scalar coefficient, $v$ is a coupled unknown value, and the second term on
the left hand side corresponds to the strong forms of other kernels. In a species transport context,
the value $\sigma$ can be regarded as a reaction rate coefficient.

The weak form, in inner-product notation, is defined as

\begin{equation}
R_i(u_h) = (\psi_i, -\sigma v) \quad \forall \psi_i,
\end{equation}
where $\psi_i$ are the test functions and $u_h \in \mathcal{S}^h$
is the finite element solution of the weak formulation.

The corresponding Jacobian (used in `CoupledForce`) is
\begin{equation}
\frac{\partial R_i(u_h)}{\partial u_j} = (\psi_i, -\sigma \phi_j).
\end{equation}

### Example Syntax

The kernel block below shows a variable $u$ that is diffusing and being produced at a rate
proportional to the concentration of a variable $v$ which is also diffusing.

         block=Kernels

In this example the input parameter "coef" that corresponds to $\sigma$ is omitted. In this case the
"coef" value defaults to one.

The coupled variable [!param](/Kernels/CoupledForce/v) cannot be equal to the equation
[!param](/Kernels/CoupledForce/variable) with this kernel. Use the [CoefReaction](/CoefReaction.md)
kernel for this purpose.




## CoupledTimeDerivative

### Description

The `CoupledTimeDerivative` kernel is very similar to the
[`TimeDerivative`](/TimeDerivative.md) kernel with the
exception that the time derivative operator is applied to a coupled variable $v$ instead
of the variable $u$ to whom's residual the `CoupledTimeDerivative` kernel
contributes. Consequently, the strong form on the domain $\Omega$ is

\begin{equation}
\underbrace{\frac{\partial v}{\partial t}}_{\textrm{CoupledTimeDerivative}} +
\sum_{i=1}^n \beta_i = 0 \in \Omega
\label{strong}
\end{equation}
where the second term on the left hand side corresponds to the
strong forms of other kernels. The `CoupledTimeDerivative` weak form is then

\begin{equation}
R_i(u_h) = \bigg(\psi_i, \frac{\partial v_h}{\partial t}\bigg) \quad \forall
\psi_i,
\label{weak}
\end{equation}
where the $\psi_i$ are test functions and $u_h \in \mathcal{S}^h$ is the finite
element solution of the weak formulation.

The Jacobian contribution is equal to
\begin{equation}
\frac{\partial R_i(u_h)}{\partial u_j} = (\psi_i, a_v\phi_j).
\end{equation}
where $a_v$ is a constant that depends on the time stepping scheme; $a_v$ is
denoted by `_dv_dot` in the `CoupledTimeDerivative` class.

### Example Syntax

`CoupledTimeDerivative` is used for example in the split Cahn Hilliard equations
for phase field calculations. The syntax is simple, taking its type
(`CoupledTimeDerivative`), the variable to that the residual the
`CoupledTimeDerivative` contributes, and the coupled variable `v` that the time
derivative operator acts upon. Example syntax can be found in the kernel block
below:





## Diffusion

### Description

The steady-state diffusion equation on a domain $\Omega$ is defined as
\begin{equation}
-\nabla \cdot \nabla u = 0 \in \Omega.
\end{equation}

The weak form of this equation, in inner-product notation, is given by:

\begin{equation}
R_i(u_h) = (\nabla \psi_i, \nabla u_h) = 0 \quad \forall  \psi_i,
\end{equation}
where $\psi_i$ are the test functions and $u_h \in \mathcal{S}^h$ is the finite
element solution of the weak formulation.

Since we seek $u_h = \sum_j u_j \phi_j$, for some unknown coefficients $u_j$
and given basis functions $\phi_j$, the Jacobian is defined as:

\begin{equation}
\frac{\partial R_i(u_h)}{\partial u_j} = (\nabla \psi_i, \nabla \phi_j).
\end{equation}




## DivField


### Overview

The DivField object implements the following PDE term for coupled scalar-vector
PDE systems:

\begin{equation}
  k \nabla \cdot \vec{u},
\end{equation}

where $k$ is a constant scalar coefficient and $\vec{u}$ is a vector field
variable. Given scalar test functions $\psi_i$, the weak form, in inner-product notation, is given by:

\begin{equation}
  R_i(\vec{u}) = (\psi_i, k \nabla \cdot \vec{u}) \quad \forall \psi_i.
\end{equation}

### Example Input File Syntax





## FunctionDiffusion


### Overview

The `FunctionDiffusion` object represents a diffusion term with a function coefficient for
scalar field variables. This term is

\begin{equation}
  - \nabla \cdot f(\mathbf{r}, t) \nabla v
\end{equation}

where

- $v$ is a scalar field solution variable, and
- $f(\mathbf{r}, t)$ is a scalar function serving as a diffusion coefficient.

Note that the [!param](/Kernels/FunctionDiffusion/v) parameter is optional. If no variable is entered 
there, then the kernel's nonlinear variable will be used in the operator as usual. 

### Example Input File Syntax





## GenericKernel

GenericKernel acts as a switch between the AD/non-AD base class for objects that
calculate residual vector contributions of nonlinear scalar field variables.

This effectively allows a class to either inherit from [Kernel](Kernel.md) for
the non-AD or ADKernel for the AD case via the boolean `<is_ad>`.

## GenericKernelScalar

GenericKernelScalar acts as a switch between the AD/non-AD base class for objects that
calculate residual vector contributions of volumetric (kernel) integrals on 
nonlinear scalar variables coupled with field variables.

This effectively allows a class to either inherit from [KernelScalarBase](KernelScalarBase.md) for
the non-AD or ADKernelScalarBase for the AD case via the boolean `<is_ad>`.

See [GenericKernel](GenericKernel.md) for a similar description for field variables.

## GradField


### Overview

The GradField object implements the following PDE term for coupled
scalar-vector PDE systems:

\begin{equation}
  - k \nabla v,
\end{equation}

where $k$ is a constant scalar coefficient and  $v$ is a scalar field variable.
Given vector test functions $\vec{\psi_i}$, the weak form, in inner-product
notation, is given by:

\begin{equation}
  R_i(v) = (\nabla \cdot \vec{\psi_i}, k v) \quad \forall \vec{\psi_i}.
\end{equation}

### Example Input File Syntax





## Kernel

Kernel is the base class for object that calculate residual vector contributions
of nonlinear scalar field variables.

Derived from it are two sets of optimized base classes that - through loop
reordering - reduce the number of necessary residual evaluations and enable the
compiler to perform code vectorization. These base classes have restrictions on
the mathematical form of the residuals they can be applied to.

- [KernelValue](/KernelValue.md)
- [ADKernelValue](/ADKernelValue.md)
- [KernelGrad](/KernelGrad.md)
- [ADKernelGrad](/ADKernelGrad.md)

## KernelGrad

Derive from this base class if your residual is of the form

\begin{equation}
  (\dots,\nabla\psi_i)
\end{equation}

i.e. if the test function $\nabla\psi_i$ (`_grad_test[_i][_qp]`) can be factored out.

### Derived classes

Override

- `precomputeQpResidual()` instead of `computeQpResidual()` (do not multiply by `_grad_test[_i][_qp]`).
- `precomputeQpJacobian()` instead of `computeQpJacobian()` (do not multiply by `_grad_test[_i][_qp]`)
- `computeOffDiagJacobian` still has to be implemented as if deriving from `Kernel`.

Note that `precomputeQpResidual()` and `precomputeQpJacobian()` return a `RealGradient` type.

## KernelScalarBase

The `KernelScalarBase` is part of the scalar augmentation system to complement the [ScalarKernel](syntax/ScalarKernels/index.md) class. Its principal purpose is to add standard
quadrature loops and assembly routines to handle the contributions from a single added
scalar variable to a [Kernel](syntax/Kernels/index.md) class, including the entire row of the Jacobian.
These routines will assist with representing weak form terms in a partial differential equation involving
scalar variables integrated over the interior of a domain. As usual, this piece of physics is referred to
as the "residual" and is evaluated at integration quadrature points within that domain. To implement your own physics in MOOSE, you create your own kernel by subclassing the MOOSE `KernelScalarBase` class.

The Kernel scalar augmentation system supports the use of [!ac](AD) for residual calculations, as such
there are two options for creating field-scalar coupling objects:
`KernelScalarBase` and `ADKernelScalarBase`. To further understand
automatic differentiation, please refer to the [automatic_differentiation/index.md] page for more
information.

Developers should read all sections; users can find [#KSB-parameters] described at the bottom.

### Creation of Kernel Scalar Coupling Classes id=KSB-coupling

Each `Kernel` object has a +focus+ field variable or spatial variable; its job is to contribute to the
residual as well as the row of the Jacobian matrix. Herein, as in the source code of `Kernels`, this
spatial variable will be called `_var`. In a coupled (multi-physics) weak form, all domain integral terms
containing the test function of `_var` are potential candidates for `Kernel` contributions.

The philosophy of the scalar augmentation class `KernelScalarBase` is to add a focus scalar variable
referred to as `_kappa` to the `Kernel` object so that all terms in the coupled weak form that involve
`_var`, `_kappa`, and/or their test functions can be assembled in one or multiple class instances.
This philosophy is similar to how the lower dimensional variable `_lambda` is added to the element faces
of `DGKernel` and `IntegratedBC` objects associated with the hybrid finite element method (HFEM). Documentation for that approach can be found [HFEMDiffusion](source/dgkernels/HFEMDiffusion.md) and [HFEMDirichletBC](source/bcs/HFEMDirichletBC.md) along with the base classes `DGLowerDKernel` and `LowerDIntegratedBC`.

In a `KernelScalarBase` subclass, a naming scheme is established for the quadrature point methods of the two
variable types: methods contributing to the test function of `_kappa` have "Scalar" near the front
and methods contributing to the trial function of scalar variables in the Jacobian have "Scalar"
at the end. The `computeScalarQpResidual()` function +should+ be overridden (see [#KSB-parameters]
for cases where the scalar should be suppressed). The `computeQpResidual()` function +must+ be
overridden as usual for `Kernels`, although it may return zero.

For non-AD objects, several contributions to the Jacobian matrix can be optionally overridden for use in
Newton-type nonlinear solvers. As mentioned later, the developer should choose and document which terms
(rows) of the residual and terms (rows and columns) of the Jacobian will be attributed to an instance of
the developed class. These choices can be motivated by whether some terms in the weak form can be or have
already been implemented within other MOOSE classes.

- `computeQpJacobian()`: Jacobian component d-`_var`-residual / d-`_var`
- `computeQpOffDiagJacobian(jvar_num)`: off-diagonal Jacobian component d-`_var`-residual / d-`jvar`
- `computeQpOffDiagJacobianScalar(svar_num)`: off-diagonal Jacobian component d-`_var`-residual / d-`svar`
- `computeScalarQpJacobian()`: Jacobian component d-`_kappa`-residual / d-`_kappa`
- `computeScalarQpOffDiagJacobian(jvar_num)`: off-diagonal Jacobian component d-`_kappa`-residual / d-`jvar`
- `computeScalarQpOffDiagJacobianScalar(svar_num)`: off-diagonal Jacobian component d-`_kappa`-residual / d-`svar`

Examples of some of these methods are shown below in [#KSB-examples]. Loops over the coupled variables wrap around these quadrature loops. The integer for the spatial variable is `jvar_num` and the integer for the
scalar variable is `svar_num`.

Also, there are some pre-calculation routines that are called
within the quadrature loop once before the loop over spatial variable test and shape functions as well as
before the loop over scalar components. These methods are useful for material or stabilization calculations.

- `initScalarQpResidual()`: evaluations depending on qp but independent of test functions
- `initScalarQpJacobian(jvar_num)`: evaluations depending on qp but independent of test and shape functions
- `initScalarQpOffDiagJacobian(jsvar)`: evaluations depending on qp but independent of test and shape functions

In addition to those mentioned in the [Kernel](syntax/Kernels/index.md) documentation, you have access to
several member variables inside your `KernelScalarBase` class for computing the
residual and Jacobian values in the above mentioned functions:

- `_h`, `_l`: indices for the current test and trial scalar component respectively.
- `_kappa`: value of the scalar variable this Kernel operates on; indexed by `_h` (i.e. `_kappa[_h]`).
- `_kappa_var`: ID number of this scalar variable; useful to differentiate from others.
- `_k_order`: order (number of components) of the scalar variable.

Since the test and trial "shape" functions of a scalar are "1", variables are not required for that
value. Examples of the source codes below demonstrate this fact.

`ADKernelScalarBase` only works with MOOSE configured with global AD indexing (the default).

While these quadrature loops are convenient for implementation in a single object, the speed of
parallel execution may be slower due to the sequential assembly needed from each element assembling
to the same scalar variable `_kappa`. For greater speed, the developer may instead implement the
terms for `computeScalarQpResidual()` and `computeScalarQpJacobian()` through a derived class of `ElementIntegralUserObject` as discussed at [ScalarKernels/index.md#couple-spatial].

### Examples from Source Code id=KSB-examples

As mentioned, the `computeScalarQpResidual` method +should+ be overridden for both flavors of kernels, non-AD
and AD. As an example, consider the scalar residual weak form term of the
[`ScalarLMKernel`](/ScalarLMKernel.md) class:

\begin{equation}
  F^{(\lambda)} \equiv \int_{\Omega} \phi^h \;\text{d}\Omega - V_0 = 0 \label{eq:eq1}
\end{equation}

The [`ScalarLMKernel`](/ScalarLMKernel.md) class is implemented using the
[`GenericKernelScalar`](/GenericKernelScalar.md) template class to contain both the AD and non-AD
versions within the same source files; the test sources files in the SolidMechanics module described
at the bottom of this section appear more simply since they are non-AD only: [HTLSDR-header].
The `computeScalarQpResidual` method for this class is
provided in [scalar-kernel-non-ad-residual], where `_value/_pp_value` is equal to $V_0$.

         re=template <bool is_ad>\nGenericReal<is_ad>\nScalarLMKernelTempl<is_ad>::computeScalarQpResidual.*?}
         caption=The C++ weak-form residual statement of [eq:eq1].

Meanwhile, the contribution to the spatial variable residual of this object is associated with [eq:eq2]
and implemented in [kernel-non-ad-residual] (note that the scalar variable `_kappa` is termed as
$\lambda^h$ in this weak form).

\begin{equation}
  F^{(\phi)}_i \equiv \lambda^h \int_{\Omega} \varphi_i \;\text{d}\Omega \label{eq:eq2}
\end{equation}

         re=template <bool is_ad>\nGenericReal<is_ad>\nScalarLMKernelTempl<is_ad>::computeQpResidual.*?}
         caption=The C++ weak-form residual statement of [eq:eq2].

This object also overrides the `computeScalarQpOffDiagJacobian` method to define the Jacobian term related
to [eq:eq1] as shown in [non-ad-s-v-jacobian].

         re=template <bool is_ad>\nReal\nScalarLMKernelTempl<is_ad>::computeScalarQpOffDiagJacobian.*?}
         caption=The C++ weak-form Jacobian for d-`_kappa`-residual / d-`jvar`.

Notice that there is a conditional to confirm that the coupled `jvar` is the focus variable `_var`, otherwise it returns zero. Also, this method only returns a "Real" value since this method is only called
by the non-AD version of the class during Jacobian computation; an assert is used to verify this intention.

Similarly, it also overrides the `computeQpOffDiagJacobianScalar` method to define the Jacobian term related
to [eq:eq2] as shown in [non-ad-v-s-jacobian].

         re=template <bool is_ad>\nReal\nScalarLMKernelTempl<is_ad>::computeQpOffDiagJacobianScalar.*?}
         caption=The C++ weak-form Jacobian for d-`_var`-residual / d-`svar`.

Also notice the conditional that confirms the coupled `svar` is the focus scalar `_kappa`, otherwise it returns zero.

Depending upon the weak form and its coupling terms between spatial and scalar variables, not all of the
methods listed in [#KSB-coupling] need to be overridden.

The AD version of this object, [`ADScalarLMKernel`](/ADScalarLMKernel.md), only requires the residual
implementation. A solely AD source file would only need to override `computeScalarQpResidual` and `computeQpResidual` and leave all the Jacobian methods as base definitions, which return zero. See
[MortarScalarBase](source/constraints/MortarScalarBase.md) for examples of AD-only and non-AD separate classes.

As a more complicated example of the scalar augmentation system for kernels, the SolidMechanics test
app contains headers, source, and test files for an alternative implementation of the
"HomogenizedTotalLagrangianStressDivergence" system from the SolidMechanics module. This Kernel is
designated with the suffix "S" to distinguish from the existing objects in the module. Also, there are
other intermediate classes such as "TotalLagrangianStressDivergence" that are also designated with
an "S" suffix. These other classes are needed since the lower class needs to also derive from
`KernelScalarBase`. Meanwhile, they do not need the `scalar_variable` parameter and function
identically to their original module source object; see the [#KSB-parameters] section for a comment
about leaving this parameter blank.

The scalar augmentation system is designed such that multiple scalar variables can be coupled to
an instance of the Kernel class, each focusing on one scalar from the list. This approach is similar
to how SolidMechanics module classes operator on one component variable of the displacement vector
field and are coupled to the other components. The developer can decide how to organize the coupling
and off-diagonal Jacobian terms in a logical way and document this for the user.

Examples of two schemes for decomposing the coupling terms and having multiple scalar variables are
contained in the source files of the SolidMechanics module test directory as well as input files
`2drow.i` and `2dsole.i`, with listings below. The comments within these header and source files
serve as documentation and should be consulted to visualize how the rows and columns of the relevant
residual and Jacobian contributions are handled. The suffix "R" refers to assembling the entire row
of the Jacobian in one object, and the suffix "A" refers to assembling symmetric pairs of the residual
and Jacobian; see the header file for clarification.

         re=/// Total Lagrangian formulation.*?}
         caption=Organization of spatial and scalar variable contributions by row.


         re=/// Total Lagrangian formulation.*?}
         caption=Organization of spatial and scalar variable contributions by symmetric pairs.


The displaced mesh features are not yet tested for the scalar augmentation system.

### Parameters id=KSB-parameters

There is one required parameters the user must supply for a kernel derived
from `KernelScalarBase`:

- `scalar_variable`: the focus scalar variable of the kernel, for which assembly
  of the residual and Jacobian contributions will occur. It must be a `MooseScalarVariable`.
  This parameter may be renamed in a derived class to be more physically meaningful.

If the `scalar_variable` parameter is not specified, then the derived class will behave
identically to a regular `Kernel`, namely without any scalar functionality. This feature
is useful if the scalar augmentation in inserted into a class structure with several
levels and not all derived members use scalar variables.

As an example, the parameter listing is shown below for the `ScalarLMKernel` object
with the `scalar_variable` parameter renamed to `kappa`:


Note: to avoid an error message "Variable 'kappa' does not exist in this system", the following
block should be added to the input file:


There are also some optional parameters that can be supplied to
`KernelScalarBase` classes. They are:

- `compute_scalar_residuals`: Whether to compute scalar residuals. This
  will automatically be set to false if a `scalar_variable` parameter is not
  supplied. Other cases where the user may want to set this to false is during
  testing when the scalar variable is an `AuxVariable` and not a solution variable
  in the system.
- `compute_field_residuals`: Whether to compute residuals for the primal field
  variable. If several `KernelScalarBase` objects are used in the input file
  to compute different rows (i.e. different variables) of the global residual,
  then some objects can be targeted to field variable rows and others to scalar
  variable rows.

## KernelValue

Derive from this base class if your residual is of the form

\begin{equation}
  (\dots,\psi_i)
\end{equation}

i.e. if the test function $\psi_i$ (`_test[_i][_qp]`) can be factored out.

### Derived classes

Override

- `precomputeQpResidual()` instead of `computeQpResidual()` (do not multiply by `_test[_i][_qp]`)
- `precomputeQpJacobian()` instead of `computeQpJacobian()` (do not multiply by `_test[_i][_qp]`)
- `computeOffDiagJacobian` still has to be implemented as if deriving from `Kernel`.

## MassEigenKernel

### Description

`MassEigenKernel` is used in the context of solving eigenvalue problems of the
form

\begin{equation}
\label{eq:general}
\widetilde{A}\vec{u} = \lambda\widetilde{B}\vec{u}
\end{equation}

where $\lambda$ represents the eigenvalue and $\vec{u}$ represents the
eigenvector. Kernels that inherit from `EigenKernel` like `MassEigenKernel` are
grouped into the $\widetilde{B}\vec{u}$ term and have their residual
contributions multiplied by the eigenvalue $\lambda$. Consider the equation below

\begin{equation}
\label{eq:specific}
-\nabla^2 u + ku = \underbrace{\lambda u}_{\textrm{MassEigenKernel}}
\end{equation}

where $k$ is some reaction coefficient that accounts for loss of $u$. The terms
on the LHS of [eq:specific] are equivalent to the LHS of [eq:general]
and similarly for the right hand sides.

### Example Syntax

The kernels describing [eq:specific] are shown in the `Kernel` block below


The syntax for `MassEigenKernel` is simple, taking only its type and the
variable that the kernel acts on.




## MassLumpedTimeDerivative

### Description

Lumping of the time derivative can be useful for a couple of reasons. Lumping
helps ensure conservation of mass at a node. In a standard node-based Galerkin
approximation, fluxes from spatial terms can be thought of as "entering"
nodes. If there is no flux to a node, then the mass at that node should stay
fixed. However, if the standard Galerkin method is applied to a time derivative
term, $(\psi_i, \frac{\partial u_h}{\partial t})$ the corresponding coefficient
matrix is tri-diagonal and the mass at a node is affected by fluxes to neighboring
nodes. This can lead to violation of local mass conservation and generation of
spurious oscillations with unphysical under- and over-shoot phenomena. Lumping
fixes this problem by isolating a nodal solution from neighboring nodal
solutions in the time derivative term. Mathematically, lumping looks like
this. We start with our governing equation $u_t = Au$ where A is a
differential operator. We write our finite element solution as

\begin{equation}
  u(t, x) = \sum u_j(t) \phi_j(x)
\end{equation}

Substituting into our governing equation, we have:

\begin{equation}
  \sum u_j'\phi_j = \sum u_jA\phi_j
\end{equation}

Now we apply our test functions $\psi_i$ and integrate over the volume:

\begin{equation}
  \sum u_j' (\psi_i,\phi_j) = \sum u_j (\psi_i, A\phi_j)
\end{equation}

After applying all of our test functions, we have the matrix system

\begin{equation}
  \widetilde{M}\vec{u'} = \widetilde{K}\vec{u}
\end{equation}

where here $\vec{u}$ denotes the vector of coefficients $u_j$. $\widetilde{M}$
is the mass matrix and $\widetilde{K}$ is the stiffness matrix. Note that
neither of these matrices are ever explicitly formed in MOOSE but they are still
directly relevant. As mentioned previously, a standard Galerkin procedure
results in a tri-diagonal $\widetilde{M}$. As it turns out, the sum of the
matrix row elements in $\widetilde{M}$ is one. Lumping then consists of summing
the matrix row elements (result 1) and placing the sums on the diagonals. The
result is the identity matrix and $\widetilde{M}\vec{u'}$ becomes simply
$\vec{u'}$:

\begin{equation}
  \vec{u'} = \widetilde{K}\vec{u}
\end{equation}

As seen by the above equation, besides helping with local conservation of mass,
mass lumping makes explicit time stepping feasible because it removes the need
for solving a linear system.

### Example Syntax

The `MassLumpedTimeDerivative` syntax is simple, only taking `type` and
`variable` as shown in the kernel block below. This particular test file, from
which the kernel block is taken, demonstrates a case where the concentration of
$u$ would become negative in a non-lumped scheme for sufficiently small time
steps.





## MassMatrix

This object is meant to build mass matrices for preconditioning techniques that
require them. It is only meant for filling matrices, so all vector tag
parameters are suppressed. The [!param](/Kernels/MassMatrix/matrix_tags)
parameter default is cleared such that the user should provide some non-empty
parameter value for [!param](/Kernels/MassMatrix/matrix_tags) or
[!param](/Kernels/MassMatrix/extra_matrix_tags).




## MatBodyForce

### Description

`MatBodyForce` implements a force term given via a material property. This kernel leverages
the formation in [BodyForce](BodyForce.md) by multiplying the jacobian and residual by a
material property. Jacobian terms are given by leveraging the
[DerivativeMaterialInterface](/DerivativeMaterialInterface.md). All other implementation
details are the same as [BodyForce](BodyForce.md).

### Example Syntax





## MatCoupledForce

### Description

`MatCoupledForce` implements a right hand side forcing term of the form:

\begin{equation}
 \text{PDE} = \sum\limits_{j=1}^n c_j p_j(t, \vec{x}) v_j(t, \vec{x}),
\end{equation}
where $c_j$ are fixed coefficients, $p_j$ are material properties, and $v_j$ are coupled variables.

The weak form, in inner-product notation, is defined as

### Example Syntax

The kernel block below models the situation where variable $u$ is computed by: $u = \sum\limits_{j=1}^n c_j p_j(t, \vec{x}) v_j(t, \vec{x})$.


         block=Kernels

The answer is verified with the postprocessor:

         block=Postprocessors





## MatDiffusion


Implements the term
\begin{equation}
-\nabla\cdot D(c,a,b,\dots) \nabla u,
\end{equation}
where the diffusion coefficient $D$ (`diffusivity`) is provided by a `FunctionMaterial` function material (see `Phase Field Module` for more information), $u$ is the nonlinear variable the kernel is operating on.  

This kernel can be used in a coupled form if the optional `v` variable is
specified. This allows applying the diffusion operator to a variable $u$ given
by `v`, which is different from the kernel variable.

$D$ can depend on arbitrary nonlinear variables $a,b,\dots$ (`args`). The
complete Jacobian contributions are provided by the kernel. To build the
Jacobian the kernel uses all derivatives of $D$ with respect to the kernel
variable and the variables specified in `args`.




## MaterialDerivativeRankFourTestKernel


This kernel puts a selected tensorial (`RankFourTensor` type) material property (`material_property`) in the residual vector
and assembles the Jacobian using the derivatives of the material property as provided by the
[DerivativeMaterialInterface](/DerivativeMaterialInterface.md).

This kernel is best set up using the [MaterialDerivativeTest](/MaterialDerivativeTestAction.md) action.




## MaterialDerivativeRankTwoTestKernel


This kernel puts a selected tensorial (`RankTwoTensor` type) material property (`material_property`) in the residual vector
and assembles the Jacobian using the derivatives of the material property as provided by the
[DerivativeMaterialInterface](/DerivativeMaterialInterface.md).

This kernel is best set up using the [MaterialDerivativeTest](/MaterialDerivativeTestAction.md) action.




## MaterialDerivativeTestKernel

### Description

`MaterialDerivativeTestKernel` is a generic test `Kernel` that allows checking
the correctness of derivative material properties using the built-in Jacobian
checks in the MOOSE test harness. Its weak form is given by $(\psi_i, p)$
where p is a material property that depends on the governing
variables. `MaterialDerivativeTestKernel` inherits from
`DerivativeMaterialInterface` which gives it access to functions like
`getMaterialPropertyDerivative` and `mapJvarToCvar`, explained below:

- `getMaterialPropertyDerivative` takes a material property name
  (let's call it "p") and a variable name (let's call it "u") and returns a
  `MaterialProperty` equal to the derivative of the supplied material property
  with respect to the supplied variable, e.g. $\frac{\partial p}{\partial
  u}$.
- `mapJvarToCvar` maps the global variable number to the kernel's coupled variable number.

This interface allows for easy and elegant construction of correct Jacobians for
physics that depend on materials that are functions of governing variables.

### Example Syntax

The `Kernel` and `Material` blocks below demonstrate how to utilize the
`DerivativeMaterialInterface` capabilities in an input file.

- Kernel block


- Material block


`MaterialDerivativeTestMaterial` takes two variables, `var1` and `var2` as input
parameters. It declares a material property with the name
`material_derivative_test_property`. It also declares two material property
derivatives that are the derivatives of `material_derivative_test_property` with
respect to `var1` and `var2`. In our test input file above, we assign `var1 = u`
and `var2 = v`. Then as long as we pass `u` and `v` as coupled variables in the
`args` parameter of `MaterialDerivativeTestKernel`, we will automatically access
the correct material property derivatives in our kernel.

This kernel puts a selected scalar (`Real` type) material property (`material_property`) in the residual vector
and assembles the Jacobian using the derivatives of the material property as provided by the
[DerivativeMaterialInterface](/DerivativeMaterialInterface.md).




## MaterialPropertyValue


This kernel sets the kernel variable $u$ (`variable`) weekly enforced to the
value of a material  property $p$ (`prop`).

\left(\pm(p-u),\psi\right)

The $\pm$ sign is controlled by the `positive` boolean parameter.

This kernel can be used to emulate the action of nodal patch recovery, by finding
a projection of an interior material property onto (nodal) basis function degrees
of freedom. It can be used to generate a smooth field for outputting material
properties.





## MatReaction


Implements
\begin{equation}
(-L(v,a,b,\dots) v, \psi),
\end{equation}
where $L$ (`mob_name`) is a reaction rate, $v$ is either a coupled variable (`v`)
or - if not explicitly specified - the nonlinear variable the kernel is operating on.

Note the negative sign, which does *not* appear in [Reaction](/Reaction.md) or
[CoefReaction](/CoefReaction.md).




## NullKernel


This kernel can be used as a placeholder if a nonlinear variable was added to the simulation but
the kernels for that variable have not yet been created / added to the input file. This kernel
will ensure that the kernel coverage checking of the domain does not flag the variable as problematic.
It will also ensure that the system matrix remains invertible as it contributes a small number times
the identity matrix to the Jacobian for the variable it applies to.

### Alternatives

- Ideally, the non-linear variable should be moved to be an [auxiliary variable](syntax/AuxVariables/index.md). This will reduce the size of the nonlinear system, making it easier to solve.

- The kernel block coverage checking of the domain can also be turned off by setting `kernel_coverage_check=false` in the `[Problem]` block.

- A time derivative kernel can be used for a non-linear variable $v$ with the missing physics kernels, as this describes a valid equation $\dfrac{dv}{dt}=0$.


This kernel should mainly be used for creating small tests and while debugging simulations.




## Reaction / ADReaction

### Description

`Reaction` (and its automatic differentiation version, `ADReaction`) implements
a simple first-order reaction term where the rate of reaction is directly proportional
to the governing variable $u$. Its weak form is given by
\begin{equation}
(\psi_i, \lambda u_h)
\end{equation}
where $\lambda$ is the rate coefficient.

`Reaction` can be used to help set-up variations of advection-diffusion-reaction
equations.

### Example Syntax

The syntax for `Reaction` is simple, only taking the `type` and `variable`
parameters. An example block is shown below for a diffusion-reaction equation:


There is no FV (finite volume) version of `Reaction`. If you wish to use FV, use
[/FVCoupledForce.md].




## ScalarLagrangeMultiplier

This Kernel implements part of the equation that enforces the constraint of

\begin{equation}
 \int_{\Omega} \phi = V_0
\end{equation}

where $V_0$ is a given constant, using a Lagrange multiplier approach. The residual of $\phi$ related to the Lagrange multiplier is given as:

\begin{equation}
  F^{(\phi)}_i \equiv \lambda^h \int_{\Omega} \varphi_i \;\text{d}\Omega \label{eq:eq1}
\end{equation}

In particular, this Kernel implements the residual contribution from
the $\lambda$ in [eq:eq1] , and their Jacobian contributions. See also [AverageValueConstraint](source/scalarkernels/AverageValueConstraint.md) for the residual of the Lagrange multiplier variable.

The detailed description of the derivation can be found at [scalar_constraint_kernel](https://github.com/idaholab/large_media/blob/master/framework/scalar_constraint_kernel.pdf).




## ScalarLMKernel

This `Kernel` demonstrates the usage of the scalar augmentation class described in [KernelScalarBase.md].
This single kernel is an alternative to the combination of [ScalarLagrangeMultiplier.md],
[AverageValueConstraint](source/scalarkernels/AverageValueConstraint.md), and an
[Elemental Integral Postprocessor](source/postprocessors/ElementIntegralVariablePostprocessor.md).
All terms from the spatial and scalar variables are handled by this object.

This Kernel enforces the constraint of

\begin{equation}
 \int_{\Omega} \phi = V_0
\end{equation}

where $V_0$ is a given constant, using a Lagrange multiplier approach. Since this is
a single constraint, a single [scalar variable](source/variables/MooseVariableScalar.md) $\lambda$ is required, as shown below.

```
[Variables]
  [lambda]
    family = SCALAR
    order = FIRST
  []
[]
```

The residual of $\phi$ related to the Lagrange multiplier is given as:

\begin{equation}
  F^{(\phi)}_i \equiv \lambda^h \int_{\Omega} \varphi_i \;\text{d}\Omega \label{eq:eq1}
\end{equation}

The residual of the Lagrange multiplier $\lambda$ is given as:

\begin{equation}
  F^{(\lambda)} \equiv \int_{\Omega} \phi^h \;\text{d}\Omega - V_0 = 0 \label{eq:eq2}
\end{equation}

This Kernel implements the residual and Jacobian contributions to the spatial variable $\phi$ equation
from the $\lambda$ in [eq:eq1].
Also, it implements the residual and Jacobian contributions to the scalar Lagrange multiplier
$\lambda$ constraint equation from the spatial variable $\phi$ in [eq:eq2].

So that the input syntax matches with [ScalarLagrangeMultiplier.md], a `Postprocessor` is required
that computes the total volume of the domain, assigned to the parameter `pp_name`.

Currently, a [NullScalarKernel](source/scalarkernels/NullScalarKernel.md) is required to activate the dependency of the scalar variable within the block or subdomain of this object. See one of the example files listed below.

The detailed description of the derivation of the weak form
can be found at [scalar_constraint_kernel](https://github.com/idaholab/large_media/blob/master/framework/scalar_constraint_kernel.pdf).




## TimeDerivative

### Description

The `TimeDerivative` kernel implements a simple time derivative for the domain $\Omega$ given by

\begin{equation}
\underbrace{\frac{\partial u}{\partial t}}_{\textrm{TimeDerivative}} +
\sum_{i=1}^n \beta_i = 0 \in \Omega.
\end{equation}
where the second term on the left hand side corresponds to the strong forms of
other kernels. The corresponding `TimeDerivative` weak form using inner-product notation is

\begin{equation}
R_i(u_h) = (\psi_i, \frac{\partial u_h}{\partial t}) \quad \forall \psi_i,
\end{equation}
where $u_h$ is the approximate solution and $\psi_i$ is a finite element test function.

The Jacobian is given by

\begin{equation}
\frac{\partial R_i(u_h)}{\partial u_j} = (\psi_i, a\phi_j).
\end{equation}
where $a$ is referred to as `du_dot_du` in MOOSE syntax. More information about time kernels can be
found on the Kernels description [page](syntax/Kernels/index.md).

### Example Syntax

Time derivative terms are ubiquitous in any transient simulation. The kernel
block for a transient advection-diffusion-reaction problem that demonstrates the
`TimeDerivative` syntax is shown below:





## UserForcingFunction


This kernel has been deprecated. Please use [BodyForce.md].




## VectorBodyForce

### Description

`VectorBodyForce` is analogous to [`BodyForce`](/BodyForce.md)
except it is applied to vector finite element variables. Instead of taking one
`function` parameter, the user can pass up to three functions representing the
individual components of the vector variable. If not supplied by the user,
`function_x` will default to '1', while `function_y` and `function_z` default to '0'.




## VectorCoupledTimeDerivative


### Overview

The `VectorCoupledTimeDerivative` kernel is very similar to the
[`VectorTimeDerivative`](/VectorTimeDerivative.md) kernel with the
exception that the time derivative operator is applied to a coupled variable $\vec{v}$ instead
of the variable $\vec{u}$ to whom's residual the `VectorCoupledTimeDerivative` kernel
contributes. Consequently, the strong form on the domain $\Omega$ is

\begin{equation}
\underbrace{\frac{\partial \vec{v}}{\partial t}}_{\textrm{VectorCoupledTimeDerivative}} +
\sum_{i=1}^n \beta_i = 0 \in \Omega
\label{strong}
\end{equation}
where the second term on the left hand side corresponds to the
strong forms of other kernels. The `VectorCoupledTimeDerivative` weak form is then

\begin{equation}
R_i(\vec{u}_h) = \bigg(\vec{\psi}_i, \frac{\partial \vec{v}_h}{\partial t}\bigg) \quad \forall
\vec{\psi}_i,
\label{weak}
\end{equation}
where the $\vec{\psi}_i$ are test functions and $\vec{u}_h$ is the finite
element solution of the weak formulation.

The Jacobian contribution is equal to
\begin{equation}
\frac{\partial R_i(\vec{u}_h)}{\partial u_j} = (\vec{\psi}_i, a_v\vec{\phi}_j).
\end{equation}
where $a_v$ is a constant that depends on the time stepping scheme; $a_v$ is
denoted by `_dv_dot` in the `VectorCoupledTimeDerivative` class.

### Example Input File Syntax





## VectorDiffusion

### Description

`VectorDiffusion` is analogous to [`Diffusion`](/Diffusion.md)
except it is applied to vector finite element variables.




## VectorFunctionReaction


### Example Input File Syntax





## VectorTimeDerivative


### Overview

The `VectorTimeDerivative` kernel implements a simple time derivative for the domain $\Omega$ given by

\begin{equation}
\underbrace{\frac{\partial \vec{u}}{\partial t}}_{\textrm{VectorTimeDerivative}} +
\sum_{i=1}^n \beta_i = 0 \in \Omega.
\end{equation}
where the second term on the left hand side corresponds to the strong forms of
other kernels. The corresponding `VectorTimeDerivative` weak form using inner-product notation is

\begin{equation}
R_i(\vec{u}_h) = (\vec{\psi}_i, \frac{\partial \vec{u_h}}{\partial t}) \quad \forall \vec{\psi}_i,
\end{equation}
where $\vec{u}_h$ is the approximate solution and $\vec{\psi}_i$ is a finite element test function.

The Jacobian is given by

\begin{equation}
\frac{\partial R_i(\vec{u}_h)}{\partial u_j} = (\vec{\psi}_i, a\vec{\phi}_j).
\end{equation}
where $a$ is referred to as `du_dot_du` in MOOSE syntax. More information about time kernels can be
found on the Kernels description [page](syntax/Kernels/index.md).

### Example Input File Syntax

Time derivative terms are ubiquitous in any transient simulation. The kernel
block for a transient diffusion problem that demonstrates the
`VectorTimeDerivative` syntax is shown below:





# libtorch

# linearfvbcs

## LinearFVAdvectionDiffusionExtrapolatedBC

### Description

`LinearFVAdvectionDiffusionExtrapolatedBC` will contribute to the system matrix and right hand side
of a linear finite volume system.

To approximate the boundary value ($u_f$) two different approaches are supported depending on the setting of the
[!param](/LinearFVBCs/LinearFVAdvectionDiffusionExtrapolatedBC/use_two_term_expansion) parameter. When the two-term
expansion is enabled the face value is approximated as:

u_f = u_C + \nabla u_C \cdot \vec{d}_{Cf}~,

where $u_C$ and $\nabla u_C$ are the solution value and gradient in the boundary cell, while
$\vec{d}_{Cf}$ is the vector pointing to the face center from the boundary cell centroid.
When [!param](/LinearFVBCs/LinearFVAdvectionDiffusionExtrapolatedBC/use_two_term_expansion) is disabled the following first-order
approximation is used:

u_f = u_C.

The contributions to the system matrix and right hand side resulting from the boundary value and the
boundary normal gradient are computed accordingly.

This boundary condition should only be used for problems which involve advection and/or diffusion
problems.

### Example Syntax





## LinearFVAdvectionDiffusionFunctorDirichletBC

### Description

`LinearFVAdvectionDiffusionFunctorDirichletBC` will specify the value of a field at the boundary.
The value will be determined by a `Functor`
(through the [!param](/LinearFVBCs/LinearFVAdvectionDiffusionFunctorDirichletBC/functor) parameter).

This boundary condition should only be used for problems which involve advection and/or diffusion
problems.

### Example Syntax

In this example the functor is defined using a [MooseParsedFunction.md].





## LinearFVAdvectionDiffusionOutflowBC

### Description

`LinearFVAdvectionDiffusionOutflowBC` will contribute to the system matrix and right hand side
of a linear finite volume system. The contributions can be derived using the
integral of the advective flux over a boundary face ($S_b$) of a boundary element:

\int\limits_{S_b} \vec{v} \cdot \vec{n} u dS  \approx \vec{v}_f \cdot \vec{n} u_f |S_b|~,

where $\vec{v}_f$, $\vec{n}$ and $|S_b|$ are the outlet face velocity, outward pointing surface vector
and the surface area,

The value of $u_f$ can be computed two different ways depending on the setting of the
[!param](/LinearFVBCs/LinearFVAdvectionDiffusionOutflowBC/use_two_term_expansion) parameter. When the two-term
expansion is enabled the face value is approximated as:

u_f = u_C + \nabla u_C \cdot \vec{d}_{Cf}~,

where $u_C$ and $\nabla u_C$ are the solution value and gradient in the boundary cell, while
$\vec{d}_{Cf}$ is the vector pointing to the face center from the boundary cell centroid.
When [!param](/LinearFVBCs/LinearFVAdvectionDiffusionOutflowBC/use_two_term_expansion) is disabled the following first-order
approximation is used:

u_f = u_C.

This boundary condition assumes zero normal gradient contribution to the diffusion terms.

This boundary condition should only be used for problems which involve advection and/or diffusion
problems.

### Example Syntax





# linearfvkernels

## LinearFVAdvection

### Description

This kernel contributes to the system matrix and the right hand side
of a system which is solved for a linear finite volume variable [MooseLinearVariableFV.md].
The contributions can be derived using the discretized term of the advection term:

\int_{V_C} \nabla \cdot (u \vec{v}) dV = \sum_f\int\limits_{S_f} u \vec{v}\cdot \vec{n} dS \approx
\sum_f u_f\vec{v}\cdot \vec{n}_f|S_f|,

where $V_C$ is a cell in the mesh, while $\vec{v}$ is a pre-defined
constant advecting velocity that can be supplied through the
[!param](/LinearFVKernels/LinearFVAdvection/velocity) parameter.
The face value of the variable $u_f$ is computed using the user-selected interpolation
technique that can be supplied through the [!param](/LinearFVKernels/LinearFVAdvection/advected_interp_method) parameter.

In the simplest case, using a linear interpolation method and an internal face
for the integration, we get the following matrix contribution to the degree of freedom corresponding
to the variable on $V_C$:

\vec{v} \cdot \vec{n}_f |S_f| g_{C,f},

where $g_C$ is the geometric interpolation weight for the interpolation. Similarly, the same term
contributes to the degree of freedom on the other side of the face with:

\vec{v} \cdot \vec{n}_f |S_f| (1-g_{C,f}).

### Example input syntax

This example describes a pure advection problem with a source term on a 2D mesh.





## LinearFVAnisotropicDiffusion

### Description

This kernel contributes to the system matrix and the right hand side of a system
which is solved for a [linear finite volume variable](MooseLinearVariableFV.md).
The difference between this kernel and [LinearFVDiffusion.md] is that this kernel requires
a vector of diffusion coefficients, where every entry describes the diffusion coefficient for
a principal direction. This is equivalent to supplying a diagonal tensor in the
fully anisotropic diffusion case.

The implementation in this kernel is based on the derivation in [!cite](liu2015finite). The
contributions of the system matrix and right hand side can be derived using the divergence
theorem on a volumetric integral over cell $C$:

\int\limits_{V_C} \nabla \cdot \mathbb{D} \nabla u dV =
\sum\limits_f \int\limits_{S_f} \mathbb{D} \nabla u \cdot \vec{n} dS,

where $\mathbb{D}$ denotes a space dependent diagonal diffusion tensor, while the right hand side
describes the sum of the surface integrals on each side of cell $C$.
Following [!cite](liu2015finite) and using the assumption that the tensor is diagonal,
we can manipulate this expression to arrive to the following form:

\sum\limits_f \int\limits_{S_f} \mathbb{D} \vec{n} \cdot \nabla u dS,

where $mathbb{D} \vec{n}$ can be split into two contributions:

\mathbb{D} \vec{n} = (\mathbb{D}\vec{n}\cdot \vec{n}) \vec{n} + (\mathbb{D}\vec{n} - \mathbb{D}\vec{n}\cdot \vec{n} \vec{n}).

Plugging this expression back to the surface integral, we get the following:

\sum\limits_f \int\limits_{S_f} (\mathbb{D}\vec{n}\cdot \vec{n}) \vec{n} \cdot \nabla u +
(\mathbb{D}\vec{n} - \mathbb{D}\vec{n}\cdot \vec{n} \vec{n}) \cdot \nabla u dS,

where we can treat the normal projection ($\int\limits_{S_f} (\mathbb{D}\vec{n}\cdot \vec{n}) \vec{n} \cdot \nabla u dS$) the same way as described in [LinearFVDiffusion.md] with
$\mathbb{D}\vec{n}\cdot \vec{n}$ replacing the diffusion coefficient. The
second term ($\int\limits_{S_f} (\mathbb{D}\vec{n} - \mathbb{D}\vec{n}\cdot \vec{n} \vec{n}) \cdot \nabla u dS dS$) can be treated explicitly, similarly to the nonorthogonal correction in
[LinearFVDiffusion.md].




## LinearFVDiffusion

### Description

This kernel contributes to the system matrix and the right hand side of a system
which is solved for a linear finite volume variable [MooseLinearVariableFV.md].
The contributions can be derived using the integral of the diffusion term in the following form:

-\int\limits_{V_C} \nabla \cdot D \nabla u dV =
\sum\limits_f \int\limits_{S_f} -D \nabla u \cdot \vec{n} dS,

where we used the divergence theorem to transform a volumetric integral over cell $V_C$ of a
vector field to a sum of surface integrals over the faces of the cell.
Furthermore, $D$ denotes a space dependent diffusion coefficient.
With this, we can use the finite volume approximation for the face integrals in the following way:

-\int\limits_{S_f} D\nabla u \cdot \vec{n} dS \approx
-D_f\left(|\vec{\Delta}|[u_N - u_C] + \overline{\nabla u} \cdot \vec{k}\right) |S_f|,

where $|S_f|$ denotes the surface area.
Vectors $\vec{\Delta}$ and $\vec{k}$ are determined to respect $\vec{n} = \vec{\Delta} + \vec{k}$,
where $\vec{\Delta}$ is always parallel to the line connecting the current and neighbor cell centroids.
We use the over-relaxed approach for the split of the normal vector,
described in [!cite](moukalled2016finite) and [!cite](jasak1996error) in detail.
As shown above, using these two vectors, the approximate form of the normal-gradient is
typically split into two terms:

- $|\vec{\Delta}|[u_N - u_C]$ which describes a contribution that comes from
  a finite difference approximation of the gradient on orthogonal grids.
  Hence, it is referred to as an orthogonal contribution. For orthogonal meshes, $|\Delta|$
  is just $\frac{1}{|\vec{r}_{CN}|}$ where $|\vec{r}_{CN}|$ is the distance between the
  current and neighbor cell centroids. This term contributes a ($|\vec{\Delta}||S_f|$)
  to the diagonal and off-diagonal entries of the system matrix with different signs.
- On non-orthogonal meshes, besides $|\vec{\Delta}| = \frac{1}{|\vec{r}_{CN}*\vec{n}|}$,
  the following correction term is needed: $\overline{\nabla u} \cdot \vec{k}$, where
  $\overline{\nabla u}$ denotes the interpolated gradient at the face center computed using the cell
  gradients on the current and neighbor cells. This term is treated in an explicit manner
  meaning that it is added to the right hand side vector of the system.

For more information on the numerical representation of the diffusion term and the different
techniques used for applying boundary conditions through this kernel, see [!cite](moukalled2016finite)
and [!cite](jasak1996error).

The diffusion coefficient parameter ([!param](/LinearFVKernels/LinearFVDiffusion/diffusion_coeff))
accepts anything that supports functor-based evaluations. For more information on functors in
MOOSE, see [Functors/index.md].

### Example input syntax

The input file below shows a pure diffusion problem on a two-dimensional domain.





## LinearFVReaction

### Description

This kernel contributes to the system matrix of a system which is solved for a
linear finite volume variable [MooseLinearVariableFV.md]. The contribution for each cell
is the numerical integral of the reaction coefficient ($c$) times
the field quantity ($u$) in the following form:

\int\limits_{V_C} c u dV \approx c_C u_C V_C~,

where $u_C$, $c_C$ and $V_C$ denote the cell centroid values of $u$ and $c$ and the volume, respectively.
This means that the diagonal entry of the system matrix corresponding to cell
$C$ will be increased by $c_C V_C$.

The reaction coefficient parameter ([!param](/LinearFVKernels/LinearFVReaction/coeff))
accepts anything that supports functor-based evaluations. For more information on functors in
MOOSE, see [Functors/index.md].

### Example Syntax

The case below demonstrates the use of `LinearFVReaction` where the reaction coefficient is
supplied based upon a function form:






## LinearFVSource

### Description

This kernel contributes to the right hand side of a system which is solved for a
linear finite volume variable [MooseLinearVariableFV.md]. The contribution for each cell
is the numerical integral of the source density function ($s$) in the following form:

\int\limits_{V_C} s dV \approx s_C V_C~,

where $s_C$ and $V_C$ denote the source density at the cell centroid and the cell volume, respectively.
This integral is added to the corresponding entry of the right hand side of the linear system.
The source density parameter ([!param](/LinearFVKernels/LinearFVSource/source_density))
accepts anything that supports functor-based evaluations. For more information on functors in
MOOSE, see [Functors/index.md].

### Example Syntax

The case below demonstrates the use of `LinearFVSource` where the force term is
supplied based upon a function form:





## LinearFVTimeDerivative

### Description

This kernel represents a time derivative term in a partial differential equation
discretized using the finite volume method:

\int\limits_{V_C} \frac{\partial cu}{\partial t} dV \approx \left(\frac{\partial cu}{\partial t}\right)_C V_C~,

where $\left(\frac{\partial cu}{\partial t}\right)_C$ and $V_C$ are the time derivative of the
field value at the cell center and the cell volume, respectively.
Note that we added a multiplier, $c$ which often represents a material property.
A good example for the multiplier can be the density in the momentum equation
in the Navier Stokes equation.
This can be defined through parameter [!param](/LinearFVKernels/LinearFVTimeDerivative/factor)
that accepts anything that supports functor-based evaluations. For more information on functors in
MOOSE, see [Functors/index.md].
This kernel adds to the matrix diagonal and right hand side of a
linear system and the contributions depend on the
method chosen for time integration. For more information on available methods, see
the [TimeIntegrators](Executioner/TimeIntegrators/index.md) page.
For example, with an implicit Euler scheme the contribution to the right hand side becomes:

\frac{c_C}{\Delta t}V_C,

where $\Delta t$ and $c_C$ are the time step size and multiplier at the cell center,
respectively. With these, the contribution to the right hand side becomes:

\frac{c_C u_{old,C}}{\Delta t}V_C,

where $u_{old,C}$ represents the solution at the previous time step.

### Example Syntax

The case below demonstrates the use of `LinearFVTimeDerivative` used in a simple
linear time-dependent diffusion problem:





# markers

## BoundaryMarker


### Description

The `BoundaryMarker` is a stand-alone marker that marks all elements either
directly or within a given [!param](/Adaptivity/Markers/BoundaryMarker/distance)
to a boundary.

Currently this Marker may give inaccurate
results when using distributed meshes while also supplying the
[!param](/Adaptivity/Markers/BoundaryMarker/distance) parameter. Parts of the
boundary on different processors will not affect the distance calculation.
Marking elements directly adjacent to a boundary will always work.

This marker is not yet optimized for scalability
when using the [!param](/Adaptivity/Markers/BoundaryMarker/distance) parameter
and will have a complexity of order `O(N*M)`, where `N` is the total number of
elements in the mesh, and `M` is the number of elements adjacent to the
boundary.

### Example Input Syntax






## BoundaryPreservedMarker

### Description

This is the same as [ErrorFractionMarker](ErrorFractionMarker.md), which
marks elements for refinement or coarsening based on the fraction of the min/max error
from the supplied indicator while preserving the given boundary.

The motivation is to preserve the boundary geometry during the mesh coarsening.
Any elements that connect with the boundary will be maintained during coarsening.
These elements might be coarsened later if the boundary moves to a different location.

### Example Input File Syntax

           block=Adaptivity
           link=False





## BoxMarker


### Description

The `BoxMarker` is a stand-alone marker that marks all
elements inside and outside for coarsening or refinement. The marker
operates using a bounding box that is specified by lower and upper
extents of the bounding box, in 3 dimensions regardless of the
dimensions of the problem.


### Example Input Syntax





## ComboMarker


### Description

The `ComboMarker` is used to combine multiple markers into a single marker. This is done by
taking the maximum value of the marker value from the supplied markers. Therefore, refinement
of an element takes precedence.

### Example Input Syntax





## Errorfractionmarker


### Description

The `ErrorFractionMarker` utilizes the value from an
[Indicator](/Indicators/index.md) as a measure of "error" on each
element. Using this error approximation the following algorithm is
applied:


1. The elements are sorted by increasing error.
2. The elements comprising the "refine" fraction, from highest error to lowest, of the total error are marked for refinement.
3. The elements comprising the "coarsen" fraction, from lowest error to highest, of the total error are marked for refinement.

### Example Input Syntax





## ErrorToleranceMarker


### Description

The `ErrorTolerenceMarker` requires an approximation of
the error to be supplied via an
[Indicator](/Indicators/index.md). Using the measure of error an
element is define for coarsening or refinement using a hard tolerances:

* Refine if the element error is greater than value supplied in "refine" input parameter.
* Coarsen if the element error is less than value supplied in "coarsen" input parameter.

### Example Input Syntax





## OrientedBoxMarker


### Description

The `OrientedBoxMarker` operates the in a similar
fashion as the [BoxMarker](/BoxMarker.md); however, the box is
defined given a center, width, length, and height. The box is then
oriented by defining direction vectors for the width and length
dimensions.

The refinement flags for elements inside and/or outside of the box are
then defined.

### Example Input Syntax





## ReporterPointMarker


### Description

The `ReporterPointMarker` is a stand-alone marker that marks all
elements as either "inside" or "outside" based on whether or not the element contains a point defined by a vector of coordinates given in a `Reporter`.  

### Example Input Syntax

The mesh domain in the following input file is a 2D square with $x=(0,1)$ and $y=(0,1)$.  The marker labeled "box" gets valid coordinates from the vector coords in the `ConstantReporter`.  For this 2D domain, only points with coord/z=0 vector entries will be found inside the domain.  The final reporter vector entry with coord/z=1 will produce a point outside the domain and will be ignored.  Elements containing a point them are marked with the "REFINE" flag and empty elements are marked "DO_NOTHING".  Alternatively, empty elements could be marked with the "COARSEN" flag to coarsen the mesh if points move out of an element.

In the `ReporterPointMarker` labeled `bad_coord`, the reporter vectors containing coordinates are a different size, triggering an error.  





## UniformMarker


### Example Input Syntax





## ValueRangeMarker


### Description

The `ValueRangeMarker` utilizes an
[Indicator](/Indicators/index.md) as en estimate of error. Elements
with error estimates inside and outside of an allowable range can then
be marked for coarsening or refinement.

By default values inside the range are marked for refinement, but this
may be reversed using the "invert" parameter.

Additionally, a third state buffer region exists outside of the define
range bounds. Elements in this region may be marked to a different
state. Typically, this buffer region is used to define a region of
elements that are marked with "DO_NOTHING" to avoid having elements
marked for refinement directly adjacent to elements marked for
refinement.

### Example Input Syntax





## ValueThresholdMarker


### Description

The `ValueThresholdMarker` requires an estimate of error
be provided from an [Indicator](/Indicators/index.md). Using this
indicator an element is marked for refinement or coarsening if the
element error value above or below the coarsening and refinement
thresholds.

By default elements with error greater than the threshold defined in
the "refine" parameter will be marked for refinement. Element with
error less than the threshold defined in the "coarsen" parameters will
be marked for coarsening. This behavior can be inverted using the
"invert" parameter.

Additionally, a third buffer region can be defined. Elements in this
region may be marked to a different state. Typically, this buffer
region is used to define a region of elements that are marked with
"DO_NOTHING" to avoid having elements marked for refinement directly
adjacent to elements marked for refinement.

### Example Input Syntax





# materials

## ADDerivativeSumMaterial


### Description

This material generates new material properties that sum up the values and derivatives of a specified set of function materials. Using `args` argument the union of all sets of dependent variables has to be specified so that the `ADDerivativeSumMaterial` can gather the necessary derivatives to sum up.

### Example usage





## ADGenericConstantRankTwoTensor


### Overview

`ADGenericConstantRankTwoTensor` creates a `RankTwoTensor` material property that use
constant values to fill the tensor. The input of the constants should be column major-ordered.

### Example Input File Syntax





## ADGenericFunctionRankTwoTensor


### Overview

`ADGenericFunctionRankTwoTensor` creates a `RankTwoTensor` material property that uses
functions to fill the tensor. The input of the functions should be column major-ordered.

### Example Input File Syntax





## ADPiecewiseLinearInterpolationMaterial


This model computes a material property using a piecewise linear interpolation to define the dependence of the property on a specified variable.  The property is computed as $f(x)$ using the piecewise linear interpolation, where the coupled variable provides the value of $x$ at each location where this is evaluated.




## CompileTimeDerivativesMaterial

`CompileTimeDerivativesMaterial` is a class template that enables the creation of material classes that compute closed form expressions and their derivatives. The [CompileTimeDerivatives](CompileTimeDerivatives.md) framework is used to construct the expression derivatives at compile time.

### Template parameters


## CoupledValueFunctionMaterial


CoupledValueFunctionMaterial evaluates MOOSE Functions with a set of up to
four coupled variable values `v` as its input parameters. The coupled variable
values are substituted for the `x`,`y`,`z`, and `t` function variables in that
order.

With the [!param](/Materials/CoupledValueFunctionMaterial/parameter_order) a
custom mapping from coupled variable to function parameters can be supplied.




## DerivativeMaterialInterface

In model development, in particular using the finite element method, it is often
convenient to encapsulate expression values *together with their derivatives*.
The derivatives are often needed to compute Jacobian matrix entries.

In MOOSE we use material properties to provide values for expressions that can
be directly computed from variables in the solve. To store the derivatives of
these material properties with respect to the variables they depend on we also
use material properties. We use a standardized naming scheme to name the
material property derivatives. The derivative of a material property `F` with
respect to a variable `c` would be named `dF/dc`.

To enforce this naming scheme we provide the `DerivativeMaterialInterface`,
a *veneer* template that provides methods to *declare* and *get* material
properties that are derivatives of other material properties.

The `DerivativeMaterialInterface` is utilized by inheriting from it and
supplying the original parent class as a template argument.

### Examples

The  can be used from Materials (to declare and get material property
derivatives) or from Kernels (to get material property derivatives).

### Use in a Material class

#### Header

```c++
## nclude "DerivativeMaterialInterface.h"
## nclude "Material.h"

//...

// we template the interface on 'Material'
class MyMaterial : public DerivativeMaterialInterface<Material>
{

//...

private:
  MaterialProperty<Real> & F;
  MaterialProperty<Real> & dFdc;
  MaterialProperty<Real> & d2Fdc2;
};
```

Note that it is possible to template the interface on arbitrary classes,
including classes derived from `Material` or `Kernel`.

#### Implementation

```c++
## nclude "MyMaterial.h"

//...

MyMaterial::MyMaterial(const InputParameters & parameters) :
    DerivativeMaterialInterface<Material>(parameters),
    // get the c variable value, number, and name
    _c(coupledValue("c")),
    _c_var(coupled("c")),
    _c_name(getVar("c", 0)->name()),
    // declare material property and first and second derivative w.r.t. c
    F(declareProperty<Real>("F")),
    dFdc(declarePropertyDerivative<Real>("F", _c_name))
    d2Fdc2(declarePropertyDerivative<Real>("F", _c_name, _c_name))
{
}
```

Material property derivatives do *not* need to be declared or computed in the
same Material as their corresponding undifferentiated properties (though
oftentimes it is a natural choice that provides encapsulation).

### Use in a Kernel class

#### Header

```c++
## nclude "DerivativeMaterialInterface.h"
## nclude "Kernel.h"

//...

// we template the interface on 'Kernel'
class MyKernel : public DerivativeMaterialInterface<Kernel>
{

//...

protected:
  const MaterialProperty<Real> & F;
  const MaterialProperty<Real> & dFdc;
};
```

Note that material property derivatives that are fetched (and *not* declared) in
a class need to be stored in `const` references. It is recommended to use
constant references for regular material properties as well, if they are not
written to.

#### Implementation

```c++
## nclude "MyKernel.h"

//...

MyKernel::MyKernel(const InputParameters & parameters) :
    DerivativeMaterialInterface<Kernel>(parameters),
    // get the c variable value, number, and name
    _c(coupledValue("c")),
    _c_var(coupled("c")),
    _c_name(getVar("c", 0)->name()),
    // fetch material property and first derivative w.r.t. c
    F(getMaterialProperty<Real>("F")),
    dFdc(getMaterialPropertyDerivative<Real>("F", _c_name))
{
}
```

Here we may also request other derivatives, such as

```
  // get the eta variable value, number, and name
  _eta(coupledValue("eta")),
  _eta_var(coupled("eta")),
  _eta_name(getVar("eta", 0)->name()),
  // fetch material property and first derivative w.r.t. eta
  dFdeta(getMaterialPropertyDerivative<Real>("F", _eta_name))
```

The *eta* derivative may not necessarily be declared anywhere in the simulation.
The interface will return a default value of zero in that case (see below).

## Default values

When requesting non-existing material property derivatives using any of the
`getMaterialPropertyDerivative` methods, a *zero* object will be returned.
For `Real` types this will be `0` for vectors and tensors those will be
objects with zeroes in all entries.

Knowing this, kernels utilizing the derivatives should always implement the most
complete expressions including all possible derivatives, even though they might
not be provided in every simulation.

## DerivativeParsedMaterial


This material class does everything the `ParsedMaterial` does, plus automatic
symbolic differentiation of the function expression. The function material
property derivatives follow a naming scheme defined in
`DerivativeMaterialPropertyNameInterface`. The maximum order of derivatives
generated is set using the `derivative_order` parameter.

Only required derivatives will be evaluated (e.g. the split operator kernel does
not require third order derivatives. Second-order derivatives are only required
for the Jacobian, as discussed [here](../)).

Non linear and auxiliary variables declared in the
[!param](/Materials/DerivativeParsedMaterial/coupled_variables) parameter, constants declared in
[!param](/Materials/DerivativeParsedMaterial/constant_names) and
[!param](/Materials/DerivativeParsedMaterial/constant_expressions), material properties
declared in [!param](/Materials/DerivativeParsedMaterial/material_property_names), and
postprocessors ([!param](/Materials/DerivativeParsedMaterial/postprocessor_names)) may be
used in the parsed function expression. Note that the constants can be defined
using parsed expressions as long as these expressions only use numbers and/or
constants already defined to the left of the current constant, line in this
example:

```yaml
    constant_names       = 'T    kB         E'
    constant_expressions = '300  8.6173e-5  T*kB'
```

where `E` can be defined in terms of `T` and `kB`, as those constants are to the
left of `E`.

If a material property `M` is listed in
[!param](/Materials/DerivativeParsedMaterial/material_property_names) a special syntax
(`M(c1,c2)` where `c1` and `c2` are variables) can be used to declare variable
dependencies  as well as selecting derivatives of material properties (for
example, `d2M:=D[M(c1,c2),c2,c2]` would make the second derivative of `M` with
respect to `c2` available as `d2M` in the parsed function expression). If
variable dependencies are declared, the necessary derivatives of the coupled
material properties will be automatically pulled in when constructing the
derivatives of the parsed function.

In phase field, an application would be the definition of a mobility term

\begin{equation}
M = \frac D{\frac{\partial^2 F}{\partial c^2}}
\end{equation}

containing the second derivative of a function $F$, or a custom switching
function derivative in a Grand potential model


The *ft* defined above would have accurately constructed automatic derivatives
w.r.t. $\eta$ (`eta`), which contain second and higher derivatives of $h$ (make
sure to set the `derivative_order` of $h$ high enough!).

The [!param](/Materials/DerivativeParsedMaterial/material_property_names) are parsed by
the [`FunctionMaterialPropertyDescriptor` class](http://mooseframework.org/docs/doxygen/moose/classFunctionMaterialPropertyDescriptor.html),
which understands the following syntax:

| Expression | Description |
| - | - |
| `F` | A material property called *F* with no declared variable dependencies (i.e. vanishing derivatives) |
| `F(c,phi)` | A material property called *F* with declared dependence on 'c' and 'phi' (uses `DerivativeFunctionMaterial` rules to look up the derivatives) using the round-bracket-notation |
| `d3x:=D[x(a,b),a,a,b]` | The third derivative $\frac{\partial^3x}{\partial^2a\partial b}$ of the a,b-dependent material property *x*, which will be referred to as `d3x` in the function expression |
| `dF:=D[F,c]` | Derivative of *F* w.r.t. *c*. Although the c-dependence of *F* is not explicitly declared using the round-bracket-notation it is implicitly assumed as a derivative w.r.t. *c* is requested |
| `F_old:=Old[F]` | Old (previous time step) state of *F*. Note that no derivatives of this property are available. |
| `F_older:=Older[F]` |  Older (two time steps ago) state of *F*. Note that no derivatives of this property are available. |

Add `outputs=exodus` to the material block to automatically write all
derivatives and the function to the exodus output.




## DerivativeSumMaterial


### Description

This material generates new material properties that sum up the values and derivatives of a specified set of function materials. Using `args` argument the union of all sets of dependent variables has to be specified so that the `DerivativeSumMaterial` can gather the necessary derivatives to sum up.

### Example usage





## GenericConstant2DArray


This can be used to quickly create simple constant 2D array material properties, for testing,
for initial survey of a problem or simply because the material properties do not vary much over the
domain explored by the simulation.

### Example Input File Syntax

In this example, `GenericConstantArray` is used to define an anisotropic reaction term for this
2D diffusion-reaction simulation. The equation for the second component of $u$ contains both a reaction term
with itself and a source term from the reaction of the first component.





## GenericConstantArray


Array material properties are multi-dimensional material properties. Note that vector material properties
are also an option if the array dimension is really the number of dimensions of the problem (1D/2D/3D).

This can be used to quickly create simple constant 1D array material properties, for testing,
for initial survey of a problem or simply because the material properties do not vary much over the
domain explored by the simulation.

### Example Input File Syntax

In this example, `GenericConstantArray` is used to define an anisotropic diffusion coefficient for this 2D anisotropic diffusion-reaction
problem.





## GenericConstantMaterial / ADGenericConstantMaterial


This can be used to quickly create simple constant material properties, for testing,
for initial survey of a problem or simply because the material properties do not vary much over the
domain explored by the simulation.

### Example Input File Syntax

In this example, we create an `GenericConstantMaterial` for the diffusion coefficient for this fluid flow simulation.





## GenericConstantRankTwoTensor


### Overview

`GenericConstantRankTwoTensor` creates a `RankTwoTensor` material property that use
constant values to fill the tensor. The input of the constants should be column major-ordered.

This can be used to quickly create simple constant tensor material properties, for testing,
for initial survey of a problem or simply because the material properties do not vary much over the
domain explored by the simulation.

### Example Input File Syntax





## GenericConstantRealVectorValue


### Overview

`GenericConstantRealVectorValue` creates a `RealVectorValue` material property that use
constant values to fill the value.

This can be used to quickly create simple constant 3-vector properties, for testing,
for initial survey of a problem or simply because the material properties do not vary much over the
domain explored by the simulation.

The AD counterpart `ADGenericConstantRealVectorValue` creates a `ADRealVectorValue` material property.

### Example Input File Syntax





## GenericConstantSymmetricRankTwoTensor


### Overview

`GenericConstantSymmetricRankTwoTensor` creates a `SymmetricRankTwoTensor` material property that use
constant values to fill the tensor. The input of the constants follows the way how a `SymmetricRankTwoTensor` is filled.

This object functions similarly to the [GenericConstantRankTwoTensor](GenericConstantRankTwoTensor.md), but it leverages the symmetry property of the tensor for more efficient computation.

### Example Input File Syntax





## GenericConstantVectorMaterial


This can be used to quickly create simple constant anisotropic material properties, for testing,
for initial survey of a problem or simply because the material properties do not vary much over the
domain explored by the simulation.

### Example Input File Syntax

In this example, we create a `GenericConstantVectorMaterial` to generate an
anisotropic vector diffusivity and then compute the integral of the diffusive
flux through a specified boundary on the mesh.





## GenericFunctionMaterial


This can be used to quickly create simple functionalized material properties, for testing,
for initial survey of a problem or simply because the material properties do not vary much
from the defined function over the domain explored by the simulation.

### Example Input File Syntax

In this example, `GenericFunctionMaterial` is used to define a diffusion
coefficient that is inversely proportional to time. The diffusion coefficient is
retrieved as a `MaterialProperty` by the diffusion kernel.





## GenericFunctionRankTwoTensor


### Overview

`GenericFunctionRankTwoTensor` creates a `RankTwoTensor` material property that uses
functions to fill the tensor. The input of the functions should be column major-ordered.

### Example Input File Syntax





## GenericFunctionVectorMaterial


This can be used to quickly create simple functionalized vector material properties, for testing,
for initial survey of a problem or simply because the material properties do not vary much
from the defined function over the domain explored by the simulation.

### Example Input File Syntax

In this example, `ADGenericFunctionVectorMaterial` is used to define a linearly varying in space,
quadratic in time anisotropic diffusion coefficient for this finite volume diffusion calculation.
We add the prefix `AD` as this simulation is making use of automatic differentiation to compute the Jacobian exactly.
The diffusion coefficient is retrieved as an `ADMaterialProperty` by the diffusion kernel.





## InterpolatedStatefulMaterial...


### Description

`InterpolatedStatefulMaterial` reconstitutes the old state of a material property from the old state of the AuxVariables holding the projected components of the material property.

Variants include:

- `InterpolatedStatefulMaterialReal`
- `InterpolatedStatefulMaterialRealVectorValue`
- `InterpolatedStatefulMaterialRankTwoTensor`
- `InterpolatedStatefulMaterialRankFourTensor`

This object is set up by the [ProjectedStatefulMaterialStorageAction](ProjectedStatefulMaterialStorageAction.md).





## MaterialADConverter

The `MaterialADConverter` is used to explicitly convert regular material
properties into AD material properties and visa versa.

When using the [`MaterialADConverter`](MaterialADConverter.md) object
for RankTwoTensor eigenstrains in the
`Physics/SolidMechanics/QuasiStatic` block setting
`automatic_eigenstrain_names = true`, eigenstrains listed as MaterialADConverter
input tensors will not be included in the `eigenstrain_names` list passed. Set
the automatic/_eigenstrain/_names = false and populate this list manually if
these components need to be included.

### Description and Syntax





## MaterialFunctorConverter

The `MaterialFunctorConverter` is used to explicitly convert functors, such as [functor material properties](syntax/FunctorMaterials/index.md)
into regular non-AD or AD material properties.

If this material is indicated as [!param](/Materials/MaterialFunctorConverter/constant_on) an element or a subdomain,
we always evaluate the functor on the first quadrature point of every element, and we recommend the
[functor caching](syntax/Functors/index.md#caching) be turned on.

This `Material` handles the conversion from functor material properties to regular material properties. Unfortunately, the conversion
in the other direction, from regular material properties to functors, is not implemented and would be quite challenging
notably because of the need to handle complex material property dependency resolution.




## ParsedMaterial


Sets up a single material property that is computed using a parsed function expression.

A `ParsedMaterial` object takes the function expression as an input parameter in
the form of a Function Parser expression. Parsed materials (unlike
`ParsedFunctions`) can couple to nonlinear variables, material properties and
[functors](syntax/Functors/index.md).
In its configuration block all nonlinear variables the function depends on
([!param](/Materials/ParsedMaterial/coupled_variables)), as well as constants
([!param](/Materials/ParsedMaterial/constant_names) and
[!param](/Materials/ParsedMaterial/constant_expressions)), other material
properties ([!param](/Materials/ParsedMaterial/material_property_names)),
postprocessors ([!param](/Materials/ParsedMaterial/postprocessor_names)), and
functors ([!param](/Materials/ParsedMaterial/functor_names) and
[!param](/Materials/ParsedMaterial/functor_symbols)) are
declared. Constants can be declared as parsed expressions (which can depend on
previously defined constants). One application would be the definition of a
temperature $T$, the Boltzmann constant $k_B$, a defect formation energy $E_F$,
and then an equilibrium defect concentration defined using a Boltzmann factor
$\exp(-\frac{E_d}{k_BT})$.

### Example

The following material object creates a single property for visualization purposes.
It will be 0 for phase 1, -1 for phase 2, and 1 for phase 3





## PiecewiseConstantByBlockMaterial


### Overview

This object is useful for providing a material property value, for finite volume
calculations, that is discontinuous from subdomain to subdomain. `prop_name` is
required. The map parameter `subdomain_to_prop_value` is used for specifying the
property value on a subdomain name basis; the first member of each pair should
be a subdomain name while the second member should be a real value.




## PiecewiseLinearInterpolationMaterial


This model computes a material property using a piecewise linear interpolation to define the dependence of the property on a specified variable.  The property is computed as $f(x)$ using the piecewise linear interpolation, where the coupled variable provides the value of $x$ at each location where this is evaluated.




## VectorFromComponentVariablesMaterial

### Description

`VectorFromComponentVariablesMaterial` computes a vector material property with
name specified by the `vector_prop_name` parameter from coupled variable
components. The x-component is computed through the `u` coupled
variable. Optional coupled variables `v` and `w` compute the y- and z-components
respectively.

An example of this object's use is shown in the listing below where in this case
a velocity material property is being declared. The ability to pass constants to
the coupled variables is leveraged in this example. Actual coupled variable
instances would be used in, for example, a Navier-Stokes simulation in which the
nonlinear system solves for velocity components and the vector velocity needs to
be constructed.





# mesh

## AnnularMesh


### Description

The `AnnularMesh` mesh generator builds simple 2D annular and disc meshes.  They are created by drawing radial lines and concentric circles, and the mesh consists of the quadrilaterals thus formed.  Therefore, no sophisticated paving is used to construct the mesh.

The inner radius and the outer radius must be specified.  If the inner radius is zero a disc mesh is created, while if it is positive an annulus is created.  The annulus has just one subdomain (block number = 0), whereas the disc has two subdomains: subdomain zero consists of the outer quadrilaterals, while the other (block number = 1) consists of the triangular elements that emanate from the origin.

The minimum and maximum angle may also be specified.  These default to zero and 360, respectively.  If other values are chosen, a sector of an annulus, or a sector of a disc will be created.  Both angles are measured anti-clockwise from the $x$ axis.

The number of elements in the radial direction and the angular direction may be specified.  In addition, a growth factor on the element size in the radial direction may be chosen.  The element-size (in the radial direction) is multiplied by this factor for each concentric ring of elements, moving from the inner to the outer radius.

Sidesets are also created:

- Sideset 0 is called "rmin" and is the set of sides at the minimum radius (which is zero for the disc).
- Sideset 1 is called "rmax" and is the set of sides at the maximum radius.
- Sideset 2 is called "dmin" and is the set of sides at the minimum angle, which is created only in the case of a sector of an annulus (or disc)
- Sideset 3 is called "dmax" and is the set of sides at the maximum angle, which is created only in the case of a sector of an annulus (or disc)


### Example Syntax

A full annulus with minimum radius 1 and maximum radius 5, with smaller elements near the inside of the annulus.  (A disc would be created by setting rmin to zero.)


A sector of an annulus, sitting between 45 and 135 degrees.  (A sector of a disc would be created by setting rmin to zero.)


An example of using sidesets





## ConcentricCircleMesh


### Description

The `ConcentricCircleMesh` object is to generate meshes for concentric circles. Particularly, it would be useful to generate 2D meshes for typical LWR fuels. Users can refine meshes by providing a higher number of rings for each specified concentric circle region or a higher number of sectors in each quadrant. The test, [concentric_circle_mesh.i](test/tests/mesh/cconcentric_circle_mesh/concentric_circle_mesh.i), explains the use of the 'ConcentricCircleMesh' object. To execute the test only for generating 2D meshes,

```bash
~/projects/moose/test/moose_test-opt -i concentric_circle_mesh.i --mesh-only
```

To execute the test with the engineering and mathematical physics solvers,

```bash
~/projects/moose/test/moose_test-opt -i concentric_circle_mesh.i
```

Be aware: `ConcentricCircleMesh` only works with the ReplicatedMesh type.

#### More Information

`ConcentricCircleMesh` works by creating the first quadrant called "top_right." MooseEnum called portion controls which portion of meshes is generated. Any other one-fourth portions of circles are generated by rotating the "top_right" portion. Half portions are generated by stitching two different one-fourth portions depending on users' usages.

Users must provide the input parameters such as a number of sectors in a quadrant, a list of radii, a list of rings, the inner mesh fraction, a boolean for the volume preserving function.
* list of radii: specific locations of radii of concentric circles
* list of rings: numbers of rings for concentric circles
* inner mesh fraction: ratio of the length of the inner square to the radius of the innermost circle mesh
* volume for concentric circles can be preserved or not (on/off).

Users can choose if meshes for the moderator are added to meshes for concentric circles or not. A portion can be specified, however, it is not required. The default setting generates the full concentric circles.

### Developer Information

If you're going to enhance `ConcentricCircleMesh,` may be developing the windmill approach for the moderator might be necessary. New algorithms for adding nodes and elements, including the connectivity, may be needed. They can be found in `ConcentricCircleMesh.C`. The smoothing method can be incorporated to the developed meshes.  

### Example Syntax





## FileMesh


### Supported File Formats

The `FileMesh` is the default type for MOOSE and as the name suggests it reads the mesh from an external file. MOOSE
supports reading and writing a large number of formats and could be extended to read more.


| Extension   | Description |
| :-          | :- |
| .e, .exd    | Sandia's ExodusII format |
| .dat        | Tecplot ASCII file |
| .fro        | ACDL's surface triangulation file |
| .gmv        | LANL's GMV (General Mesh Viewer) format |
| .mat        | Matlab triangular ASCII file (read only) |
| .msh        | GMSH ASCII file |
| .n, .nem    | Sandia's Nemesis format |
| .plt        | Tecplot binary file (write only) |
| .node, .ele; .poly | TetGen ASCII file (read; write) |
| .inp        | Abaqus .inp format (read only) |
| .ucd        | AVS's ASCII UCD format |
| .unv        | I-deas Universal format |
| .xda, .xdr  | libMesh formats |
| .vtk, .pvtu | Visualization Toolkit |




## GeneratedMesh


### Description

The `GeneratedMesh` object is the built-in mesh generation capable of creating lines, rectangles, and rectangular
prisms ("boxes"). The mesh automatically creates side sets that are logically named and numbered as follows:

- In 1D, left = 0, right = 1
- In 2D, bottom = 0, right = 1, top = 2, left = 3
- In 3D, back = 0, bottom = 1, right = 2, top = 3, left = 4, front = 5

The length, width, and height of the domain, as well as the number of elements in each direction can be specified
independently.

### Example Syntax

         block=Mesh




## ImageMesh


### Description

The `ImageMesh` object is a convenience tool for setting up a mesh to match the pixel structure of a two or three
dimensional image. It is generally used in union with the [ImageFunction](/ImageFunction.md) object to
perform simulations that rely on image data, such as setting up an initial condition of a grain structure. By default
the generated mesh is sized to the dimensions of the images and creates one element per pixel.

### Example Syntax





## MeshGeneratorMesh


The `MeshGeneratorMesh` is a `MooseMesh` object on which the mesh generators will build. They may
not act directly on this mesh, but eventually, after possibly multiple mesh generators were chained
together, their contribution should be merged into this mesh.

The [!param](/Mesh/MeshGeneratorMesh/final_generator) is used when there is an ambiguity as to which
constructed mesh should be used by the simulation. A warning is output if this parameter is not provided
when an ambiguity is detected. However, in most cases, this parameter is not required and the warning
is really indicating an issue with the chaining of mesh generators.




## MooseMesh

MooseMesh is the base class that all mesh objects in MOOSE must inherit from. MooseMesh is responsible for holding the underlying
data structures holding the actual mesh (through libMesh) and caches for many commonly accessed entities. MOOSE currently requires
an active Mesh for every simulation even if the mesh is not strictly necessary when wrapping a third party application or running
non-FE type calculations. The Mesh however can consist of just a single element.

### Side sets and Node sets

MOOSE can apply several different objects to side sets and node sets to either compute quantities of interest or set boundary
conditions. It is important to understand the different between these two concepts. Node sets are simply a set of nodes, typically on
a boundary, that all contain a common ID (the node set ID). These can be created and assigned in your mesh builder program (such
as Cubit or Gmsh). Side sets are a collection of $dim - 1$ elements (sides or edges), typically on a boundary or on a plane within
your mesh. These can be created and assigned in your mesh building program.

By default, MOOSE will construct a node set corresponding to each side set within your mesh. This means that if you always prefer
side sets (to node sets) you won't have any issues applying any kind of boundary condition or other "boundary" type object within
MOOSE.

#### More detail id=more_detail

As users of MOOSE, you do have the ability to control whether side sets or node sets are automatically constructed. By default
node sets are constructed from side sets but the converse is not true. Both of these parameters can be controlled by the following
parameters (respectively)

```
Mesh/construct_node_list_from_side_list=true
Mesh/construct_side_list_from_node_list=false
```

If you have a mesh that is missing a side set (but it has a node set) you may be able to get around that issue by setting
the second parameter (from above) to true. The construction will happen at the end of the mesh generation process.

You could also use the [SideSetsFromNodeSetsGenerator.md] class to construct side sets from node
sets (or the [NodeSetsFromSideSetsGenerator.md] for vice versa). These objects allow you to manually
construct the relevant side sets and node sets earlier in the mesh generation process.

To declare subdomains which are not found on the mesh right after the mesh is setup, a list of IDs can be
specified using the [!param](/Mesh/MeshGeneratorMesh/add_subdomain_ids) parameter and/or a list of names can be specified using the
[!param](/Mesh/MeshGeneratorMesh/add_subdomain_names) parameter. This permits setting up block restricted objects that will only act
on subdomains created during the simulation (e.g. using the [CoupledVarThresholdElementSubdomainModifier.md]).
Likewise, sidesets which are not found on the mesh right after the mesh is setup, can be added with the parameters
[!param](/Mesh/MeshGeneratorMesh/add_sideset_ids) and [!param](/Mesh/MeshGeneratorMesh/add_sideset_names).

### Minimal interface

When inheriting from MooseMesh, the developer is responsible for creating the mesh and cloning the mesh (used for displaced mesh problems).
The methods that need to be overridden are "buildMesh" and "safeClone".

## PatternedMesh


The `PatternedMesh` object is similar to [TiledMesh](/TiledMesh.md) but restricted to two dimensions but
adds the ability to create a tile pattern from an arbitrary number of input meshes.

For example the input meshes shown in Figures 1 and 2 can be organized into a two dimensional pattern within the input
file, as shown below, to create the pattern shown in Figure 3.









## RinglebMesh

### Overview

This mesh can be applied to a Ringleb problem. This problem tests the spatial accuracy of high-order methods. The flow is transonic and smooth. The geometry is also smooth, and high-order curved boundary representation appears to be critical.

### Governing Equations

The governing equations are the 2D Euler equations with $\gamma = 1.4$.

### Geometry

Let $k$ be a streamline parameter, i.e., $k = constant$ on each streamline. The two stream lines for the two wall boundaries are $k=k_{max}=1.5$ for the inner wall, and $k=k_{min}=0.7$ for the outer wall. Let $q$ be the velocity magnitude. For each fixed $k$ , $k_{min} \leq k \leq k_{max}$, the variable $q$  varies between $Q_0=0.5$ and $k$ . For each $q$ , define the speed of sound $a$ , density $\rho$ , pressure $p$, and a quantity denoted by $J$ by:
\begin{equation*}
a=\sqrt{1 - \frac{\gamma-1}{2}q^2};\quad \rho = a^{\frac{2}{\gamma-1}};\quad p = \frac{1}{\gamma}a^{\frac{2 \gamma}{\gamma-1}};\quad J = \frac{1}{a} + \frac{1}{3a^3} + \frac{1}{5a^5} - \frac{1}{2}\log \frac{1+a}{1-a}
\end{equation*}

For each pair $(q,k)$, set:
\begin{equation*}
x(q,k) = \frac{1}{2\rho}\left( \frac{2}{k^2}-\frac{1}{q^2} \right) - \frac{J}{2}
\quad \mathrm{and} \quad
y(q,k) = \pm \frac{1}{k \rho q} \sqrt{1-\frac{q^2}{k^2}}
\end{equation*}

### Mesh Overlook

For example, let's consider the following input file:

```
[Mesh]
  type = RinglebMesh
  kmin = 0.7
  num_k_pts = 9
  num_q_pts = 20
  kmax = 1.2
  n_extra_q_pts = 2
  gamma = 1.4
  triangles = true
[]
```

The corresponding mesh looks like this:

       style=width:50%;

### Further RinglebMesh Documentation




## SpiralAnnularMesh

This mesh is derived from MooseMesh. It has an annular shape, and nodes are located on different concentric rings between the inner and outer circles. The elements are triangular.

Here are the required parameters :

- `inner_radius`
- `outer_radius`
- `nodes_per_ring`
- `num_rings`

Given all these parameters, the radial bias will be computed automatically.

It is also possible to specify if you want a second-order Mesh : TRI3 elements will become TRI6 elements. To do that, simply change the `use_tri6` parameter to `true`.

### Example Input File

For example, with the following input file :

```
[Mesh]
  type = SpiralAnnularMesh
  use_tri6 = true
  inner_radius = 1
  nodes_per_ring = 18
  outer_radius = 10
  num_rings = 10
[]
```

The resulting mesh looks like this :

       style=width:50%;

### Further SpiralAnnularMesh Documentation




## StitchedMesh


### Overview

The `StitchedMesh` object allows for multiple mesh files to be "stitched" together to form a single mesh for use
in a simulation. For example, consider the following three meshes.




Using the `StitchedMesh` object from within the [Mesh](/Mesh/index.md) block of the input file, as shown in the input
file snippet below, these three square meshes are joined into a single mesh as shown in Figure 4.






## TiledMesh


### Example

As the name suggests, the `TiledMesh` object may be utilized to repeat a mesh multiple times. The test, [tiled_mesh_test.i](test/tests/mesh/tiled_mesh/tiled_mesh_test.i), will be used to illustrate the use of
the `TiledMesh` object. This test file is shown at the bottom of this section for reference. To execute the test the
moose test application must be compiled:

```bash
cd ~/projects/moose/test
make -j 8
```

Then navigate to the location of the test:

```bash
cd tests/mesh/tiled_mesh
```



The example utilizes a cube (cube.e) mesh as input as shown in Figure 1, which is a regular cube on the domain from
0 to 10 in the x, y, and z-directions.

As specified in the input file for this test (see below), this mesh is then used to create two tiles in the x, y,
and z directions. To execute the example and create a new mesh, the moose test application is executed with the special "--mesh-only" flag, which indicates that only the mesh operations should be performed. Running this command will create
the resulting mesh file (tiled_mesh_test_in.e), which is intended to be used by a separate input file to run a
complete simulation.

```bash
~/projects/moose/test/moose_test-opt -i tiled_mesh_test.i --mesh-only
```






# meshdivisions

## CartesianGridDivision


The number of mesh divisions/regions is the product of the number of bins in each direction.

Points that lie outside the Cartesian grid may be assigned to the grid outer bins
using the [!param](/MeshDivisions/CartesianGridDivision/assign_domain_outside_grid_to_border)
parameter.

Using a [Positions](syntax/Positions/index.md) object as the [!param](/MeshDivisions/CartesianGridDivision/center_positions)
parameter, multiple Cartesian grids can be created around each position computed by that object. The division index
of a point is then:

\text{division index} = (i - 1) N_{\text{single division}} + \text{division index in Cartesian grid centered around position i}

with $i$ the index in the `Positions` object of the position nearest from the point and $N_{\text{single division}}$ the number of divisions for a single Cartesian grid, based on the X/Y/Z discretization specified.

For points lying within the standard tolerance of an internal boundary of the Cartesian grid, this object
will output a warning. If you do not mind the indetermination on which bins they belong to but do mind
that a warning is output, please reach out to a MOOSE (or any MOOSE app) developer.




## CylindricalGridDivision


The number of mesh divisions/regions is the product of the number of bins in each coordinate.

Points that lie outside the cylindrical grid may be assigned to the closest grid outer bins
using the [!param](/MeshDivisions/CylindricalGridDivision/assign_domain_outside_grid_to_border)
parameter.

The [!param](/MeshDivisions/CylindricalGridDivision/center) should be a point on the axis of the cylinder
that also corresponds to the reference for the minimal ([!param](/MeshDivisions/CylindricalGridDivision/cylinder_axial_min)) and maximal ([!param](/MeshDivisions/CylindricalGridDivision/cylinder_axial_max)) axial extent of the cylinder.

Using a [Positions](syntax/Positions/index.md) object as the [!param](/MeshDivisions/CylindricalGridDivision/center_positions)
parameter, multiple cylindrical grids can be created around each position computed by that object. The division index
of a point is then:

\text{division index} = (i - 1) N_{\text{single division}} + \text{division index in cylindrical grid centered around position i}

with $i$ the index in the `Positions` object of the position nearest from the point and $N_{\text{single division}}$ the number of divisions for a single cylindrical grid, based on the number of rings and axial discretization specified.

We have not implemented restrictions in the azimuthal direction so the entire ($0$, $2 \pi$) arc will be split.
This is a desirable extension of this object.

For points lying within the standard tolerance of an internal boundary of the cylindrical grid, this object
will output a warning. If you do not mind the indetermination on which bins they belong to but do mind
that a warning is output, please reach out to a MOOSE (or any MOOSE app) developer.




## ExtraElementIntegerDivision


The extra element integers are scanned throughout the mesh to determine the number of
bins.
The ordering of the divisions is the same as the numerical ordering of the extra element integers.




## FunctorBinnedValuesDivision


The number of divisions is simply equal to the number of bins.

Points that lie outside the (min_value, max_value) interval may be assigned to the outer bins
using the [!param](/MeshDivisions/FunctorBinnedValuesDivision/assign_out_of_bounds_to_extreme_bins)
parameter.

The `FunctorBinnedValuesDivision` will bin elements using the `ElemArg` functor argument. Where this is evaluated depends on
the functor, but tends to be at the element vertex average (approximation of the centroid).
The `FunctorBinnedValuesDivision` will bin points using the `ElemPointArg` functor argument. The evaluation is also
functor-implementation dependent. The element is located using the mesh point locator. If the point is located near several
elements, then the one with the lowest ID is used.

For points laying within the standard tolerance of an internal boundary of the bins, this object
will output a warning. If you do not mind the indetermination on which bins they belong to but do mind
that a warning is output, please reach out to a MOOSE (or any MOOSE app) developer.




## NearestPositionsDivision


The number of divisions is simply equal to the number of positions in the [Positions](syntax/Positions/index.md)
object specified in the [!param](/MeshDivisions/NearestPositionsDivision/positions) parameter.

For points lying within the standard tolerance of an internal boundary of the bins,
(equi-distance between the point and two positions in the `Positions` object) this object
will output a warning. If you do not mind the indetermination on which bins they belong to but do mind
that a warning is output, please reach out to a MOOSE (or any MOOSE app) developer.




## NestedDivision


The divisions are numbered from 0 to the product of the number of divisions/regions in
each of the divisions passed in the [!param](/MeshDivisions/NestedDivision/divisions) parameter.

The first division specified always corresponds to the outermost indexing. The last division specified rules
the innermost indexing. Each division object specified may have its own nesting of indexing. For example,
[CartesianGridDivision.md] nests indexing into the X, Y and Z bins.




## SphericalGridDivision


The number of mesh divisions/regions is the product of the number of bins in each coordinate, which currently only
includes the radial direction.

Points that lie outside the spherical grid may be assigned to the closest grid outer bins (on the inner or outer shell)
using the [!param](/MeshDivisions/SphericalGridDivision/assign_domain_outside_grid_to_border)
parameter.

Using a [Positions](syntax/Positions/index.md) object as the [!param](/MeshDivisions/CylindricalGridDivision/center_positions)
parameter, multiple cylindrical grids can be created around each position computed by that object. The division index
of a point is then:

\text{division index} = (i - 1) N_{\text{single division}} + \text{division index in cylindrical grid centered around position i}

with $i$ the index in the `Positions` object of the position nearest from the point and $N_{\text{single division}}$ the number of divisions for a single spherical grid, based on the number of rings specified.

We have not implemented binning in the azimuthal nor toroidal coordinates nor restrictions in those angular coordinates.
This is a desirable extension of this object.

For points lying within the standard tolerance of an internal boundary of the spherical grid, this object
will output a warning. If you do not mind the indetermination on which bins they belong to but do mind
that a warning is output, please reach out to a MOOSE (or any MOOSE app) developer.




## SubdomainsDivision


If not setting the [!param](/MeshDivisions/SubdomainsDivision/block) parameter:
The divisions are numbered from 0 to the number of blocks in the mesh minus one.
The ordering of the divisions is the same of the ordering of the IDs of the subdomains.

If specifying a block restriction using the [!param](/MeshDivisions/SubdomainsDivision/block) parameter:
The divisions are numbered from 0 to the number of blocks specified minus one. An invalid id is returned
for points and elements outside the block restriction. The order of the divisions is the same
as the ordering of the blocks in the [!param](/MeshDivisions/SubdomainsDivision/block) parameter.




# meshgenerators

## AddMetaDataGenerator


### Overview

This MeshGenerator object allows the user to add external Mesh Metadata to the input mesh. This would allow the input mesh, especially from `FileMeshGenerator`, to be compatible with those mesh generators (e.g., mesh generators in the Reactor Module) that depend on Mesh Metadata to function.





## AdvancedExtruderGenerator


### Overview

The `AdvancedExtruderGenerator` adds more customization options over the [MeshExtruderGenerator](MeshExtruderGenerator.md). This mesh generator is also capable of fixing inverted elements on-the-fly during extrusion.

### Multiple Elevations

`AdvancedExtruderGenerator` extrudes a lower-dimension mesh (1D or 2D) given by [!param](/Mesh/AdvancedExtruderGenerator/input) into a higher-dimension mesh (2D or 3D) in a direction defined by [!param](/Mesh/AdvancedExtruderGenerator/direction). The extruded mesh can have multiple elevations with variable extrusion (axial) lengths provided by [!param](/Mesh/AdvancedExtruderGenerator/heights). Each elevation can have separate subdomains, extra element extra integers, and boundaries defined. The number of axial elements in the different elevations can be provided through [!param](/Mesh/AdvancedExtruderGenerator/num_layers). Within each elevation, the axial element dimension can be biased using the corresponding growth factor value in [!param](/Mesh/AdvancedExtruderGenerator/biases).

### Subdomain ID Remapping

By default, the extruded higher-dimension elements retain the same subdomain ids as their original lower-dimension elements. `AdvancedExtruderGenerator` provides an option to remap subdomain ids for each elevation through [!param](/Mesh/AdvancedExtruderGenerator/subdomain_swaps), which is a double indexed array input parameter. Each elemental vector of [!param](/Mesh/AdvancedExtruderGenerator/subdomain_swaps) contains subdomain remapping information for a particular elevation, where the first elemental vector represents the first extruded elevation. The elemental vector contain pairs of subdomain ids: the first subdomain id is the `input` mesh subdomain id that needs to be remapped, and the second subdomain id the new subdomain id to be assigned.

### Extra Element Integer ID Remapping

Extra element integer ID remapping works in a similar manner as subdomain ID remapping. The extra element integers to be remapped must already exist in the `input` mesh and need to be specified in [!param](/Mesh/AdvancedExtruderGenerator/elem_integer_names_to_swap). Leveraging the recently updated [MOOSE input file syntax](https://mooseframework.inl.gov/application_usage/input_syntax.html) system, the remapping information of multiple extra element integers is provided as a triple-indexed array input parameter ([!param](/Mesh/AdvancedExtruderGenerator/elem_integers_swaps)). For each extra element integer, the syntax is similar to [!param](/Mesh/AdvancedExtruderGenerator/subdomain_swaps). The following input example shows the remapping of two extra element integers.


### Boundary ID Remapping

Boundary ID remapping also works similarly to subdomain ID remapping. During extrusion, the lower-dimension boundaries are also converted into higher-dimension boundaries. A double indexed array input parameter, [!param](/Mesh/AdvancedExtruderGenerator/boundary_swaps), can be used to remap the boundary ids. Here, the boundary ids to be remapped must exist in the `input` mesh, otherwise, dedicated boundary defining mesh generators, such as [SideSetsBetweenSubdomainsGenerator](SideSetsBetweenSubdomainsGenerator.md) and [SideSetsAroundSubdomainGenerator](SideSetsAroundSubdomainGenerator.md), need to be used to define new boundary ids along different axial heights.

### Interface Boundaries

The other categories of the boundaries that can be defined are the interfaces between subdomains in different elevations, as well as the top/bottom surfaces of the subdomains. As each elevation interface (or top/bottom surface) is simply a duplicate of the `input` mesh, these interface (or top/bottom surface) boundaries correspond to the subdomains of the `input` mesh, which are referred to as `source_blocks`. Also, due to the nature of sidesets, they can be defined on either side of the elevation interface. Thus, both `upward` and `downward` boundaries can be defined. Here `upward` means the normal vector of the sideset has the "same-ish" direction as the [!param](/Mesh/AdvancedExtruderGenerator/direction) vector; `downward` means the normal vector of the sideset has the "opposite-ish" direction as the [!param](/Mesh/AdvancedExtruderGenerator/direction) vector.


### Helicoidal extrusion

The user may elect to perform a helicoidal extrusion along an axis going through the (0, 0, 0) point aligned with
the extrusion [!param](/Mesh/AdvancedExtruderGenerator/direction) vector parameter. The user must then select a non-zero
[!param](/Mesh/AdvancedExtruderGenerator/twist_pitch) parameter.
After an extrusion distance of a pitch, a full rotation of the 2D shape being extruded will have been performed.
By default, the rotation is performed in a clockwise direction around the axis of extrusion. To change the direction of the rotation, please specify a negative [!param](/Mesh/AdvancedExtruderGenerator/twist_pitch).

### Example Syntax





## AllSideSetsByNormalsGenerator


### Overview

This mesh generator is useful for adding all possible sidesets to a mesh based on unique normal
directions.  It works well for more regular shapes that don't have curves or many disjoint surfaces
with similar normals.  If desired however, it is capable of following a slowly changing normal around
a surface so that a curve can be assigned a single sideset. This is accomplished by setting
*fixed_normal* to false. In this case a cylinder mesh can be given exactly three normals, one for the
two and bottom respectively, and a third normal for the curved surface of the cylinder.

The sideset number assignment is not predictable. This utility assigns sideset numbering based on the
unique normals seen while iterating over the mesh. Further enhancements could be made to more
carefully control this assignment.




## AnnularMeshGenerator


### Overview

This MeshGenerator object creates a mesh with an annular shape, and Quad4 elements distributed on several rings. The user can choose the inner and outer radii, as well as the number of elements in the radial and angular directions.

It is also possible to create a disc-shaped mesh with this class. To do so, the user has to choose 0 for the value of the inner radius. This will create a mesh composed of TRI3 elements at the center of the disc, and QUAD4 everywhere else.

If $dmin \neq 0$ and $dmax \neq 360$, this will create a fraction of an annulus or disc.

### Description

The AnnularMesh mesh generator builds simple 2D annular and disc meshes. They are created by drawing radial lines and concentric circles, and the mesh consists of the quadrilaterals thus formed. Therefore, no sophisticated paving is used to construct the mesh.

The inner radius and the outer radius must be specified. If the inner radius is zero a disc mesh is created, while if it is positive an annulus is created. The annulus has just one subdomain (block number = 0), whereas the disc has two subdomains: subdomain zero consists of the outer quadrilaterals, while the other (block number = 1) consists of the triangular elements that emanate from the origin.

The minimum and maximum angle may also be specified. These default to zero and 360, respectively. If other values are chosen, a sector of an annulus, or a sector of a disc will be created. Both angles are measured anti-clockwise from the xx axis.

The number of elements in the radial direction and the angular direction may be specified. By default, the mesh spacing is uniform in the radial direction, but the following options are available for more control over the radial meshing:
- A growth factor that controls the element size in the radial direction may be specified.  In this case, the radial element size in the innermost ring is multiplied by this factor for each concentric ring of elements, moving from the inner to the outer radius. If the growth factor is positive, the element radial dimension increases with increasing radial position, while if the growth factor is negative, the element radial dimension decreases with increasing radial position.
- A list of values that define the radial positions of the rings of interior nodes can be specified. This allows for direct control of the element size for every one of the concentric rings. In this case, the number of radial elements is not specified, because it is inferred from the length of that list.
- A flag that enforces equal areas among all of the elements. When true, this parameter will automatically determine the radial element spacing so that each element has the same area.

Sidesets are also created:

- Sideset 0 is called "rmin" and is the set of sides at the minimum radius (which is zero for the disc).
- Sideset 1 is called "rmax" and is the set of sides at the maximum radius.
- Sideset 2 is called "dmin" and is the set of sides at the minimum angle, which is created only in the case of a sector of an annulus (or disc)
- Sideset 3 is called "dmax" and is the set of sides at the maximum angle, which is created only in the case of a sector of an annulus (or disc)




## BlockDeletionGenerator


### Overview

The `BlockDeletionGenerator` is used to remove elements from a mesh matching a
user provided subdomain ID. While most mesh generation operations should be
based on geometric operations, it is sometimes easier to remove discretized
elements, by blocks, for certain problems.

For example, if we have a mesh that models both a pipe and its interior,
but we only want to model the fluid flow, we may delete the subdomain associated
with the pipe.

Once a block is deleted from the mesh, it should not be referred to in the input.
Variables and materials can no longer be block restricted to a deleted block, for example.

Lower-dimensional elements created from the deleted elements will also be removed.

### Example input syntax

In this example input file, we remove blocks 1 and 3 with a single `BlockDeletionGenerator`.
This leaves only block 2 in the simulation.





## BlockToMeshConverterGenerator


### Overview

The `BlockToMeshConverterGenerator` moves one (or more) blocks from a mesh to form a new mesh object.
This does not erase/delete the blocks from the original mesh. The new mesh has only one block (unnamed with ID 0)

No sidesets are preserved in or added to the new mesh
(neither are any element/node unique id's or ids in general, regardless of what options are set).

### Visual Example

In the input below, six selected blocks are extracted from the input 3D mesh in the first figure.
The final mesh is shown in the second figure.







## BoundaryDeletionGenerator





## BoundingBoxNodeSetGenerator


### Overview

The MeshGenerator allows the user to specify a bounding box that overlays the
mesh domain. All of the nodes inside or outside of that bounding box are then
added to a new nodeset, which is specified by the user.




## BreakBoundaryOnSubdomainGenerator





## BreakMeshByBlockGenerator


### Description

This class implements a MeshGenerator to split a monolithic mesh by blocks similar to what is proposed by VP Nguyen [!cite](Nguyen2014).

To split the mesh, nodes shared by multiple blocks are duplicated N-1 times (where N is the number of blocks sharing a particular node). Each duplicated nodes is assigned to one block and all the elements sharing that node are updated. A new sideset identifying the new interface is added, and it is always linked to elements belonging to blocks with the lower ID.

As an option, the interface can be split into $Q$ different sidesets, where $Q$ is the number of adjacent block pairs. This is achieved by setting `split_interface=true` and is useful when modeling interfaces with different parameters.

Two types of block restricted option are provided, namely `surrounding_blocks` and `block_pairs`. The `surrounding_blocks` will create interfaces surrounding specified block. When `surrounding_blocks` is provided, the additional boundary `interface_transition` can be added by setting `add_transition_interface=true`. The `interface_transition` boundary identifies the interface between the provided blocks and the rest of the mesh. The `block_pairs` option will create interfaces  only \emph{between} the specified block pairs. Multiple block pairs can be provided, and they are separated by semicolon (`;`). The `block_pairs` option does not work with `add_transition_interface`. By default when no block restricted option is used, interfaces will be generated between all blocks. In addition, the `add_interface_on_two_sides` parameter allows to generate interface boundaries on both sides of the interface which can be used to enforce thermal and mechanical contact at the interface.

### Example Input File Syntax

#### Single Interface


#### Multiple Interfaces

When `split_interface=true`, the new generated interface is split by block pairs
and named by joining the block names. For instance if one has two neighboring
blocks - one named `wood` and named `steel` with `blockID` equal to `1` and `2`,
respectively - the new interface will be named `wood_steel`. The naming order
follows the block ID order. For this simple example, the new sideset will be on
the block named `wood`. If one block is not named, its name will default to
`Block` plus the `blockID`. For instance, if block 2 is not named the new
interface will be named `wood_Block2`.


#### block_pair option

For `block_pair` option, only the nodes that are shared by specific block pairs will be newly created. In the example below, three different cases are shown, where one, two and three new nodes are created, respectively.


         block=Mesh





## BreakMeshByElementGenerator


### Overview

The `BreakMeshByElementGenerator` is used to break all element-element interfaces in specified subdomains. All element-element interfaces are grouped into a boundary of user's choice.

### Example input syntax

In this example input file, we break all element-element interfaces in subdomains 1 and 2.





## CartesianMeshGenerator


### Overview

The `CartesianMeshGenerator` object is the built-in mesh generation capable of creating lines, rectangles, and hexahedra ("boxes").
The mesh spacing can be non-uniform and each line/rectangle/hexahedron can be assigned a separate subdomain id.
The mesh automatically creates side sets that are logically named and numbered as follows:

- In 1D, left = 0, right = 1
- In 2D, bottom = 0, right = 1, top = 2, left = 3
- In 3D, back = 0, bottom = 1, right = 2, top = 3, left = 4, front = 5

The length, width, and height of each element, as well as their subdomain id can be set independently.
Each linear subdivision in x, y, or z can be additionally subdivided into sub-elements.

### Example Syntax

         block=Mesh




## CircularBoundaryCorrectionGenerator


### Overview

The `CircularBoundaryCorrectionGenerator` object performs radius correction to preserve circular area considering polygonization effect for full or partial circular boundaries in a 2D mesh within the `Z=0` plane.

In a 2D mesh, a "circular boundary" consists of sides that connect a series of nodes on the circle, which actually form a polygon boundary. Due to the polygonization effect, the area within a "circular boundary" in a 2D mesh is actually smaller than a real circle with the same radius. Such a discrepancy could cause issues in some simulations that involve physics that are sensitive to volume conservation.

Therefore, a corrected radius can be used to generate the "circle-like" polygon to enforce that the polygon area is the same as the original circle without polygonization. This can be achieved with either of the following approaches.

#### Moving Radial Nodes

The most straightforward approach for circular correction is to move the nodes on the circular boundary in their respective radial directions (see the left sub-figure of [schematic]). In that case, the azimuthal angle intervals of the boundary sides do not change. Therefore, the algorithm is relatively simple. This is also the default approach of this mesh generator.

For a polygon region used to mesh a full or partial circle, each side (with index $i$) corresponds to an azimuthal angle interval, $\theta_i$ , which is defined by the side and the center of the polygon:

S_{polygon}=\frac12r_{polygon}^2\Sigma_i~\sin \theta_i

with

\Theta_{total}=\Sigma_i~\theta_i

$\Theta_{total}$ should be $2\pi$ for a full circle and between 0 to $2\pi$ for a partial circle. For such a full or partial real circle, the area has the following form:

S_{circle}=\frac{\Theta_{total}}{2}r_{circle}^2=\frac12r_{circle}^2\Sigma_i~\theta_i

To enforce that $S_{polygon}=S_{circle}$, the radii of the polygon and the circle have the following relation,

r_{polygon}=\sqrt{\frac{\Sigma_i~\theta_i}{\Sigma_i~\sin \theta_i}}r_{circle}=f_{corr}r_{circle}

Where $f_{corr}$ is the correction factor used in this object to ensure volume preservation.

      style=display: block;margin-left:auto;margin-right:auto;width:60%;
      id=schematic
      caption=A schematic drawing showing the two approaches to correct the polygonization effect for a partial circular boundary

#### Optional additional circular boundary expansion in the span direction

Moving the radial nodes is undoubtedly the most generalized approach for a full circular boundary. However, for a partial circular boundary, moving the two end nodes in their radial directions may deform the original shape. Therefore, moving the end nodes in the span direction of the partial circular boundary (i.e., arc) provides an alternative approach (see the right subfigure of [schematic]). Moving the end nodes in the span direction inevitably changes the azimuthal angle intervals. To make this change consistent for all the boundary sides, a scaling coefficient, $c$, is applied to every $\theta_i$.

\theta_i^{corr}=c\theta_i

f=\frac{r_{polygon}}{r_{circle}}=\frac{\cos\left(\Sigma_i~\theta_i/2\right)}{\cos\left(c\Sigma_i~\theta_i/2\right)}=\sqrt{\frac{\Sigma_i~\theta_i-\sin\left(\Sigma_i~\theta_i\right)}{\Sigma_i~\sin\left(c\theta_i\right)-\sin\left(c\Sigma_i~\theta_i\right)}}

f^2=\frac{1+\cos\left(\Sigma_i~\theta_i\right)}{1+\cos\left(c\Sigma_i~\theta_i\right)}=\frac{\Sigma_i~\theta_i-\sin\left(\Sigma_i~\theta_i\right)}{\Sigma_i~\sin\left(c\theta_i\right)-\sin\left(c\Sigma_i~\theta_i\right)}

 Note that if the partial circular boundary happens to be a half circle (i.e., $\Sigma_i~\theta_i=\pi$), [span_relation_2] cannot be solved as both numerator and denominator are zero. In that case the span direction is also the radial direction. Therefore, $c$ has a trivial value of unity; and the node moving should be calculated using the "radial nodes moving" approach. If the boundary if not a half circle (i.e., $\Sigma_i~\theta_i\neq\pi$), the above equation is solved by Newton-Raphson method to obtain $c$. The displacement of the end nodes ($e_{end}$) can be calculated as follows.

e_{end}=r_{polygon}\sin\left(\frac12c\Sigma_i~\theta_i\right)-r_{circular}\sin\left(\frac12\Sigma_i~\theta_i\right)

Users should set [!param](/Mesh/CircularBoundaryCorrectionGenerator/move_end_nodes_in_span_direction) as `true` to enable this radius correction approach for partial circular boundaries.

### Usage

This object is capable of correcting multiple circular boundaries within a 2D mesh at the same time. Each circular boundary must be provided as a single boundary id/name in [!param](/Mesh/CircularBoundaryCorrectionGenerator/input_mesh_circular_boundaries).

Moving the nodes on a circular boundary may flip the local elements. In order to reduce the probability of element flipping, a transition area is defined for each circular boundary, which is a ring area covering both inner and outer sides of the circular boundary in which the nodes will be moved based on the correction factor. The moving distance fades as the node-to-circle distance increases. The transition area size is defined using a fraction of the boundary radius, which can be customized in [!param](/Mesh/CircularBoundaryCorrectionGenerator/transition_layer_ratios).

### Example Syntax





## CoarsenBlockGenerator


### Overview

This MeshGenerator object allows the user to coarsen one or more blocks in a mesh. It has been designed
to work with previously refined meshes that were saved to a file without the mesh refinement pattern information. For example, refined meshes stored using [Exodus.md] or [VTKOutput.md] file formats do not contain the information needed to recognize parent and children elements from uniform refinement. The heuristic can still work in the general case of non-uniform refinement. The heuristic is unlikely to work on a non-previously-refined mesh that we seek to coarsen.

If elements are refined, using a [RefineBlockGenerator.md] for example, during the mesh generation process, this generator will not be able to coarsen
them.

The user has to provide the ids of the blocks to be modified, as well as the corresponding levels of coarsening for each block. These must match up to the order of the aforementioned block id list, e.g. if the blocks you wish to modify are '0 2 1 4', with 1 coarsening for block 0, 2 for block 2, 3 for block 1, and 4 for block 4, then the coarsening list will need to look like '1 2 3 4'.

The user provides the starting point for the coarsening algorithm with the [!param](/Mesh/CoarsenBlockGenerator/starting_point) parameter. The element containing that point is found, then the algorithm attempts to coarsen by selecting each node of that element as the interior node of a coarse element containing that element. Once this element is coarsened, the neighbors of the coarse element
are considered as targets for the next round of coarsening, until all elements are coarsened once for that round of coarsening. If
the user has specified more than one round of coarsening, the algorithm is iterated.

The starting point should be in the most refined region of the mesh
and it should also be in the subdomain that the user has selected to be the most coarsened. These are
due to limitations in the algorithm used for coarsening.

Every block to be coarsened should be in a contiguous region of finer elements. The algorithm used for
selecting new candidates for coarsening is not able to skip an already coarse region to reach other fine
regions to coarsen.

This mesh generator currently only works with QUAD and HEX elements and only outputs QUAD4 / HEX8 elements respectively. Please
contact a MOOSE developer if you require a different element type. If you are wanting to coarsen a triangle
or tetrahedral elements mesh though, it would probably be easier for you to just re-generate the mesh with a
coarser size.

If the mesh has been refined in a prior simulation using MOOSE h-refinement, please use a [Checkpoint.md] `.cpr`
format, and then regular [Adaptivity](syntax/Adaptivity/index.md) to coarsen instead of this mesh generator.

If the input mesh has non-conformalities due to prior use of adaptive mesh refinement,
this mesh generator may be able to remove them.
However if the input mesh is disjoint (for example, nodes are not stitched together between two neighbor elements), this will not be improved. You may try a [MeshRepairGenerator.md]
to stitch overlapping nodes before using a `CoarsenBlockGenerator`.

Sidesets containing sides that were coarsened into a coarser element side will not contain the coarse
side. This is not implemented.




## CombinerGenerator


### Overview

The `CombinerGenerator` allows the user to combine the outputs of multiple `MeshGenerator`s into a single mesh.  This is somewhat similar to the [StitchedMeshGenerator.md] with the difference being that `CombinerGenerator` makes no attempt to "heal" / "join" the mesh like [StitchedMeshGenerator.md] does.  There `CombinerGenerator` is more suited to creation of disjoint meshes (where the individual pieces are not directly tied together).

`CombinerGenerator` preserves subdomain names and boundary names (node sets, side sets, and edge sets).
If the corresponding IDs exist in multiple meshes, then the meshes/copies listed
later in [!param](/Mesh/CombinerGenerator/inputs)/[!param](/Mesh/CombinerGenerator/positions)
take precedence.

### Usage

There are three main ways to use the `CombinerGenerator`:

#### 1. Combine Multiple `MeshGenerator`s

The most straightforward thing to do is simply to combine the output of multiple `MeshGenerator`s together into a single mesh.  For example:

         block=Mesh

Will generate a mesh that looks like:



#### 2. Combine Multiple `MeshGenerator`s AND Translate Them

It is also possible to translate (move) the input `MeshGenerator`s as they are combined.  This is done using the `positions` option which takes triplets of floating point numbers that are interpreted as displacement vectors for moving each of the input meshes.

If you specify `positions` then the number of `positions` must match the number of `inputs`, unless only one input is specified (more on that in a moment).

         block=Mesh

Will generate a mesh that looks like:


Alternatively, the same displacement vectors can be supplied in a file with the `positions_file` option. The above mesh can equivalently be generated with the following.

         block=Mesh

where the `positions.txt` file contains the floating point triplets.


The same restrictions on `positions` also apply to the number of entries in `position_file`.

#### 3. Copy a Single Input Multiple Times With Translations

The final option is to provide exactly one `inputs` but specify multiple `positions`.  This will cause the single input to be copied multiple times with the position of each copy specified by the `positions` parameter.  For example

         block=Mesh

Will generate a mesh that looks like:


Again, the same capability can be achieved with the `positions_file` option.




## ConcentricCircleMeshGenerator


### Overview

The `ConcentricCircleMeshGenerator` object is used to generate a 2D mesh for concentric circles.
Users can refine the mesh by providing a high number of rings for each specified concentric circle
region or a high number of sectors in each quadrant. The test, [concentric_circle_mesh_generator.i](test/tests/meshgenerators/concentric_circle_mesh_generator/concentric_circle_mesh_generator.i),
explains the use of the `ConcentricCircleMeshGenerator` object. To execute the test, only generating
a 2D mesh:

```bash
~/projects/moose/test/moose_test-opt -i concentric_circle_mesh_generator.i --mesh-only
```

To execute the test with the engineering and mathematical physics solvers:

```bash
~/projects/moose/test/moose_test-opt -i concentric_circle_mesh2.i
```

Be aware: `ConcentricCircleMeshGenerator` only works with Replicated meshes.

#### More Information

`ConcentricCircleMeshGenerator` works by creating the first quadrant, called "top_right." An input
parameter, called [!param](/Mesh/ConcentricCircleMeshGenerator/portion), controls which portion of
mesh would be generated. Any other one-fourth portions of circles are generated by rotating the
"top_right" portion. Half portions are generated by stitching two different one-fourth portions
depending on users' preference.

Users must provide the input parameters, such as:

- number of azimuthal sectors in a quadrant
- list of radii: specific locations of radii of concentric circles
- list of rings: numbers of rings for concentric circles
- inner mesh fraction: ratio of the length of the inner square to the radius of the innermost circle mesh
- whether the volume for concentric circles should be preserved or not (true/false)
- iteration number: number of iterations for Laplace smoothing

Users can choose if the mesh for the enclosing square is added to the concentric circle mesh or not.
A portion can be specified, however, it is not required. The default setting generates the full
concentric circles.

### Developer Information

If one needs to enhance `ConcentricCircleMeshGenerator,` Laplace smoothing has to be constrained to
the center circle. Efficient algorithms for adding nodes and elements, including the connectivity,
may be needed. They can be found in `ConcentricCircleMeshGenerator.C`.

### Example Syntax





## CutMeshByLevelSetGenerator


### Overview

The `CutMeshByLevelSetGenerator` is an extended version of [`CutMeshByPlaneGenerator`](/CutMeshByPlaneGenerator.md). It is used to trim a 3D input mesh based on a given level set `f(x,y,z)=0`. The portion of the input mesh that is within the level set (i.e., `f(x,y,z)<=0`) is retained, while the portion of the input mesh that is outside the level set (i.e., `f(x,y,z)>0`) is discarded. The input mesh, given by [!param](/Mesh/CutMeshByLevelSetGenerator/input), must be 3D and contain only first-order elements. The level set is specified by [!param](/Mesh/CutMeshByLevelSetGenerator/level_set), which can be interpreted by `FParser` as a function of `x`, `y`, and `z` (i.e., `f(x,y,z)`). As each element that is across the cutting level set is cut based on the interception points, this mesh generator ensures a smooth cut instead of a "zigzag" cut along element boundaries.

Using this mesh generator, a 3D structured mesh defined by a bounding box (e.g., generated by [`GeneratedMeshGenerator`](/GeneratedMeshGenerator.md)) can be subtracted into a 3D mesh with its shape define by a given level set.

### Methods

`CutMeshByLevelSetGenerator` first converts all elements of the input mesh into `TET4` elements. Next, the `TET4` elements sliced by the level set are further split into `TET4` elements. This mesh generator uses exact the same algorithm as its sibling mesh generator, [`CutMeshByPlaneGenerator`](/CutMeshByPlaneGenerator.md). At the first-order element level, cutting by a plane and cutting by a level set are the same.

### Example Syntax






## CutMeshByPlaneGenerator


### Overview

The `CutMeshByPlaneGenerator` is basically the 3D version of [`XYMeshLineCutter`](/XYMeshLineCutter.md). It is used to slice a 3D input mesh along a given plane, and discard the portion of the mesh on one side of the plane. The input mesh, given by [!param](/Mesh/CutMeshByPlaneGenerator/input), must be 3D and contain only first-order elements. The cutting plane is specified by [!param](/Mesh/CutMeshByPlaneGenerator/plane_normal) and [!param](/Mesh/CutMeshByPlaneGenerator/plane_point), which are two `libMesh::Point` type data that represent the normal vector of the cutting plane and a point on the cutting plane, respectively. This mesh generator removes the part of the mesh located on the side of the plane in the direction of the normal vector. As each element that is across the cutting plane is cut based on the interception points, this mesh generator ensures a straight cut instead of a "zigzag" cut along element boundaries as generated by [`PlaneDeletionGenerator`](/PlaneDeletionGenerator.md).

### Methods

`CutMeshByPlaneGenerator` first converts all elements of the input mesh into `TET4` elements. Next, the `TET4` elements sliced by the cutting plane are further split into `TET4` elements. 

#### Splitting of Non-TET4 Elements

The splitting of non-TET4 elements was performed using the same algorithm as described in [`ElementsToTetrahedronsConverter`](/ElementsToTetrahedronsConverter.md). Note that only those elements that will be fully or partially retained after the cutting are split.

#### Cutting of TET4 Elements along Plane

Once all the elements of the input mesh have been converted into TET elements, the cutting method only needs to be applied to TET elements. First, all the elements that are cut by the given cutting plane are identified. For the TET elements involved, their relationship with the cutting plane can be categorized into one of the six cases shown in [tet_cut]. For each of these six cases, new nodes are created at the intersection points between the cutting plane and the edges of the TET element. Then the red part of the original TET element is removed and new TET element(s) are created as shown in [tet_cut]. The cross-sections created by this cutting procedure are assigned a new boundary ID as defined by [!param](/Mesh/CutMeshByPlaneGenerator/cut_face_id)

      style=display: block;margin-left:auto;margin-right:auto;width:75%;
      id=tet_cut
      caption=The six possible cases when slicing a TET element. The cutting plane intersection with the element is shown as blue faces. The red part of the original TET element is removed after cutting, while the blue part of the original TET element is kept and split into multiple TET elements if necessary.

### Example Syntax






## DistributedRectilinearMeshGenerator


### Overview

Similar to GeneratedMeshGenerator - builds lines, rectangles and rectangular prisms.  
It differs though in the way the mesh is constructed in parallel.  
While `GeneratedMeshGenerator` creates a full copy of the mesh on every processor
- `DistributedRectilinearMeshGenerator` only creates the
elements / nodes each processor is assigned.  This makes it _much_ faster
in parallel and much leaner in memory.

Be aware: `DistributedRectilinearMeshGenerator` turns on `parallel_type = distributed`.  
So make sure that everything you're using in your problem works with that before using this!

#### More Information

`DistributedRectilinearMeshGenerator` works by first creating a "dual graph" of the element connectivity
- before ever building an elements.  
It then uses [PetscExternalPartitioner.md] to partition that graph - assigning elements to processors.  
Then, each processor can read the partition map and build only the elements that need to be on that processor.  
Final steps include adding in "ghosted" elements and making sure that boundary conditions are right.

### Example Syntax





## ElementGenerator


### Overview

This MeshGenerator object allows the user to create a single element (it is possible to create a simple mesh by adding elements one by one).

The user has to provide the positions of the nodes for their element, as well as the type of element they want (QUAD4, TRI3,...) and the element node connectivity.

### Further ElementGenerator Documentation




## ElementOrderConversionGenerator


### Overview

The `ElementOrderConversionGenerator` converts all the elements of the [!param](/Mesh/ElementOrderConversionGenerator/input) mesh into the element types that are specified by an order category parameter, [!param](/Mesh/ElementOrderConversionGenerator/conversion_type):

- `FIRST_ORDER`: Converts the input mesh with second-order and/or higher-order elements into a mesh with only first-order elements. 
- `SECOND_ORDER_NONFULL`: Converts the input mesh with first-order elements into a mesh with second-order elements. For those first-order element types with two second-order equivalents, this option only converts the elements to the "non-full-ordered" element types. Note that the original "full-ordered" second-order or higher-order elements in the input mesh are retained without conversion (i.e., no downgrades).
- `SECOND_ORDER`: Converts the input mesh with first-order elements and/or "non-full-ordered" second-order elements into a mesh with "full-ordered" second-order elements.
- `COMPLETE_ORDER`: Converts the input mesh with first-order elements and/or second-order elements into a mesh with "complete" order elements.

The element type conversion maps of different [!param](/Mesh/ElementOrderConversionGenerator/conversion_type) options are summarized in [conversion_map_1d], [conversion_map_2d], and [conversion_map_3d]

|   | EDGE2 | EDGE3 |
| - | - | - |
| `FIRST_ORDER` | EDGE2 | EDGE2 |
| `SECOND_ORDER_NONFULL` | EDGE3 | EDGE3 |
| `SECOND_ORDER` | EDGE3 | EDGE3 |
| `COMPLETE_ORDER` | EDGE3 | EDGE3 |

|   | TRI3 | TRI6 | TRI7 | QUAD4 | QUAD8 | QUAD9 |
| - | - | - | - | - | - | - |
| `FIRST_ORDER` | TRI3 | TRI3 | TRI3 | QUAD4 | QUAD4 | QUAD4 |
| `SECOND_ORDER_NONFULL` | TRI6 | TRI6 | TRI7 | QUAD8 | QUAD8 | QUAD9 |
| `SECOND_ORDER` | TRI6 | TRI6 | TRI7 | QUAD9 | QUAD9 | QUAD9 |
| `COMPLETE_ORDER` | TRI7 | TRI7 | TRI7 | QUAD9 | QUAD9 | QUAD9 |

|   | TET4 | TET10 | TET14 | HEX8 | HEX20 | HEX27 | PRISM6 | PRISM15 | PRISM18 | PRISM20 | PRISM21 | PYRAMID5 | PYRAMID13 | PYRAMID14 | PYRAMID18 |
| - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
| `FIRST_ORDER` | TET4 | TET4 | TET4 | HEX8 | HEX8 | HEX8 | PRISM6 | PRISM6 | PRISM6 | PRISM6 | PRISM6 | PYRAMID5 | PYRAMID5 | PYRAMID5 | PYRAMID5 |
| `SECOND_ORDER_NONFULL` | TET10 | TET10 | TET14 | HEX20 | HEX20 | HEX27 | PRISM15 | PRISM15 | PRISM18 | PRISM20 | PRISM21 | PYRAMID13 | PYRAMID13 | PYRAMID14 | PYRAMID18 |
| `SECOND_ORDER` | TET10 | TET10 | TET14 | HEX27 | HEX27 | HEX27 | PRISM18 | PRISM18 | PRISM18 | PRISM20 | PRISM21 | PYRAMID14 | PYRAMID14 | PYRAMID14 | PYRAMID18 |
| `COMPLETE_ORDER` | TET14 | TET14 | TET14 | HEX27 | HEX27 | HEX27 | PRISM21 | PRISM21 | PRISM21 | PRISM21 | PRISM21 | PYRAMID18 | PYRAMID18 | PYRAMID18 | PYRAMID18 |




## ElementsToSimplicesConverter


An input mesh, as specified in the
[!param](/Mesh/ElementsToSimplicesConverter/input) parameter, will be modified
to replace each non-simplex mesh element with a set of simplices
connecting the same nodes.  Each quad is split into 2 triangles, each
pyramid into 2 tetrahedra, each prism into 3 tets, and each cube into
6 tets.

The input mesh must be "flat", not hierarchically refined.

The algorithm in 2D splits quads along their shortest interior
diagonal, to try to improve element quality.

Currently the algorithm in 3D uses node ids to decide on splitting
directions in a consistent way across face neighbors; this may change
in the future.

In 3D, the geometry of any non-planar quadrilateral faces of cubes
and/or prisms will not be exactly preserved, due to the change from
bilinear or biquadratic mapping on quadrilaterals to linear or
quadratic mapping on the triangles that replace them.




## ElementsToTetrahedronsConverter


### Overview

The `ElementsToTetrahedronsConverter` converts a 3D mesh that consists of first-order elements (e.g., TET4, PYRAMID5, PRISM6, and HEX8) into a mesh that only contains TET4 elements.

### Methods

All original mesh elements which are not TET4 type are converted into TET4 elements through splitting by this mesh generator. To be specific, each HEX8 element is split into six TET4 elements; each PRISM6 element is split into three TET4 elements; and each PYRAMID5 element is split into two TET4 elements. Details on the splitting approach follow.

      style=display: block;margin-left:auto;margin-right:auto;width:32%;float:left;
      id=hex_split
      caption=An example of splitting of a HEX8 element into six TET4 elements.

      style=display: block;margin-left:auto;margin-right:auto;width:32%;float:left;
      id=prism_split
      caption=An example of splitting of a PRISM6 element into three TET4 elements.

      style=display: block;margin-left:auto;margin-right:auto;width:36%;float:left;
      id=pyramid_split
      caption=An example of splitting of a PYRAMID5 element into two TET4 elements.

After this conversion, all the elements become TET4 elements. In that case, all the subdomain IDs and names can be preserved.

#### Splitting of HEX8 Elements

There are multiple ways to split one HEX8 element into multiple TET4 elements, resulting in either five or six TET4 elements (or even more if additional nodes can be added). A splitting method that does not require adding nodes needs to split each of the six quadrilateral faces of a HEX8 element into two triangles, which can be done in two different ways for each face. As these quadrilateral faces could be shared with neighboring HEX8 or other types of elements, the splitting of the quadrilateral faces on neighboring elements must be performed consistently. To achieve a consistent splitting approach, which will be discussed later in this documentation page, a HEX8 element needs to be split into six TET4 elements. An example of this splitting is illustrated in [hex_split]. Note that the splitting approach shown in [hex_split] is not unique and will be discussed later.

#### Splitting of PRISM6 Elements

A PRISM6 element can be split into three TET4 elements. An example of this splitting is illustrated in [prism_split]. Note that the splitting approach shown in [prism_split] is not unique and will be discussed later. Namely, the three quadrilateral faces of a PRISM6 element need to be split consistently with the neighboring elements.

#### Splitting of PYRAMID5 Elements

A PYRAMID5 element can be split into two TET4 elements. An example of this splitting is illustrated in [pyramid_split]. Note that the splitting approach shown in [pyramid_split] is not unique and will be discussed later. Namely, the one quadrilateral face of a PYRAMID5 element needs to be split consistently with the neighboring elements.

#### Consistent Splitting for Neighboring Elements

As discussed above, although splitting of non-TET elements into TET4 elements is not unique, it is crucial to ensure that the splitting of the neighboring elements involves consistent splitting of the quadrilateral faces. To achieve this, the following approach is used. For each quadrilateral face, there are two ways to split it into two triangles, which correspond to the two diagonal lines of the quadrilateral face. Therefore, in order to ensure that one of the two diagonal lines is selected consistently for all the elements, the diagonal line that involves the node with the lowest global node ID among the four nodes of the quadrilateral face is selected.

### Example Syntax






## ExamplePatchMeshGenerator

### Overview

This MeshGenerator object allows the user to create 2D or 3D patch meshes.  The
2D patch mesh has one interior element and four exterior elements, and the 3D
patch test has one interior element and six exterior elements.  Each element in
a patch mesh has a unique shape.  See [!cite](macneal1985patch) for details on
these meshes.

The resulting mesh has sidesets named left, right, top, and bottom, and if a 3D
mesh, sidesets named front and back.





## ExtraNodesetGenerator


If you look up node IDs in Paraview for the [!param](/Mesh/ExtraNodesetGenerator/nodes) parameter,
note that you need to subtract 1 from the IDs listed in Paraview, since Paraview starts its indexing
from 1 instead of from 0 like in MOOSE.




## FileMeshGenerator


### Supported File Formats

The `FileMeshGenerator` is the default type for MOOSE and as the name suggests it reads the mesh from an external file. MOOSE
supports reading and writing a large number of formats and could be extended to read more.

Reading with the `FileMeshGenerator`. These capabilities are inherited from the
libMesh file IO readers.

| Extension   | Description |
| :-          | :- |
| .e, .exd    | Sandia's ExodusII format |
| .bxt        | DynaIO |
| .cpr        | Checkpoint file |
| .fro        | ACDL's surface triangulation file |
| .mat        | Matlab triangular ASCII file |
| .msh        | GMSH ASCII file |
| .n, .nem    | Sandia's Nemesis format |
| .node, .ele; .poly | TetGen ASCII file |
| .inp        | Abaqus .inp format |
| .off        | OFF |
| .ucd        | AVS's ASCII UCD format |
| .unv        | I-deas Universal format |
| .xda, .xdr  | libMesh formats |
| .vtk, .pvtu | Visualization Toolkit |

Writing (using the [Outputs](syntax/Outputs/index.md) block). We list these formats here
for convenience if you are considering using MOOSE as a mesh file converter.

| Extension   | Description              | Output type |
| :-          | :-                       | :- |
| .e, .exd    | Sandia's ExodusII format | [Exodus.md] |
| .cpr        | Checkpoint file          | [Checkpoint.md] |
| .dat        | Tecplot ASCII file       | [Tecplot.md] |
| .gmv        | LANL's GMV (General Mesh Viewer) format | [GMVOutput.md] |
| .n, .nem    | Sandia's Nemesis format  | [Nemesis.md] |
| .plt        | Tecplot binary file      | [Tecplot.md] |
| .xda, .xdr  | libMesh formats          | [XDA.md] |
| .vtk, .pvtu | Visualization Toolkit    | [VTKOutput.md] |

These formats (for writing meshes) are supported by libMesh and could easily be added to MOOSE if needed:

| Extension     | Description                       |
| :-            | :-                       | :- |
| .fro          | ACDL's surface triangulation file |
| .mesh, .meshb | Medit |
| .msh          | GMSH ASCII file |
| .node, .ele; .poly | TetGen ASCII file |
| .ucd          | AVS's ASCII UCD format |


### Unsupported File Formats

These file formats are unsupported, however, using other tools they can be converted to supported formats.
In general, the mesh must respect the limitations of the target format for a successful conversion.

Tools offering conversion capabilities:

- [Paraview](https://www.paraview.org/)
- [meshio](https://pypi.org/project/meshio/2.3.5/), can also be installed with `mamba/conda`
- [em2ex](https://github.com/cpgr/em2ex)

The conversion capabilities to be able to read those files are summarized here for convenience:

| Extension   | Description | Conversion tool | Target format |
| :-          | :-          | :-              | :-     |
| .msh        | ANSYS msh   | meshio          | Exodus |
| .avs        | AVS-UCD     | meshio          | Exodus |
| .cgns       | CGNS        | meshio/Paraview | Exodus |
| .xml        | DOLFIN xml  | meshio          | Exodus |
| .case       | EnSight     | Paraview        | Exodus |
| .f3grid     | FLAC3D      | meshio          | Exodus |
| .grdecl     | Eclipse     | em2ex           | Exodus |
| .csv        | Leapfrog Geothermal | em2ex   | Exodus |
| .h5m        | H5M         | meshio          | Exodus |
| .mdpa       | Kratos/MDPA | meshio          | Exodus |
| .mesh, .meshb | Medit     | meshio          | Exodus |
| .med        | MED/Salome  | meshio          | Exodus |
| .bdf/.fem/.nas | Nastran  | meshio          | Exodus |
| .vol        | Netgen      | meshio          | Exodus |
|             | Neuroglancer | meshio         | Exodus |
| .obj        | OBJ         | meshio          | Exodus |
| .post, .dato | PERMAS     | meshio          | Exodus |
| .ply        | PLY         | meshio          | Exodus |
| .stl        | STL         | meshio          | Exodus |
| .svg        | SVG         | meshio          | Exodus |
| .su2        | SU2         | meshio          | Exodus |
| .ugrid      | UGRID       | meshio          | Exodus |
| .tin        | WKT TIN     | meshio          | Exodus |
| .xdmf, .xmf | XDMF        | meshio          | Exodus |

### Extra element integer

When reading a mesh file in Sandia's ExodusII format, users can use parameter `exodus_extra_element_integers` to load elemental variables for setting extra element integers of the mesh.
The names of the extra element integers will be the same as the names of the
element variables in the mesh file.

### Exodus restart

This generator can also be used for
restarting variables from the Exodus file format. In order to indicate that the
mesh file can be used to restart variables, simply set the parameter
`use_for_exodus_restart = true`. The `initial_from_file_var` parameter must also
be set in the variables sub-block as described in [MooseVariableBase.md#restart]
in order to perform variable restart.

Additional documentation about restarting from Exodus may be found in the [restart-recovery page](restart_recover.md optional=True).

### Loading a split mesh

[Mesh splits](syntax/Mesh/splitting.md) usually do not require a `FileMeshGenerator`, they can be performed and loaded from the command line. The only use case for loading a split mesh using a `FileMeshGenerator` is to perform additional mesh generation on the split. For example, a 2D split mesh can be pre-split before extrusion to avoid ever having to load the full 3D mesh in serial.

To load a split mesh using the `FileMeshGenerator`, split your mesh as usual using the command line:

```
- mpirun -n 4 <executable> -i <input_file> --split-mesh 16 --split-file mesh_splitted
```

then load it with the `FileMeshGenerator` input parameter by using distributed meshes with the command line option:

```
- mpirun -n 4 <executable> -i <input_file> --distributed-mesh
```

Input file:

```
[fmg]
  type = FileMeshGenerator
  file = 'mesh_splitted.cpr'
[]
```




## FillBetweenCurvesGenerator


### Overview

The `FillBetweenCurvesGenerator` offers similar functionality to [`FillBetweenPointVectorsGenerator`](/FillBetweenPointVectorsGenerator.md) by leveraging [`FillBetweenPointVectorsTools`](/FillBetweenPointVectorsTools.md). Instead of manually inputting the two boundaries [!param](/Mesh/FillBetweenPointVectorsGenerator/positions_vector_1) and [!param](/Mesh/FillBetweenPointVectorsGenerator/positions_vector_2), The `FillBetweenCurvesGenerator` directly takes boundary information from the two input meshes ([!param](/Mesh/FillBetweenCurvesGenerator/input_mesh_1) and [!param](/Mesh/FillBetweenCurvesGenerator/input_mesh_2)) that contain the curve meshes consisting of `Edge2` elements (e.g., generated by [`ParsedCurveGenerator`](/ParsedCurveGenerator.md)). The input meshes can be translated using [!param](/Mesh/FillBetweenCurvesGenerator/mesh_1_shift) and [!param](/Mesh/FillBetweenCurvesGenerator/mesh_2_shift).

      style=display: block;margin-left:auto;margin-right:auto;width:80%;
      id=example_tlc
      caption=A typical example of using `FillBetweenCurvesGenerator` to connect a logarithmic curve and a circular curve.

All the other meshing options are the same as [`FillBetweenPointVectorsGenerator`](/FillBetweenPointVectorsGenerator.md).

### Example Syntax





## FillBetweenPointVectorsGenerator


### Overview

The `FillBetweenPointVectorsGenerator` class uses the fundamental functionalities of [`FillBetweenPointVectorsTools`](/FillBetweenPointVectorsTools.md). Therefore, this class provides a testing tool for `FillBetweenPointVectorsTools` as well as a generalized platform for users to create meshes using the tool set. Users are required to provide the three major inputs needed to use `FillBetweenPointVectorsTools`:

- [!param](/Mesh/FillBetweenPointVectorsGenerator/positions_vector_1) and [!param](/Mesh/FillBetweenPointVectorsGenerator/positions_vector_2): the vectors of points on the two boundaries (i.e., Side 1 and Side 2).
- [!param](/Mesh/FillBetweenPointVectorsGenerator/num_layers): number of element sublayers.

Aside from these fundamental input parameters, users can also assign block and the external boundary IDs through [!param](/Mesh/FillBetweenPointVectorsGenerator/block_id) and [!param](/Mesh/FillBetweenPointVectorsGenerator/input_boundary_1_id)/[!param](/Mesh/FillBetweenPointVectorsGenerator/input_boundary_2_id)/[!param](/Mesh/FillBetweenPointVectorsGenerator/begin_side_boundary_id)/[!param](/Mesh/FillBetweenPointVectorsGenerator/end_side_boundary_id).

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=transition
      caption=A schematic drawing showing different transition layer meshes generated between two arc boundaries: (left to right) very fine mesh, fine mesh, and coarse mesh; (top to bottom) uniformly distributed nodes, slightly biased nodes, and heavily biased nodes.

In general, `FillBetweenPointVectorsGenerator` handles many different scenarios. As shown in [Figure 1](#transition), non-uniformly distributed boundary nodes (i.e., biased) may be input. The mesh generator does have some limitations. For example, the two input curves cannot intersect each other; and the interpolated nodes should not lead to flipped elements or overlapped elements. Due to the complexity of geometry, the mesh generator may not produce an error message in all the problematic cases. Users should cautiously examine the generated mesh by setting [!param](/Mesh/FillBetweenPointVectorsGenerator/show_info) as `true` and by running a simple diffusion problem.

The spacings of element sublayers can be biased by setting [!param](/Mesh/FillBetweenPointVectorsGenerator/bias_parameter). Any positive [!param](/Mesh/FillBetweenPointVectorsGenerator/bias_parameter) is directly used as the fixed mesh biasing factor with the default value 1.0 for non-bias. By setting [!param](/Mesh/FillBetweenPointVectorsGenerator/bias_parameter) as 0.0, automatic biasing will be used, where the local node density values on the two input boundaries are used to determine the local biasing factor (see [Figure 2](#bias) as an example). In that case, Gaussian blurring is used to smoothen the local node density to enhance stability of the algorithm, which can be tuned through [!param](/Mesh/FillBetweenPointVectorsGenerator/gaussian_sigma).

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=bias
      caption=A schematic drawing showing different biasing option for sublayers: (left) non-bias; (middle) fixed biasing factor = 0.8; (right) automatic biased based on boundary nodes.


In some special cases, when [!param](/Mesh/FillBetweenPointVectorsGenerator/positions_vector_1) and [!param](/Mesh/FillBetweenPointVectorsGenerator/positions_vector_2) have the same length, users can set [!param](/Mesh/FillBetweenPointVectorsGenerator/use_quad_elements) as true to construct the transition layer mesh using quadrilateral elements (see [Figure 3](#quad) as an example).

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=quad
      caption=A schematic drawing showing a transition layer meshed by quadrilateral elements.

### Example Syntax





## FillBetweenSidesetsGenerator


### Overview

The `FillBetweenSidesetsGenerator` offers similar functionality to [`FillBetweenPointVectorsGenerator`](/FillBetweenPointVectorsGenerator.md) by leveraging [`FillBetweenPointVectorsTools`](/FillBetweenPointVectorsTools.md). Instead of manually inputting the two boundaries [!param](/Mesh/FillBetweenPointVectorsGenerator/positions_vector_1) and [!param](/Mesh/FillBetweenPointVectorsGenerator/positions_vector_2), The `FillBetweenSidesetsGenerator` directly takes boundary information ([!param](/Mesh/FillBetweenSidesetsGenerator/boundary_1) and [!param](/Mesh/FillBetweenSidesetsGenerator/boundary_2)) of two input meshes, [!param](/Mesh/FillBetweenSidesetsGenerator/input_mesh_1) and [!param](/Mesh/FillBetweenSidesetsGenerator/input_mesh_2). The input meshes can be translated using [!param](/Mesh/FillBetweenSidesetsGenerator/mesh_1_shift) and [!param](/Mesh/FillBetweenSidesetsGenerator/mesh_2_shift). The generated transition layer mesh can be output as a standalone mesh or a stitched mesh with the input meshes, depending on [!param](/Mesh/FillBetweenSidesetsGenerator/keep_inputs).

      style=display: block;margin-left:auto;margin-right:auto;width:80%;
      id=example_tlc
      caption=A typical example of using `FillBetweenSidesetsGenerator` to connect two square meshes together.

If [!param](/Mesh/FillBetweenSidesetsGenerator/keep_inputs) is set as `true`, the original boundaries of the input meshes defined by [!param](/Mesh/FillBetweenSidesetsGenerator/boundary_1) and [!param](/Mesh/FillBetweenSidesetsGenerator/boundary_2) are deleted after stitching the input meshes with the generated transition layer mesh.

All the other meshing options are the same as [`FillBetweenPointVectorsGenerator`](/FillBetweenPointVectorsGenerator.md).

### Example Syntax





## FlipSidesetGenerator


### Overview

The `FlipSidesetGenerator` object flips the normal of a sideset by changing the element the sideset is attached to. 
The sideset cannot be flipped if the original element it is attached to does not have a neighbor through the sideset. 




## GeneratedMeshGenerator


### Overview

The `GeneratedMeshGenerator` object is the built-in mesh generation capable of creating lines, rectangles, and rectangular
prisms ("boxes"). The mesh automatically creates boundaries that are logically named and numbered as follows:

- In 1D, left = 0, right = 1
- In 2D, bottom = 0, right = 1, top = 2, left = 3
- In 3D, back = 0, bottom = 1, right = 2, top = 3, left = 4, front = 5

The length, width, and height of the domain, as well as the number of elements in each direction can be specified
independently.




## ImageMeshGenerator


### Overview

The `ImageMeshGenerator` object is a convenience tool for setting up a mesh to match the pixel structure of a two or three
dimensional image. It is generally used in union with the [ImageFunction](/ImageFunction.md) object to
perform simulations that rely on image data, such as setting up an initial condition of a grain structure. By default
the generated mesh is sized to the dimensions of the images and creates one element per pixel.




## ImageSubdomainGenerator


### Example Syntax

Normal usage of ImageSubdomainGenerator involves creation of a standard mesh (in the example, `GeneratedMeshGenerator`), using that mesh as the input for ImageSubdomainGenerator, and providing an image to sample. See an example below:


In this example, the parameter `threshold` is used. This sets a color value above which the subdomain ID is set to `upper_value` (default = 1) and below which the subdomain ID is set to `lower_value` (default = 0). More information about these and other extended parameters can be seen below in the Input Parameters section.

#### Input Image (kitten.png)


#### Mesh Subdomain ID Output





## LowerDBlockFromSidesetGenerator


### Overview

This mesh generator accepts a list of sidesets and creates a lower dimensional
block of elements along those sides. The order of the newly create lower
dimensional element block will match the order of the parent elements
(e.g. first order for first order parents, second order for second order parents).

Element sides are not explicitly meshed in MOOSE/libMesh, i.e. no shape functions
live on the lower dimensional sides. To run kernels on lower dimensional manifolds
they need to be explicitly meshed. That can be accomplished in a mesh generation
tool like Cubit, or using this MeshGenerator.

In 3D simulations, the appropriate 2D elements (for 2D simulations, 1D elements)
will be meshed in at selected side sets (boundaries).

### Coupling between side and volume meshes

The newly-generated lower dimensional side elements will share nodes with the higher
dimensional volume's elements. Coupling to the variables from volume elements
"just works".

Coupling in the other direction is not as straight forward. The lower dimensional
variables exist on some nodes of the adjacent volume elements. The volume kernels
will run on the volume quadrature points at which *tapered off* values from the
adjacent edges can be found. Use at your own risk.




## MeshCollectionGenerator


### Overview

The `MeshCollectionGenerator` creates a new mesh that is a collection of
sub-meshes (provided in the `inputs` parameter). The sub-meshes are not linked in
any way and interaction between them only occurs due to contact or other
constraints.




## MeshDiagnosticsGenerator


This mesh generator currently will only accept serialized meshes.  This is most easily accomplished by leaving the mesh type set to `replicated`.
Some of the diagnostics would work as well for distributed meshes, contributions are welcome.

The diagnostics implemented are presented below. The filters and visualization capabilities in Paraview or
other visualization software may be leveraged for further diagnostics of mesh issues.

### Element volume check

Turn this check on with the [!param](/Mesh/MeshDiagnosticsGenerator/examine_element_volumes) parameter.

A minimum and a maximum element volume can be specified to the `MeshDiagnosticsGenerator` using
the [!param](/Mesh/MeshDiagnosticsGenerator/minimum_element_volumes) and the
[!param](/Mesh/MeshDiagnosticsGenerator/maximum_element_volumes) parameters.
These diagnostics are mostly used to detect zero or negative volume elements, from distorted meshes.

Large elements may be sub-divided using the [RefineBlockGenerator.md] with for example a
[!param](/Mesh/RefineBlockGenerator/max_element_volume).

Negative volume elements can be flipped using a [MeshRepairGenerator.md] with the
[!param](/Mesh/MeshRepairGenerator/fix_elements_orientation) parameter. This will flip them, making the volume
positive, though it may not fix the Jacobian everywhere.

### Side planarity check

Turn this check on with the [!param](/Mesh/MeshDiagnosticsGenerator/examine_nonplanar_sides) parameter.

Non-planar elements are generally *supported* in MOOSE. However, the ray-tracing capabilities treat them
approximately at the moment, so it may be useful to examine the mesh before use.

### Subdomain element types check

Turn this check on with the [!param](/Mesh/MeshDiagnosticsGenerator/examine_element_types) parameter.

The [Exodus.md] output format only supports a single element type (TRI3, QUAD4, HEX8, HEX20, etc) per
subdomain. Rather than erroring at the time of output, this diagnostic outputs which subdomains present
multiple element types.

Subdomains with mixed element types can be split by element type using a [MeshRepairGenerator.md] with the
[!param](/Mesh/MeshRepairGenerator/separate_blocks_by_element_types) parameter.

### Sideset orientation check

Turn this check on with the [!param](/Mesh/MeshDiagnosticsGenerator/examine_sidesets_orientation) parameter.

Sidesets are oriented. They are represented in MOOSE by a list of elements and sides. Along the boundary,
the orientation of these sides should in general be consistent. If it is not, the normal of the sideset is
essentially reversed from one side to the next in the sideset.

The sideset orientation check is a heuristic for a common error case.
The sideset orientation is only checked for sides that are delimiting two different subdomains. The check
makes sure that the order of the subdomains, e.g. which one owns the element and which one owns the element on the
other side of the side (the neighbor), does not change throughout the sideset.

### Element overlap checks

Turn this check on with the [!param](/Mesh/MeshDiagnosticsGenerator/examine_element_overlap) parameter.

Overlap between elements are generally undesirable. Overlapping elements can be associated with non-conformality and/or
breaks in the mesh, which generally are not supported without special numerical treatments, such as using
[interface kernels](syntax/InterfaceKernels/index.md) or mortar methods. Beyond having disconnected elements, the
overlap means the volume of the mesh does not match the physical space volume, raising concerns about accuracy.

We support two heuristics to detect these overlaps:

- detecting when the centroid of an element is inside another element
- detecting when a node of an element is inside another element

These two checks are heuristics. They can have false negatives if elements overlap but in a way that the centroids
and nodes remain outside of other elements. This can happen for example with curved side elements overlapping on a side.

### Non-conformality check

Turn this check on with the [!param](/Mesh/MeshDiagnosticsGenerator/examine_non_conformality) parameter.

Non-conformality in MOOSE is generally only supported if it is arising from adaptive mesh refinement created
by the underlying mesh library. Additional information about the parent/child relationship between coarse and fine
elements is stored at the element level. However, numerous external meshes, especially arising from simulations
using adaptive mesh refinement, will present non-conformality. To support them, we usually resort to special numerical treatments,
such as mortar methods.

Non-conformality is detected by this diagnostic by looking for nodes that are near an element within a tolerance but
not part of this element's nodes.

If the non-conformality is extremely minor, and the non-conformal nodes are very close to other nodes,
they can be merged together using a [MeshRepairGenerator.md].

#### Non-conformality arising from Adaptive Mesh Refinement

Turn this check on with the [!param](/Mesh/MeshDiagnosticsGenerator/search_for_adaptivity_nonconformality) parameter.

In the special case of meshes where isotropic adaptive h-refinement was performed, the `MeshDiagnosticsGenerator` can detect
at the interface between coarse and fine elements that the fine elements could be combined into a coarse element.
The coarse element, if it were refined with MOOSE h-adaptivity, would be refined into the same fine elements as
originally present in the mesh.

This check will only detect mesh refinement for triangle and quadrilateral 2D elements and, tetrahedral and hexahedral 3D
elements. For tetrahedra, because the refinement pattern depends on the selection of a diagonal inside the coarse element,
the check only considers the `tip` fine elements on the four vertex of the coarse element.

This check is a heuristic. It will only detect adaptive *uniform* mesh refinement and it will only detect it
near interfaces between coarse and fine elements. If the entire mesh is refined the same number of times for each
element, it will not be detected.

This check may report false positives on some immersed meshes and slit meshes because it will detect non-conformal nodes
and will try to examine if the elements next to these nodes can be grouped to form coarser elements.

### Elements and sides local Jacobian check

The local Jacobian is checked for positivity for every element and sides. Negative Jacobians are a common issue
with a poor, usually externally generated, mesh.

A fifth-order Gauss quadrature is used for this check. If you intend to use another quadrature, for example a higher
order to integrate more accurately high order finite element variables,
feel free to modify the generator for your needs.

### Example input syntax: all diagnostics turned on

In this example, we examine a very basic mesh with all the diagnostics offered by the `MeshDiagnosticsGenerator`.
This simple mesh presents no issue.





## MeshExtruderGenerator


### Overview

The mesh extruder generator is a tool for increasing the dimensionality of a lower dimension mesh (1D or 2D). Each element is converted
to one or more copies of its corresponding higher dimensional element along the specified axis. The Mesh Extruder can also add
in the extra sidesets resulting from increasing the dimensionality of the original mesh. Existing sidesets are extruded.

Through the `existing_subdomains`, `layers`, and `new_ids` options, it is possible to specify that an extruded block exists in some layers,
 but not others. This allows for serrated patterns and gaps. Note that no error will be thrown if the resulting blocks overlap. These three
  options must have the same number of values given to them.  The extrusion vector may use decimal values. 

### Visual Example

#### Input 2D Mesh


#### Output of MeshExtruderGenerator





## MeshGenerator

This is the base class for the `MeshGenerator` system.

There are two types of mesh generators:

- Those who create a mesh (examples: [GeneratedMeshGenerator.md], [AnnularMeshGenerator.md], [FileMeshGenerator.md]).
- Those who modify an existing mesh (examples: [MeshExtruderGenerator.md], [StitchedMeshGenerator.md], [RenameBlockGenerator.md], [RenameBoundaryGenerator.md]).

The purpose of these objects is to create complex meshes using only one input file. Indeed, you can use several MeshGenerator blocks in your input file. Those represent the different steps necessary to create your complex mesh. Note that an option exists for printing mesh information to screen (see [#showing-mesh-information]) for tracking down problems when generating complex meshes with multiple mesh generators.

### Input File Example

```
[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 3
    ny = 3
    nz = 3
  []

  [tmg]
    type = TiledMeshGenerator
    input = gmg
    x_width = 1
    y_width = 1
    z_width = 1

    left_boundary = left
    right_boundary = right
    top_boundary = top
    bottom_boundary = bottom
    front_boundary = front
    back_boundary = back

    x_tiles = 2
    y_tiles = 1
    z_tiles = 5
  []
[]

[Outputs]
  exodus = true
[]
```

Let's analyze the different steps. First, we use a [GeneratedMeshGenerator.md] to create a 3D mesh labeled `gmg` (here it's simply a regular cube). After that, we use this mesh as an input (via `input = gmg`) to create a larger mesh using a [TiledMeshGenerator.md].

### Developing a MeshGenerator

For mesh generators that create a mesh, care must be taken as to the parallel type of the mesh. You will override the `generate()` method, obtain a base mesh object, and then return your generated mesh. For obtaining the base mesh object, there are three options:

- If the mesh to be generated is agnostic to the parallel type (that is, it can be either replicated or distributed), use `MeshGenerator::buildMeshBaseObject()` to generate the base mesh. See [GeneratedMeshGenerator.md] for an example.
- If the mesh to be generated is only replicated, use `MeshGenerator::buildReplicatedMesh()` to generate the base mesh.
- If the mesh to be generated is only distributed, use `MeshGenerator::buildDistributedMesh()` to generate the base mesh. See [DistributedRectilinearMeshGenerator.md] for an example.

You should +only+ use these APIs to create the base mesh in generators that create meshes. This is very important, because the internal preparation of the meshes for use is dependent on the parallel type of the mesh.

For mesh generators that modify an existing mesh, you should have as an input parameter a `MeshGeneratorName` (or multiple, as a `std::vector<MeshGeneratorName>` if applicable) to obtain the mesh(es) to modify. You can then obtain said meshes via `MeshGenerator::getMesh()` and `MeshGenerator::getMeshByName()`. For examples, see [RenameBoundaryGenerator.md] and [StitchedMeshGenerator.md]. You then act on said meshes by overriding the `generate()` method, and returning the resulting mesh.

#### Using Sub MeshGenerators

Your mesh generator can instantiate subgenerators itself, to create existing meshes for the primary generator to combine and/or modify.  The easiest way to do this is to call `MeshGenerator::addMeshSubgenerator()`, which takes as arguments the generator class name and object name to instantiate, followed by an arbitrary number of name/value pairs of subgenerator parameters to set. Sub generators can be chained together by coupling them via input parameters, that is, setting input names as the names of other sub generators. To obtain a mesh from a sub generator, use the same `MeshGenerator::getMeshByName()` API as described above but with the name of the created sub generator.

If you wish to use an input mesh from the primary generator as an input to a sub generator, you must first call `MeshGenerator::declareMeshForSub()` or `MeshGenerator::declareMeshForSubByName()` to declare said input as a dependency for the sub generator instead of the generator that creates the sub generator.

#### Declaring a Null or Dummy Input

By default, the MeshGenerator system assumes that all parameters of type `MeshGeneratorName` or `std::vector<MeshGeneratorName>` are to be used as mesh inputs. If one of said names is not found, an error will be reported stating that the input mesh cannot be found. There exist cases where you want to allow the user to provide a "null" or dummy value for an input. An example is letting the user define a hole in a mesh pattern.

You may do this by using the `MeshGenerator::declareNullMeshName()` API. This API takes a name that is to be considered unused as an input mesh. Any input with this name will not be searched for as an existing MeshGenerator mesh and will return an uninitialized mesh when using the input mesh getters (`MeshGenerator::getMesh()`, etc).

### Showing Mesh Information

The parameter [!param](/Mesh/GeneratedMeshGenerator/show_info) prints to screen detailed information about a mesh immediately after it is generated. It can be used to quickly verify properties about the mesh such as: sidesets, subdomains, and volumes.

Take the simple example:

```
[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    ny = 2
    show_info = true
  []
```

The above will result in on-screen output similar to the following (ran with two processes):

```
GeneratedMeshGenerator 'gmg':  Mesh Information:
GeneratedMeshGenerator 'gmg':   elem_dimensions()={2}
GeneratedMeshGenerator 'gmg':   spatial_dimension()=2
GeneratedMeshGenerator 'gmg':   n_nodes()=25
GeneratedMeshGenerator 'gmg':     n_local_nodes()=15
GeneratedMeshGenerator 'gmg':   n_elem()=16
GeneratedMeshGenerator 'gmg':     n_local_elem()=8
GeneratedMeshGenerator 'gmg':     n_active_elem()=16
GeneratedMeshGenerator 'gmg':   n_subdomains()=1
GeneratedMeshGenerator 'gmg':   n_partitions()=2
GeneratedMeshGenerator 'gmg':   n_processors()=2
GeneratedMeshGenerator 'gmg':   n_threads()=1
GeneratedMeshGenerator 'gmg':   processor_id()=0
GeneratedMeshGenerator 'gmg':   is_prepared()=true
GeneratedMeshGenerator 'gmg':   is_replicated()=true
GeneratedMeshGenerator 'gmg':
GeneratedMeshGenerator 'gmg':  Mesh Bounding Box:
GeneratedMeshGenerator 'gmg':   Minimum: (x,y,z)=(       0,        0,        0)
GeneratedMeshGenerator 'gmg':   Maximum: (x,y,z)=(       1,        1,        0)
GeneratedMeshGenerator 'gmg':   Delta:   (x,y,z)=(       1,        1,        0)
GeneratedMeshGenerator 'gmg':
GeneratedMeshGenerator 'gmg':  Mesh Element Type(s):
GeneratedMeshGenerator 'gmg':   QUAD4
GeneratedMeshGenerator 'gmg':
GeneratedMeshGenerator 'gmg':  Mesh Nodesets:
GeneratedMeshGenerator 'gmg':   None
GeneratedMeshGenerator 'gmg':
GeneratedMeshGenerator 'gmg':  Mesh Sidesets:
GeneratedMeshGenerator 'gmg':   Sideset 0 (bottom), 4 sides (EDGE2), 4 elems (QUAD4), 5 nodes
GeneratedMeshGenerator 'gmg':    Side volume: 1
GeneratedMeshGenerator 'gmg':    Bounding box minimum: (x,y,z)=(       0,        0,        0)
GeneratedMeshGenerator 'gmg':    Bounding box maximum: (x,y,z)=(       1,        0,        0)
GeneratedMeshGenerator 'gmg':    Bounding box delta: (x,y,z)=(       1,        0,        0)
GeneratedMeshGenerator 'gmg':   Sideset 1 (right), 4 sides (EDGE2), 4 elems (QUAD4), 5 nodes
GeneratedMeshGenerator 'gmg':    Side volume: 1
GeneratedMeshGenerator 'gmg':    Bounding box minimum: (x,y,z)=(       1,        0,        0)
GeneratedMeshGenerator 'gmg':    Bounding box maximum: (x,y,z)=(       1,        1,        0)
GeneratedMeshGenerator 'gmg':    Bounding box delta: (x,y,z)=(       0,        1,        0)
GeneratedMeshGenerator 'gmg':   Sideset 2 (top), 4 sides (EDGE2), 4 elems (QUAD4), 5 nodes
GeneratedMeshGenerator 'gmg':    Side volume: 1
GeneratedMeshGenerator 'gmg':    Bounding box minimum: (x,y,z)=(       0,        1,        0)
GeneratedMeshGenerator 'gmg':    Bounding box maximum: (x,y,z)=(       1,        1,        0)
GeneratedMeshGenerator 'gmg':    Bounding box delta: (x,y,z)=(       1,        0,        0)
GeneratedMeshGenerator 'gmg':   Sideset 3 (left), 4 sides (EDGE2), 4 elems (QUAD4), 5 nodes
GeneratedMeshGenerator 'gmg':    Side volume: 1
GeneratedMeshGenerator 'gmg':    Bounding box minimum: (x,y,z)=(       0,        0,        0)
GeneratedMeshGenerator 'gmg':    Bounding box maximum: (x,y,z)=(       0,        1,        0)
GeneratedMeshGenerator 'gmg':    Bounding box delta: (x,y,z)=(       0,        1,        0)
GeneratedMeshGenerator 'gmg':
GeneratedMeshGenerator 'gmg':  Mesh Edgesets:
GeneratedMeshGenerator 'gmg':   None
GeneratedMeshGenerator 'gmg':
GeneratedMeshGenerator 'gmg':  Mesh Subdomains:
GeneratedMeshGenerator 'gmg':   Subdomain 0: 16 elems (QUAD4, 16 active), 25 active nodes
GeneratedMeshGenerator 'gmg':    Volume: 1
GeneratedMeshGenerator 'gmg':    Bounding box minimum: (x,y,z)=(       0,        0,        0)
GeneratedMeshGenerator 'gmg':    Bounding box maximum: (x,y,z)=(       1,        1,        0)
GeneratedMeshGenerator 'gmg':    Bounding box delta: (x,y,z)=(       1,        1,        0)
GeneratedMeshGenerator 'gmg':   Global mesh volume = 1
```

The parameter [!param](/Mesh/GeneratedMeshGenerator/output) enables the output of a mesh file immediately after it is generated. It can be used to view the intermediate meshes block during mesh generation.

Take the simple example:


The above will result in an intermediate mesh file 'left_in.e' in addition to the final mesh file 'output_intermediate_mesh_in.e' when ran in mesh only mode.

### Using data-driven generation

The system optionally supports the capability to do "data-driven" generation. With data-driven generation, a `generateData()` method is overriden on each generator and
said generator is set to support this generation by calling

```
MeshGenerator::setHasGenerateData(params);
```

within the parameters of the generator.

The parameter [!param](/Mesh/MeshGeneratorMesh/data_driven_generator) is then set in the top
level `Mesh` block, in which you set the name of the generator that will consume data-driven
generators. When this is set, all parents of the generator described in the parameter will
generate only by calling `generateData()`, and not `generate()`. Thus, they will simply
generate metadata and not an actual mesh. The generator that is set in
[!param](/Mesh/MeshGeneratorMesh/data_driven_generator) will call `generate()`, and all
other dependents will as well. All sub-generators of a generator that is ran in
data-only mode will also be ran in data-only mode.

Note that all generators that have this method enabled will always call `generateData()`
during generation, and will only call `generate()` afterwards if they are not the parent
to a generator that is data-driven.

This is an advanced method that requires a heavy understanding of all generators that
exist in the generation tree, and thus it is not enabled by default. To enable it, the
parameter `allow_data_driven_mesh_generation` on your application can be set to true.

## MeshRepairGenerator


### Overview

The `MeshRepairGenerator` provides a collection of operations to repair defects / modify features in a mesh.
If the defects/features are not present in the mesh, the `MeshRepairGenerator` does not modify the mesh.
The operations currently implemented are:

- overlapping node merges. This operation considers all nodes in the entire mesh and looks for nodes in neighboring
  elements that may overlap. If overlaps are found, only one node is kept.

- flipping the orientation of negative volume elements. Negative volume elements can arise from a wrong orientation.

- separating elements in subdomains into several subdomains depending on their element types. Subdomains with a mix of
  element types are not supported by [Exodus.md] output. The new split subdomains' names have the type of the element appended to their respective names.

- merging boundaries with the same name but different boundary IDs.




## MoveNodeGenerator


### Overview

This MeshGenerator object allows the user to Move one or more nodes' locations on an existing mesh.

The user has to provide the ids the nodes to be modified. Nodes can then be moved by either providing the new positions for each node or a shift to apply to each node.




## NodeSetsFromSideSetsGenerator


### Overview

This MeshGenerator object allows the user to generate a corresponding node set for every side set in the mesh.
It does not delete or erase side sets.

In the current implementation, this operation indiscriminately converts +all+ side sets into node sets.

This operation can also be performed [automatically](MooseMesh.md#more_detail) at the end of the mesh generation
process if `construct_node_list_from_side_list = true` in the `[Mesh]` block.





## OrientedSubdomainBoundingBoxGenerator


### Overview

### Example Syntax





## OverlayMeshGenerator


### Overview

The `OverlayMeshGenerator` object is the built-in mesh generation capable of creating a Cartesian mesh overlaying the given input mesh. The overlay mesh uses [DistributedRectilinearMeshGenerator.md] as sub-generator. The input parameters for DistributedRectilinearMeshGenerator are all available for OverlayMeshGenerator. The required input parameters are [!param](/Mesh/OverlayMeshGenerator/dim) (the dimension of the domain) and [!param](/Mesh/OverlayMeshGenerator/input) (the base mesh we want to overlay).

### Example Syntax

         block=Mesh




## ParsedCurveGenerator


### Overview

The `ParsedCurveGenerator` object generates a 3D curve mesh composed of EDGE2 elements which connect the series of points given by $[x(t),~y(t),~z(t)]$, where the range of t is specified by the user. The curve to be generated is described by the following equations,

\begin{cases}
  x = x(t)\\
  y = y(t)\\
  z = z(t)
\end{cases},

where, $x(t)$, $y(t)$, and $z(t)$ are all provided in the form of [C++ function parser](http://warp.povusers.org/FunctionParser/) through [!param](/Mesh/ParsedCurveGenerator/x_formula), [!param](/Mesh/ParsedCurveGenerator/y_formula), and [!param](/Mesh/ParsedCurveGenerator/z_formula), respectively. The constants used in these formulae can be defined by [!param](/Mesh/ParsedCurveGenerator/constant_names) and [!param](/Mesh/ParsedCurveGenerator/constant_expressions).

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=xyz_curve
      caption=A 3D open curve generated by `ParsedCurveGenerator` defined as $x(t)\=\cos t$; $y(t)\=\sin t$; $z(t)\= t$ with $t$ ranging from $0$ to $4\pi$.

Key $t$ values including the starting and ending values of $t$ must be specified by [!param](/Mesh/ParsedCurveGenerator/section_bounding_t_values). Optionally, intermediate $t$ values can be added so that the curve can be divided into several sections. Note that the elements in [!param](/Mesh/ParsedCurveGenerator/section_bounding_t_values) must be unique and change monotonically. Each interval defined by [!param](/Mesh/ParsedCurveGenerator/section_bounding_t_values) must have a corresponding number of segments (i.e., EDGE2 elements), $N_{seg}$, defined by [!param](/Mesh/ParsedCurveGenerator/nums_segments).

### Calculating Segment Division Points

Each section of the curve should ideally have segments of similar length. However, it is challenging to predict the corresponding $t$ values that yield segments with similar length. Hence, oversampling is used to determine the $t$ values which result in consistent segment length. The oversampling factor $N_{os}$ can be defined through [!param](/Mesh/ParsedCurveGenerator/oversample_factor). Assuming that a section of curve is defined by $t_n$ and $t_{n+1}$, the distance between the starting and ending points of this section has the following form,

d_n = \sqrt{\left[x(t_n)-x(t_{n+1})\right]^2+\left[y(t_n)-y(t_{n+1})\right]^2+\left[z(t_n)-z(t_{n+1})\right]^2}

Thus, the oversampling target is to achieve that the maximum interval between neighboring sampling points is lower than a threshold value defined as follows,

d_{os,threshold} = \frac{d_n}{N_{seg}N_{os}}

The oversampling is realized by a binary algorithm, which divides oversized intervals in halves until all the intervals are shorter than $d_{os,threshold}$. Then the oversampled section points are used to determine the actual point locations (i.e., $t$ values).

### Example Syntax

`ParsedCurveGenerator` is capable of generating both open and closed curves.

For open curve generation, the approach is straightforward with the example shown as follows.

         id=open_curve_input
         caption=the input syntax sample to generate an open logarithmic curve

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=open_curve
      caption=An open logarithmic curve generated by `ParsedCurveGenerator`.

On the other hand, for closed curve generation (defined by [!param](/Mesh/ParsedCurveGenerator/is_closed_loop)), ideally the starting and ending values of $t$ should lead to the same $x(t)$, $y(t)$, and $z(t)$ values, as shown below.

         id=closed_curve_input
         caption=the input syntax sample to generate a closed half circular and half elliptical curve

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=closed_curve
      caption=A closed half circular and half elliptical curve generated by `ParsedCurveGenerator`.

If the starting and ending values of $t$ lead to different $x(t)$, $y(t)$, or $z(t)$ values, the curve will be "forced" to close by directly connecting the starting and ending points (see [forced_closed_curve]).

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=forced_closed_curve
      caption=a fraction of the curve shown in [closed_curve] forced to be closed.

By default, the curve section that closes the curve consists of only one EDGE2 element. However, users can also use [!param](/Mesh/ParsedCurveGenerator/forced_closing_num_segments) to specify the number of elements in that curve section.

### Used with Other Mesh Generators

If [!param](/Mesh/ParsedCurveGenerator/z_formula) is set as zero (which is the default value), the generated curve resides in the XY-plane, and a pair of such `ParsedCurveGenerator` objects can naturally be connected by [`FillBetweenCurvesGenerator`](/FillBetweenCurvesGenerator.md) using [`FillBetweenPointVectorsTools`](/FillBetweenPointVectorsTools.md).

Additionally, closed XY-plane curve meshes generated by `ParsedCurveGenerator` can be used by [`XYDelaunayGenerator`](/XYDelaunayGenerator.md) as either [!param](/Mesh/XYDelaunayGenerator/boundary) or [!param](/Mesh/XYDelaunayGenerator/holes). See example below.

         id=xy_curve_list
         caption=the input syntax sample to use `ParsedCurveGenerator` with [`XYDelaunayGenerator`](/XYDelaunayGenerator.md)

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=xy_curve_fig
      caption=An example mesh generated by using `ParsedCurveGenerator` with [`XYDelaunayGenerator`](/XYDelaunayGenerator.md)




## ParsedElementDeletionGenerator


### Overview

The `ParsedElementDeletionGenerator` allows the user to specify a parsed criterion for the deletion of
an element.

The components of the vertex-average of each element are made available as function symbols `x`, `y`, and `z`.
The volume of each element is made available as function symbol `volume`.

The parsed expression syntax available is the same as used
in [`ParsedFunction`](MooseParsedFunction.md) and [`ParsedMaterial`](ParsedMaterial.md).

The criterion for deletion is that the expression evaluates to something that is strictly positive. For example,
`volume < 1e-10` will delete all elements below that volume.




## ParsedExtraElementIDGenerator


This mesh generator adds an extra element integer in an input mesh based on an parsed expression evaluated at the ceontroid of every element.
The extra element integer can be added for elements only within certain mesh subdomains using the [!param](/Mesh/ParsedExtraElementIDGenerator/restricted_subdomains) parameter.
Other extra element integers, already existing in the mesh, can also be used in the expression.




## ParsedGenerateNodeset


Optionally, additional constraints can be imposed when examining a node based on :

- the subdomain of the element owning the node considered for the nodeset
- whether the node is already part of (or not part of) an existing boundary
- whether the node is 'external', e.g. it lies on the mesh exterior boundary





## ParsedGenerateSideset


Optionally, additional constraints can be imposed when examining a node based on :

- the side's normal
- the subdomain of the element owning the side considered for the sideset
- the neighbor of this element, on the other side of the side
- whether the side is already part of (or not part of) an existing boundary
- whether the side is 'external', e.g. it lies on the mesh exterior boundary





## ParsedNodeTransformGenerator


### Overview

The `ParsedNodeTransformGenerator` generator allows the user to specify parsed expressions to compute the new positions of all mesh nodes as the function of their old positions.
The old node positions components are made available as function symbols `x`, `y`, and `z`. The new node position components are determined by the [!param](/Mesh/ParsedNodeTransformGenerator/x_function),
[!param](/Mesh/ParsedNodeTransformGenerator/y_function), and [!param](/Mesh/ParsedNodeTransformGenerator/z_function) parameters. The parsed expression syntax available is the same as used
in [`ParsedFunction`](MooseParsedFunction.md) and [`ParsedMaterial`](ParsedMaterial.md).





## ParsedSubdomainMeshGenerator


### Example

The desired example mesh is a 1-by-1 2D square which contains Block 1 (a centered 0.8-by-0.8 square) and Block 2 (a 0.4-by-0.4 square located in the bottom left quarter of Block 1). The remaining edge of the square can be Block 0.

The combinatorial expression that defines Block 1 is below.

```
x > 0.1 & x < 0.9 & y > 0.1 & y < 0.9
```

The expression

```
x < 0.5 & y < 0.5
```

can partially define Block 2, but the region outside Block 1 also needs to be excluded. The input file syntax needed to generate this example is shown below.


The final mesh output is:





## PatternedMeshGenerator


### Overview

The `PatternedMeshGenerator` object is similar to [TiledMeshGenerator](/TiledMeshGenerator.md). However, it is restricted to two dimensions and
adds the ability to create a tile pattern from an arbitrary number of input meshes.

The MeshGenerators provided in inputs are no longer required to have the same boundary ids for a given boundary name.
In this case, boundary ids for all (cloned) input MeshGenerators are first renamed to a common unused set of ids. Then the resulting stitched patterned mesh will be changed again to boundary ids that are the same as the first entry of the passed inputs parameter.

Although best efforts have been made to ensure that the PatternedMeshGenerator fails with a descriptive error message when provided with invalid or ambiguous input, there are some exceptions that will result in silent failure (the input meshes are stitched together incorrectly and the program continues to run). If this occurs, this issue is likely that one of the left/right/top/bottom_boundary input parameters is set to an incorrect value (i.e., left_boundary = 'right', when the 'right' boundary does not have outward normal (-1, 0, 0)). Check for mistakes like these when troubleshooting errors. Additionally, it should be confirmed that the values of the left/right/top/bottom_boundary parameters are correct for EVERY mesh provided in the 'inputs' parameter (i.e., each mesh in 'inputs' should have the same boundary name, ids may differ, and locations).

For example the input meshes shown in Figures 1 and 2 can be organized into a two dimensional pattern within the input
file, as shown below, to create the pattern shown in Figure 3.








## PlaneDeletionGenerator


### Overview

Allows for deletion of elements that lie on one side of a plane.  The plane can be specified via a point and a vector that is normal to the plane.  All elements whose centroids lie "above" (in the direction of the normal vector) the plane will be removed from the mesh.

An optional `new_boundary` parameter can also be specified which will make any newly-created free-surfaces have that boundary ID.

### Example

```
[Mesh]
  [generated]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 4
    ny = 4
    nz = 4
  []
  [deleter]
    type = PlaneDeletionGenerator
    point = '0.5 0.5 0'
    normal = '-1 1 0'
    input = generated
    new_boundary = 6
  []
[]
```

       caption=The Original Mesh
       style=width:50%;padding:20px;

       caption=With the elements removed (and showing the new boundary)
       style=width:50%;padding:20px;





## PlaneIDMeshGenerator


### Overview

The `PlaneIDMeshGenerator` object applies an extra IDs to axial planes defined in a extruded mesh.

### Extra ID Control

The `PlaneIDMeshGenerator` takes a mesh object and its axial layer structure as input.
This axial plane structure given in [!param](/Mesh/PlaneIDMeshGenerator/plane_coordinates) contains a list of coordinates defining each plane from bottom to top.
If there are N planes, N+1 coordinate points should be defined here.

If each axial plane is uniformly sub-divided into multiple layers during the extrusion, distinct extra IDs can be optionally assigned to individual layers in each plane.
[!param](/Mesh/PlaneIDMeshGenerator/num_ids_per_plane) defines the number of unique IDs in each plane defined in [!param](/Mesh/PlaneIDMeshGenerator/plane_coordinates).

Note that this generator only works for extruded geometries where the concept of axial layer is valid.
The axis of plane can be specified using [!param](/Mesh/PlaneIDMeshGenerator/plane_axis).

### Example Syntax





## PolyLineMeshGenerator


Using the `PolyLineMeshGenerator` object from within the
[Mesh](/Mesh/index.md) block of the input file will construct an open
or closed (looped) one-dimensional manifold of Edge elements
connecting each adjacent pair of points in a user-specified list.
Points can live in 3-D space by default, but loops in the X-Y plane
are particularly useful as inputs to subsequent triangulator mesh
generators.

### Example

The following Mesh block will connect the specified 3 points with a
total of 9 Edge2 elements.




## RefineBlockGenerator


### Overview

This MeshGenerator object allows the user to refine one or more blocks in a mesh.

The user has to provide the ids of the blocks to be modified, as well as the corresponding levels of refinement for each block. These must match up to the order of the aforementioned block id list, e.g. if the blocks you wish to modify are '0 2 1 4', with 1 refinement for block 0, 2 for block 2, 3 for block 1, and 4 for block 4, then the refinement list will need to look like '1 2 3 4'. By default, refinement in libMesh refines neighboring blocks to avoid meshing problems. This generator shares this default, but it can be disabled with "enable_neighbor_refinement=false".




## RefineSidesetGenerator


### Overview

This MeshGenerator object allows the user to refine one or more boundaries in a mesh, as well as neighboring elements of the boundary/boundaries.

The user has to provide the name(s) of the boundary/boundaries to be modified, as well as the corresponding levels of refinement for each boundary. These must match up to the order of the aforementioned boundary name list, e.g. if the boundaries you wish to modify are 'left right', with 1 refinement for left, 2 for right, then the refinement list will need to look like '1 2'. By default, refinement in libMesh refines neighboring boundaries to avoid meshing problems. This generator shares this default, but it can be disabled with setting [!param](/Mesh/RefineSidesetGenerator/enable_neighbor_refinement) to `false`. Additionally, the user must provide the type of refinement to perform in [!param](/Mesh/RefineSidesetGenerator/boundary_side) where "primary" merely refines the elements on the boundary, "secondary" only refines the neighbors of the boundary, and "both" refines both the elements on the boundary and its neighboring elements.




## RenameBlockGenerator


### Renaming or Setting Block Names

When using the `RenameBlockGenerator` to change block names, the result is independent of ordering.

The following will change the name for the block `meaningless` to `inside` and will set the name for block `5` to `outside`:

```
[rename]
  type = RenameBlockGenerator
  input = some_mesh
  old_block = 'meaningless 5'
  new_block = 'inside outside'
[]
```

### Merging Blocks

The `RenameBlockGenerator` can be used to merge blocks together. The result is independent of ordering when [!param](/Mesh/RenameBlockGenerator/new_block) contains only block IDs. When [!param](/Mesh/RenameBlockGenerator/new_block) contains block names, the result is not necessarily independent of ordering.

The following will result in the merging of the elements in blocks `1`, `2`, and `3` into block `0`:

```
[merge]
  type = RenameBlockGenerator
  input = some_mesh
  old_block = '1 2 3'
  new_block = '0 0 0'
[]
```

As discussed previously, when providing names in [!param](/Mesh/RenameBlockGenerator/new_block), the result may be ordering-dependent. If a name is provided in [!param](/Mesh/RenameBlockGenerator/new_block) that does not already exist in the mesh, it will take the ID of the first rename.

Take the following examples (assuming that the block `some_block` does not exist yet):

```
[mergename0]
  type = RenameBlockGenerator
  input = some_mesh
  old_block = '0 1'
  new_block = 'some_block some_block'
[]
```

```
[mergename1]
  type = RenameBlockGenerator
  input = some_mesh
  old_block = '1 0'
  new_block = 'some_block some_block'
[]
```

The result of each will be a block named `some_block` that contains elements that were in blocks `0` and `1`. However, because the block `some_block` takes the ID of the first rename execution, the ID of `some_block` will be `0` in the case of the generator `mergename0` and `1` in the case of the generator `mergename1`.

In the case of providing [!param](/Mesh/RenameBlockGenerator/new_block) by ID, the following examples (assuming that the block `2` does not exist yet) will have the same result:

```
[mergeblock0]
  type = RenameBlockGenerator
  input = some_mesh
  old_block = '0 1'
  new_block = '2 2'
[]
```

```
[mergeblock1]
  type = RenameBlockGenerator
  input = some_mesh
  old_block = '1 0'
  new_block = '2 2'
[]
```

That is, a block will be created with the ID `2` that contains the elements previously in blocks `0` and `1`.

In summary, the possibility of ordering-dependent results with the `RenameBlockGenerator` depends on whether or not name(s) are provided in [!param](/Mesh/RenameBlockGenerator/new_block) and said name(s) do not exist yet.




## RenameBoundaryGenerator


### Renaming or Setting Boundary Names

When using the `RenameBoundaryGenerator` to change boundary names, the result is independent of ordering.

The following will change the name for the boundary "meaningless" to "interior" and the name for boundary "5" to "exterior":

```
[rename]
  type = RenameBoundaryGenerator
  input = some_mesh
  old_boundary = 'meaningless 5'
  new_boundary = 'interior exterior'
[]
```

For the special case where the original boundary name and ID are the same, this mesh generator
will convert *both* to the new boundary name/ID. For instance, if the mesh contains a boundary
named `3` that also has an ID of `3`, this mesh generator will convert both the name and ID.

### Merging Boundaries

When using the `RenameBoundaryGenerator` to merge boundaries, the result is not necessarily independent of ordering.

For example, take the following:

```
[merge]
  type = RenameBoundaryGenerator
  input = some_mesh
  old_boundary = '0 1 2 3`
  new_boundary = 'bottom_and_left bottom_and_left top_and_right top_and_right'
[]
```

The above will result in two boundaries:

- Boundary "0" with name "bottom_and_left" that contains the sides from the original boundaries "0" and "1".
- Boundary "2" with name "top_and_right" that contains the sides from the original boundaries "2" and "3".

Take the first execution, "0" to "bottom_and_left". The "RenameBoundaryGenerator" will use the original boundary ID, which is "0". The second execution, "1" to "bottom_and_left", will use the new ID associated with "bottom_and_left", which is "0", and merge "1" into it. The result is similar for the third and fourth executions.

The order dependent behavior only exists when the new boundary provided is a name. Take the following instead:

```
[merge]
  type = RenameBoundaryGenerator
  input = some_mesh
  old_boundary = '0 1 2 3'
  new_boundary = '0 0 4 4'
[]
```

The result is:

- Boundary "0" that contains the sides from original boundaries "0" and "1".
- Boundary "4" that contains the sides from original boundaries "2" and "3".




## RinglebMeshGenerator


### Overview

This mesh can be applied to a Ringleb problem. This problem tests the spatial accuracy of high-order methods. The flow is transonic and smooth. The geometry is also smooth, and high-order curved boundary representation appears to be critical.

### Governing Equations

The governing equations are the 2D Euler equations with $\gamma = 1.4$.

### Geometry

Let $k$ be a streamline parameter, i.e., $k = constant$ on each streamline. The two stream lines for the two wall boundaries are $k=k_{max}=1.5$ for the inner wall, and $k=k_{min}=0.7$ for the outer wall. Let $q$ be the velocity magnitude. For each fixed $k$ , $k_{min} \leq k \leq k_{max}$, the variable $q$  varies between $Q_0=0.5$ and $k$ . For each $q$ , define the speed of sound $a$ , density $\rho$ , pressure $p$, and a quantity denoted by $J$ by:
\begin{equation*}
a=\sqrt{1 - \frac{\gamma-1}{2}q^2};\quad \rho = a^{\frac{2}{\gamma-1}};\quad p = \frac{1}{\gamma}a^{\frac{2 \gamma}{\gamma-1}};\quad J = \frac{1}{a} + \frac{1}{3a^3} + \frac{1}{5a^5} - \frac{1}{2}\log \frac{1+a}{1-a}
\end{equation*}

For each pair $(q,k)$, set:
\begin{equation*}
x(q,k) = \frac{1}{2\rho}\left( \frac{2}{k^2}-\frac{1}{q^2} \right) - \frac{J}{2}
\quad \mathrm{and} \quad
y(q,k) = \pm \frac{1}{k \rho q} \sqrt{1-\frac{q^2}{k^2}}
\end{equation*}

### Mesh Example

For example, let's consider the following input file:

```
[Mesh]
  [./ringleb]
    type = RinglebMeshGenerator
    kmin = 0.7
    num_k_pts = 9
    num_q_pts = 20
    kmax = 1.2
    n_extra_q_pts = 2
    gamma = 1.4
    triangles = true
  []
[]
```

The corresponding mesh looks like this:

       style=width:50%;




## SideSetExtruderGenerator


The `SideSetExtruderGenerator` differs from the [MeshExtruderGenerator](MeshExtruderGenerator.md) in that the extruded
block has the same dimensionality as the input mesh.

The `SideSetExtruderGenerator` will not throw any errors if you extrude a mesh through (overlap with) another mesh or
another part of the mesh. It will throw an error if the extrusion vector would create a mesh with a negative determinant
(the nested [MeshExtruderGenerator](MeshExtruderGenerator.md) throws the error).

The output will have no sidesets, even the sideset which served for extrusion will be removed.
The user is expected to use the other sideset generating generators on the output if sidesets are needed. 

### Visual Example

The following 2D mesh has the `right` sideset extruded using a `SideSetExtruderGenerator` with the (1, 0.5, 0) vector.



### Implementation details

SideSetExtruderGenerator is actually a mere wrapper of 4 other generators:

- a [LowerDBlockFromSidesetGenerator](LowerDBlockFromSidesetGenerator.md) to generate a block from the sideset
- a [BlockToMeshConverterGenerator](BlockToMeshConverterGenerator.md) to generate a block with the mesh
- a [MeshExtruderGenerator](MeshExtruderGenerator.md) to extrude the new mesh
- a [StitchedMeshGenerator](StitchedMeshGenerator.md) to stitch the original mesh and the extruded mesh.


As such, the `SideSetExtruderGenerator` is exactly equivalent to the output of a recipe similar to the one below.
If you are needing to tweak the output of `SideSetExtruderGenerator`, it may be preferable to use these generators
instead. `SideSetExtruderGenerator` uses the default parameters of these sub-generators. 


The input above should be equivalent to the input shown below.





## SideSetsAroundSubdomainGenerator


### Overview

By default, `SideSetsAroundSubdomainGenerator` creates a sideset (with ID defined
by the user) around an associated block ID. Multiple sidesets over multiple blocks
can be defined at once.

Optional parameters allow more specific behavior:

- A normal vector can be defined (using `normal`) such that only faces whose outward facing normal is equivalent (or within a specified tolerance `normal_tol`) is added to the sideset.

- `replace` is a boolean parameter that sets whether any old sidesets should be replaced or preserved (default is preservation).

- `fixed_normal` is a boolean parameter inherited from `SideSetsGeneratorBase` that sets whether a sideset defined on a qualifying face is to be "painted" onto adjacent faces (default = False). This allows sidesets for slightly curved boundaries to be more easily defined. Fixing the normal (setting `fixed_normal = True`) disables this behavior.




## SideSetsBetweenSubdomainsGenerator





## SideSetsFromBoundingBoxGenerator


### Overview

This `MeshGenerator` can be used in two ways:

-  To define a new sideset on multiple boundaries (default) - provide multiple boundary names or IDs, and all nodes existing on each provided boundary within the bounding box (or outside if `location = OUTSIDE`) will be assigned the new boundary name/ID.

- To define a new sideset *only* on overlapping boundaries (`boundary_id_overlap = True`) - provide multiple boundary names or IDs, and all nodes within the bounding box (or outside if `location = OUTSIDE`) that are currently assigned to ALL of the listed boundary names/IDs will be assigned the new boundary name/ID.




## SideSetsFromNodeSetsGenerator


### Overview

This MeshGenerator object allows the user to make matching side sets for every existing node set.
It does not delete or erase the original node sets in the process. A side may only be created from
several nodes if the nodes are forming a side of an element.

For example, for a 2D element, nodes from the node set must be on the two edges of a vertex of an element to make this vertex be part
of the created sideset. For a 3D hexagonal element, the four nodes on the corners of a face of an element
must be part of the original node set to make the quadrilateral face be part of the created side set.

In the current implementation, this operation indiscriminately converts +all+ node sets into side sets.

This operation can also be performed [automatically](MooseMesh.md#more_detail) at the end of the mesh generation process
if `construct_side_list_from_node_list = true` in the `[Mesh]` block.





## SideSetsFromNormalsGenerator


See also: [AllSideSetsByNormalsGenerator](/AllSideSetsByNormalsGenerator.md)

If the mesh contains multiple disjoint faces with the same normal, they will all be added to the sideset.

This will not generate internal (within the domain, on boundaries between blocks) sidesets,
even if there are internal faces with the desired normal.
For internal sidesets, use [SideSetsAroundSubdomainGenerator](/SideSetsAroundSubdomainGenerator.md)
with a [!param](/Mesh/SideSetsAroundSubdomainGenerator/normal) parameter.




## SideSetsFromPointsGenerator


This is similar to the [SideSetFromNormalsGenerator](/SideSetsFromNormalsGenerator.md)
but may be easier to use if the user knows the external coordinates on the mesh
without knowing the normal vector around those points. Multiple points can be
provided to define multiple sidesets.




## SmoothMeshGenerator


### Example

The `iterations` parameter controls the number of smoothing steps to do.  Each
smoothing step will iterate the mesh toward the "true" smoothed mesh (as
measured by the Laplacian smoother).  Note that the mesh should reach "steady
state": after just a few iterations the mesh will stop moving by much.

As an example here is an original mesh going through 12 iterations of this smoother:

       id=inl-logo
       caption=12 iterations of Laplacian smoothing.  Coloring is by element quality (higher is better).
       style=width:50%;padding:20px;




## SphereMeshGenerator


### Overview

The `SphereMeshGenerator` creates a 3-D mesh of a sphere. The mesh refinement and smoothing parameters define the mesh density. [fig:sphere_mesh] depicts several sphere meshes (sliced in half to illustrate the interior elements) for different selections of refinement and smoothing parameters.

       caption=Sphere meshes created with different choices for refinement level and smoothing operations




## SpiralAnnularMeshGenerator


### Overview

The generated mesh has an annular shape, and nodes are located on different concentric rings between the inner and outer circles. The elements are triangular.

Here are the required parameters:

- `inner_radius`
- `outer_radius`
- `nodes_per_ring`
- `num_rings`

Given all these parameters, the radial bias will be computed automatically.

It is also possible to specify if you want a second-order Mesh : TRI3 elements will become TRI6 elements. To do that, simply change the `use_tri6` parameter to `true`.

### Example Input File

For example, with the following input file block:


The resulting mesh looks like this:

       style=width:50%;




## StackGenerator


### Overview

The `StackGenerator` object allows to create a new 2D or 3D mesh by stitching
several 2D or 3D meshes on top of each other (and so create a stack).

The parameters to be provided are the input meshes, the dimension of the meshes
(you can only stack together meshes of the same dimension), the names of the
boundaries to be stitched, and the vertical height of the bottom of the final mesh.

### Further StackGenerator Documentation




## StitchBoundaryMeshGenerator


### Description

`StitchBoundaryMeshGenerator` stitches two boundaries by merging their nodes together. The boundary ids are specified by `stitch_boundaries_pair`. To fully stitch two boundaries, the pairs of nodes on two boundaries must be at the same locations within a default tolerance. The two boundaries must be in the same mesh.


### Example Input Syntax





## StitchedMeshGenerator


### Example

Consider the following three meshes.




Using the `StitchedMeshGenerator` object from within the [Mesh](/Mesh/index.md) block of the input file, as shown in the input
file snippet below, these three square meshes are joined into a single mesh as shown in Figure 4.

Note that the way that the meshes are merged gives precedence to the left-most mesh listed in terms of sidesets: the sidesets of the second, third, etc meshes will be subsumed into the sidesets of the first mesh. The names of the sidesets in the first mesh are what the names that will remain in the outputted mesh. 






## SubdomainBoundingBoxGenerator


### Overview

This MeshGenerator takes a user-specified axis aligned box defined in terms of
extreme coordinates (lower left and upper right), and changes subdomain IDs of
all elements or elements with certain subdomain IDs  either inside or outside
the box to the specified ID.




## SubdomainIDGenerator





## SubdomainPerElementGenerator





## SymmetryTransformGenerator


Only the plane or mirror symmetry is currently implemented in the `SymmetryTransformGenerator`. Point or rotational symmetries are not implemented.

### Overview

The `SymmetryTransformGenerator` makes a mirror reflection of a mesh across an arbitrary plane (or line in 2D) supplied by the user.
All input is expected to be three dimensional even if the mesh in question is two dimensional; in such a case,
let the z component be 0 (for example, `mirror_normal_vector = '1 1 0'`).

The user sets the plane that will be reflected over by giving two vectors: a vector that gives the position of
any given point on the line/plane from the origin; and, a vector that is normal (aka perpendicular/ orthogonal)
to said line/plane. The normal vector establishes the slope of the plane of reflection. 




## TiledMeshGenerator


### Example

As the name suggests, the `TiledMeshGenerator` object may be utilized to repeat
a mesh multiple times. The test, [tiled_mesh_generator.i](test/tests/meshgenerators/tiled_mesh_generator/tiled_mesh_generator.i),
will be used to illustrate the use of the `TiledMeshGenerator` object. This test
file is shown at the bottom of this section for reference.



The example utilizes a cube (cube.e) mesh as input as shown in Figure 1, which
is a regular cube on the domain from 0 to 10 in the x, y, and z-directions.

As specified in the input file for this test (see below), this mesh is then used
to create two tiles in the x, y, and z directions. To execute the example and
create a new mesh, the moose test application can be executed with the special
"--mesh-only" flag, which indicates that only the mesh operations should be
performed. Running this command will create the resulting mesh file
(tiled_mesh_test_in.e), which is intended to be used by a separate input file
to run a complete simulation.

```bash
cd ~/projects/moose/test/tests/meshgenerators/tiled_mesh_generator/
~/projects/moose/test/moose_test-opt -i tiled_mesh_generator.i --mesh-only
```





## TransfiniteMeshGenerator

The `TransfiniteMeshGenerator` produces two-dimensional meshes from a set of 4 corner vertices by interpolating the edges into the inner domain. The resulting mesh  consists of QUAD4 elements of aspect ratio and skewness determined by the points on the boundary edges.




### Overview

&nbsp;

Given a set of 4 corners the TransfiniteMeshGenerator constructs by default the straight edges that connect the vertices and fills up the interior with straight lines. The test, [quadrilater_generator.i](test/tests/meshgenerators/transfinite_generator/quadrilater_generator.i),
illustrates the use of the `TransfiniteMeshGenerator` object to construct general quadrilaterals as in Fig. 2. By default the distribution of points along edges is considered equidistant, unless specified otherwise by the user using the parameters `bias_x` or `bias_y`. The core of the algorithm interpolates/fills up the inner domain for any edge type, curved, parametrized, discrete. The current implementation considers all these cases with special attention given to arcs of a circle which are widely encountered in scientific computing applications. 

The convention for the corners numbering should follow Fig. 1, prescribed in the order +(0,0) - (0,1) - (1,1) - (1,0)+. The direction along edges, important if the user provides them using the DISCRETE option, should follow the direction of the arrows as in Fig. 1.




This generator allows any type of curvilinear edges. In Fig. 3 we show a mesh where the top edge has an inward arc circle. However, this algorithm generates a mesh for any parametrized edge, or given set of points on an edge. For arcs of a circle, since they are widely encountered in applications, we customized an approach that requires a user to specify only the deviation from a straight line in the middle of an edge. 

The default distribution of points on an edge is equidistant and nothing explicit needs to be specified. However, for meshes that need to capture more scales in different regions we have two additional options that can be prescribed.  The distribution of points on an edge can be either provided as a discrete set of points, using the edge type `DISCRETE`, or as a bias along the edge. The only requirement is that opposite edges have the same number of points.

### Example




&nbsp;

This mesh generator considers 4 types of edges, each of which should have a type defined in "edge"`_type`, where "edge" is either `left`, `right`, `top` or `bottom`.  For some edge types, an edge parameter, similarly named "edge"`_parameter`, is necessary to define the shape of the edge.

Admissible types are:

  - `LINE` - constructs a line between the already-provided corner vertices. A quadrilateral can be obtained only with line sides as in Fig. 2.

  - `CIRCARC` - constructs an arc of a circle, based on a required edge parameter. This parameter can be the distance at the middle of an edge between a straight line and the arc of circle desired, as in the test [arccircle_generator.i](test/tests/meshgenerators/transfinite_generator/arcircle_generator.i). The edge is then generated by computing the middle point on the edge. The deviation from a straight line is set by convention to be positive if the arc circle is outward, or negative if inward, in this fashion the user can specify different orientations, as in Fig. 4.
  The midpoint could instead be obtained from a QUAD8 element as provided by an external mesh generator and inserted as input by the user in the same  edge parameter, as in the test [arccircle_midpoint_generator.i](test/tests/meshgenerators/transfinite_generator/arcircle_midpoint_generator.i). Different point distributions along arc circles can be prescribed as for the other edge types and propagate via the polar coordinates parametrization.

&nbsp;



    block=Mesh/transf


  - `DISCRETE` - constructs a line along a set of points, provided by the user in a required edge parameter.  Coordinates for each point are separated by whitespace, and points are separated by newlines.  Points are connected in the order represented by arrows in Fig. 1.  A test is available in [discrete_generator.i](test/tests/meshgenerators/transfinite_generator/discrete_generator.i) and illustrated in Fig. 4. This option is the only one that does not support a different point redistribution via the options `bias_x` and `bias_y`; these will have no effect, since it is assumed the user desires their edge points exactly as specified. 

  - `PARSED` - constructs a curvilinear edge, as provided by a parametric function specified in the corresponding edge parameter.  In this parameter, the function to be parsed should be a map from the unit interval `r=[0,1]`, with the output `x` and `y` components separated by a semicolon.  The test [parsed_generator.i](test/tests/meshgenerators/transfinite_generator/parsed_generator.i) illustrates this by constructing a stenotic pipe mesh using parsed top and bottom edges.




    block=Mesh/transf


Since opposite sides need to have the same number of points, we consider top-bottom edges to have `nx` points, and left-right edges `ny` points. By default they are taken to be equidistant, unless the user specifies a distancing via the parameters `bias_x` or `bias_y`. Different point distributions can propagate on curvilinear edges, generating domains as in Fig. 5. Note that the bias along an edge is implemented as propagated by the parametrization, so for a parametrized edge $x(r),\ y(r)$ the bias is constructed first for the parameter $r$ and propagated as the parametrized edge is generated. 





## TransformGenerator


### Overview

The Transform MeshGenerator applies one of three linear transformations
(TRANSLATE, ROTATE, or SCALE) to the entire mesh.
In addition, the following specific translations are available:

- `TRANSLATE_CENTER_ORIGIN`: Translates the center of the mesh to be at the origin
- `TRANSLATE_MIN_ORIGIN`: Translates the minimum of the mesh to be at the origin

Several independent modifiers may be executed in a specific order to perform more complex transformations.
This class simply calls through to the methods in libMesh's
[MeshTools::Modification](https://mooseframework.inl.gov/docs/doxygen/libmesh/namespacelibMesh_1_1MeshTools_1_1Modification.html)
namespace.




## UniqueExtraIDMeshGenerator



### Overview


`UniqueExtraIDMeshGenerator` object applies a new set of extra IDs determined by parsing existing extra IDs.
First, the existing extra IDs of each element are parsed to find a set of unique combinations of their ID values.
Then, a new ID value are determined to individual unique combination and assign it to the corresponding element.
The new ID is embedded in all the existing IDs, i.e. elements with a unique new ID value have a unique value for all existing IDs.

The `UniqueExtraIDMeshGenerator` requires the following parameters:

- [!param](/Mesh/UniqueExtraIDMeshGenerator/id_name): list of existing extra ID names.

- [!param](/Mesh/UniqueExtraIDMeshGenerator/new_id_name): name of the new extra ID name.

Optionally, users can control how the new ID values are determined by using [!param](/Mesh/UniqueExtraIDMeshGenerator/new_id_rule), which is a vector of unsigned integers.
If [!param](/Mesh/UniqueExtraIDMeshGenerator/new_id_rule) is provided, new ID values are determined by multiplying the provided integers to the corresponding existing ID values and then summing the resulting values as: new_id_value = new_id_rule\[0\] * extra_id_value\[0\] + ... + new_id_rule\[n\] * extra_id_value\[n\].

### Example Syntax





## XYDelaunayGenerator


An input mesh will be used to define the outer boundary of the
generated output mesh, as well as to specify any Steiner points
interior to that boundary which must be included in as output mesh
vertices.  Additional interior vertices can be automatically generated
by specifying a desired triangle area (either as a constant or as a
function of triangle center location that can be specified or
automatically generated).  Additional interior boundary "holes" can
be specified by the mesh generators specified in the [!param](/Mesh/XYDelaunayGenerator/holes) vector parameter.
Additional interior vertices can also be specified using [!param](/Mesh/XYDelaunayGenerator/interior_points). This is useful when specific interior nodal locations need to be defined. Note that enabling [!param](/Mesh/XYDelaunayGenerator/smooth_triangulation) will shift these specified points.

Each input mesh, as specified in the
[!param](/Mesh/XYDelaunayGenerator/boundary) parameter and optionally
in the [!param](/Mesh/XYDelaunayGenerator/holes) parameter,
can define a ring of boundary segments either by including edge
elements for each segment or by including face elements whose external
edges are to be treated as segments.  For the outer
[!param](/Mesh/XYDelaunayGenerator/boundary)
mesh, a subset of edges or faces can be examined instead of
the entire mesh, using the
[!param](/Mesh/XYDelaunayGenerator/input_subdomain_names) parameter to
list edge element subdomains or the
[!param](/Mesh/XYDelaunayGenerator/input_boundary_names) parameter to
list face boundaries.

If multiple boundary rings exist in a mesh, only the ring enclosing
the rest of the mesh is considered to be "the" boundary.  Input meshes
which are not simply connected, which therefore have multiple outer
boundary rings, are not yet supported.

If the input boundary mesh has nodes inside the boundary ring, these
nodes are treated as required in the output mesh.  This is useful for
ensuring that the output mesh has a vertex at a specific point of
interest.  For meshes with interior nodes that should not be
considered required, a user can first use a
[LowerDBlockFromSidesetGenerator.md] to generate the desired boundary
ring and a [BlockDeletionGenerator.md] on that to remove everything
except the desired boundary edges.  Setting
[!param](/Mesh/BlockDeletionGenerator/delete_exteriors) to
false is necessary in this workflow to prevent the new edge elements
from being deleted along with their interior-parent elements.

Using stitching options, meshes used as "holes" can subsequently be
stitched into those portions of the output mesh.  For this use case
some care may be required: refinement of stitched hole boundaries
should be disallowed so that the boundary nodes in the newly
triangulated mesh still precisely match the boundary nodes in the hole
mesh.

Interior vertices can be adjusted after mesh generation using the [!param](/Mesh/XYDelaunayGenerator/smooth_triangulation) parameter, to produce a
more "smooth" mesh, but currently the only mesh smoother option is a
simple Laplacian smoother; this can have unwanted side-effects on
meshes with concave boundaries or poor nodal valences, and so it is
disabled by default for robustness.


The elements generated by `XYDelaunayGenerator` can be refined according
to a given maximum element area. This element area limit can be provided
using one of the following three approaches:

- A uniform area defined by [!param](/Mesh/XYDelaunayGenerator/desired_area).
- A parsed space-dependent area function defined by [!param](/Mesh/XYDelaunayGenerator/desired_area_func).
- An automatically generated area function calculated based on inverse
  distance interpolation of the `EDGE` element size of the external and
  holes boundaries with an option to include a background value for those
  regions away from those boundaries. This feature is enabled by [!param](/Mesh/XYDelaunayGenerator/use_auto_area_func),
  while the related parameters include [!param](/Mesh/XYDelaunayGenerator/auto_area_func_default_size),
  [!param](/Mesh/XYDelaunayGenerator/auto_area_func_default_size_dist),
  [!param](/Mesh/XYDelaunayGenerator/auto_area_function_num_points), and
  [!param](/Mesh/XYDelaunayGenerator/auto_area_function_power).

      style=width:80%;
      id=xyd_area_options
      caption=Examples of using different element area limiting options.

A detailed comparison is made in the Figure, using a 1 meter radius circular
external boundary with 8 `EDGE` elements in its upper half and 16 in its
lower half, and two squares with 0.2 meter side length with different
`EDGE` element sizes as the hole boundaries.

### Examples

Using instances of the [PolyLineMeshGenerator.md] to create a boundary
and a few holes, followed by a `XYDelaunayGenerator` object to
triangulate the region between them, the [Mesh](/Mesh/index.md) block
shown in the input file snippet below generates the final mesh shown
in [Figure 1](#withholes).

For this example a specified fixed interpolation of boundary edges is
used, but refinement to a desired maximum triangle size allows
automatic placement of nodes in the mesh interior.


      style=width:32%;
      id=withholes
      caption=Fig. 1: Resulting triangulated mesh from a polyline boundary and holes.

In the input file snippet below, hole stitching is done recursively,
so that each internal "boundary" polyline (after refinement) remains
preserved in the final mesh shown in [Figure 2](#nested).


      style=width:32%;
      id=nested
      caption=Fig. 2: Resulting triangulated mesh with nested polyline boundaries and an internal grid.



## XYMeshLineCutter


### Overview

The `XYMeshLineCutter` is used to trim off a fraction of the input mesh which is located on one side of a given straight line. The input mesh, which is given by [!param](/Mesh/XYMeshLineCutter/input), must be a 2D mesh in the XY-plane and only contain TRI3 and QUAD4 elements. The cutting straight line is provided by [!param](/Mesh/XYMeshLineCutter/cut_line_params), which is a vector of three `Real` type values, which are $a$, $b$, and $c$ in the line equation $ax+by+c=0$. This mesh generator remove the part of the mesh that matches $ax+by+c>0$. The trimmed mesh is processed to ensure a smooth cross-section instead of a "zigzag" cross-section as generated by [`PlaneDeletionGenerator`](/PlaneDeletionGenerator.md).

Two methods can be used by this mesh generator to achieve the mesh cutting: the "Element Cutting" (`CUT_ELEM_TRI`) method and the "Node Moving" (`MOV_NODE`) method, which can be selected through [!param](/Mesh/XYMeshLineCutter/cutting_type). The `MOV_NODE` method is the same method used by `HexagonMeshTrimmer` and `CartesianMeshTrimmer` in the `Reactor` module. That is, the nodes near the cutting line are moved to the cutting line to ensure the smoothness of the cross-section. On the other hand, the `CUT_ELEM_TRI` method first converts all the QUAD4 elements crossed by the cutting line into pairs of TRI3 elements. Then all the TRI3 elements crossed by the cutting line are further split into two or three TRI elements with a division matching the cutting line.

The two methods have their own Cons and Pros, respectively, and are complementary to each other. The `CUT_ELEM_TRI` method keeps all the subdomain interfaces and even preserves the volume of the subdomains. However, it may lead to some small elements near the cutting line. On the other hand, the `MOV_NODE` method does not produce too fine elements but may deform the subdomain interfaces, hence not preserving relative subdomain volumes. Therefore, if only one subdomain is involved in the cutting, or all the cut subdomain interfaces are symmetric over the cutting line, the `MOV_NODE` method is preferred. On the other hand, if complex subdomain interfaces are involved in the cutting, the `CUT_ELEM_TRI` method is preferred.

The id of the new external boundary produced by the trimming can be assigned using [!param](/Mesh/XYMeshLineCutter/new_boundary_id). As either method creates TRI3 elements if there are QUAD4 elements crossed by the cutting line, and as Exodus format does not allow TRI3 and QUAD4 elements sharing the same subdomain id and name. The newly formed TRI3 subdomains' ids and names can be customized using [!param](/Mesh/XYMeshLineCutter/tri_elem_subdomain_name_suffix) and [!param](/Mesh/XYMeshLineCutter/tri_elem_subdomain_shift).

### Example Syntax

The simple example of this mesh generator is to cut a square mesh that contains only one subdomain as shown in [simple_cut_original].

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=simple_cut_original
      caption=The simple one-block mesh to be trimmed by this mesh generator.

The simple mesh shown above can be cut by `XYMeshLineCutter` with `CUT_ELEM_TRI` method using the following input block:


The mesh after the line cutting using `CUT_ELEM_TRI` method is shown in [simple_cut_elem]

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=simple_cut_elem
      caption=The simple one-block mesh cut using the `CUT_ELEM_TRI` method.

Alternatively, the simple mesh can also be cut with the `MOV_NODE` method and produce the following output shown in [simple_cut_node]

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=simple_cut_node
      caption=The simple one-block mesh cut using the `MOV_NODE` method.

As both methods work well, the `CUT_ELEM_TRI` method does produce some fine elements near the cutting line. 

On the other hand, if a more complex mesh that contains multiple subdomains needs to be cut, as illustrated in [complex_cut_original].

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=complex_cut_original
      caption=The complex multi-block mesh to be trimmed by this mesh generator.

The complex mesh shown above can be cut by `XYMeshLineCutter` with `CUT_ELEM_TRI` method using the following input block:


The mesh after the line cutting using `CUT_ELEM_TRI` method is shown in [complex_cut_elem]

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=complex_cut_elem
      caption=The complex multi-block mesh cut using the `CUT_ELEM_TRI` method.

The fine elements issue near the cutting line can be relieved by enabling [!param](/Mesh/XYMeshLineCutter/improve_tri_elements), as shown in [complex_cut_elem_improve].

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=complex_cut_elem_improve
      caption=The complex multi-block mesh cut using the `CUT_ELEM_TRI` method.

Alternatively, the complex mesh can also be cut with the `MOV_NODE` method and produce the following output shown in [complex_cut_node]

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=complex_cut_node
      caption=The complex multi-block mesh cut using the `MOV_NODE` method.

By comparing the output meshes produced using the two methods, it is clear that the `CUT_ELEM_TRI` method preserve the original shape better but creates fine TRI3 elements near the cutting line. On the other hand, the `MOV_NODE` method is free from the "fine elements" issue, but does skew the interface near the cutting line slightly if this interface is not symmetric near the cutting line. The skewing can be relieved by listing the interface boundary ids in [!param](/Mesh/XYMeshLineCutter/other_boundaries_to_conform), as shown in [complex_cut_node_extra]. In summary, users should make a wise selection on the method according to their specific applications.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=complex_cut_node_extra
      caption=The complex multi-block mesh cut using the `MOV_NODE` method with all interfaces provided as `other_boundaries_to_conform`.




## XYZDelaunayGenerator


An input mesh will be used to define the outer boundary of a
generated tetrahedral output mesh.  Additional interior vertices can
be automatically generated by specifying a desired tetrahedral volume.
Additional interior boundary "holes" can be specified by the mesh
generators specified in the [!param](/Mesh/XYZDelaunayGenerator/holes)
vector parameter.

Each input mesh, as specified in the
[!param](/Mesh/XYZDelaunayGenerator/boundary) parameter and optionally
in the [!param](/Mesh/XYZDelaunayGenerator/holes) parameter,
can define a closed manifold of boundary triangles either by including
Tri3 elements for each triangle or by including volume elements whose
external faces comprise the boundary manifold.

If multiple disconnected manifolds exist in a boundary mesh, only the
manifold enclosing the rest of the mesh is considered to be "the"
boundary.  Input meshes which are not connected, which therefore have
multiple outer boundary manifolds, are not yet supported.

Nodes internal to the boundary mesh are currently ignored.  Future
expansions of this class may allow such nodes to be retained as nodes
in the output tetrahedralization.

Using stitching options, meshes used as "holes" can subsequently be
stitched into those portions of the output mesh.

Interior vertices can be adjusted after mesh generation using the
[!param](/Mesh/XYZDelaunayGenerator/smooth_triangulation) parameter,
to produce a more "smooth" mesh, but currently the only mesh smoother
option is a simple Laplacian smoother; this can have unwanted
side-effects on meshes with concave boundaries or poor nodal valences,
and so it is disabled by default for robustness.

The elements generated by `XYZDelaunayGenerator` can be refined according
to a given uniform element volume specified as
[!param](/Mesh/XYZDelaunayGenerator/desired_volume).
This refinement is currently controlled by the third-party Netgen
code.





# meshmodifiers

## ActivateElementsByPath

This MeshModifier uses the +function path+ as the metric to activate (add) an element by moving the element from an "inactive" subdomain to the "active" subdomain. It uses the user provided points $(x(t), y(t), z(t))$ with components defined by the functions specified by the parameters `function_x`, `function_y`, and `function_z` in the input. An element is activated at time $t_0$ if this element is close (distance < `activate_distance`) to the point $(x(t_0), y(t_0), z(t_0))$.




## ActivateElementsCoupled

This MeshModifier uses the +coupled variable value+ as the metric to activate (add) an element by moving the element from an "inactive" subdomain to the "active" subdomain. It uses a coupled variable to decide whether to activate an element. The `coupled_var`, `activate_value` and the `activate_type` needs to be provided in the input to form the activation criterion. By default, the element is activated if the averaged value of the coupled variable in the element is `above` the `activate_value`. User can set `activate_type = 'below'` or `'equal'` to activate element when the averaged coupled variable value is below or equal to the `activate_value`.




## ActivateElementsUserObjectBase

The `ActivateElementsUserObjectBase` class is for activating (adding) an element by moving the element from an "inactive" subdomain to the "active" subdomain. There are two metrics for activating an element, i.e., by +function path+ and by +coupled variable value+, which are implemented in the classes [ActivateElementsByPath](/ActivateElementsByPath.md) and [ActivateElementsCoupled](/ActivateElementsCoupled.md), respectively.

This mesh modifier updates the boundary information due to the addition of elements across subdomains. User can save this boundary information by passing the changed boundary name to  `expand_boundary_name` in the input block.  Note that current implementation does not de-activate an element once the element is activated.

## CoupledVarThresholdElementSubdomainModifier


### Overview

The `CoupledVarThresholdElementSubdomainModifier` changes the element subdomain if a coupled variable meets a particular criterion. The `threshold` and `criterion_type` are used to determine this criterion. By default, the element changes subdomain if the averaged value of the coupled variable in the element is `above` the `threshold`. Other types of criterion are `below` and `equal` to the `threshold` value.

The `CoupledVarThresholdElementSubdomainModifier` inherits from the [ElementSubdomainModifier.md]. Details on solution reinitialization, stateful material property reinitialization and moving boundary/interface nodeset/sideset modification can be found in the description of the [ElementSubdomainModifier.md].

### Irreversible Modification

Consider a unit square domain, and an auxiliary variable defined by the function $\phi(x,y,t) = (x-t)^2+y^2-0.5^2$. The function represents a signed-distance function of a circle of radius $0.5$ whose center is moving along the x-axis towards the right.

Initially, the domain is decomposed by a vertical line $x=0.25$. The elements on the left side of the vertical line have subdomain ID of 1, and the elements on the right side have subdomain ID of 2. The `CoupledVarThresholdElementSubdomainModifier` sets the coupled variable to be $\phi$, and the criterion to be `below` a `threshold` value of 0, so all the elements within the moving circle will change subdomain ID from 2 to 1:



### Reversible Modification

The irreversible modification is useful for applications suhc as element death and activation, but the subdomain modificationan can be changed to reversible by setting the parameter `complement_subdomain_id` to 2. Then the subdomain ID of all elements outside the circle will be set to 2:






## ElementSubdomainModifier

### Overview

The `ElementSubdomainModifier` modifies an element subdomain ID. This class is inherited by other mesh modifiers, such as [CoupledVarThresholdElementSubdomainModifier.md] and [TimedSubdomainModifier.md], which implement different criteria for a subdomain ID to be modified.

The `ElementSubdomainModifier` can model

- Element death (with applications in ablation, fracture, etc.);
- Element activation (with applications in additive manufacturing, sintering, solidification, etc.);
- Moving interface (with applications in metal oxidation, phase transformation, melt pool, etc.).

The `ElementSubdomainModifier` only changes the element's subdomain. It inherits from `ElementSubdomainModifierBase`, which handles the corresponding

- Moving boundary/interface nodeset/sideset modification,
- Solution reinitialization, and
- Stateful material property reinitialization,

all of which are demonstrated below.

Consider a unit square domain decomposed by a vertical line $x=0.25$. The elements on the left side of the vertical line have subdomain ID of 1, and the elements on the right side have subdomain ID of 2. The `ElementSubdomainModifier` is used to change the subdomain ID from 2 to 1 for elements within a circle of radius 0.5 whose center moves along the bottom side towards the right.

### Moving boundary/interface nodeset/sideset modification

If the moving boundary is defined completely around a subdomain, or between subdomains, then [SidesetAroundSubdomainUpdater.md] may be more useful to use in conjunction with the `ElementSubdomainModifier`, rather than using the `moving_boundaries` and `moving_boundary_subdomain_pairs` parameters in `ElementSubdomainModifier`.

The change of element subdomains will alter the definitions of certain sidesets and nodesets. The parameters `moving_boundaries` and `moving_boundary_subdomain_pairs` can optionally be used to modify the corresponding sidesets/nodesets over the elements that change subdomain. The names of the boundaries are specified in `moving_boundaries`, and the pair of subdomains that each boundary in `moving_boundaries` lies between must be specified in the corresponding `moving_boundary_subdomain_pairs`. The element side from the first subdomain of the pair is added to the boundary.

If the boundaries provided through `moving_boundaries` already exist, the modifier will attempt to modify the provided sidesets/nodesets whenever an element changes subdomain ID. If the boundaries do not exist, the modifier will create sidesets and nodesets with the provided names.



The modifier only creates and modifies boundaries over elements that change subdomain, so the vertical boundary between subdomains 1 and 2 at $x=0.25$ is not added to the created boundary. 

If only one boundary is provided but multiple pairs of subdomains are specified, then all the pairs are applied to the one boundary. Element sides on a subdomain's external boundary can also be added by specifying only one subdomain.



Since the update of the moving boundary only occurs over elements that change subdomain, this can be used to update boundaries which do not cover the entirety of a subdomain:


 

Even though the `moving_boundary_subdomain_pairs` defines the moving boundary to be between subdomains 1 and 2 only, the right side of subdomain 2 remains throughout, as no element sides belong to elements that change subdomain.

Nodal and integrated BCs can be applied on the moving boundary.

### Solution reinitialization

By default, all elements that change subdomain ID are reinitialized to the new subdomain's initial condition. Suppose the auxiliary variable $u$ has an initial variable value of $1$ in subdomain 1 and $-0.5$ in subdomain 2, and the variable value doubles at each timestep in subdomain 1:



### Stateful material property reinitialization

Similarly, all stateful material properties will be re-initialized when an element changes subdomain ID. Suppose initially the diffusivity is $0.5$ in subdomain 1 and $-1$ in subdomain 2, and the diffusivity doubles at each time step in subdomain 1:



### Reinitialization restrictions

Depending on the physics, one may or may not want to reinitialize the solution when an element and its related nodes change subdomain ID. For the below examples, consider a unit square domain decomposed by vertical lines $x=0.3$ and $x=0.6$. The elements on the left have subdomain ID of 1, the elements in the middle have subdomain ID of 2, and the elements on the right have subdomain ID of 3.

The `ElementSubdomainModifier` is used to change the subdomain ID to 1 for elements within a circle of radius 0.3 whose center moves along the bottom side towards the right, and to subdomain ID 2 for elements within a circle of radius 0.3 whose center moves along the top side towards the right.

An auxiliary variable $u$ is defined over the domain, with initial values of 1, 2, and 3 in subdomains 1, 2, and 3 respectively:



However, if a list of subdomains (IDs or names) is provided through the parameter `reinitialize_subdomains`, the reinitialization only occurs if the element's new subdomain ID is in the provided list:



If an empty list is given in `reinitialize_subdomains`, then there is no reinitialization of any elements that change subdomain ID.



Reinitialization can be further restricted by setting the parameter `old_subdomain_reinitialized` to `false`. The modifier will then additionally check the element's old subdomain ID. Reinitialization then only occurs if the old subdomain ID was not in the list provided in the parameter `reinitialize_subdomains`.



## MoveNodesToSphere


Moves all nodes from the supplied [!param](/UserObjects/MoveNodesToSphere/boundary) or [!param](/UserObjects/MoveNodesToSphere/block)
to the surface of the sphere specified by the [!param](/UserObjects/MoveNodesToSphere/center) and
[!param](/UserObjects/MoveNodesToSphere/radius) parameters.

This is performed by default during adaptivity to allow adaptive refinement of curved geometries.
It can also be performed using regular execution schedules specified by the [!param](/UserObjects/MoveNodesToSphere/execute_on)
parameter.




## SidesetAroundSubdomainUpdater

### Description

The `SidesetAroundSubdomainUpdater` mesh modifier updates a sideset during a simulation by reassigning it based on a pair of subdomain sets, the [!param](/MeshModifiers/SidesetAroundSubdomainUpdater/inner_subdomains) and [!param](/MeshModifiers/SidesetAroundSubdomainUpdater/outer_subdomains). The sideset will be updated to comprise all sides along `inner_subdomains` that are neighboring `outer_subdomains` or that have no neighbor. This dynamic update can be useful in conjunction with subdomain update user objects such as [CoupledVarThresholdElementSubdomainModifier](CoupledVarThresholdElementSubdomainModifier.md).

Use the [!param](/MeshModifiers/SidesetAroundSubdomainUpdater/execution_order_group) parameter to ensure that this user object is run after any subdomain changing user object has fully traversed the mesh.

### Example Input Syntax





## TimedElementSubdomainModifier

### Overview

The `TimedElementSubdomainModifier` is a base class to be inherited by other mesh modifiers. It inherits
from `ElementSubdomainModifier` and additionally provides the ability to change elements subdomains
at given times.

## TimedSubdomainModifier


### Overview

For geometrically complex models, an efficient option is to define the volumes to be excavated/backfilled by means of subdomains (aka 'blocks'). This leads to the task of moving all elements from one subdomain to another at pre-known points in time. Furthermore, in some engineering applications
(e.g. geotechnics or mining) it might be necessary to reassign several subdomains during one simulation.
Addressing this task, the `TimedSubdomainModifier` eases re-assignment of all elements of a subdomain, makes Moose input files shorter, and reduces
potential sources of error compared to the usage of [CoupledVarThresholdElementSubdomainModifier.md] (which in turn has its advantages if the geometry is not organized into subdomains).

The `TimedSubdomainModifier` inherits from the [ElementSubdomainModifier.md]. Details on solution reinitialization, stateful material property reinitialization and moving boundary/interface nodeset/sideset modification can be found in the description of the [ElementSubdomainModifier.md].

The subdomains and times to be used by the `TimedSubdomainModifier` can be specified using one of the following options:

- 3 vectors containing the times, source and destination subdomains/blocks, or
- path to an CSV file

### Example Input File Syntax

#### Vectors of data in the input file

If the data on the subdomains and times should be provided directly in the input file, the following 3 parameters must be used. The vector of data in each parameter must have the same number of items:

- [!param](/MeshModifiers/TimedSubdomainModifier/times): Vector of times at which the elements are to be moved.
- [!param](/MeshModifiers/TimedSubdomainModifier/blocks_from): Vector of subdomain/blocks to move from. The subdomains/blocks may be given as ID or name.
- [!param](/MeshModifiers/TimedSubdomainModifier/blocks_to): Vector of subdomain/blocks to move to. The subdomains/blocks may be given as ID or name.


#### Reading data from CSV file

To read the data on the subdomains and times from an CSV file, the following parameters are to be used:

- [!param](/MeshModifiers/TimedSubdomainModifier/data_file): Name of the file in which the data is read.
- [!param](/MeshModifiers/TimedSubdomainModifier/delimiter): Optional CSV delimiter character. Defaults to comma (`,`).
- [!param](/MeshModifiers/TimedSubdomainModifier/comment): Optional CSV comment character. Defaults to hash character (`;`).
- [!param](/MeshModifiers/TimedSubdomainModifier/header): This parameter must be set to True, if the columns are to be found via header ([!param](/MeshModifiers/TimedSubdomainModifier/time_column_text), [!param](/MeshModifiers/TimedSubdomainModifier/blocks_from_column_text), and [!param](/MeshModifiers/TimedSubdomainModifier/blocks_to_column_text)). See following parameters.
- [!param](/MeshModifiers/TimedSubdomainModifier/time_column_index) -or- [!param](/MeshModifiers/TimedSubdomainModifier/time_column_text): Zero-based index or name of the column defining the times.
- [!param](/MeshModifiers/TimedSubdomainModifier/blocks_from_column_index) -or- [!param](/MeshModifiers/TimedSubdomainModifier/blocks_from_column_text): Zero-based index or name of the column defining the subdomains/blocks to move all elements from.
- [!param](/MeshModifiers/TimedSubdomainModifier/blocks_to_column_index) -or- [!param](/MeshModifiers/TimedSubdomainModifier/blocks_to_column_text): Zero-based index or name of the column defining the subdomains/blocks to move all elements to.


With the corresponding CSV-file:





## VariableValueElementSubdomainModifier

The `VariableValueElementSubdomainModifier` MeshModifier adjusts the element's subdomain according to a provided variable value. Subdomain IDs can be assigned based on the average variable value within the element, rounded to the nearest existing subdomain ID in the mesh.

**Note:** If the target value is not found in the subdomain ID list, a warning will be triggered. The system will then assign the smallest subdomain ID in the mesh that matches or exceeds the target subdomain ID to the element. Alternatively, if all subdomain IDs are smaller than the target, the system will assign the largest subdomain ID available in the mesh to the element.





# multiapps

## CentroidMultiApp


### Description

Creates a sub-app at the centroid of every element in the parent app, which can be leveraged for
doing multiscale solves. This object requires no special parameters, but this is
[block restrictable](BlockRestrictable.md) so that the sub-applications can be restricted to only
be generated on specified subdomains.

### Example Input Syntax

The following code snippet demonstrates the creation of a CentroidMultiApp object.





## FullSolveMultiApp


### Overview

The FullSolveMultiApp object is designed to perform a complete simulation every time it executes,
thus it can be used for creating simulations that have portions that are on drastically different
time scales.

### Example Input File Syntax

The following code snippet demonstrates how to create a FullSolveMultiApp object.






## QuadraturePointMultiApp


### Description

Creates a sub-app at the quadrature points within every element in the parent app, which can be leveraged for
doing multiscale solves. This object requires no special parameters, but this is
[block restrictable](BlockRestrictable.md) so that the sub-applications can be restricted to only
be generated on specified subdomains.

Boundary quadrature points are not added to the list of quadrature points, only element quadrature points.

The default mesh quadrature order will be used to locate quadrature points, not the actual quadrature order from the
[Quadrature](syntax/Executioner/Quadrature/index.md) specified in the Executioner.

### Example Input Syntax

The following code snippet demonstrates the creation of a `QuadraturePointMultiApp` object.





## TransientMultiApp


### Overview

The TransientMultiApp is designed to perform simulations with sub-applications that progress in
time with the main application.  A `TransientMultiApp` requires that your "sub-apps" use an
`Executioner` derived from [Transient.md].

### Time step size

By default, the time step size used by the main app and the sub-apps is the same
and is determined by taking the minimum over the time steps computed in the main
app and all sub apps.

Sub-cycling, where sub apps may perform multiple (smaller) time
steps for each main app time step, may be enabled using the
[!param](/MultiApps/TransientMultiApp/sub_cycling) parameter.
When performing sub-cycling, transferred auxiliary variables on sub-apps are allowed to be
interpolated between the start time and the end time of the main app with
[!param](/MultiApps/TransientMultiApp/interpolate_transfers) parameter.

### Start and end time

The [!param](/Executioner/Transient/start_time) of the sub app may differ from
that of the main app.
If the start time of the sub app is smaller than that of the main app, then if there
is sub-cycling, then in the first step, the sub app will take steps until its time
becomes synchronized with the main app time (taking a total time step larger
than the main app's first step). If there is no sub-cycling, then the sub app
will be out of sync with the main app. If the start time of the sub app is
larger than the main app's start time, then sub apps will not take steps until
their start time is reached, regardless of sub-cycling.

The [!param](/Executioner/Transient/end_time) of the sub app may also differ from
the main app. If the sub app's end time is smaller than the parent's end time,
then the main app will continue to solve past the sub app's end time, but the sub app will not solve anymore.
If the sub app's end time is larger than the parent's end time,
then the sub app will not reach its end time, since the solve will not go past
the parent app's end time.

### Time state of TransientMultiApps

`TransientMultiApps` are "auto-advanced" by default whenever we are not doing
Picard iterations between the main and sub-application. This means that the
`Transient::endStep` and `Transient::postStep` methods of the sub-applications
executioner are called, regardless of whether the sub-application solve fails or
not. The `endStep` method increments the time and also performs
`EXEC_TIMESTEP_END` output. When sub-applications are auto-advanced, their
`endStep` call happens before the main application's `endStep` call. This has
the important benefit that when main application output occurs, the
sub-application's and main application's time states are the same, which
enables MOOSE restart/recovery capability.

### Handling sub-application solve failures

As noted above, the default behavior when running `TransientMultiApps` is that
their time state is incremented, e.g. they are "auto-advanced", regardless of
whether their solve is actually successful. This is undesirable behavior, but we
believe that the syncing of main and sub-application states, under normal
operation, to enable correct [checkpoint](/Checkpoint.md) output is a good
trade. Given the constraints of the elected design, there are still multiple ways to turn a failed
sub-application solve from a warning into an exception that will force corrective
behavior in either the sub- or main-application:

1. The user can set `auto_advance = false` in the `Executioner` block of the
   main application . This will cause the main application to immediately cut
   its time-step when the sub-application fails. *However*, setting this
   parameter to `false` also eliminates the possibility of doing restart/recover
   because the main and sub will be out of sync if/when checkpoint output occurs.
2. The user can set `catch_up = true` in the `TransientMultiApp` block. This
   will cause the sub-application to try and catch up to the main application
   after a sub-app failed solve. If catch-up is unsuccessful, then MOOSE
   registers this as a true failure of the solve, and the main dt will *then*
   get cut. This option has the advantage of keeping the main and sub
   transient states in sync, enabling accurate restart/recover data.

In general, if the user wants sub-application failed solves to be treated as
exceptions, we recommend option 2 over option 1.

### Example Input File Syntax

The following input file shows the creation of a TransientMultiApp object with the time step
size being governed by the main application.





# nodalkernels

## ConstantRate


This ODE is solved at every node.
The [!param](/NodalKernels/ConstantRate/rate) parameter is controllable, so the [Control system](syntax/Controls/index.md) may be leveraged to dynamically control the rate during the simulation.

A more flexible alternative to controlling the rate with Controls is to use a [UserForcingFunctionNodalKernel.md] which has a rate that depends on space and time based on a [Function](syntax/Functions/index.md).

### Example input syntax

In this input file, the variable `lower` is the solution to the ordinary differential equation:

\dfrac{d lower}{d t} = -1

which is solved at every node on the block `lower`, which is a lower
dimensional subset of the square mesh. The constant rate term, $-1$ is
added using a `ConstantRate` nodal kernel.





## CoupledForceNodalKernel


### Description

The `CoupledForceNodalKernel` applies either a sink or source term
proportional to the value of a coupled variable `v`. An optional parameter
`coef` determines whether the term is a source or a sink and the proportionality
between the coupled variable and the applied force. When `coef` is positive
(the default value is 1), then the term is a source.

### Example Syntax





## LowerBoundNodalKernel


### Description

`LowerBoundNodalKernel` is meant to be used to impose a lower bound on a coupled
variable `v`. The variable specified by the `variable` parameter is a Lagrange
multiplier. It should have an order equivalent to that of the coupled variable
`v`. The lower bound is specified using the `lower_bound` parameter. By default
it is 0. An optional parameter is `exclude_boundaries` which can be used to
specify boundary nodes where the `LowerBoundNodalKernel` should not be
applied. This can be useful for avoiding singularities in the preconditioning
matrix that can arise when a constraint is active in the same place that another
constraint (like a `DirichletBC` is also active).

### Example Syntax





## PenaltyDirichletNodalKernel


### Description

The `PenaltyDirichletNodalKernel` object is to apply Dirichlet boundary conditions using the penalty method for nodesets. It is similar to the [`PenaltyDirichletBC`](/PenaltyDirichletBC.md) class which operates on sidesets.

### Example Syntax





## ReactionNodalKernel


### Description

The `ReactionNodalKernel` is meant to apply a simple volumetric sink reaction
term of the form $k*u$ at nodes, where $k$ is an optional user-supplied reaction
rate coefficient and $u$ is the variable that the `ReactionNodalKernel` is
being applied to.

### Example Syntax





## TimeDerivativeNodalKernel


This kernel will use the same time stepping scheme as specified for
other nonlinear variables in the [Executioner](syntax/Executioner/index.md).

### Example input syntax

In this input file, the variable `lower` is the solution to the ordinary differential equation:

\dfrac{d lower}{d t} = -1

which is solved at every node on the block `lower`, which is a lower
dimensional subset of the square mesh. The time derivative term is
added using a `TimeDerivativeNodalKernel`.





## UpperBoundNodalKernel


### Description

`UpperBoundNodalKernel` is meant to be used to impose a upper bound on a coupled
variable `v`. The variable specified by the `variable` parameter is a Lagrange
multiplier. It should have an order equivalent to that of the coupled variable
`v`. The upper bound is specified using the `upper_bound` parameter. By default
it is 0. An optional parameter is `exclude_boundaries` which can be used to
specify boundary nodes where the `UpperBoundNodalKernel` should not be
applied. This can be useful for avoiding singularities in the preconditioning
matrix that can arise when a constraint is active in the same place that another
constraint (like a `DirichletBC` is also active).

### Example Syntax





## UserForcingFunctionNodalKernel


The forcing function is a space and time dependent [Function](syntax/Functions/index.md).

The contribution to the Jacobian from this nodal kernel is 0, as
the function is deemed to not have any dependence on nonlinear variables, as functions generally do not.

### Example input syntax

In this example, the nodal scalar variable `v`, which lives independently on each node, is the solution to the following equation:

\dfrac{d v}{dt} = \dfrac{1}{4} (16*t + t^4)

The time dependent term on the right is specified using a `UserForcingFunctionNodalKernel`.





# outputs

## BlockRestrictionDebugOutput


### Overview

The BlockRestrictionDebugOutput object is, as the name suggests, designed to write out
information regarding block-restriction of Moose objects for debugging purposes. Please
refer to the [Debug/index.md] for more information.




## Checkpoint


### Overview

The Checkpoint output object is designed to perform
[restart and recovery](restart_recover.md optional=True) of simulations. The output files
created contain a complete snapshot of the simulation. These files are required to perform
restart or recovery operations with a MOOSE-base application.

### Example Input Syntax

The simplest method for enabling checkpoint files is to use the short-cut syntax
(see [syntax/Outputs/index.md]) as follows. This will write checkpoint files at every timestep, but only
keep the most recent two sets of files to avoid excessive data storage.

```text
[Outputs]
  checkpoint = true
[]
```

To change the interval, the number of stored files, or any of the other parameters for the
Checkpoint object it is required to create a sub-block.






## Console

The Console object in MOOSE is a buffered ostringstream object that should be used to for
all screen based output. Each MooseObject derived class has access to the _console
member for screen writing. Output to this object can be controlled in various ways from
the `[Outputs]` block. Information can be disabled, output at a lower frequency, colored,
or color removed.

### Multiapp Output

When using the MOOSE Multiapp system, Output to the _console object will be automatically
indented and labeled according to the multiapp level. This can make it easier to identify
where output is coming from in a more complex simulation.





## ControlOutput


### Overview

The ControlOutput object, when enabled, will show the active parameters that are being
controlled via the [Controls/index.md]. This output can automatically be enabled from the
command-line using the "--show-controls" flag.




## CSV


### Overview

The CSV output object creates files containing comma separated values. Unless disabled
(see [Outputs](syntax/Outputs/index.md)) all postprocessors and scalar variables will be written to a single
file that includes a time column.

If [vector postprocessors](syntax/VectorPostprocessors/index.md) exist within the simulation, an additional set of files will be created ---
one each for every vector that exists within a `VectorPostprocessor` object for
each timestep.




## DOFMap


### Overview

When debugging a simulation it may be necessary to investigate the [!ac](DOF) map, the
DOFMap output is designed to provide a machine readable file format for investigating the DOF map.




## Exodus


### Overview

The Exodus output object is the preferred way to write out simulation results.  It creates ExodusII formatted files that are easily read by Peacock, Paraview, Visit and other postprocessing applications.

ExodusII has many benefits over other formats.  It is a binary format based on NetCDF so the files are compact.  It also can store multiple timesteps worth of information within one file, reducing output file clutter and storage for simulation results.  Only if the mesh changes (adaptivity, movement if outputting the displaced mesh) will a new file need to be written.

Most of the time to do Exodus output you can simply set `exodus = true` in your `Outputs` block.  For more control you can add sub-block of `Outputs` and set `type = Exodus`.  That gives you full access to the parameters described below.

### Advanced Parameters

#### `output_dimension`

The `output_dimension` parameter allows you to override the default selection for the dimensionality of the output.  This is normally not needed (MOOSE can usually figure out what the dimensionality should be), but there are special cases where you might want to set this option.  In particular, if you are running a 2D simulation that is generating 3D displacement fields you will need to use `output_dimension = 3` to force the dimension so that Peacock and Paraview can properly render those displacements.




## FileOutput

Base class meant to handle the naming of files for file-based outputs.

## GMV


### Overview

The GMV output writes variable information using a format suitable for the
[General Mesh Viewer](https://www.generalmeshviewer.com).




## Gnuplot


### Overview

The GNU output writes postprocessor and scalar variable data in a format suitable for use with
[gnuplot](http://www.gnuplot.info).




## JSON

The `JSONOutput` object exists to output values from the [Reporters/index.md] in the [!ac](JSON)
format.  Reporter values are arbitrary types, as such the JSON output supports the output of any
type if the correct output helper function exists.

### Example

The following input snippet demonstrates the default method for enabling JSON output.


The resulting [!ac](JSON) output is generally in the following form, where the time information are
provided at the top level and reporters values are nested within a list for the time steps.


### Distributed Output

If a Reporter value is computed with `REPORTER_MODE_DISTRIBUTED` (see [Reporters/index.md] a JSON
file for each process will automatically be created with the distributed data and the total number
of parts and part number for the file will be included in the output.

### `to_json` function

In similar fashion to the [DataIO.md] functions used for
[restart and recovery](restart_recover.md optional=True) a `to_json` method must exist for a
type to be supported for output to a [!ac](JSON) file. The function is defined in the
[nlohmann/json](https://github.com/nlohmann/json) library---the library relied upon by MOOSE for
JSON support---for this purpose.

For example, the following code snippets show the declaration and definition of the `to_json` method
for the `MooseApp` object.






## MaterialPropertyDebugOutput


### Overview

The MaterialPropertyDebugOutput object is, as the name suggests, designed to write out material
property information for debugging purposes. Please refer to the [Debug/index.md] for
more information.




## Nemesis


### Overview

The Nemesis output is the parallel version of the [ExodusII](Exodus.md) format, which should generally
be used when running a simulation with a distributed mesh. See [Mesh/index.md] for
more information.





## Output (Outputs)

The Output object is the pure-virtual base class for all screen and file-based output in MOOSE. Developers should rarely
derive from this object directly, instead one of the intermediate base classes "should" be used if appropriate instead.

## OutputWarehouse

The `OutputWarehouse` is a storage container for all [Output](syntax/Outputs/index.md)
objects.

Warehouses are used to store objects. Using warehouses is preferable in terms of encapsulation and code design
to storing everything in central simulation classes like the [FEProblem.md]. The `OutputWarehouse` does not
derive from the other warehouse classes, such as the `MooseObjectWarehouse`.

The `OutputWarehouse` inherits the
[SetupInterface.md] and forward the setup calls (such as `timestepSetup`) to the objects they hold. Similarly,
on a call to `outputStep` on the warehouse, all the objects the `OutputWarehouse` holds will also perform
`outputStep`.

In addition to keeping track of all `Outputs` objects, the `OutputWarehouse` also:

- keeps track of the `sync_times` at which output is forced
- handles the output to the console. The `ConsoleStream` that many objects use to output, uses the `OutputWarehouse`
  under the hood to output its messages.

## PerfGraphOutput


### Description

The [/PerfGraph.md] object holds timing data for MOOSE.  With this object you can control when it's contents get printed to the screen and how detailed the data is.  The easiest way to print out the `PerfGraph` is simply to add `perf_graph = true` to your `[Outputs]` block like so:

```
[Outputs]
  perf_graph = true
[]
```

This will cause a simple, short printing of the `PerfGraph`.  For more detailed printing you'll want to create a sub-block in `[Outputs]` like so:

```
[Outputs]
  [pgraph]
    type = PerfGraphOutput
    execute_on = 'initial final'  # Default is "final"
    level = 2                     # Default is 1
    heaviest_branch = true        # Default is false
    heaviest_sections = 7         # Default is 0
  []
[]
```

Controlling when it gets printed is achieved by setting `execute_on`.  By default it's set to `final` which causes the information to be printed at the end of the simulation.

Controlling the detail is done by setting `level`.  The default level is `1` which print fairly basic performance information.  Setting the number higher causes more detail to come out.

Example with `level = 1`:

```
-------------------------------------------------------------------------------------------------------------
|                 Section                |   Self(s)  |    %   | Children(s) |    %   |  Total(s)  |    %   |
-------------------------------------------------------------------------------------------------------------
| App                                    |      0.004 |   1.95 |       0.207 |  98.05 |      0.212 | 100.00 |
|   FEProblem::computeUserObjects        |      0.000 |   0.07 |       0.000 |   0.00 |      0.000 |   0.07 |
|   FEProblem::solve                     |      0.014 |   6.59 |       0.119 |  56.44 |      0.133 |  63.03 |
|     FEProblem::computeResidualInternal |      0.000 |   0.01 |       0.079 |  37.45 |      0.079 |  37.45 |
|     FEProblem::computeJacobianInternal |      0.000 |   0.01 |       0.040 |  18.83 |      0.040 |  18.84 |
|     Console::outputStep                |      0.000 |   0.12 |       0.000 |   0.00 |      0.000 |   0.12 |
|   FEProblem::outputStep                |      0.000 |   0.04 |       0.001 |   0.42 |      0.001 |   0.46 |
|     PerfGraphOutput::outputStep        |      0.000 |   0.00 |       0.000 |   0.00 |      0.000 |   0.00 |
|     Console::outputStep                |      0.001 |   0.32 |       0.000 |   0.00 |      0.001 |   0.32 |
|     CSV::outputStep                    |      0.000 |   0.10 |       0.000 |   0.00 |      0.000 |   0.10 |
-------------------------------------------------------------------------------------------------------------
```

Example with `level = 3`:

```
-------------------------------------------------------------------------------------------------------------------------------------
|                             Section                            |   Self(s)  |    %   | Children(s) |    %   |  Total(s)  |    %   |
-------------------------------------------------------------------------------------------------------------------------------------
| App                                                            |      0.004 |   1.87 |       0.218 |  98.13 |      0.222 | 100.00 |
|   MooseApp::run                                                |      0.000 |   0.00 |       0.218 |  98.13 |      0.218 |  98.13 |
|     MooseApp::setup                                            |      0.000 |   0.00 |       0.065 |  29.29 |      0.065 |  29.29 |
|       MooseApp::runInputFile                                   |      0.000 |   0.05 |       0.039 |  17.64 |      0.039 |  17.69 |
|         GeneratedMesh::init                                    |      0.005 |   2.18 |       0.000 |   0.00 |      0.005 |   2.18 |
|         GeneratedMesh::prepare                                 |      0.001 |   0.25 |       0.002 |   1.03 |      0.003 |   1.28 |
|           GeneratedMesh::update                                |      0.000 |   0.17 |       0.002 |   0.86 |      0.002 |   1.03 |
|             GeneratedMesh::cacheInfo                           |      0.001 |   0.51 |       0.000 |   0.00 |      0.001 |   0.51 |
|         FEProblem::init                                        |      0.000 |   0.04 |       0.019 |   8.62 |      0.019 |   8.66 |
|           GeneratedMesh::meshChanged                           |      0.000 |   0.00 |       0.002 |   0.95 |      0.002 |   0.95 |
|             GeneratedMesh::update                              |      0.000 |   0.18 |       0.001 |   0.64 |      0.002 |   0.82 |
|               GeneratedMesh::cacheInfo                         |      0.001 |   0.37 |       0.000 |   0.00 |      0.001 |   0.37 |
|           FEProblem::EquationSystems::Init                     |      0.017 |   7.67 |       0.000 |   0.00 |      0.017 |   7.67 |
|     MooseApp::execute                                          |      0.000 |   0.00 |       0.153 |  68.84 |      0.153 |  68.84 |
|       MooseApp::executeExecutioner                             |      0.000 |   0.05 |       0.152 |  68.79 |      0.153 |  68.84 |
|         FEProblem::initialSetup                                |      0.001 |   0.30 |       0.006 |   2.74 |      0.007 |   3.04 |
|           GeneratedMesh::meshChanged                           |      0.000 |   0.00 |       0.002 |   0.98 |      0.002 |   0.99 |
|             GeneratedMesh::update                              |      0.000 |   0.17 |       0.002 |   0.69 |      0.002 |   0.87 |
|               GeneratedMesh::cacheInfo                         |      0.001 |   0.39 |       0.000 |   0.00 |      0.001 |   0.39 |
|           FEProblem::projectSolution                           |      0.003 |   1.57 |       0.000 |   0.00 |      0.003 |   1.57 |
|           FEProblem::reinitBecauseOfGhostingOrNewGeomObjects   |      0.000 |   0.00 |       0.000 |   0.00 |      0.000 |   0.00 |
|           FEProblem::updateGeometricSearch                     |      0.000 |   0.00 |       0.000 |   0.00 |      0.000 |   0.00 |
|         FEProblem::computeUserObjects                          |      0.000 |   0.10 |       0.000 |   0.00 |      0.000 |   0.10 |
|         FEProblem::solve                                       |      0.014 |   6.44 |       0.130 |  58.64 |      0.144 |  65.07 |
|           FEProblem::computeResidualSys                        |      0.000 |   0.01 |       0.101 |  45.42 |      0.101 |  45.43 |
|             FEProblem::computeResidualInternal                 |      0.000 |   0.01 |       0.101 |  45.41 |      0.101 |  45.42 |
|               FEProblem::computeResidualTags                   |      0.000 |   0.12 |       0.100 |  45.30 |      0.101 |  45.41 |
|                 NonlinearSystemBase::computeResidualTags       |      0.001 |   0.23 |       0.100 |  45.06 |      0.100 |  45.30 |
|                   NonlinearSystemBase::computeResidualInternal |      0.000 |   0.22 |       0.098 |  44.22 |      0.098 |  44.44 |
|                     NonlinearSystemBase::Kernels               |      0.098 |  44.22 |       0.000 |   0.00 |      0.098 |  44.22 |
|                   NonlinearSystemBase::NodalBCs                |      0.001 |   0.62 |       0.000 |   0.00 |      0.001 |   0.62 |
|           FEProblem::computeJacobianInternal                   |      0.000 |   0.00 |       0.029 |  13.10 |      0.029 |  13.10 |
|             FEProblem::computeJacobianTags                     |      0.000 |   0.03 |       0.029 |  13.07 |      0.029 |  13.10 |
|               NonlinearSystemBase::computeJacobianTags         |      0.029 |  13.07 |       0.000 |   0.00 |      0.029 |  13.07 |
|           Console::outputStep                                  |      0.000 |   0.10 |       0.000 |   0.00 |      0.000 |   0.10 |
|         FEProblem::outputStep                                  |      0.000 |   0.05 |       0.001 |   0.49 |      0.001 |   0.53 |
|           PerfGraphOutput::outputStep                          |      0.000 |   0.00 |       0.000 |   0.00 |      0.000 |   0.00 |
|           Console::outputStep                                  |      0.001 |   0.41 |       0.000 |   0.00 |      0.001 |   0.41 |
|           CSV::outputStep                                      |      0.000 |   0.07 |       0.000 |   0.00 |      0.000 |   0.07 |
-------------------------------------------------------------------------------------------------------------------------------------
```

The columns `Self`, `Children` and `Total` represent the time spent *in* the section, *in sections underneath* the section, and the sum of those two.

The percentage columns following each one are the percent that the time to the left is of the total run-time of the App.


### Levels

The following are the current level "recommendations"... note that Apps are free to add code sections to whatever level they wish... so this is just a suggestion!

- 0: Just the "root" - the whole application time
- 1: Minimal set of the most important routines (residual/jacobian computation, etc.)
- 2: Important initialization routines (setting up the mesh, initializing the systems, etc.)
- 3: More detailed information from levels `1` and `2`
- 4: This is where the Actions will start to print
- 5: Fairly unimportant, or less used routines
- 6: Routines that rarely take up much time

### Heaviest Branch

To output the most expensive ("heaviest") trace through the code set `heaviest_branch = true`.  It will print something like this:

```
-------------------------------------------------------------------------------------------------------------------------------------
|                             Section                            |   Self(s)  |    %   | Children(s) |    %   |  Total(s)  |    %   |
-------------------------------------------------------------------------------------------------------------------------------------
| App                                                            |      0.004 |   1.86 |       0.218 |  98.14 |      0.222 | 100.00 |
|   MooseApp::run                                                |      0.000 |   0.00 |       0.218 |  98.14 |      0.218 |  98.14 |
|     MooseApp::execute                                          |      0.000 |   0.00 |       0.153 |  68.88 |      0.153 |  68.88 |
|       MooseApp::executeExecutioner                             |      0.000 |   0.05 |       0.153 |  68.83 |      0.153 |  68.88 |
|         FEProblem::solve                                       |      0.014 |   6.43 |       0.130 |  58.56 |      0.144 |  64.99 |
|           FEProblem::computeResidualSys                        |      0.000 |   0.01 |       0.101 |  45.36 |      0.101 |  45.37 |
|             FEProblem::computeResidualInternal                 |      0.000 |   0.01 |       0.101 |  45.35 |      0.101 |  45.36 |
|               FEProblem::computeResidualTags                   |      0.000 |   0.11 |       0.100 |  45.24 |      0.101 |  45.35 |
|                 NonlinearSystemBase::computeResidualTags       |      0.001 |   0.23 |       0.100 |  45.01 |      0.100 |  45.24 |
|                   NonlinearSystemBase::computeResidualInternal |      0.000 |   0.22 |       0.098 |  44.17 |      0.098 |  44.38 |
|                     NonlinearSystemBase::Kernels               |      0.098 |  44.16 |       0.000 |   0.00 |      0.098 |  44.16 |
-------------------------------------------------------------------------------------------------------------------------------------
```

### Heaviest Sections

By setting `heaviest_sections = 10` (or any positive integer) you can get a print out of the 10 sections that take the most "Self" time like so:

```
---------------------------------------------------------------------
|                   Section                   |   Self(s)  |    %   |
---------------------------------------------------------------------
| NonlinearSystemBase::Kernels                |      0.098 |  44.14 |
| NonlinearSystemBase::computeJacobianTags    |      0.029 |  13.05 |
| MooseApp::setupOptions                      |      0.026 |  11.58 |
| FEProblem::EquationSystems::Init            |      0.017 |   7.65 |
| FEProblem::solve                            |      0.014 |   6.42 |
| GeneratedMesh::init                         |      0.005 |   2.17 |
| App                                         |      0.004 |   1.86 |
| FEProblem::projectSolution                  |      0.003 |   1.57 |
| GeneratedMesh::cacheInfo                    |      0.003 |   1.26 |
| Action::CreateProblemAction::FEProblem::act |      0.003 |   1.25 |
---------------------------------------------------------------------
```





## Progress


### Overview

The Progress output displays an ASCII art progress bar at the end of each timestep, visualizing the amount of simulation time that has passed vs. the total simulation time. It requires the use of a transient executioner along with predetermined start and end times. The width of the bar widget can be specified using the [!param](/Outputs/Progress/progress_bar_width) parameter. If omitted the value of the `MOOSE_PPS_WIDTH` environment variable is queried. If that variable is not set the terminal window width is queried (with a fallback value of 132 chars).

```
+-Progress (full.i)--------------------------------+
|#########################.........................|
+--------------------------------------------------+
```




## ReporterDebugOutput


### Overview

The ReporterDebugOutput object is, as the name suggests, designed to write out [Reporter](Reporters/index.md) information for debugging purposes. Please refer to the [Debug/index.md] for
more information.




## SolutionHistory


### Overview

The SolutionHistory output is a simple output format that writes the nonlinear and linear
solve history to a file.





## TableOutput

The `TableOutput` handles the output of tables to the command line, showing the values of
postprocessors, reporters and scalar variables. It also handles the output of
those same quantities as well as vector postprocessors to CSV files.

### Example output

Table output to the command line is formatted as below for postprocessors and scalar variables
respectively.

```
Postprocessor Values:
+----------------+----------------+----------------+----------------+----------------------+----------------+
| time           | dT             | max_v          | mdot           | total_fission_source | total_power    |
+----------------+----------------+----------------+----------------+----------------------+----------------+
|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |         0.000000e+00 |   0.000000e+00 |
|   1.000000e+00 |   1.541793e+01 |   2.101305e+00 |   1.870911e+04 |         6.303327e+01 |   2.999999e+09 |
+----------------+----------------+----------------+----------------+----------------------+----------------+


Scalar Variable Values:
+----------------+----------------+
| time           | lambda         |
+----------------+----------------+
|   0.000000e+00 |   3.501308e-13 |
|   1.000000e+00 |   3.501308e-13 |
+----------------+----------------+
```

And to CSV files:


## Tecplot


### Overview

The Tecplot output writes variable data in a format suitable for use with
[Tecplot](https://www.tecplot.com).




## TopResidualDebugOutput


### Overview

The TopResidualDebugOutput object is, as the name suggests, designed to write out residual
information for debugging purposes. Please refer to the [Debug/index.md] for more information.




## VariableResidualNormsDebugOutput


### Overview

The VariableResidualNormsDebugOutput object is, as the name suggests, designed to write out
variable residual norms for debugging purposes. Please refer to the [Debug/index.md] for
more information.




## VTK


### Overview

The VTK output write variable, postprocessor, and scalar variable information using the
[Visualization Toolkit](https://vtk.org/) format. To use this object libMesh must
be configured with the `--enable-vtk` option.




## XDA/XDR


### Overview

The XDA/XDR output objects write solution information using the libMesh XDA (ASCII) or
XDR (binary) format.




XDA.md

## XMLOutput


### Overview

The [VectorPostprocessors/index.md] allows vectors of data to be generated. This data is
traditionally output in the form of CSV files. For large numbers of vectors this can be
problematic for many reasons. Foremost, a CSV file is created for each object and each timestep,
resulting in a large number of output files.

If a single file is desired for all objects and timesteps the XML output can be used. If the
VectorPostprocessor object(s) are being executed in distributed mode there will be a file
created for each processor being utilized.

### Example Input File Syntax

#### Replicated Data

If the VectorPostprocessor is defined to execute in "replicated" mode (the default), then
a single XML file will be created. For example, [xml-replicated] enables the XML output that will
result in a single output file (xml_out.xml); the resulting content of this file is shown
below the snippet.

         caption=Example input file snippet with VectorPostprocessor data with XML output.

         caption=Output resulting from executing content of [xml-replicated].

Notice the "distributed" object creates a vector "data", but this data is not populated
during initial setup; no data exists with "time=0".

#### Distributed Data

In the distributed case, the actual vectors of data within a VectorPostprocessor object only
contain portions of the complete vector on each processor. For example, if [xml-replicated]
is re-executed with three processes and the parallel type is changed to distributed, an XML file
will be created for each processor. Each file will contain the portion of that data
associated with the processor, as shown in the three files below.







# parser

## Builder

The MOOSE Builder object is responsible for constructing the necessary [Actions](Action.md) that build the objects which compose a complete MOOSE based simulation.
It is important to note that +this+ object is not responsible for the raw
file-base I/O and parsing. The builder abstraction expects information to be parsed first and organized into a hierarchy of blocks with zero or more children at each level. All of the name/value pairs at each level are used to construct one or more complete objects.

### Associating parser blocks

The Builder works by using a list of registered syntax blocks with C++ types. Each
time the Builder is handed a block, it will consult the registered syntax for a list
of objects to build. MOOSE is delivered with a very low-level list of syntax where
each type of object is exposed directly to the input file by system type (e.g.
Kernels, BCs, Outputs, etc). Each application that builds upon MOOSE can augment
or replace this syntax completely. The registered list of syntax can be viewed
on the mooseframework.org website, or can be dumped on the command-line in a number
of different formats. The registration itself occurs in [Moose.C](Moose.md).

### Parameter Substitution

See [Brace Expressions](input_syntax.md optional=True)

### Active/Inactive block parameters

The Builder supports the ability to selectively activate or deactivate individual blocks
without the use of block comment characters through the use of the special "active" and
"inactive" parameter blocks. Either of these parameters (but not both) can be added
to any block (including the top level) to selectively turn individual blocks on/off.

## CommandLine

The CommandLine object is responsible for parsing and encapsulating the arguments
passed to the application via the command line. Normally developers and users
will +not+ interact with this object directly. Instead, arguments that appear
on the command line are normally spliced into the HIT parse tree when appropriate,
or are used to set [InputParameters.md] on the Application (MooseApp-derived) object
itself.

### Overriding Input File Syntax

When running multiple cases with similar input parameters, it can be convenient
to supply some arguments right on the command line. This is accomplished by
providing a fully-qualified name/value pair on the command line corresponding
to the parameter you wish to override or add.

For example given this snippet of an input file either one or both of these
parameters could be overridden from the command line with the syntax shown.
Entirely new sections can be constructed right on the command line if desired.

```
[Section]
  [object]
     some_parameter = foo
     another_parameter = bar
  []
[]


## On the command line
./MyApp-opt -i input.i Section/object/some_parameter=new_value
./MyApp-opt -i input.i Section/object/new_parameter=some_value
```

### Overriding MultiApp Syntax

Syntax from MultiApp files can be overridden as well. Since a single input file
can and is often used to spawn several SubApps a custom syntax was developed
to allow users to override one or more MultiApps or individual SubApps at a time.

Given the same input file syntax seen above see the syntax below for the various
ways in which SubApp syntax can be overridden or supplied on the command line.

```
[Multiapp]
  [sub_app_left]
    ...
  []

  [sub_app_right]
    ...
  []
[]

## Global MultApp Override
./MyApp-opt -i input.i :Section/object/some_parameter=new_value

## Whole MultiApp Override
./MyApp-opt -i input.i sub_app_left:Section/object/some_parameter=new_value

## Individual SubApp Override
./MyApp-opt -i input.i sub_app_left0:Section/object/some_parameter=new_value
                       sub_app_left1:Section/object/some_parameter=different_value
```

## Parser

The MOOSE Parser object is responsible for interacting with the HIT input file
parser. It is important to note that +this+ object is not responsible for the raw
file-base I/O. The underlying structure of the MOOSE input file is dictated by
HIT and information on the format can be found
[here](/application_usage/input_syntax.md optional=True). The parser abstraction
expects information to be organized into a hierarchy of blocks with zero or more
children at each level. It performs as much error checking as early as possible before
building any MOOSE objects.

### Includes

See [Includes](input_syntax.md optional=True)

### Multiple inputs

When multiple inputs are supplied to a MOOSE application, the parser will read
them in successively and add merge them into a single block hierarchy. Later
inputs add to and override parameters to previous inputs. This permits the user
to factor out common parts of a set of inputs and reuse them in multiple
simulations.

# partitioner

## BlockWeightedPartitioner


### Overview

Under multiphysics environment, some mesh blocks have more variables and more work load than others .  In parallel, the work
is spread out based on partitioners that assign equal number of elements to each processor. This will causes imbalanced simulations.
BlockWeightedPartitioner allow users to specify different weights for different blocks, e.g., low weights for light blocks
and high weights for heavy blocks. Weights should be proportional to the relative numbers of DOFs per element in each mesh block.
The weights do not need to be pre-normalized to any particular number.  Small numbers are better large numbers, e.g., 1 vs 2
is better than 1000 vs 2000.   Usage:



An example:







## GridPartitioner


### Description

Partitions the mesh by creating a grid in `x,y,z` and assigning each element of the mesh to a separate "cell" within the grid.  This is useful when you have simple cartesian meshes and you just want to specify partitioning fairly directly.  Sometimes a human is the best partitioner!

This is an example of a `2x2` grid partitioning for use on `4` processors.


The number of cells (`nx*ny*nz`) MUST be equal to the number of MPI processes you're attempting to use!

### How it Works

The GridPartitioner works by creating a [/GeneratedMesh.md] for the "grid".  That's the reason why this object takes similar input file parameters to a [/GeneratedMesh.md].  The GeneratedMesh created by GridPartitioner is guaranteed to contain the original domain within it.

To assign the processor IDs the centroid of each element of the mesh to be partitioned is searched for in the GeneratedMesh.  The ID of the element of the GeneratedMesh that it lies within is then assigned as the `processor_id`.





## HierarchicalGridPartitioner


### Description

The HierarchicalGridPartitioner is a two-level partitioner similar to [GridPartitioner.md].  The idea is to use a coarse grid with the number of computational nodes (nodes in your cluster you are going to use) to first partition the domain.  Then use a finer-grained grid within each of those partitions to partition for each processor within the computational node.

This type of scheme minimizes off-node communication, minimizing network communication during large simulations.

### Example

An example is the best way to explain what's going on.  The mesh in [hier_mesh] is the mesh we want to partition.  It has 128x128 elements in it (16,384 total).  We're going to be running on a cluster where we're going to use 4 computational nodes---each of which has 16 processors (64 processors total).

As shown in [hier_grid] utilizing [GridPartitioner.md] we can get a decent partitioning of this mesh by specifying the partitioning grid to be 8x8.

Now, the "problem" with this partitioning is that it will do quite a bit of off-processor communication.  Consider what's on the second node (the third and fourth rows from the bottom).  In total there will be 2x128=256 element faces with off-processor neighbors (everything above and below those two rows).  In this case that isn't even that bad.  If we were using even more processors (say 128) then each node would have a long "strip" of partitions on it where each partition would communicate both above and below it.

To fix this we can use the HierarchicalGridPartitioner using syntax shown in [hier_syntax].  By telling it that we are going to have a 2x2 arrangement of nodes and then a 4x4 arrangement of processors on each node we get [hier_pid] showing the processor assignment.  Now each node only has 128 element faces with off-processor neighbors.  Even better, there are a number of partitions that will not do any off-processor communication at all (the four interior ones in the middle of each node).  Even in this small example we've cut the off-processor communication in half by using better partitioning!  In a much larger run with larger numbers of processors per computational node (say 36, 40, 64 or even 128 which we'll see soon) this can make an even bigger difference.










## LibmeshPartitioner


The libMesh partitioners available are:

- `METIS`, which uses the [METIS library](http://glaros.dtc.umn.edu/gkhome/metis/metis/overview) for graph partitioning

- `ParMETIS`, which uses the [parallel METIS library](http://glaros.dtc.umn.edu/gkhome/metis/parmetis/overview) for graph partitioning

- `linear` partitioner, which partitions elements based solely on their ids.

- `centroid` partitioner, which partitions based on the element centroids.
  An ordering relation must be created to order the element centroids

- `hilbert_sfc` partitioner which uses Hilbert's space filling curve algorithm

- `morton_sfc` partitioner which uses Morton's space filling curve algorithm

- `subdomain partitioner`, which partitions using the element subdomains


The `LibmeshPartitioner` partitions the mesh, not the numerical system. If parts of the mesh
have more variables/DoFs than others, this may cause imbalance.

### Example input syntax

In this example, a `LibmeshPartitioner` is used to perform linear partitioning of the mesh.





## PetscExternalPartitioner

Allow users to use several external partitioning packages (parmetis, chaco, ptscotch and party) via PETSc.
Note that partitioning, just as meshing, requires a level of user insight to assure the domain is appropriately distributed. For example, edge cases where one seeks to have very few elements per process
may misbehave with certain partitioners. To avert such situations, we switch ParMETIS to PTScotch in cases with less than 28 elements per process, and notify the user.

### [ParMETIS](http://glaros.dtc.umn.edu/gkhome/metis/parmetis/overview)

ParMETIS is an MPI-based parallel graph partitioner implementing mainly a multilevel K-way algorithm.  The basic idea
of the multilevel K-way algorithm is to coarsen the graph firstly, partition the coarsened graph and then refine the partition.
It is solving a multi-constraints optimization problem.

### [PTScotch](https://www.labri.fr/perso/pelegrin/scotch/)

PTScotch is a software package  which compute parallel static mappings and parallel sparse matrix block orderings of graphs. It implements graph bipartitioning methods including band, diffusion and multilevel methods.

### [Chaco](https://www3.cs.stonybrook.edu/~algorith/implement/chaco/implement.shtml)

Chaco contains a wide variety of algorithms and options. Some of the algorithms exploit the geometry of the mesh, others its local connectivity or its global structure as captured by eigenvectors of a related matrix.

### [Party](https://cran.r-project.org/web/packages/party/vignettes/party.pdf)

The party package aims at providing a recursive partitioning laboratory assembling various high- and low-level tools for building tree-based regression and classification models.

### Use

These packages can be accessed via an unified interface in MOOSE, `PetscExternalPartitioner`. The use of the packages is accomplished by adding a subblock in `Mesh` block of input file.  For example


### Partitioning Examples

For less than 28 elements per process we switch partitioner from ParMETIS to PTScotch. For these two partitioners we illustrate the refined grid case, where the switch does not occur.

#### 4 subdomains

10x10 grid


10x10 grid


20x20 grid


20x20 grid



#### 8 subdomains






By default, all element and face weights are uniform. This can be modified by implementing `computeElementWeight`
and `computeSideWeight` in a derived class of `PetscExternalPartitioner`. For example, the [BlockWeightedPartitioner.md]
returns different weights for all elements in a block.




## RandomPartitioner


### Description

Partitions the mesh randomly.

This is useful when you want to show the importance of a good partitioner by showing the results with a *very* bad partitioner!

### How it Works

For each element, the RandomPartitioner scales a random number on `[0, 1]` to the number of processors in the partition and assigns the processor ID of the element to this value.





## SingleRankPartitioner


### Description

Partitions all elements to the given [!param](/Mesh/Partitioner/SingleRankPartitioner/rank).  Useful for restricting an application to run on only one processor.





# physics

## DiffusionCG


See the [DiffusionPhysicsBase.md] documentation for the diffusion equation solved.

### Continuous Galerkin Discretization

The volumetric discretization of the time derivative uses the [TimeDerivative.md] kernel.
The diffusion term $\nabla \cdot D \nabla u(\vec{x})$ is integrated by parts and represented using:

- a [Diffusion.md] kernel if no diffusion coefficient is passed
- a [MatDiffusion.md] kernel if a diffusion coefficient is passed, usually as a [material property](syntax/Materials/index.md)


The source term $f$ is added using:

- a [BodyForce.md] if the source is a constant, a [Postprocessor](syntax/Postprocessors/index.md) or a [Function](syntax/Functions/index.md)
- a [MatCoupledForce.md] if the force is specified using a material property
- a [CoupledForce.md] if the source is another type of [functor](syntax/Functors/index.md)


The Dirichlet boundary conditions are created using:

- a [DirichletBC.md] if the boundary value is set to a number
- a [FunctionDirichletBC.md] if set to a [Function](syntax/Functions/index.md)
- a [PostprocessorDirichletBC.md] if set to a [Postprocessor](syntax/Postprocessors/index.md)
- a [FunctorDirichletBC.md] for any other kind of [functor](syntax/Functors/index.md) for the boundary value


The Neumann boundary conditions are created using:

- a [NeumannBC.md] if the flux is set to a number
- a [FunctionNeumannBC.md] if set to a [Function](syntax/Functions/index.md)
- a [PostprocessorNeumannBC.md] if set to a [Postprocessor](syntax/Postprocessors/index.md)
- a [FunctorNeumannBC.md] for any other kind of [functor](syntax/Functors/index.md) for the flux value


We could use a [Functor](syntax/Functors/index.md) object to cover every need, but the specialized objects
are a few percent faster, depending on the case.

The user may switch between using / not using automatic differentiation for the kernel and boundary
conditions using the [!param](/Physics/Diffusion/ContinuousGalerkin/use_automatic_differentiation). This parameter is only
obeyed if the AD/non-AD object exists for the requested diffusivity / source / boundary value functor etc.





## DiffusionFV


See the [DiffusionPhysicsBase.md] documentation for the diffusion equation solved.

### Finite Volume Discretization

The volumetric discretization of the time derivative uses the [FVTimeKernel.md] kernel.
The diffusion term $\nabla \cdot D \nabla u(\vec{x})$ is integrated by parts and represented using a [FVDiffusion.md] kernel.
The source term $f$ is added using:

- a [FVBodyForce.md] if the source is a constant, a [Postprocessor](syntax/Postprocessors/index.md) or a [Function](syntax/Functions/index.md)
- a [FVCoupledForce.md] if the source is another type of [functor](syntax/Functors/index.md)


The Dirichlet boundary conditions are created using:

- a [FVDirichletBC.md] if the boundary value is set to a number
- a [FVFunctionDirichletBC.md] if set to a [Function](syntax/Functions/index.md)
- a [FVFunctorDirichletBC.md] for any other kind of [functor](syntax/Functors/index.md) for the boundary value


The Neumann boundary conditions are created using:

- a [FVNeumannBC.md] if the flux is set to a number
- a [FVFunctionNeumannBC.md] if set to a [Function](syntax/Functions/index.md)
- a [FVFunctorNeumannBC.md] for any other kind of [functor](syntax/Functors/index.md) for the flux value


We could use a [Functor](syntax/Functors/index.md) object to cover every need, but the specialized objects
are a few percent faster, depending on the case.




## DiffusionPhysicsBase

This is a base class for the derived [Physics](syntax/Physics/index.md) actions setting up objects
to solve the diffusion equation with a particular discretization.

The diffusion equation solved is:

\dfrac{\partial u}{\partial t} - \nabla \cdot D \nabla u(\vec{x}) - f(\vec{x}) = 0

with Dirichlet boundary conditions:

u(\vec{x}) = g

and / or Neumann boundary conditions:

D\dfrac{\partial u}{\partial n} = h

over the boundaries specified by the [!param](/Physics/Diffusion/FiniteVolume/dirichlet_boundaries) and
[!param](/Physics/Diffusion/FiniteVolume/neumann_boundaries) parameters respectively.

The values set at the Dirichlet boundary conditions, $g$, and Neumann boundary conditions, $h$,
are set by the [!param](/Physics/Diffusion/FiniteVolume/boundary_values) and
[!param](/Physics/Diffusion/FiniteVolume/boundary_fluxes) respectively.

# positions

## DistributedPositions


The `DistributedPositions` may require re-ordering the `Positions` objects as it must be initialized last.

### Example File Syntax

In this example, the `DistributedPositions` is distributing a set of positions from
one object onto another, forming a lattice of lattices.





## ElementCentroidPositions


### Overview

The `ElementCentroidPositions` may be block-restricted to limit the gathering of elements
to certain subdomains.

The `ElementCentroidPositions`, when used in conjunction with a [TransientMultiApp.md]
enables creating the same subapps as the [CentroidMultiApp.md], except that it is not limited to transients.




## ElementGroupCentroidPositions


### Overview

This [Positions](syntax/Positions/index.md) object can be used to keep track of the centroids of
assemblies, fuel pins, or axial levels of fuel pins, using the `assembly_id`, `pin_id` and `plane_id`
respectively in the Reactor module.

Each block or extra element id specified in the parameters creates new
bins; it does not indicate a wider group of element to compute the centroid of.

So for example, if three blocks and two types of extra element ids are specified,
and for the latter two and four specific ids are specified, then the centroids will be computed for
each of the `3 * 2 * 4` groups of elements.

If any group of element is empty, the `ElementGroupCentroidPositions` will emit a warning
and automatically remove it from the positions calculated.

This object does not support distributed meshes. If you require its use with distributed meshes
use a replicated mesh to generate the positions then after converting them to the expected format,
load them from file using a [FilePositions.md].
If you are also using displaced meshes, then contact a MOOSE developer.

### Example input syntax

In this example, we first compute the `Positions` of the centroids of each subdomain in the mesh.


We also show we can narrow this down to a single group


We then introduce extra element integer ids. Every position will correspond to the centroid of
elements that are in a given subdomain, and also hold the extra element integer ids specified.
Every additional element integer creates more combinations, more groups of elements for which the
centroids are computed and stored.


With this example, we show that specifying a simple space, like this `; ;` will request all
the available values for the element ids. This is easier than specifying them all in the input.


Finally, we do not use the `block` parameter to generate the centroids of the groups
corresponding to combinations of three extra element ids.





## FilePositions


### Overview

The format of the file should be a single position, three space-separated numbers,
on every line. No header is needed.

The `FilePositions` is similar the `positions_file` argument of [MultiApps](syntax/MultiApps/index.md).




## FunctorPositions


See the [Functor](syntax/Functors/index.md) for the list of available functors.
The functors are evaluated at the origin of the mesh at the current time.

### Example File Syntax

In this example, the `FunctorPositions` is obtaining the positions from three time-dependent functions.
The functions are evaluated at the origin of the mesh at the current time.





## InputPositions


This object should be used to specify a few positions. A [FilePositions.md] should be preferred
if there are many positions.




## MultiAppPositions


### Overview

`MultiApps` have a position that is used to translate their frame of reference compared to
the main app frame of reference. This position can be used to align the meshes for the transfers or
for outputting the `MultiApps` [Exodus results](Exodus.md) at the translated positions.

This should +not+ be used to generate new `MultiApps`. The `MultiApps` have already
been created when the positions are gathered.

### Example MultiApp File Syntax

In this example, the `MultiAppPositions` is obtaining the positions of three `MultiApps`.





## QuadraturePointsPositions


### Overview

The `QuadraturePointsPositions` may be block-restricted to limit the gathering of quadrature points to elements
from certain subdomains.

This object is currently set to:

- using the default element order for the quadrature
- using the Gauss quadrature rule
- using the element quadrature


The `QuadraturePointsPositions`, when used in conjunction with a [TransientMultiApp.md]
enables creating the same subapps as the [QuadraturePointMultiApp.md], except that it is not limited to transients.




## ReporterPositions


In order to retrieve a [Reporter](syntax/Reporters/index.md) with the `ReporterPositions`,
it must be a vector of points (`std::vector<Point>`).

### Example File Syntax

In this example, the `ReporterPositions` is obtaining the positions from two other
`Positions`, using the fact that `Positions` objects are [Reporters](syntax/Reporters/index.md)
in the back-end.





## TransformedPositions


The `TransformedPositions` may require re-ordering the `Positions` objects as it must be initialized after the positions it transforms.

Rotations along X Y and Z generally do not commute. If in doubt, using multiple `TransformedPositions`
to get the desired rotations may make it easier.

### Example File Syntax

In this example, several `TransformedPositions` are used to perform various transformations
on `Positions` objects.





# postprocessors

## AreaPostprocessor

The AreaPostprocessor is a SidePostprocessor that computes the area or dimension - 1 "volume" of a given side of the mesh. This
postprocessor may be applied to one or more boundaries simultaneously, the latter case produces a total area is output.

## Description and Syntax






## AverageElementSize


Other relevant metrics about the [mesh](syntax/Mesh/index.md) may be obtained locally using an [ElementQualityAux.md].

### Example input syntax

In this example, an advection problem is solved at multiple mesh refinement levels for a [Method of Manufactured Solution](python/mms.md optional=true) study. The size of the mesh is output to CSV using the `AverageElementSize` postprocessor.





## AverageNodalVariableValue


### Example Input File Syntax




## AverageVariableChange

This post-processor computes a volume-weighted norm of the change of a variable
or auxiliary variable over a time step or a nonlinear iteration:

||\delta u||_{\Omega,p} = \left(\frac{1}{|\Omega|} \int\limits_\Omega |\delta u|^p \, d\Omega\right)^{\frac{1}{p}} \,,

where

- $\delta u$ is the variable change of interest,
- $\Omega$ is the domain over which the norm is taken,
- $|\Omega|$ is the volume of the domain, and
- $p$ is the order of the norm (either 1 or 2).

Denoting the current time index by $n$ and the current nonlinear iteration index
by $(\ell)$, the variable change may be with respect to either the old time value,

\delta u \equiv u_n^{(\ell)} - u_{n-1}

or the previous nonlinear iteration value,

\delta u \equiv u_n^{(\ell)} - u_n^{(\ell-1)}

as determined by the value of [!param](/Postprocessors/AverageVariableChange/change_over).

Volume-weighting the norm produces a value that is independent of the size of
the domain. Without doing this, there is a domain volume bias in the norm.
Suppose $\delta u$ is constant over the domain with a value $\overline{\delta u}$:

||\delta u||_{p} = \left(\int\limits_\Omega |\overline{\delta u}|^p \, d\Omega\right)^{\frac{1}{p}}
  = |\overline{\delta u}| |\Omega|^{\frac{1}{p}} \,.




## AxisymmetricCenterlineAverageValue


### Description

'AxisymmetricCenterlineAverageValue' is a specialized case of the [SideAverageValue](/SideAverageValue.md) postprocessor for cases in which the sideset on which the average value is being calculated is along the centerline axis in axisymmetric simulations.

### Example Input syntax





## ChainControlDataPostprocessor

This [Postprocessor](syntax/Postprocessors/index.md) gets the current value of a
[/ChainControlData.md], which may be of type `Real` or `bool`. For `bool`,
a value of `true` converts to "1.0", and a value of `bool` converts to "0.0".

Within an execution step, [Controls](syntax/Controls/index.md) are executed
*before* post-processors, except for `INITIAL`, so depending on the sequence
of executions, a lag may be present.




## ChangeOverFixedPointPostprocessor

### Description

This post-processor computes the change or relative change in a post-processor
value over a fixed point iterations. It may be used to track the convergence of
the fixed point algorithm.
\begin{equation}
  (\Delta y)^n = y^n - y_{ref} \,,
\end{equation}
where $(\Delta y)^n$ is the relative change at iteration $n$, $y^n$ is the
value of post-processor $y$ at iteration $n$, and $y_{ref}$ is the reference
value for the change (either the previous iteration value, $y^{n-1}$, or the
initial value at the beginning of the iteration process, $y^0$. Relative change
is computed as
\begin{equation}
  (\Delta y)^n = \frac{y^n - y_{ref}}{y_{ref}} \,.
\end{equation}
Optionally, the user may specify to return the absolute value of the change.

### Example Syntax

The following example demonstrates how this post-processor is used:

block=Postprocessors




## ChangeOverTimePostprocessor

### Description

This post-processor computes the change or relative change in a post-processor
value over a time step or over the entire transient. The change is computed as
\begin{equation}
  (\Delta y)^n = y^n - y_{ref} \,,
\end{equation}
where $(\Delta y)^n$ is the relative change at time index $n$, $y^n$ is the
value of post-processor $y$ at time index $n$, and $y_{ref}$ is the reference
value for the change (either the previous time value, $y^{n-1}$, or the initial
value, $y^0$). The relative change, which may be requested instead using the
[!param](/Postprocessors/ChangeOverTimePostprocessor/compute_relative_change)
parameter is computed as

\begin{equation}
  (\Delta y)^n = \frac{y^n - y_{ref}}{y_{ref}} \,.
\end{equation}
Optionally, the user may specify to return the absolute value of the change.

### Example Syntax

The following example demonstrates how this post-processor is used:

block=Postprocessors




## ChangeOverTimestepPostprocessor


The `ChangeOverTimestepPostprocessor` can be used to track convergence of additional quantities computed by postprocessors. For example, in conjugate heat transfer simulations, the total energy stored in the fluid should be tracked as an additional convergence metric, and not just the residual from the equations.

The 'INITIAL' `execute_on` flag should be included in the tracked postprocessor `execute_on` parameter if the `ChangeOverTimestepPostprocessor` is set to compute the difference with regards to the initial value.

### Example input syntax

In this example, the `ChangeOverTimestepPostprocessor` is set to track the change of a `FunctionValuePostprocessor`, as a test of correctness. The `FunctionValuePostprocessor`'s evolution is known as it is defined by a `ParsedFunction`.




## ConstantPostprocessor


### Overview

The ConstantPostprocessor is used to hold a constant value. This postprocessor
may be useful as a general controllable postprocessor for the [Controls](syntax/Controls/index.md) system.

### Example Input File Syntax

In this example, the value of the ConstantPostprocessor `recv` is controlled by
a [RealFunctionControl](source/controls/RealFunctionControl.md).

  start=Controls
  end=Outputs




## CumulativeValuePostprocessor


The running sum does not take into account tallies from failed time steps.
The `CumulativeValuePostprocessor` may be executed multiple times per time step
using the `execute_on` parameter.

For time integration of postprocessors, use the [TimeIntegratedPostprocessor.md].

### Example input syntax

In this example, we tally the total number of nonlinear iterations over the time steps of the transient problem using a `CumulativeValuePostprocessor`.





## DifferencePostprocessor

The DifferencePostprocessor simply computes the difference between two other Postprocessor values:

p_1 - p_2




## ElementalVariableValue


### Description

In some cases it may be of interest to output an elemental variable value (e.g., stress)
at a particular location in the model.  This is accomplished by using the
`ElementalVariableValue` postprocessor. This postprocessor takes a specific element ID
to sample (only a single ID). The value of the specified variable is integrated over the
element and then returned.

### Example Input Syntax





## ElementArrayL2Norm





## ElementAverageMaterialProperty

This post-processor computes the average of a material property over a domain.




## ElementAverageSecondTimeDerivative


### Description

This class computes the average value of the variable's second time derivative for each element. 




## ElementAverageTimeDerivative

The ElementAverageTimeDerivative Postprocessor computes the average time derivative
of the specified variable, per element.






## ElementAverageValue


The element average of a variable is defined as the ratio of its integral over the volume of the domain:

\bar{u} = \dfrac{\int_{\Omega} u d\Omega}{\int_{\Omega} d\Omega}

This average may be taken over a restriction of blocks, but for taking an average over boundaries,
a [SideAverageValue.md] should be used instead.

### Example input syntax

In this example, we compute the average of a variable $u$ over the whole domain.





## ElementExtremeFunctorValue


You can optionally provide a [!param](/Postprocessors/ElementExtremeFunctorValue/proxy_functor),
which will change the behavior of this postprocessor to
find the element at which the proxy functor reaches the max/min value,
and then return the value of the specified functor at that element.

Like the [ElementExtremeValue.md] postprocessor, this postprocessor can also
operate on both elemental and nodal variables.
However, unlike the [ElementExtremeValue.md] postprocessor, this postprocessor
does not examine the quadrature point values, but instead passes the element
argument to the functor.

### Example Input File Syntax





## ElementExtremeMaterialProperty

This postprocessor computes the minimum or maximum of a material property from
all quadrature points in a domain.

### Example input syntax

In this example, the minimum and maximum of the material property `mat_prop` are being sampled
by two `ElementExtremeMaterialProperty` postprocessors.





## ElementExtremeValue


You can optionally provide a [!param](/Postprocessors/ElementExtremeValue/proxy_variable),
which will change the behavior of this postprocessor to
find the quadrature point at which the proxy variable reaches the max/min value,
and then return the value of the specified variable at that point.

This postprocessor can operate on both elemental and nodal variables. Note,
however, that since it works by sampling the variable at the quadrature points,
its returned value won't exactly match the variable's extreme value on the
domain (or blocks) the postprocessor is defined over. This is the case, unless
that extremum happens to be at a quadrature point, e.g., if the variable is
constant over any given element.
An alternative scheme is provided by [ElementExtremeFunctorValue.md], which
instead of sampling the variable at the quadrature points, samples the variable
at the centroid of each element in the domain (or blocks) of interest.
The corresponding postprocessor that finds (exact) extreme values of nodal
variables evaluated at nodes is [NodalExtremeValue.md].

### Example Input File Syntax





## ElementH1Error


The H1 error is a popular metric of error as it is associated with the natural norm
for commonly used finite element spaces.

||u - f||_{H_1} = \left( \int_\Omega \left( u(x,t) - f(x,t) \right)^p + \left(\nabla u(x,t) - \nabla f(x,t) \right)^p d\Omega \right)^{\dfrac{1}{p}}

where `u` is the variable parameter, `f` the function parameter, $p$ the norm exponent and $\Omega$ the domain of integration,
which may be limited to certain blocks using the `block` parameter.

### Example input syntax

In this example, we compute a variety of error between a variable and a function with the H1, L2 and H1-semi norms to verify that the H1 error is the sum of the L2 error and the H1-semi error.





## ElementH1SemiError


The gradient of the variable is compared to the gradient of the specified function.
Examining the error on the gradient can reveal excessive oscillations, highlight
the need for a higher order finite element family, or show that the gradient
of a known solution is well captured by the numerical solution.

|u - f|_{H_1} = \left( \int_\Omega \left(\nabla u(x,t) - \nabla f(x,t) \right)^p d\Omega \right)^{\dfrac{1}{p}}

where $u$ is the `variable`, $f$ the `function`, $p$ the norm exponent and $\Omega$ the integration domain,
which may be limited to certain blocks using the `block` parameter.

### Example input syntax

In this example, we compute a variety of error with the H1, L2 and H1-semi norms to verify that the H1 error is the sum of the L2 error and the H1-semi error.





## ElementHCurlError


### Overview

The H(curl)-error is the square root of the sum of the squares of the
[L2-error](ElementVectorL2Error.md) and the
[H(curl)-semierror](ElementHCurlSemiError.md).
All input parameters and their restrictions are the same as those for
[ElementHCurlSemiError.md].

### Example Input File Syntax





## ElementHCurlSemiError


### Overview

The H(curl)-semierror between a vector-valued solution $\vec{u}$ and a known
vector-valued function $\vec{f}$ is written

\begin{equation}
    \left( \int_{\Omega} || \nabla \times \vec{u}  - \nabla \times \vec{f} ||^2 \,\text{d}x \right) ^{1/2}
\end{equation}

where $||\cdot||$ denotes the l2-norm in $\mathbb{R}^d$.

The nonlinear vector variable specified for $\vec{u}$ must be of the
`NEDELEC_ONE` family, as MOOSE currently does not compute the curl for
any other finite element family.

$\vec{f}$ must be a [Function](syntax/Functions/index.md) object defining both
the `vectorValue` and `curl` methods, e.g. [MooseParsedVectorFunction.md].

### Example Input File Syntax





## ElementHDivError


### Overview

The H(div)-error is the square root of the sum of the squares of the
[L2-error](ElementVectorL2Error.md) and the
[H(div)-semierror](ElementHDivSemiError.md).
All input parameters and their restrictions are the same as those for
[ElementHDivSemiError.md].

### Example Input File Syntax





## ElementHDivSemiError


### Overview

The H(div)-semierror between a vector-valued solution $\vec{u}$ and a known
vector-valued function $\vec{f}$ is written

\begin{equation}
    \left( \int_{\Omega} | \nabla \cdot \vec{u}  - \nabla \cdot \vec{f} |^2 \,\text{d}x \right) ^{1/2}
\end{equation}

where $|\cdot|$ denotes the absolute value.

$\vec{f}$ must be a [Function](syntax/Functions/index.md) object defining both
the `vectorValue` and `div` methods, e.g. [MooseParsedVectorFunction.md].

### Example Input File Syntax





## ElementIntegralArrayVariablePostprocessor





## ElementIntegralFunctorPostprocessor


The `ElementIntegralFunctorPostprocessor` is also an intermediate base class
that should be derived from for any calculation involving
a volume integral of a functor quantity.




## ElementIntegralMaterialProperty

The `ElementIntegralMaterialProperty` postprocessor returns the integral of the
material property over the domain. If the integral of an `ADMaterialProperty` is
desired, then use `type = ADElementIntegralMaterialProperty`.

### Description and Syntax





## ElementIntegralVariablePostprocessor

The ElementIntegralVariablePostprocessor is an intermediate base class that should be derived from for any calculation involving
the integral of a variable quantity over the whole domain or a portion of the domain.

The ElementIntegralVariablePostprocessor may be used to compute the volume integral of a variable, based on the quadrature defined
for this variable. This integral may be restricted to blocks/subdomains on which the variable is defined.

### Example input file

In this input file, we use `ElementIntegralVariablePostprocessor` to compute the integral
of a variable $u$, solution of a diffusion problem, over each and all of the two subdomains it
is defined on.





## ElementL1Error


This post-processor computes the following $L^1$ error norm between an elemental
variable and a function:
\begin{equation}
  \|y_h - y\|_1 = \sum\limits_i \int\limits_{\Omega_i} |y_{h,i} - y(x)| d\Omega
\end{equation}
where

- $y_h$ is the approximate solution represented by the elemental variable,
- $y$ is the reference solution represented by a function,
- $i$ is an element index, and
- $\Omega$ is a spatial domain.





## ElementL2Difference


The element $L_2$ difference between two variables $u$ and $v$ is computed as:

||u - v||_{L_2} = \sqrt{\sum_{\text{mesh elements}} \sum_{\text{quadrature point qp}} J[qp] W[qp] c[qp] (u(qp) - v(qp))^2}

The $J$ term accounts for the geometry/volume of the element, the $W$ for the weight in the [quadrature](syntax/Executioner/Quadrature/index.md),
$c$ for an eventual coordinate change (cylindrical, spherical) and $u(qp)$ and $v(qp)$ are the values of the variable at the quadrature point.

### Example input syntax

In this example, we compute the L2 difference between two variables that are solution of the same problem, but of different order, using `ElementL2Difference` postprocessors. $u$ is a linear lagrange variable while $v$ is a second order lagrange variable. We can verify by refining the mesh that their difference goes to 0.





## ElementL2Error

The ElementL2Error computes the Euclidean distance between a field variable and an analytical function. This Postprocessor
is very useful for verifying the proper function of the framework through the [Method of Manufactured Solutions](python/mms.md optional=true).

To compute the Euclidean distance between two variables, use the [ElementL2Difference.md] instead.




## ElementL2FunctorError

The ElementL2FunctorError computes the Euclidean distance between an automatic
differentiation (AD) functor representing an approximate solution and an AD
functor representing an analytical exact solution. This Postprocessor
is very useful for verifying the proper function of the framework through the
[Method of Manufactured Solutions](python/mms.md optional=true). This class is a
generalization to the functor system of [ElementL2Error.md].




## ElementL2Norm


The element $L_2$ norm is defined as:

||u||_{L_2} = \sqrt{\int_{\Omega} u^2 d\Omega}

The element $L_2$ norm of a variable $u$ is computed as:

||u||_{L_2} = \sqrt{\sum_{\text{mesh elements}} \sum_{\text{quadrature point qp}} J[qp] W[qp] c[qp] u(qp)^2}

The $J$ term accounts for the geometry/volume of the element, the $W$ for the weight in the
[quadrature](syntax/Executioner/Quadrature/index.md), $c$ for an eventual coordinate change
(cylindrical, spherical) and $u(qp)$ is the value of the variable at the quadrature point.

### Example input syntax

In this example, we compute the L2 norm for a variety of auxiliary variable types using `ElementL2Norm` postprocessors.





## ElementSidesL2Norm


The element-sides $L_2$ norm is defined as:

||u||_{L_2(\Gamma)} = \sqrt{\int_{\Gamma} u^2 d\Gamma}

Where here $\Gamma$ is defined as the union of all sides of all
elements in a mesh, counting internal sides shared by two elements
once rather than twice.

The side $L_2$ norm of a variable $u$ is computed as:

||u||_{L_2(\Gamma)} = \sqrt{\sum_{\text{mesh element sides}} \sum_{\text{quadrature point qp}} J[qp] W[qp] c[qp] u(qp)^2}

These terms are initialized on each side, so the $J$ term accounts
for the geometry/area of the element, the $W$ for the weight in the
[quadrature](syntax/Executioner/Quadrature/index.md), $c$ for any
eventual coordinate change (cylindrical, spherical) and $u(qp)$ is the
value of the variable at the quadrature point.

### Example input syntax

In this example, we compute the L2 norm for the Lagrange multiplier variable using an `ElementSideL2Norm` postprocessor.





## ElementVectorL2Error


### Overview

The L2-error between a vector-valued solution $\vec{u}$ and a known
vector-valued function $\vec{f}$ is written

\begin{equation}
    \left( \int_{\Omega} || \vec{u}  - \vec{f} ||^2 \,\text{d}x \right) ^{1/2}
\end{equation}

where $||\cdot||$ denotes the l2-norm in $\mathbb{R}^d$.

The user can specify $\vec{u}$ with either a single nonlinear vector variable,
or with up to three nonlinear scalar variables simultaneously, which would each
typically represent the x, y, z components of the vector variable.

Likewise, the user can also specify $\vec{f}$ with either a single
[Function](syntax/Functions/index.md) object defining the `vectorValue` method,
e.g. [MooseParsedVectorFunction.md], or up to three such objects defining
the `value` method, e.g. [MooseParsedFunction.md].

### Example Input File Syntax

With a single nonlinear vector variable and a single vector-valued function:


With component-wise specifications for both the nonlinear variable and the function:





## ElementW1pError

The W1_p error between variable $u$ and function $f$ is equal to:

||u - f||_{W1_p} = \left( \int_{\Omega} (u-f)^p + (\vec{\nabla} u - \vec{\nabla} f)^p d \Omega \right)^{\dfrac{1}{p}}

The gradient difference term is computed as below:

(\vec{\nabla} u - \vec{\nabla} f)^p = \sum_{\text{dimension i}} (\dfrac{du}{dx_i} - \dfrac{df}{dx_i})^p




## EmptyPostprocessor


This postprocessor is not useful. It can be replaced by a [ParsedPostprocessor.md], a [FunctionValuePostprocessor.md] or a [Receiver.md] with no difficulty.




## FindValueOnLine

The FindValueOnLine Postprocessor is for sampling a line through a mesh or on a boundary
looking for the point at which a specific value occurs. The values of the line
must behave monotonically or an indeterminate solution may be found.






## FunctionElementAverage

This post-processor computes the average $y(t)$ of some function $f(\mathbf{x}, t)$
over a domain $V$:

y(t) = \frac{1}{V} \int\limits_V f(\mathbf{x}, t) dV \,.




## FunctionElementIntegral


This post-processor computes the integral $y(t)$ of some function $f(\mathbf{x}, t)$
over a domain $V$:
\begin{equation}
  y(t) = \int\limits_V f(\mathbf{x}, t) dV \,.
\end{equation}





## FunctionSideAverage

This post-processor computes the average $y(t)$ of some function $f(\mathbf{x}, t)$
over a boundary $A$:

y(t) = \frac{1}{A} \int\limits_A f(\mathbf{x}, t) dA \,.




## FunctionSideIntegral


The sideset may be an internal or external boundary.
The function is evaluated at each quadrature point on the specified sideset. The default quadrature rule is used for integration.

### Example input syntax

In this example test, we compute a few function integrals on the boundaries of
the domain. Since the mesh is Cartesian, the integrals are known.





## FunctionValuePostprocessor


If `FunctionValuePostprocessor` uses something like a [/MooseParsedFunction.md],
it may have indirect dependencies on other user objects/postprocessors, since
`ParsedFunction` supports postprocessor values. If this is the case, the
[!param](/Postprocessors/FunctionValuePostprocessor/indirect_dependencies)
parameter should be used to supply these indirect dependencies, otherwise these
dependencies may execute after this postprocessor, and this postprocessor may
have inaccurate values.

This object allows to supply postprocessors as arguments to the time and
space arguments of the function.
Use the [!param](/Postprocessors/FunctionValuePostprocessor/time)
to specify the postprocessor passed to the time argument.
Use the [!param](/Postprocessors/FunctionValuePostprocessor/point)
to specify postprocessors passed to the space argument.




## GreaterThanLessThanPostprocessor


### Description

The `GreaterThanLessThanPostprocessor` computes the total number of degrees of
freedom of a nonlinear `variable` that are greater than or less than the
parameter `value`. The comparison of greater or less is specified using the
`MooseEnum` parameter `comparator`; the possible values of `comparator` are
`greater` or `less`. The computation may also be restricted to a subdomain using
the parameter `subdomain`.

### Example Syntax






## InterfaceAverageVariableValuePostprocessor

### Description


This post-processor is used to compute an average value across an interface. The type of average to compute is selected by changing the `interface_value_type` parameter. If the parameter `interface_value_type` is omitted it defaults to compute the average value between the two input variables across the interface.
The various types of averages that can be computed are describe in more details in [InterfaceValueTools](/InterfaceValueTools.md).

### Example Input File Syntax

In this example the average of the diffusivity material property is computed across an interface by an `InterfaceAverageVariableValuePostprocessor`. Note that the type of the postprocessor is determined by a substitution here, replacing '${postprocessor_type}' with `InterfaceAverageVariableValuePostprocessor`.





## InterfaceDiffusiveFluxAverage


The diffusive flux average is defined as
\begin{equation}
  \dfrac{\int_{\partial \Omega} -D \vec{\nabla} u \cdot \vec{n} d\Omega}{A}
\end{equation}
with $\partial \Omega$ the interface, $D$ the diffusion coefficient, $u$ the variable,
$\vec{n}$ the normal to the interface and $A$ the surface area of the interface.


For finite volume variables, this postprocessor computes the diffusive flux using a two
point gradient. This is only accurate if the (interface) kernel is also computing gradients
this way. Currently, only [FVDiffusionInterface](/fviks/FVDiffusionInterface.md)
is computing gradients this way.

The expression of the diffusive flux in this object is generic, as described, and may differ from the diffusive flux in your specific physics implementation. If so, you may not use this object to compute the diffusive flux.




## InterfaceDiffusiveFluxIntegral


The diffusive flux integral is defined as
\begin{equation}
  \int_{\partial \Omega} -D \vec{\nabla} u \cdot \vec{n} d\Omega
\end{equation}
with $\partial \Omega$ the interface, $D$ the diffusion coefficient, $u$ the variable and
$\vec{n}$ the normal to the interface.

The integral of the diffusive flux may be used to compute the contribution of diffusion when
examining the balance of a physical quantity (energy, momentum) over a domain.

For finite volume variables, this postprocessor computes the diffusive flux using a two
point gradient. This is only accurate if the (interface) kernel is also computing gradients
this way. Currently, only [FVDiffusionInterface](/fviks/FVDiffusionInterface.md)
is computing gradients this way.

The expression of the diffusive flux in this object is generic, as described, and may differ from the diffusive flux in your specific physics implementation. If so, you may not use this object to compute the diffusive flux.




## InterfaceIntegralVariableValuePostprocessor

### IMPORTANT NOTE
*** Any derived class of InterfaceUserObject does not support yet getMaterialProperty, please use auxvariables ***

### Description

This post-processor is used to compute an integral value of variable on an interface. The type of average to compute is selected by changing the `interface_value_type` parameter. If the parameter `interface_value_type` is omitted it defaults to compute the average value between the two input variables across the interface.
The various types of averages that can be computed are describe in more details in  [InterfaceValueTools](/InterfaceValueTools.md).


### Example Input File Syntax

listing test/tests/postprocessors/interface_value/interface_integral_variable_value_postprocessor.i block=Postprocessors/diffusivity_average




## InternalSideIntegralVariablePostprocessor


The InternalSideIntegralVariablePostprocessor is also an intermediate
base class that should be derived from for any calculation involving
the integral of a variable quantity over internal sides.

### Example input syntax

In this example, an `InternalSideIntegralVariablePostprocessor` is
used to compute the integral of variable `u` over all internal sides.





## IsMatrixSymmetric

This class reports whether the system matrix is symmetric or not. If it is
symmetric then the value returned is 1, else it is 0. This class's execution is
fairly expensive so we only recommend using it on relatively small problems.





## LinearCombinationPostprocessor

### Description

This post-processor computes a linear combination between an arbitrary number of post-processors $x_i$:
\begin{equation}
  y = \sum\limits_i c_i x_i + b \,,
\end{equation}
where $c_i$ is the combination coefficient for $x_i$, and $b$ is an additional
value to add to the sum.

### Example Syntax

The following example demonstrates how this post-processor is used:

block=Postprocessors




## MaxVarNDofsPerElem

### Description

This class can be used to calculate the maximum number of degrees of freedom on
an element. This may be useful in automatic differentiation calculations to
limit the number of derivative calculations that have to be carried out.

This postprocessor is a MOOSE test object. Pass `--allow-test-objects` to your MOOSE or
MOOSE-based app executable to be able to use it in a simulation. If this object is needed often, 
it is recommended that the developer [reach out to the MOOSE development team](https://github.com/idaholab/moose/discussions) 
so that the object can be moved from `test/src` or create a new Pull Request (with contribution 
guidelines found [here](https://mooseframework.inl.gov/framework/contributing.html))
containing the move.

## MemoryUsage


This postprocessor collects various memory usage metrics:

- physical memory (most relevant, tied to hardware RAM limitation)
- virtual memory
- major page faults (how often disk swap is accessed)

The units for memory default to MegaBytes, but users can report usage in other
units through the mem_units parameter: (bytes, kilobytes, megabytes, gigabytes).

The data can be reduced in parallel as

- maximum out of all MPI ranks
- minimum out of all MPI ranks
- average over all MPI ranks
- total sum over all MPI ranks (default)

Physical memory statistics are available on Mac and Linux, virtual memory and
page fault data is Linux only.

This postprocessor can be executed multiple times per timestep and by default
aggregates the per-process peak value of the chosen metric, which then can be
output on `TIMESTEP_END`.

Until October 2018 this Postprocessor defaulted to reporting *virtual memory*.
This was changed to the more relevant *physical memory* to avoid misleading
benchmark results to be generated.

For a VectorPostprocessor that provides detailed per MPI rank memory statistics see
[`VectorMemoryUsage`](/VectorMemoryUsage.md).

### Implementation

The `/proc/self/status` files is checked first. This file only exists on Linux
systems and contains
[several columns](http://man7.org/linux/man-pages/man5/proc.5.html) with process
specific statistics. On mac systems a conditionally compiled code (`#ifdef __APPLE__`)
block uses a mach kernel API function `task_info` to obtain the memory sizes of the
current process.




## NearestNodeNumber

This postprocessor outputs the node number of the nearest node to a given point, using the computations performed by a [NearestNodeNumberUO](NearestNodeNumberUO.md) UserObject.





## NodalExtremeValue


You can optionally provide a [!param](/Postprocessors/NodalExtremeValue/proxy_variable),
which will change the behavior of this postprocessor to
find the node at which the proxy variable reaches the max/min value,
and then return the value of the specified variable at that node.

The corresponding postprocessor that finds extreme values of variables evaluated
inside elements (at quadrature points) is
[ElementExtremeValue](ElementExtremeValue.md)

### Example Input File Syntax





## NodalL2Error


This is typically used to compare a nodal variable to a known analytical solution.
To compute the error with regards to a variable, instead of a function, you may use
a [ParsedAux.md] to store the difference in an `AuxVariable`, then use the `NodalL2Error`
or [NodalL2Norm.md] postprocessor to compute the norm.

### Example input syntax

In this example, variable `u` is the solution of a diffusion-source problem. We know the
analytical solution of this problem and use the `NodalL2Error` postprocessor to examine
the quality of the numerical solution.





## NodalL2Norm


||u||_{L_2} = \sqrt{\sum_{\text{nodes n}} u(n)^2}

### Example input syntax

In this example, the L2 norm of the variable `saved` is computed on
block 0 at the end of every time step using a `NodalL2Norm` postprocessor.





## NodalMaxValue


This postprocessor is deprecated. Please use [NodalExtremeValue.md].




## NodalMaxValueId


This postprocessor performs a reduction across all ranks to compute the maximum, then returns the id of the node with the global maximum.

### Example input syntax

In this input file we obtain both the maximum value of variable `u` using a [NodalExtremeValue.md] and the location where it is reached using a `NodalMaxValueId`.





## NodalSum

Computes the sum of all of the nodal values of a specified variable.




## NodalVariableValue


### Description

In order to obtain the value of a nodal variable at a particular location (i.e.,
temperature and displacement) a `NodalVariableValue` postprocessor is used. For example,
this postprocessor is useful for obtaining the centerline temperature at the location of a
thermocouple to compare against experimental data.

### Example Input Syntax





## NumDOFs

The NumDOFs postprocessor provides information about the number of degrees of freedom (DOFs) in the simulation. This postprocessor
is capable of providing the DOFs in either the Nonlinear system (the system of PDEs you are solving), the Auxiliary system, the
system containing only explicit calculations, or both together.

If you are using [Mesh Adaptivity](syntax/Adaptivity/index.md), the number of DOFs will likely change as your simulation progresses.
You might consider using `execute_on = initial timestep_end` in that case. Otherwise `execute_on = initial` should be sufficient.

When scaling your problem up to more processor cores, try not to spread your problem out too much. A good target should be around
20,000 DOFs in your Nonlinear System. Please see this [PETSc FAQ](http://www.mcs.anl.gov/petsc/documentation/faq.html#slowerparallel) for more information.

### Description and Syntax






## NumElements


The `NumElements` [Postprocessor](Postprocessors/index.md) provides information about the number of elements in the simulation. This postprocessor
is capable of providing either the active number of elements in the simulation (i.e. only the elements that are
being used for calculations), or the total number of elements (i.e. includes parent elements of refined elements,
which are maintained for the purpose of coarsening).

This postprocessor returns the aggregate number of elements when using DistributedMesh.





## NumFailedTimeSteps


### Description

`NumFailedTimeSteps` reports the number of failed time steps.

### Example Input Syntax





## NumFixedPointIterations


Many problems, often multiphysics, need to be iterated to convergence. For steady state problem, it
can be done using a pseudo-transient, where the time step is incremented for each iteration. For problems that
are already transient in nature, it can also be done using a fixed point process. Each solve is iterated to
convergence. This postprocessor serves to measure the number of iterations needed to reach convergence.

### Example Input File Syntax

In this input file, we have a two-level multiphysics coupling, meaning that the parent app is
coupled with a sub-app, which is itself coupled with a sub-sub-app. We count the number of iterations
to converge the top level coupling with this postprocessor. The iterations taken to converge the bottom
level coupling are not counted, they would be counted by a similar postprocessor in the intermediate
sub-application.





## NumLinearIterations


The number of linear iterations reported is the total number of linear iterations over a time step for transients, and over a nonlinear solve for steady solves.




## NumMeshDivisions





## NumNodes

The NumNodes Postprocessor returns the total number of nodes in the simulation. Returns the total number
of nodes when using DistributedMesh.

### Syntax and Description






## NumNonlinearIterations


### Description

`NumNonlinearIterations` reports the number of nonlinear iterations in the just-completed
solve.

### Example Input Syntax





## NumPositions


Currently, the number of positions should be constant throughout the simulation.
Please contact a MOOSE developer if you need support for variable numbers of Positions.




## NumRelationshipManagers

The `NumRelationshipManagers` class outputs the total number of relationship managers
present in the simulation. The type of relationship managers counted can be
controlled with the `rm_type` parameter. Available options are
(case-insensitive): 'geometric, 'algebraic', 'coupling', and 'all'. The default
is 'all'.

### Syntax and Description






## NumResidualEvaluations


This postprocessor helps to understand where the computation time is being spent, to perform optimization studies for example. More information about forming the residual in the [nonlinear system](source/systems/NonlinearSystem.md) may be found [here](syntax/Kernels/index.md).




## NumTimeSteps


### Example Input Syntax





## NumVars

The NumVars Postprocessor provides information about the number of variables in the simulation. This postprocessor
is capable of providing the number of variables in either the Nonlinear system (the system of PDEs you are solving),
the Auxiliary system, the system containing only explicit calculations, or both together.

### Syntax and Description






## ParsedPostprocessor


The [!param](/Postprocessors/ParsedPostprocessor/expression) to parse may only include other postprocessors, the time variable and
constants from the input file.

Derivatives and integrals are not natively supported by the parsing operation, unless the
postprocessors in the parsed expression are already the derivatives / integrals of interest.

### Example Input File Syntax

In this test input file, we compute various quantities using ParsedPostprocessors. First,
we look at the ratio of two postprocessors:


Then we add a time dependence to the postprocessor result:


And finally we introduce constants from the input file in the parsed expression:





## PercentChangePostprocessor


This postprocessor is deprecated. Please use a [ChangeOverTimePostprocessor.md] and set the `compute_relative_change`
parameter to `true`.




## PerfGraphData


### Description

`PerfGraphData` retrieves performance data from the [/PerfGraph.md] and reports it as a `Postprocessor`.

The name of the section that you wish to retrieve performance data for is to be provided in the [!param](/Postprocessors/PerfGraphData/section_name) parameter. The performance data type (see [PerfGraph.md#performance-data-types] for details on the possible options) is to be provided in the [!param](/Postprocessors/PerfGraphData/data_type).

Most registered [PerfGraph.md] sections are not registered until the first moment they are ran. Depending on what execution flags are set (when `PerfGraphData` is executed), the system by default will error if retrieving information for a section that has not ran yet. To skip this error and return zero for sections that have not ran yet, you must set [!param](/Postprocessors/PerfGraphData/must_exist) to `false`. See [PerfGraph.md#early-retrieval] for more information.





## PointValue

The PointValue Postprocessor samples a field variable at a single point within the domain. It will throw
an error if the point being sampled lies outside of the domain.

The behavior of the PointValue processor is undefined if using discontinuous shape functions
and the sample point lies right on a discontinuity.




## Postprocessors

The Postprocessor object is the pure-virtual base class for defining all Postprocessors in MOOSE. It defines a single
method that all Postprocessors must override to produce a global scalar value. This method is generally called and stored
in multiple [Output](/Output.md) formats once per time step (when applicable).

  re=([^\n]+\n)*[^\n]+getValue[^\n]*;

## PostprocessorComparison


This post-processor is used to compare two post-processor (or constant) values.
It returns a value of 1 for "true" and 0 for "false". There are a number of
different options for the parameter `comparison_type`. Denoting the first
value as `a` and the second as `b`, these options are as follows:

| Value                 | Test      |
|-----------------------|-----------|
| `equals`              | `a == b`? |
| `greater_than`        | `a > b`?  |
| `greater_than_equals` | `a >= b`? |
| `less_than`           | `a < b`?  |
| `less_than_equals`    | `a <= b`? |

All tests use a "fuzzy" comparison; see the corresponding functions in
[MooseUtils.md].





## PseudoTimestep

The methods implemented in this postprocessor compute timesteps adaptively using Pseudo Transient Continuation strategies. This allows for steady-state problems to be solved via a time marching approach to reach the final state rapidly.
As a reminder, the time marching approach to computing steady states reframes a problem in discrete form $M\frac{\partial \mathbf u}{\Delta t}=F(\mathbf u)$, where $M$ is the mass matrix and $F()$ an operator gathering the right-hand side discrete terms.
Using implicit Euler, the problem reads

\begin{equation}
M\frac{\mathbf u_{n+1}-\mathbf u_n}{\Delta t}=F(\mathbf u_{n+1})
\end{equation}

To be consistent with the literature the current implementation has been tested only on implicit Euler.

### Overview

This object computes a timestep to accelerate the convergence to steady-state using pseudo-transient continuation.
The change in timestep is determined by the steady-state residual behavior from one iteration to another, i.e., small changes in residual indicate larger timesteps are allowed. In contrast, significant changes in the residual indicate a timestep decrease is necessary.
Following [!citep](bucker2009cfl), we recognize and implement three methods.

The user must make a method choice, between `SER`, `EXP` and `RDM`, which are implemented as listed below.
All methods require a parameter [!param](/Postprocessors/PseudoTimestep/alpha), which controls how sensitive the timestep should be with respect to residual changes, and [!param](/Postprocessors/PseudoTimestep/initial_dt) to provide a first timestep length.
If nothing is known about the problem we recommend `initial_dt = 1` and `alpha = 2`, keeping in mind that a high [!param](/Postprocessors/PseudoTimestep/alpha) corresponds to a higher sensitivity to residual changes. More specific choices for fluid dynamics problems are available in [!citep](bucker2009cfl) or [!citep](ceze2013pseudo). The parameter [!param](/Postprocessors/PseudoTimestep/alpha) is always larger than 0, noting that for some versions of Pseudo Timestep Continuation methods it can be lower than 1. We refer the user to the literature, or to perform a preliminary study for their specific problem.

Methods supported include:

- +Switched evolution relaxation (SER)+

  \begin{equation}
  \Delta t_k =\Delta t_{k-1} \cdot \bigg(\frac{R_{k-\ell}}{R_{k}}\bigg)^{\alpha}
  \end{equation}

  where $\alpha$ is a user chosen parameter. The l2-norm of the steady-state residual at step $k$ is $R_k$, and the residual at $\ell$ iterations before is denoted as $R_{k-\ell}$. To set a number of previous iterations corresponding to $\ell$ the user can prescribe an integer value for the parameter [!param](/Postprocessors/PseudoTimestep/iterations_window).

- +Residual Difference Method (RDM)+

  \begin{equation}
  \Delta t_k =\Delta t_{k-1} \cdot \alpha^{\frac{R_{k-1}-R_k}{R_{k-1}}}
  \end{equation}

  This implementation is the `RDM` method variant as found in [!citep](ceze2013pseudo), other variants are available in e.g. [!citep](bucker2009cfl).

- +Exponential progression (EXP)+

  \begin{equation}
  \Delta t_k =\Delta t_{0} \cdot \alpha^k
  \end{equation}

  where $\alpha$ is a user chosen parameter, $k$ is the current iteration step.

As noted also in [!citep](bucker2009cfl) the EXP method has an infinite growth, so for this method a [!param](/Postprocessors/PseudoTimestep/max_dt) parameter may be recommended. If no [!param](/Postprocessors/PseudoTimestep/max_dt) is provided by the user then infinite growth of the timestep is not bounded and the user will be informed by a message at the console. Ideally this method is used in conjunction with a steady state detection, i.e. setting [!param](/Executioner/Transient/steady_state_detection) to `true` and a [!param](/Executioner/Transient/steady_state_tolerance).

### Example Input File Syntax

    block=Postprocessors





## Receiver


### Overview

The Receiver Postprocessor is useful for reporting scalar values created in other parts of the system
such as in a [MultiApp](syntax/MultiApps/index.md), and moved to the Receiver using a
[MultiAppPostprocessorTransfer.md] for example.
It does +not+ compute its own value. Note that the user may set a default
value with the "default" parameter.

This can also be used to receive a restarted postprocessor value. In this case, simply define a Receiver
with the same name as the postprocessor that you wish to load when loading from restart.

### Example Input File Syntax

In this example, the value of the Receiver 'pp' in the subapp 'quad' is being populated by
the value of a variable 'parent_aux' in the main application.






## RelativeDifferencePostprocessor

### Description

This post-processor computes the absolute value of the relative difference
between 2 post-processor values:
\begin{equation}
  y = \left| \frac{x_1 - x_2}{x_1} \right| \,,
\end{equation}
where $x_1$ and $x_2$ are the 2 post-processor values. Note that $x_2$ is used
as the base for the relative difference. If $x_2 \approx 0$, then the absolute
difference is used instead to prevent division by zero:
\begin{equation}
  y = \left| x_1 - x_2 \right| \,.
\end{equation}

### Example Syntax

The following example demonstrates how this post-processor is used:

block=Postprocessors




## RelativeSolutionDifferenceNorm


The formula for the relative difference is:

\dfrac{u^{n+1} - u^n}{u^n}

where $u$ is the solution vector, composed of the degrees of freedom of all the components of all the nonlinear variables,
and $n$ is the index of the time step.

### Example input syntax

In this example, the `RelativeSolutionDifferenceNorm` is used to examine the
convergence of a transient source-diffusion problem.





## Residual

This post-processor computes the nonlinear residual norm.
The parameter [!param](/Postprocessors/Residual/residual_type) may have one of
the following values:

- `FINAL`: The final norm, obtained by `NonlinearSystemBase::finalNonlinearResidual()`
- `INITIAL`: The post-SMO initial residual norm, obtained by `NonlinearSystemBase::preSMOResidual()`.
  For the definition of pre- vs. post-SMO residual, see [NonlinearSystem.md].
- `PRE_SMO`: The pre-SMO initial residual norm, obtained by `NonlinearSystemBase::initialResidual()`
- `CURRENT`: The current norm, obtained directly from the PETSc SNES object.
  It is recommended to set [!param](/Postprocessors/Residual/execute_on) to
  `NONLINEAR_CONVERGENCE` to get the desired behavior for this option.

More information about residuals and their use in Newton's method may be found
in [NonlinearSystem.md].

The residual may be split by variables using the [VariableResidual.md] postprocessor.

### Example input syntax

In this example, `u` is the solution of a diffusion problem. A predictor time integrating
scheme is used and the `Residual` postprocessor reports the residual.





## ScalarL2Error


The function to compare the scalar variable against is evaluated at the simulation time
and at the (0,0,0) point. Given that a single number is included in this sum, the
L2 norm is the same as the absolute value.

This postprocessor does not compute the L2 error for an array scalar variable! It only
uses the first component of the scalar variable.

### Example input syntax

In this example, we solve an ODE for scalar variable `n`, then compute the convergence
to a known analytic solution to examine the order of convergence of a time scheme.





## ScalarVariable


### Example input syntax

In this example, the scalar variable `v` is the solution of a simple reaction ODE.
We use the `ScalarVariable` postprocessor to output the value of the scalar variable
to a CSV file.





## ScalePostprocessor

The ScalePostprocessor scales another Postprocessor in the simulation by a Real value.






## SideAdvectiveFluxIntegral


### Description

The `SideAdvectiveFluxIntegral` postprocessor is used to compute the side integral of the advection flux component including x, y, z and normal. This kernel supports both finite element and finite volume variables.

For finite element method, the variable needs to be a continuous finite element type(e.g.LAGRANGE, HIERARCHIC, BERNSTEIN, SZABAB, RATIONAL_BERNSTEIN, CLOUGH, HERMITE, etc.), so that the side value can be estimated in MOOSE. The advection variable can be either a variable[!param](/Postprocessors/SideAdvectiveFluxIntegral/advected_variable) or material property[!param](/Postprocessors/SideAdvectiveFluxIntegral/advected_mat_prop).

For finite volume method, an advected quantity needs to be provided[!param](/Postprocessors/SideAdvectiveFluxIntegral/advected_quantity). The advection velocity is required with [!param](/Postprocessors/SideAdvectiveFluxIntegral/vel_x) for advection flux calculation. [!param](/Postprocessors/SideAdvectiveFluxIntegral/vel_y) and [!param](/Postprocessors/SideAdvectiveFluxIntegral/vel_z) are needed for 2D and 3D simulations.

The expression of the advective flux in this object is generic, as described, and may differ from the advective flux implemented in your physics implementation. If so, you may not use this object to compute the advective flux.

### Example Input Syntax





## SideAverageFunctorPostprocessor


The [!param](/Postprocessors/SideAverageFunctorPostprocessor/functor_argument) parameter lets
the user select between face integration and element side quadrature point integration. Face integration
is more appropriate for finite volume variables, and quadrature point integration is more appropriate
for finite element variables.




## SideAverageMaterialProperty

This post-processor computes the average of a material property over a side set.
The supplied property can be of type `Real`, `std::vector<Real>`,
`RealVectorValue`, `RankTwoTensor`, `RankThreeTensor`, or `RankFourTensor`.
Depending on the property type an index with the correct dimension must be
supplied to select a scalar component from the supplied material property (e.g.
`component = '0 1'` for a property of type `RankTwoTensor`).




## SideAverageValue


### Description

`SideAverageValue` computes the area- or volume-weighted average of the integral of the specified
variable. It may be used, for example, to calculate the average temperature over a side set.

`SideAverageValue` is not suitable for use when computing the average integral value of a variable
when one of the coordinates in the sideset has a value of zero.  In those cases, such as when
computing the value of a variable on the centerline of an axisymmetric simulation, use
[AxisymmetricCenterlineAverageValue](/AxisymmetricCenterlineAverageValue.md)

### Example Input Syntax





## SideDiffusiveFluxAverage


The expression of the diffusive flux in this object is generic, as described, and may differ from the diffusive flux in your specific physics implementation. If so, you may not use this object to compute the diffusive flux.

### Example Input Syntax





## SideDiffusiveFluxIntegral


The expression of the diffusive flux in this object is generic, as described, and may differ from the diffusive flux in your specific physics implementation. If so, you may not use this object to compute the diffusive flux.

### Example Input Syntax





## SideExtremeValue


You can optionally provide a [!param](/Postprocessors/SideExtremeValue/proxy_variable),
which will change the behavior of this postprocessor to
find the point at which the proxy variable reaches the max/min value,
and then return the value of the specified variable at that node.

The corresponding postprocessor that finds extreme values of variables evaluated
inside elements (at quadrature points) is
[ElementExtremeValue](ElementExtremeValue.md)

### Example Input File Syntax





## SideFluxAverage

This object is deprecated. See [SideDiffusiveFluxAverage](/SideDiffusiveFluxAverage.md) 





## SideFluxIntegral

This object is deprecated. See [SideDiffusiveFluxIntegral](/SideDiffusiveFluxIntegral.md) 


### Example Input Syntax





## SideFVFluxBCIntegral

Computes the side integral of different finite volume flux boundary conditions.
Let $F(u)$ denote a flux on the boundary given by a flux boundary condition.
In practice, this flux can be the result of diffusive, convective
or radiative boundary conditions, to name a few. This postprocessor
provides the following expression:

\begin{equation}
\int_S \sum_i^{N_bc}F_i(u) dS,
\end{equation}

where $N_bc$ is the number of specified boundary conditions, while $S$ denotes the
boundary surface.


The current implementation only supports objects that inherit from `FVFluxBCs`.

### Example Input Syntax





## SideIntegralFunctorPostprocessor


The `SideIntegralFunctorPostprocessor` is also an intermediate base class
that should be derived from for any calculation involving
the integral of a functor quantity over a side.

The [!param](/Postprocessors/SideIntegralFunctorPostprocessor/functor_argument) parameter lets
the user select between face integration and element side quadrature point integration. Face integration
is more appropriate for finite volume variables, and quadrature point integration is more appropriate
for finite element variables.




## SideIntegralMaterialProperty

This post-processor computes the integral of a material property over a side set.
The supplied property can be of type `Real`, `std::vector<Real>`,
`RealVectorValue`, `RankTwoTensor`, `RankThreeTensor`, or `RankFourTensor`.
Depending on the property type an index with the correct dimension must be
supplied to select a scalar component from the supplied material property (e.g.
`component = '0 1'` for a property of type `RankTwoTensor`).




## SideIntegralVariablePostprocessor


The SideIntegralVariablePostprocessor is also an intermediate base class
that should be derived from for any calculation involving
the integral of a variable quantity over a side.

### Example input syntax

In this example, a `SideIntegralVariablePostprocessor` is used to compute the integral
of variable `u` over the sideset of id `0`.





## TagVectorSum

This postprocessor computes the sum of components of the requested tagged
vector. This can be useful, for instance, when analyzing the contributions of
different residual objects to global balances.




## TimeExtremeValue

The TimeExtremeValue Postprocessor reports the extreme value of coupled Postprocessor seen over time.
For example, this Postprocessor can be used to record the peak temperature or maximum stress in a
simulation with an oscillating force. The minimum, absolute minimum, and absolute maximum over time
are also options in addition to the default maximum.

The parameter [!param](/Postprocessors/TimeExtremeValue/output_type) allows the user to select whether to output the extreme value requested as described above or the time at which the extreme value occurred.






## TimeIntegratedPostprocessor


### Example input syntax

In this example we integrate variable `u` over the spatial domain using a `ElementIntegralVariablePostprocessor`
and then integrate it over time using a `TimeIntegratedPostprocessor`.





## TimePostprocessor





## TimestepSize


### Description

`TimestepSize` reports the timestep size.

### Example Input Syntax





## VariableInnerProduct


The inner product computed is for the L2 norm:

\langle u, v \rangle = \int_\Omega u(x, t) v(x, t) d\Omega

where $u$ and $v$ are the `variable` and `second_variable` parameters and $\Omega$ is the integration domain, either the whole domain or the specified `blocks`.

### Example input syntax

In this input file, we compute the inner products $\langle f,g \rangle$ and $<f,f>$ of auxiliary variables. We verify that $<f,f>$ is equal to the L2 norm.





## VariableResidual


This postprocessor allows a user to retrieve the residual at different times in the simulation using the `execute_on` parameter.

The residual for the entire system may be found using the [Residual.md] postprocessor.

### Example input syntax

In this example, the residual is output for variable `u` and `v` with two `VariableResidual` postprocessors.





## VectorPostprocessorComparison


This post-processor is used to compare two vector post-processor vectors that
have the same length. It returns a value of 1 (denoting "true") if the
comparison tests between all pairs of elements between the vectors are true.
Else it returns a value of 0 (denoting "false"). There are a number of
different options for the parameter `comparison_type`. Denoting the first
vector as `a` and the second as `b`, these options are as follows:

| Value                 | Test      |
|-----------------------|-----------|
| `equals`              | `a == b`? |
| `greater_than`        | `a > b`?  |
| `greater_than_equals` | `a >= b`? |
| `less_than`           | `a < b`?  |
| `less_than_equals`    | `a <= b`? |

All tests use a "fuzzy" comparison; see the corresponding functions in
[MooseUtils.md].





## VectorPostprocessorComponent


This postprocessor returns the value of a single entry in a vector computed
by a VectorPostprocessor.  The name of the VectorPostprocessor, name of the
vector, and index of the component must be specified.





## VectorPostprocessorReductionValue


This postprocessor performs a reduction operation on
a vectorpostprocessor and stores it as a postprocessor. The reduction operations are returning the maximum, minimum, sum, and average value of the vectorpostprocessor
entries.





## VolumePostprocessor


### Overview

Computes the volume of the Mesh or a subdomain of the Mesh.

### Example Input File Syntax

In this example, the volume of block 1, 2 and 3 are computed by three separate `VolumePostprocessor`.





# preconditioners

## FSP


### Overview

The `FieldSplitPreconditioner` allows for custom preconditioning for each nonlinear variable in the numerical
system. One or more variables may be targeted in a subsolve that will only consider part of the numerical system.
The preconditioning defined for these subsolves is used for the relevant block(s) in the global numerical system.

A `FSP` may for example be used for block-diagonal preconditioning by setting `full=false`
and no off-diagonal variable couplings. Numerical systems considering only a single variable
are then preconditioned individually. This is the default preconditioner for the `PJFNK` solves. See the
[Executioner documentation](Executioner/index.md) for more information on the default preconditioner.

More information about field split preconditioning may be found in the
[PETSc manual](https://petsc.org/release/manualpages/PC/PCFIELDSPLIT).

### Example input syntax

In this example, the preconditioning is performed by solving individual problems for each variables,
as described in the comments in the snippet. The solution for these subsolves is used to perform
the Schur decomposition preconditioning of the main numerical system.


An example of setting the [!param](/Preconditioning/FSP/off_diag_row) and
[!param](/Preconditioning/FSP/off_diag_column) parameters to create a custom
coupling matrix may be found in the
[PhysicsBasedPreconditioner.md] documentation.




## FDP


### Overview

The Finite Difference Preconditioner (FDP) forms a "Numerical Jacobian" by doing direct finite differences of residual statements. This is extremely slow and inefficient, but is a great debugging tool because it allows you to form a nearly perfect preconditioner. FDP contains the same options for specifying off-diagonal blocks as [SingleMatrixPreconditioner.md]. Since FDP builds the perfect approximate Jacobian it can be useful to use it directly to solve instead of using JFNK. The finite differencing is sensitive to the differencing parameter which can be specified using:

```
petsc_options_iname = '-mat_fd_coloring_err -mat_fd_type'
petsc_options_value = '1e-6                 ds'
```

### Example Input File Syntax





## HMG

### Overview

HMG stands for High-performance (Hybrid) MultiGrid method.
[HMG](https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/PC/PCHMG.html)'s
essential idea is to separate a multigrid method into two steps;
matrix coarsening and level solvers. The main motivation of HMG in
the first place is to use
[HYPRE](https://computing.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods)
to do matrix coarsening and generate interpolations
and use [PETSc](https://www.mcs.anl.gov/petsc/) preconditioners/solvers as level solvers.
However, the code is more general, and it can use other
codes such as [GAMG](https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/PC/PCGAMG.html)
or a user code to generate interpolations.


### Example 1

```
[Executioner]
  type = Steady

  solve_type = 'PJFNK'

  petsc_options_iname = '-pc_type'
  petsc_options_value = 'hmg'
[]
```

This configuration uses HYPRE to generate interpolations
and uses SOR preconditioners from PETSc as level solvers.

### Example 2

```
[Executioner]
  type = Steady

  solve_type = 'PJFNK'

  petsc_options_iname = '-pc_type -pc_hmg_use_subspace_coarsening'
  petsc_options_value = 'hmg true'
  petsc_options = '-snes_view'
[]
```

If there are multiple nonlinear variables, this configuration will reuse interpolations
generated for the first nonlinear variable for all other variables. This will significantly
speedup preconditioner setup. A complete toy example is [test/tests/preconditioners/hmg/diffusion_hmg.i].
We also demonstrate this capability for
realistic neutron transport calculations in the following paper:

```tex
@article{kong2020highly,
  title={{A Highly Parallel Multilevel Newton--Krylov--Schwarz Method with Subspace-Based Coarsening and Partition-Based Balancing for the Multigroup Neutron Transport Equation on Three-Dimensional Unstructured Meshes}},
  author={Kong, Fande and Wang, Yaqi and Gaston, Derek R and Permann, Cody J and Slaughter, Andrew E and Lindsay, Alexander D and DeHart, Mark D and Martineau, Richard C},
  journal={SIAM Journal on Scientific Computing},
  volume={42},
  number={5},
  pages={C193--C220},
  year={2020},
  publisher={SIAM}
}
```

## PBP


### Overview

Physics based preconditioning (PBP) is an advanced concept used to more efficiently solve using JFNK. The idea is to create a preconditioning process that targets each physics individually. In this way you can create a more effective preconditioner, while also maintaining efficiency. This object allows you to dial up a preconditioning matrix and the operations to be done on the different blocks of that matrix on the fly from the input file.

The PBP works by partially inverting a preconditioning matrix (usually an approximation of the true Jacobian) by partially inverting each block row in a Block-Gauss-Seidel way.

\boldsymbol{R}(u,v) =
  \begin{bmatrix}
    \boldsymbol{R}_u
    \\
    \boldsymbol{R}_v
  \end{bmatrix}

\boldsymbol{M} \equiv
\begin{bmatrix}
  (\boldsymbol{R}_u)_u & \boldsymbol{0}
  \\
  (\boldsymbol{R}_v)_u & (\boldsymbol{R}_v)_v
\end{bmatrix} \approx \boldsymbol{R}'

\boldsymbol{M} \boldsymbol{q} = \boldsymbol{p} \quad \Rightarrow \quad
\left\{
\begin{array}{rcl}
(\boldsymbol{R}_u)_u \boldsymbol{q}_u &=& \boldsymbol{p}_u \\[6pt]
(\boldsymbol{R}_v)_v \boldsymbol{q}_v &=& \boldsymbol{p}_v - (\boldsymbol{R}_v)_u \boldsymbol{q}_u
\end{array}
\right.

### Example Input File Syntax

Set up a PBP object for a two variable system (consisting of variables "u" and "v").
Use ILU for the "u" block and AMG for "v".
Use the lower diagonal (v,u) block.
When using `type = PBP`, MOOSE will set `solve_type = JFNK` automatically.

```
[Preconditioning]
  active = 'myPBP'

  [myPBP]
    type = PBP
    solve_order = 'u v'
    preconditioner  = 'ILU AMG'
    off_diag_row    = 'v'
    off_diag_column = 'u'
  []
[]
```




## SMP


### Overview

The Single Matrix Preconditioner (SMP) builds one matrix for preconditioning. As an example, consider the system:

\begin{aligned}
\nabla \cdot k(s,T) \nabla T  &= 0 \\
\nabla \cdot D(s,T) \nabla s  &= 0 ,
\end{aligned},

Users can then specify which off-diagonal blocks of the matrix to use like

```
off_diag_row    = 's'
off_diag_column = 'T'
```

Which would produce a preconditioning matrix like this:

\boldsymbol{M} \equiv
    \begin{bmatrix}
      \left(k(s,T) \nabla \phi_j, \nabla \psi_i\right) & \boldsymbol{0}
      \\[3pt]
      \left(\frac{\partial D(s,T)}{\partial T_j} \nabla s, \nabla \psi_i\right) & \left(D(s,T) \nabla \phi_j, \nabla\psi_i\right)
    \end{bmatrix}

In order for this to work, the `computeQpOffDiagJacobian()` function must be provided in the kernels that computes the required partial derivatives.
To use *all* off diagonal blocks, you can use the following input file syntax:

```
full = true
```

### Example Input File Syntax





## VCP


### Overview

The Variable Condensation Preconditioner (VCP) is designed to condense out variables from the linear system of equations and apply the preconditioner/solver on the reduced simplified system of equations.
The development of VCP is motivated by the need to enable a broader range of robust and scalable preconditioners for problems that have a saddle point type of Jacobian. The saddle point type of Jacobian may come from different applications. One typical example is the enforcement of constraints using Lagrange multipliers. Its special numerical character prevents the usage of many scalable iterative solvers. To resolve this issue, a static condensation step is carried out in VCP to remove the Degree of Freedoms (DoFs) that are associated with the Lagrange multipliers.  
This may result in an easy-to-solve system (sometimes it is positive definite ) which can be handled by a broader range of solvers/preconditioners with improved efficiency. With VCP, we can efficiently apply iterative solvers, e.g., BoomerAMG, to mortar-based mechanical contact problems.

### System Simplification

To illustrate the saddle point structure of the Jacobian matrix and how it can be simplified by static condensation of the Lagrange multiplier, we take the Jacobian matrix from a simple diffusion problem with equal value constraint as an example.
The system of equations at a typical time step can be written as a block matrix as follows,
\begin{equation}
	\begin{bmatrix}
  K_{1, ii} &  K_{1, ic} & & & \\
  K_{1, ci} &  K_{1, cc} & & & M\\
  & & K_{2, ii} &  K_{2, ic} & \\
  & & K_{2, ci} &  K_{2, cc} & D\\
  & M^{\intercal}&  &  D^{\intercal} & 0\\
	\end{bmatrix}_{}
	\begin{bmatrix}
\Delta u_{1,i} \\ \Delta u_{1,c} \\ \Delta u_{2,i} \\ \Delta u_{2,c} \\ \Delta \lambda
	\end{bmatrix}
=
	\begin{bmatrix}
\Delta r_{1,i} \\ \Delta r_{1,c} \\ \Delta r_{2,i} \\ \Delta r_{2,c} \\ 0
	\end{bmatrix}
\label{eqn:original_global_matrix}
\end{equation}
Here, we omit the identifier of time for simplicity. The first subscript $(\cdot)_1$ and $(\cdot)_2$ denote the primary and secondary subdomains, respectively. The second subscript $(\cdot)_{\cdot, c}$ denotes the part of the subdomain that is in contact and $(\cdot)_{\cdot, i}$ denotes the rest of the subdomain. The blocks $K_{\cdot, \cdot}$ denote the respective stiffness matrices. The block $D$ represents the coupling between the Lagrange multipliers and the primal variable in the secondary subdomain. The block $M$ denotes the coupling between the Lagrange multipliers and the primal variable in the primary subdomain.

The system of equations from mortar-based mechanical contact has a similar saddle point character, but is more complex than [eqn:original_global_matrix], considering the primary and secondary surfaces being partially in contact. For readers who are interested in the Jacobian matrix from mortar-based mechanical contact, please refer to [!citep](popp2010dual).

#### Condensation of the Lagrange Multiplier

The discrete Lagrange multipliers (i.e., $\Delta \lambda$) can be eliminated by condensation as follows,
\begin{equation}
\Delta \lambda = D^{-1}(\Delta r_{2,c}-K_{2,ci} \Delta u_{2,i}-K_{2,cc} \Delta u_{2,c}).
\label{eqn:condensation_of_LMs}
\end{equation}

By substituting [eqn:condensation_of_LMs] into [eqn:original_global_matrix], we obtain a simplified linear system of equations that  contains only the primal variable DOFs,

\begin{equation}
	\begin{bmatrix}
  K_{1, ii} &  K_{1, ic} & & \\
  K_{1, ci} &  K_{1, cc} & -MD^{-1}K_{2,ii} &  -MD^{-1}K_{2,cc} \\
  &  & K_{2, ii} &  K_{2, ic} \\
  & M^{\intercal}&  &  D^{\intercal}\\
	\end{bmatrix}
	\begin{bmatrix}
\Delta u_{1,i} \\ \Delta u_{1,c} \\ \Delta u_{2,i} \\ \Delta u_{2,c}
	\end{bmatrix}
=
	\begin{bmatrix}
\Delta r_{1,i} \\ \Delta r_{1,c} - MD^{-1}\Delta r_{2,c} \\ \Delta r_{2,i} \\ 0
	\end{bmatrix}
\label{eqn:condensed_global_matrix}
\end{equation}
This condensed system (i.e., [eqn:condensed_global_matrix]) is positive definite and therefore state-of-art iterative solution techniques, such as multigrid methods, are applicable. As a post-processing step, the Lagrange multipliers can be recovered from the displacement following [eqn:condensation_of_LMs].

#### Dual Basis Function

The computation of $D^{-1}$ in [eqn:condensation_of_LMs] and [eqn:condensed_global_matrix] can be reduced by using +dual basis+ for the Lagrange multipliers. The +dual basis+ is a relative definition to the +standard basis+, which satisfies a biorthogonal condition as follows
\begin{equation}
\label{eqn:local_biorthogonal_condition}
	\int_{\Gamma_e} \psi_j (\boldsymbol{x}) \phi_k(\boldsymbol{x})~\text{d}s = \delta_{jk} \int_{\Gamma_e} \phi_k(\boldsymbol{x})~\text{d}s,
\end{equation}
where $\phi_k(\boldsymbol{x})$ is the standard shape function, $\psi_j (\boldsymbol{x})$ is the dual shape function, and $\delta_{jk}$ is the Kronecker delta function. This biorthogonal condition can be assumed to hold in every lower-dimensional element $\Gamma_e$. Owing to the biorthogonality property of the +dual basis+ functions, the integral matrix $D$ become strict diagonal. Thus computation of $D^{-1}$ and condensation steps in [eqn:condensation_of_LMs] and [eqn:condensed_global_matrix] become trivial.

In order to reduce the computational cost brought by the condensation steps (see [eqn:condensation_of_LMs] and [eqn:condensed_global_matrix]), we recommend the usage of +dual basis+ function for the Lagrange multipliers. Meanwhile, we suggest setting the option `is_lm_coupling_diagonal = true` in the preconditioning block to let VCP take the diagonal structure of the couple matrix ($D$) into account for improved efficiency. If D is not diagonal, but the number of multiplier DoFs is small, VCP will be still beneficial. It may be expensive to compute non-diagonal D when the number of multiplier DOFs is large.

One can enable the usage of +dual basis+ by enabling `use_dual = true` in the `Variables` block:

```
[Variables]
 [./lm]
   order = FIRST
   family = LAGRANGE
   use_dual = true
 [../]
[]
```

Or, for mortar-based contact problems, the dual basis function is used +by default+ for the Lagrange multipliers (while using the contact action). An example input block for contact action is as follows:


### VCP Workflow

A schematic is included in [VCP_scheme] to demonstrate the solution process of VCP. Compared to the standard precondition and solve procedure, VCP features two additional customized computation steps (i.e., one to condense out the variable and the other to obtain the full solution vector) (see [VCP_scheme]). During static condensation of the variable (e.g., $\Delta \lambda$), the DoFs are obtained for both the variable itself ($\Delta \lambda$) and its coupled variable ($\Delta u$). Based on this information, the coupling matrices (i.e., $D$ and $M$) will be extracted from the original Jacobian matrix. Then a reduced system of equations will be obtained with the necessary submatrix operations following [eqn:condensed_global_matrix]. After solving the reduced system of equations, we obtain the primal variable solution vector, which is then utilized to update the variable $\Delta \lambda$ (see [eqn:condensation_of_LMs]) and assemble the full solution vector.

    id=VCP_scheme
    caption=The variable condensation preconditioner (VCP) workflow. Blue represents the original preconditioning steps. Orange shows the additional steps customized for VCP.
    style=display:block;margin-left:auto;margin-right:auto;width:70%

#### Special Designs in VCP

Several special designs in VCP foster improved performance:

- +Adaptive variable condensation+  The  idea  is  to  obtain  the  actual  DoFs  that  have  zero  diagonal entries by checking the Jacobian matrix at runtime.  This refines the DoF list such that variable condensation will only be carried out for those DoFs that actually result in a saddle point structure. For contact problems, this will make sure that variable condensation will only happen when the material bodies come into contact. One can optionally turn on/off this capability by setting the `adaptive_condensation = true` or `false`.

- +Standard basis+ As mentioned above, we recommend the usage of dual basis to reduce computational overhead due to the condensation step. However, it can happen if the dual basis does not work for certain problems. In this case, the user can set `use_dual = false` to use the standard basis functions. Then $D$ has off-diagonal entries. During the computation of ${D}^{-1}$, the user can choose to either use an LU solver (by setting `is_lm_coupling_diagonal = false`) or obtain an approximated inverse using the diagonal entries (by setting `is_lm_coupling_diagonal = true`).

- +Generalized condensation+ Although we are focused on using VCP for mortar-based contact problems with a saddle point structure, VCP is developed to be applicable to general problems in which improved conditioning is achievable via a reduced number of DoFs.

VCP acts on the discretized system of equations and is designed to be as general as possible. However, the current implementation is mainly tested for mortar-based mechanical contact problems. We are actively improving this implementation and are looking for applications beyond contact. Therefore, please feel free to [create an issue](https://github.com/idaholab/moose/issues) or [start a discussion](https://github.com/idaholab/moose/discussions) if you may come across any problem with VCP.

### Performance

As an illustration, we solve the 2D Hertzian problem by using VCP with several sub-preconditioner types, including BoomerAMG (AMG), successive over-relaxation (SOR), additive Schwarz method (ASM), and block Jacobi (BJAC). For all the cases, we set `adaptive_condensation = true` and `is_lm_coupling_diagonal = true`. Note that here, ASM, and BJAC converge for the mortar-based mechanical contact problem, both as a standalone preconditioner and as a sub-preconditioner. AMG and SOR stagnate as a standalone preconditioner, while converge well as a sub-preconditioner under VCP.  [hertzian_vcp_performance] shows the performance of VCP in terms of total wall time and total number of linear iterations. It can be seen that VCP can pretty efficiently converge using AMG and SOR, whereas the standard preconditioner stagnates or diverges. For the other sub-preconditioner types, VCP is still more efficient than the standard preconditioner, despite the additional computational cost from the variable condensation step. This is because a better-conditioned system is obtained after static condensation of the Lagrange multipliers. For readers who are interested in getting more details, please refer to [!citep](yushu2021m3). Note the performance of VCP for problems with increased complexities, e.g., larger, multi-physics problems, is to be examined in the future.

    id=hertzian_vcp_performance
    caption=Performance of VCP for the Hertzian problem.  Different sub-preconditioner types are utilized for comparison. Results are shown for four processors. Note the inf. identifies the case when the solver stagnates thus the wall time and total number of iterations go to infinity.
    style=display:block;margin-left:auto;margin-right:auto;width:85%

### Example Input File Syntax





# predictors

## AdamsPredictor


An Adams predictor is automatically added by MOOSE for the [AB2PredictorCorrector.md]
time stepping/integration scheme.

The formula for the update by Adams' predictor is:

\phi_{new} = A \phi + B \phi_{old} + C \phi_{older}

with \phi being the solution vector, including all degrees of freedom for the nonlinear variables
and

A = 1 + \dfrac{\Delta t}{\Delta t_{old}} (1 + \dfrac{\Delta t}{2\Delta t_{old}})

B = - \dfrac{\Delta t}{\Delta t_{old}} (1 + \dfrac{\Delta t}{2\Delta t_{old}} + \dfrac{\Delta t}{2\Delta t_{older}})

C = \dfrac{\Delta t}{\Delta t_{old}} \dfrac{\Delta t}{2\Delta t_{older}}

with $\dfrac{\Delta t}$, $\dfrac{\Delta t_{old}}$ and $\dfrac{\Delta t_{older}}$
being the current, previous and antepenultimate time steps sizes.

### Example input syntax

In this example, an `AdamsPredictor` is implicitly being created by specifying the
`AB2PredictorCorrector` time stepping scheme. The predictor is being used on every
time step to perform a first update step.





## SimplePredictor


The simple predictor uses the solution from the previous time step to update the solution
before a non linear solve.
The simple predictor update is:

\phi = \phi (1 + s \dfrac{\Delta t}{\Delta t_{old}}) - \phi_{old} s \dfrac{\Delta t}{\Delta t_{old}}

with $\phi$ the solution vector, which includes all the application's non linear variables,
and $s$ a scaling factor, specified by the [!param](/Executioner/Predictor/SimplePredictor/scale)
parameter. That scaling factor is further scaled with the size of the current time step $\Delta t$
divided by the previous one.

### Example input syntax

In this example, a `SimplePredictor` is specified in the executioner to use the previous
time step solution to compute better initial guesses for each non linear solve.





# problems

## DisplacedProblem


The `DisplacedProblem` encompasses a normal undisplaced [FEProblemBase.md], which can
be a [FEProblem.md] or an [EigenProblem.md] for example. Function attributes of the
`DisplacedProblem` often forward to the normal encompassed problem, and are only
modified when displacements affect the behavior, such as for [Adaptivity](syntax/Adaptivity/index.md).

The `DisplacedProblem` object contains a displaced nonlinear system, a displaced
auxiliary system and a displaced mesh. The undisplaced mesh can also be obtained from the
`DisplacedProblem`.

The `DisplacedProblem` is automatically created by the [CreateDisplacedProblemAction.md]
when the [!param](/Mesh/SetupMeshAction/displacements) parameter is set in the `[Mesh]` block.




## DumpObjectsProblem


Run any input file overriding the `Problem/type` parameter to `DumpObjectsAction` and
setting the `Problem/dump_path` parameter to the full _hit_ input file syntax path of an
action to dump the individual Moose objects and variables created by the action.

After the parse and setup stage the `DumpObjectsProblem` will not execute the input any
further. Any objects created and parameters set by the selected action will be dumped to
the screen and Moose will halt execution.

### Example

The input file `two_block_new.i` is a test for the SolidMechanics Physics action, an action
that sets up (aux)variables, (aux)kernels, and materials for mechanics problems. Let's
see if we can examine what exactly a particular action block (`[./block2]`) in this file sets
up.

Compile the solid_mechanics module executable and run

```
./solid_mechanics-opt -i test/tests/action/two_block_new.i Problem/type=DumpObjectsProblem Problem/dump_path=Physics/SolidMechanics/QuasiStatic/block2
```

You should obtain the output

```
[AuxKernels]
  [./stress_xx_block2]
    type = RankTwoAux
    block = 2
    execute_on = TIMESTEP_END
    index_i = 0
    index_j = 0
    rank_two_tensor = stress
    variable = stress_xx
  [../]
  [./strain_yy_block2]
    type = RankTwoAux
    block = 2
    execute_on = TIMESTEP_END
    index_i = 1
    index_j = 1
    rank_two_tensor = total_strain
    variable = strain_yy
  [../]
[]

[AuxVariables]
  [./stress_xx]
    blocks = '1 2'
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./strain_yy]
    blocks = '1 2'
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[Kernels]
  [./TM_block20]
    type = StressDivergenceTensors
    block = 2
    component = 0
    displacements = 'disp_x disp_y'
    use_displaced_mesh = true
    variable = disp_x
  [../]
  [./TM_block21]
    type = StressDivergenceTensors
    block = 2
    component = 1
    displacements = 'disp_x disp_y'
    use_displaced_mesh = true
    variable = disp_y
  [../]
[]

[Materials]
  [./block2_strain]
    type = ComputeFiniteStrain
    block = 2
    displacements = 'disp_x disp_y'
  [../]
[]

[Variables]
  [./disp_x]
    blocks = '1 2'
  [../]
  [./disp_y]
    blocks = '1 2'
  [../]
[]
```

which is what the


block in this input file creates.

The AuxVariables and AuxKernels are triggered by the `generate_outputs` parameter, the Kernels
are informed by the choice of coordinate system, as is the finite strain calculator material.

Note that this particular action creates Moose objects only for the selected blocks, while it sets up
Moose variables for the set union of all blocks handled by the action.





## EigenProblem


`EigenProblem` is the primary eigenvalue system in the MOOSE framework.
It offers linear and nonlinear eigensolvers by leveraging [SLEPc](https://slepc.upv.es)
capabilities (mainly the EPS system). For linear problems,
the system supports one eigenvalue and multiple eigenvalues. For
nonlinear problems, we currently support solving for the smallest (in magnitude)
eigenvalue. The development of nonlinear eigensolver was mainly motivated
by neutron transport criticality calculations, but the implementation
and algorithm are general and applicable to other applications.

A generalized (linear) eigenvalue problem can uniformly be rewritten as
\begin{equation}
Ax = \lambda Bx,
\end{equation}
$A$ and $B$ are matrices, $x$ is an eigenvector, and $\lambda$ is the eigenvalue.
Generally speaking, $A$ is a nonsingular matrix, and $B$ can be singular
(e.g., an eigenvalue problem with Dirichlet boundary conditions).
Many solvers in SLEPc can handle this linear eigenproblem.
We can choose these algorithms in the executioner block.
Here is an example with Jacobi Davidson:

         block=Executioner
         link=False

Note that to use the linear solvers from SLEPc, we need to form accurate
$A$ and $B$ that will be utilized to represent the underlying physics.
If $A$ and $B$ are incorrect, you will likely end up with the
wrong eigenvalue and eigenvector. For that reason, if you
want to use linear eigenvalue solvers, you need to implement
Jacobian by hand or with AD in the corresponding kernels.
Details of all the linear eigensolvers can be found in
[SLEPc Users Manual](https://slepc.upv.es/documentation/slepc.pdf).

In a multiphysics environment, physics are often nonlinear. For instance,
 neutron transport with temperature feedback. In this case,
 $A$ and $B$ are not constant anymore; instead, they depend on
 the eigenvector directly or indirectly. To describe our nonlinear
 solver, we write a generalized nonlinear eigenvalue problem as,
\begin{equation}
A(x) = \lambda B(x),
\end{equation}
where $A(\cdot)$ and $B(\cdot)$ are nonlinear functions. In the EigenProblem
system, the kernels of $A(\cdot)$ are referred to as "noneigen,"
and the kernels of $B(\cdot)$ are referred to as "eigen."
To utilize Newton method to solve this problem, we define $\lambda = \frac{1}{|B(x)|}$,
and rewrite the nonlinear eigen problem as
\begin{equation}
0=F(x) = A(x) - \lambda B(x).
\end{equation}
Newton can be applied to solve this problem. The only issue is that
the derivatives of $\lambda$ with respective to $x$ can be dense.
We use the Jacobian-free Newton method to overcome this difficulty,
where the action of Jacobian on a solution vector is approximated via finite differences.
To handle various use cases, variants of Newton are provided
in this system. There is a current list:

- `PJFNK` - Preconditioned Jacobian-free Newton Krylov: The preconditioning matrix
  is formed using noneigen kernels. We do have an option to allow users to
  incorporate eigen kernels into the preconditioning matrix. Still, in
  general, we won't encourage users to do that since the preconditioning
  matrix might be singular when close to the solution.

          block=Executioner
          link=False

- `JFNK` - Jacobian-free Newton Krylov:  Users are responsible for
  providing a preconditioner. This allows users to build a customized
  preconditioner, such as using a sweeper in radiation transport,
  that might be more efficient for their underlying problems.

          block=Executioner Preconditioning
          link=False

- `PJFNKMO`- Matrix-only Preconditioned Jacobian-free Newton Krylov: Mathematically,
 this option is the same as PJFNK. The difference is the residual evaluation.
 PJFNK calls the user residual/function evaluation routine, which includes all finite element calculations.
 PJFNKMO forms residual vectors via  matrix-vector multiplications: $A (x) = Ax$
 and $B(x) = Bx$. This is useful when matrices are constant. This option will be
 more efficient. If the problem is nonlinear, i.e. the matrices are not constant,
 you should not use this solve option because we do not attempt to re-evaluate $A$
 and $B$ at each Newton iteration. This solve option is valid with Picard iterations
 when the matrices are constant at each Picard iteration with conditions only changing
 with Picard iterations. We do re-evaluate the two matrices at the beginning of each
 Picard iteration.

           block=Executioner
           link=False

- `Newton` - Newton method: Both Jacobian and preconditioning matrices are $A$.
 This option is added for consistency between the nonlinear system and
 the nonlinear eigensystem. Since this option does not account for the derivative
 of eigenvalue with respective to the eigenvector, this option is not efficient.
 Users should not use it in general.


 In general, `EigenProblem` takes care of the following customizations of the solve:

- normalization and scaling parameters for eigenvectors

- setting the type of the SLEPc eigenvalue solver

- whether to start solves with free power iterations and how many

- selecting the eigenvector of interest for the residual




## ExternalProblem

Intermediate class that should be used as an extension point (inheritance) for externally
coupled codes (MOOSE-Wrapped Apps). The external coupling interface should override the
"solve" method along with a method for testing convergence of the last solve.

More information on using the `ExternalProblem` for wrapping applications may be found
in the [application development documentation](modules/doc/content/application_development/moose_wrapped_apps.md optional=True).

### Examples

- External Petsc Application


The [ExternalPetscProblem](modules/external_petsc_solver/doc/content/source/ExternalPETScProblem.md optional=True)
inherits from the `ExternalProblem` to run a pure PETSc solver. It is also able to sync the PETSc solutions
to MOOSE variables.

- Cardinal


[Cardinal](https://github.com/neams-th-coe/cardinal) is an open source coupling of MOOSE with the Monte Carlo
code [OpenMC](https://github.com/openmc-dev/openmc) and the spectral element CFD code
[NekRS](https://github.com/Nek5000/nekRS), which are both
external solvers and not MOOSE-based applications.
The `ExternalProblem` is used to order the solves and custom transfers were implemented to
pass fields between each application.



## FEProblem

The FEProblem class represents a normal (default) Problem class encompassing the
necessary objects for the actual physics solve. The FEProblem object contains one
[NonlinearSystem.md] and one [AuxiliarySystem.md].






## FEProblemBase

The FEProblemBase class is an intermediate base class containing all of the common
logic for running the various MOOSE simulations. MOOSE has two built-in types of
problems [FEProblem.md] for solving "normal" physics problems and [EigenProblem.md]
for solving Eigenvalue problems. Additionally, MOOSE contains an [ExternalProblem.md]
problem useful for creating ["MOOSE-wrapped Apps"](moose_wrapped_apps.md optional=True).


### Convenience Zeros

One of the advantages of the MOOSE framework is the ease at building up Multiphysics
simulations. Coupling is a first-class feature and filling out residuals, or
material properties with coupling is very natural. When coupling is optional, it
is often handy to have access to valid data structures that may be used in-place
of the actual coupled variables. This makes it possible to avoid branch statements
inside of your residual statements and other computationally intensive areas of
code. One of the ways MOOSE makes this possible is by making several different
types of "zero" variables available. The following statements illustrate how
optional coupling may be implemented with these zeros.

```cpp
// In the constructor initialization list of a Kernel

  _velocity_vector(isParamValid("velocity_vector") ? coupledGradient("velocity_vector") : _grad_zero)


// The residual statement

  return _test[_i][_qp] * (_velocity_vector[_qp] * _grad_u[_qp]);
```

### Selective Reinit

The system automatically determines which variables should be made available for use on the
current element ("reinit"-ed). Each variable is tracked on calls through the coupling interface.
Variables that are not needed are simply not prepared. This can save significant amounts
of time on systems that have several active variables.

### Finite Element Concepts

#### Shape Functions id=shape_functions

- While the weak form is essentially what you need for adding physics to MOOSE, in traditional finite element software more work is necessary.
- We need to discretize our weak form and select a set of simple "basis functions" amenable for manipulation by a computer.

       caption=Example of linear Lagrange shape function associated with single
       node on triangular mesh
       style=width:50%;

       caption=1D linear Lagrange shape functions
       style=width:25%;

- Our discretized expansion of $u$ takes on the following form:
  $u \approx u_h = \sum_{j=1}^N u_j \phi_j$
- The $\phi_j$ here are called "basis functions"
- These $\phi_j$ form the basis for the "trial function", $u_h$
- Analogous to the $x^n$ we used earlier
- The gradient of $u$ can be expanded similarly:
   $\nabla u \approx \nabla u_h = \sum_{j=1}^N u_j \nabla \phi_j$
- In the Galerkin finite element method, the same basis functions are used for both the trial and test functions:
    $\psi = \{\phi_i\}_{i=1}^N$
- Substituting these expansions back into our weak form, we get:
    $\left(\nabla\psi_i, k\nabla u_h \right) - \langle\psi_i, k\nabla u_h\cdot \hat{n} \rangle +
       \left(\psi_i, \vec{\beta} \cdot \nabla u_h\right) - \left(\psi_i, f\right) = 0, \quad i=1,\ldots,N$
- The left-hand side of the equation above is what we generally refer to as the $i^{th}$ component of our "Residual Vector" and write as $R_i(u_h)$.
- Shape Functions are the functions that get multiplied by coefficients and summed to form the solution.
- Individual shape functions are restrictions of the global basis functions to individual elements.
- They are analogous to the $x^n$ functions from polynomial fitting (in fact, you can use those as shape functions).
- Typical shape function families: Lagrange, Hermite, Hierarchic, Monomial, Clough-Toucher
    - MOOSE has support for all of these.
- Lagrange shape functions are the most common.
    -  They are interpolary at the nodes, i.e., the coefficients correspond to the values of the functions at the nodes.

##### Example 1D Shape Functions

       style=width:50%;

Linear Lagrange

       style=width:50%;

Quadratic Lagrange

       style=width:50%;

Cubic Lagrange

       style=width:50%;

Cubic Hermite

##### 2D Lagrange Shape Functions

Example bi-quadratic basis functions defined on the Quad9 element:

- $\psi_0$ is associated to a "corner" node, it is zero on the opposite edges.
- $\psi_4$ is associated to a "mid-edge" node, it is zero on all other edges.
- $\psi_8$ is associated to the "center" node, it is symmetric and $\geq 0$ on the element.

       style=width:50%;

$\psi_0$

       style=width:50%;

$\psi_4$

       style=width:50%;

$\psi_8$

#### Numerical Integration id=numerical_integration

- The only remaining non-discretized parts of the weak form are the integrals.
- We split the domain integral into a sum of integrals over elements:
  $\int_{\Omega} f(\vec{x}) \;\text{d}\vec{x} = \sum_e \int_{\Omega_e} f(\vec{x}) \;\text{d}\vec{x}$
- Through a change of variables, the element integrals are mapped to integrals over the "reference" elements $\hat{\Omega}_e$.
  $\sum_e \int_{\Omega_e} f(\vec{x}) \;\text{d}\vec{x} =
        \sum_e \int_{\hat{\Omega}_e} f(\vec{\xi}) \left|\mathcal{J}_e\right| \;\text{d}\vec{\xi}$
- $\mathcal{J}_e$ is the Jacobian of the map from the physical element to the reference element.
- To approximate the reference element integrals numerically, we use quadrature (typically "Gaussian Quadrature"):
  $\sum_e \int_{\hat{\Omega}_e} f(\vec{\xi}) \left|\mathcal{J}_e\right| \;\text{d}\vec{\xi} \approx
        \sum_e \sum_{q} w_{q} f( \vec{x}_{q}) \left|\mathcal{J}_e(\vec{x}_{q})\right|$
- $\vec{x}_{q}$ is the spatial location of the $q$th quadrature point and $w_{q}$ is its associated weight.
- MOOSE handles multiplication by the Jacobian and the weight automatically, thus your `Kernel` is only responsible for computing the $f(\vec{x}_{q})$ part of the integrand.
- Under certain common situations, the quadrature approximation is exact!
    - For example, in 1 dimension, Gaussian Quadrature can exactly integrate polynomials of order $2n-1$ with $n$ quadrature points.
- Note that sampling $u_h$ at the quadrature points yields:
   $\begin{aligned}
    u(\vec{x}_{q}) &\approx u_h(\vec{x}_{q}) = \sum u_j \phi_j(\vec{x}_{q}) \\
    \nabla u (\vec{x}_{q}) &\approx \nabla u_h(\vec{x}_{q}) = \sum u_j \nabla \phi_j(\vec{x}_{q})\end{aligned}$
- And our weak form becomes:
  $\begin{aligned}
  R_i(u_h) &= \sum_e \sum_{q} w_{q} \left|\mathcal{J}_e\right|\left[ \nabla\psi_i\cdot k \nabla u_h + \psi_i \left(\vec\beta\cdot \nabla u_h \right) - \psi_i f \right](\vec{x}_{q}) \\
  &- \sum_f \sum_{q_{face}} w_{q_{face}} \left|\mathcal{J}_f\right| \left[\psi_i k \nabla u_h \cdot \vec{n} \right](\vec x_{q_{face}})
  \end{aligned}$
- The second sum is over boundary faces, $f$.
- MOOSE `Kernels` must provide each of the terms in square brackets (evaluated at $\vec{x}_{q}$ or $\vec x_{q_{face}}$ as necessary).



When [!param](/Problem/FEProblem/check_uo_aux_state) is set to true, MOOSE will evaluate user objects
(including all postprocessors and vector postprocessors) and auxiliary kernels on every execute flag except `linear`
twice. It then compares the results after two evaluations including the auxiliary system solutions and all the real reporter values added by user objects.
When MOOSE sees a difference, it will issue an error indicating that there are unresolved dependencies
during the evaluation because otherwise the results should only depend on primary solutions and should not change.
MOOSE also prints the details about the difference to help users removing the states caused by these unresolved dependencies.




## ReferenceResidualProblem


### Description

By default, MOOSE checks convergence using relative and absolute criteria. Once the residual drops
below either an absolute tolerance, or the residual divided by the initial residual for the current
time step drops below a relative tolerance, the solution is considered converged. This works well for
many problems, but there are some scenarios that are problematic for convergence:

1. There is a large scaling difference between the solution variables, so taking the $L^2$ norm of the
   combined vector skews the convergence check so that it becomes increasingly dominated by the variable
   with larger absolute values in the residual vector as the scaling difference increases.

1. The model conditions have changed very little from the previous step, so the initial residual is very
   low because the solution is essentially converged before any nonlinear iterations have been performed.
   The standard convergence check that uses the initial residual as a reference quantity eventually fails
   after a few steps because the solution is forced to converge to tighter limits with each time
   step, until numerical roundoff error prevents the solution from converging more tightly.

1. The state of the problem is such that the values of the residual at all degrees of freedom where
   Dirichlet boundary conditions are applied are zero in the converged solution. An example of this is a
   mechanics model that has Dirichlet boundary conditions to prevent rigid body motion, but the model
   only experiences free thermal expansion, so there are no reaction loads at those points. Another
   example is if there is a time step when no loading is applied.


`ReferenceResidualProblem` checks for convergence by comparing the residual to a different
reference quantity (instead of the initial residual). The user specifies a reference vector that can be used in
a relative convergence check. Because the solution variables can have significantly different
scaling, the convergence check performed in `ReferenceResidualProblem` checks convergence of the
solution variables individually. When the $L^2$ norm of the residual for each solution variable is
less than either the relative tolerance times the $L^2$ norm of the corresponding reference variable
or the absolute tolerance, the solution is considered converged.

By checking the convergence of individual variables and comparing to reference quantities that are
meaningful even when the solution is not changing, `ReferenceResidualProblem` addresses the first two
issues listed above. The third issue is potentially more of a problem with `ReferenceResidualProblem`
than the standard MOOSE convergence check, and dealing with
it is discussed in [#zero_resid].

Use of this procedure requires that the user provide physically meaningful reference quantities. The
vector of the reaction loads (in the case of mechanics) or integrated fluxes (in the case of
diffusion problems) is typically suitable for this purpose, as it provides a measure of the loading
applied to the system. To make these reference quantities, simply add the
[!param](/Kernels/NullKernel/extra_vector_tags) parameter to the computing objects that you
want to add into the reference vector. An explicit example is given in [#example] below.
Alternatively, the [!param](/Kernels/NullKernel/absolute_value_vector_tags)` parameter can be
used in the kernels to assemble the absolute value of the contribution to each degree of freedom
affected by the kernel.

Since relative convergence is computed differently with this approach, the nonlinear relative
tolerance required to achieve the same error is typically different than with the default approach in
MOOSE, and the differences will vary by the problem. The code user must evaluate the behavior of
their model to ensure that appropriate tolerances are being used.

#### Dealing with Residuals that are Zero at Boundaries id=zero_resid

As mentioned in the third case above where relative convergence checks can fail,
the converged solutions for some problems are zero on all boundaries with Dirichlet
boundary condition (BC) because of the nature of the loading conditions. This would
make the `ReferenceResidualProblem` convergence checks fail because the norm of the
reference vector would be zero in this case.  This is manifested when the reference
values decrease at the same rate as the residuals, so relative convergence is never
achieved.

In some mechanics problems, such as those with symmetry planes, this might happen
only in one direction. This situation can be remedied by grouping together the
residuals for all components of the displacement variables rather than checking
them individually. If the reference vector for one of the variables in the group
is zero (because there are no Dirichlet BCs that restrict the solution in that direction),
but it is nonzero for the others, the residual for the set of variables will
be checked together, and the variable with a zero value will not prevent
convergence as it normally would.  Grouping variables is accomplished by
using the `group_variables` option, which is used to provide one or more
lists of names of variables to group together.

In some cases, however, there may be no degrees of freedom with nonzero residuals
at Dirichlet BCs for even a group of variables.  This could happen in mechanics
problems that only have free expansion, in which the Dirichlet BCs are important
for preventing rigid body motion, but do not restrain the deformation of the body.
This could also happen if there is simply no loading on a model during a time step.

It is necessary in such cases to also specify an absolute tolerance using `nl_abs_tol`,
which is a problem-specific value that must be higher than the residual below which
the solution can no longer converge tighter due to numeric roundoff errors, but sufficiently
low to ensure that the solution is converged when that limit is reached.

Alternatively, the [!param](/Kernels/NullKernel/absolute_value_vector_tags)
parameter can be used in the kernels or the action that sets them up. This option does not
rely on the use of Dirichlet BCs to compute a meaningful reference vector, and can typically
remedy this issue.

### Example Input Syntax id=example


where the [!param](/Problem/ReferenceResidualProblem/extra_tag_vectors) parameter indicates the additional vectors that should be added to the
nonlinear system. This parameter must contain the name of the reference vector, which is defined in the
[!param](/Problem/ReferenceResidualProblem/reference_vector) parameter. In this example we only create one extra vector, the `ref` vector, that will be
used for holding the reference residuals. To have computing objects add into the reference vector,
simply specify the name of that reference vector with the [!param](/BCs/DirichletBC/extra_vector_tags)
parameter as illustrated below:


In this example we are using the integrated fluxes as the reference quantities that we will compare
the individual variable residuals to.

#### Grouping Variables


Multiple groupings of variables can be provided in `group_variables` by separating them by  semicolon.
Convergence for those variables that are not given in `group_variables` is checked individually. A given variable can only be included in one group.




## SolutionInvalidity

### Description

The [/SolutionInvalidity.md] object holds solution invalid warning information for MOOSE. This object allows you to mark a solution as "invalid" under certain conditions and output in which objects and how many times the conditions occurs. An invalid solution means that the solution somehow does not satisfy requirements, such as a value being out of the bounds of a correlation.  Solutions are allowed to be invalid *during* the nonlinear solve, but they are not allowed to be invalid once the solve has converged. A "converged" solution that is marked as invalid will cause MOOSE to behave as if the solution did NOT converge - including cutting back timesteps, etc.

To declare a solution as "invalid", use the macro in the following code to mark it. The user can provide a message to describe the reason for invalidity:


The `flagInvalidSolution` macro will mark the solution as not converged when triggered. The `flagSolutionWarning` will not do so but simply report on the number of warnings encountered.

It is recommended to have a unique message for each invalidity, especially when you want to mark multiple types of invalid solutions within one object.

If any solution invalidity is detected during the solve, a summary table of solution invalid warnings will be generated and reported at the end of each time step. An example of this output is shown below:

```
Solution Invalid Warnings:
---------------------------------------------------------------------------------------------------------
|     Object      | Converged | Timestep | Total |                        Message                       |
---------------------------------------------------------------------------------------------------------
| NonsafeMaterial |        16 |       48 |    48 | The diffusivity is greater than the threshold value! |
| NonsafeMaterial |        16 |       48 |    48 | Extra invalid thing!                                 |
---------------------------------------------------------------------------------------------------------
```

1. *Object*: shows the moose object name registered for the solution invalid detection and an optional description
2. *Converged*: shows the number of solution invalid warnings for the latest iteration, at convergence
3. *Timestep*: shows the number of solution invalid warnings for the latest time step over all iterations
4. *Total*: shows the total number of solution invalid warnings for the entire simulation
5. *Message*: shows the description of the solution invalidity

When the solution is converged, the number of solution invalid warnings is reported for the latest iteration (linear/nonlinear), the last time step (over all solver iterations) and the entire simulation.
SolutionInvalidity warnings can come from numerous objects, some executed once and some executed on every quadrature point. The number of occurrences reported reflects this.

This Solution Invalid Warnings table can be silenced by setting [!param](/Problem/FEProblem/allow_invalid_solution) to 'true'. Then the converged solution will be accepted even if there are still solution invalid warnings, but a message will be generated at the end of the calculation as a reminder:

```
*** Warning ***
The Solution Invalidity warnings are detected but silenced! Use Problem/show_invalid_solution_console=true to show invalid solution counts
```

The Solution Invalid Warning can also be printed out immediately after it is detected by setting [!param](/Problem/FEProblem/immediately_print_invalid_solution) to `true`.



# relationshipmanagers

## RelationshipManager

The RelationshipManager system is for making MOOSE aware of extra geometric,
algebraic, or coupling information needed to perform a calculation. This is an
extension of the "stencil" concept when working with a structured mesh and
performing calculations where you need neighboring information. Relationship
managers (RMs) come in three flavors: geometric, algebraic, and coupling.  For
discerning between the three types, we can think of three levels of "element
dependencies". An element K1 has a coupling dependency on element K2 if the dofs
on K1 might need sparsity pattern entries for dofs on K2.  An element K1 has an
algebraic dependency on K2 if a processor which owns K1 might need to examine
the solution dof values on K2.  An element K1 has a geometric dependency on K2
if a processor which owns K1 might need to examine the geometry of K2. For any
element K, we could call the set of coupling-ghosted ("coupled") elements C(K),
call the set of algebraic-ghosted ("evaluable") elements E(K), and call the set
of geometry-ghosted ("ghosted") elements G(K). It should be safe to assume that,
for any element K, C(K) implies E(K) implies G(K), meaning that a requirement
for coupling ghosting means that algebraic and geometric ghosting will be
required as well. As a more concrete example, it will be impossible to
investigate the degrees of freedom on an element in the `libMesh::DofMap` if
that element has been deleted from the current process, e.g. if we forgot to
geometrically ghost the element. Hence geometrically ghosted elements must be a
super-set of algebraically ghosted elements which must be a super-set of
coupling-ghosted elements.

The RM system is fully pluggable like other MOOSE systems but it not intended to
be exposed in the input file in any way. Instead, individual objects that
require extra information should "register" an appropriate RM right in its
`validParams` function and have MOOSE add the appropriate object to the
simulation at the proper time. It is possible for a single RM to define
geometric, algebraic, and coupling-ghosting, e.g like the RM defined for
`DGKernelBase` derived-objects:

```c++
params.addRelationshipManager("ElementSideNeighborLayers",
                              Moose::RelationshipManagerType::GEOMETRIC |
                                  Moose::RelationshipManagerType::ALGEBRAIC |
                                  Moose::RelationshipManagerType::COUPLING);
```

An application developer should always respect the superset relationships
discussed in the introductory paragraph, e.g. the following relationship
manager additions would provide a valid ghosting set-up:

```c++
params.addRelationshipManager(
    "ElementSideNeighborLayers",
    Moose::RelationshipManagerType::GEOMETRIC,
    [](const InputParameters &, InputParameters & rm_params) {
      rm_params.set<unsigned short>("layers") = 3;
    }
);
params.addRelationshipManager(
    "ElementSideNeighborLayers",
    Moose::RelationshipManagerType::ALGEBRAIC,
    [](const InputParameters &, InputParameters & rm_params) {
      rm_params.set<unsigned short>("layers") = 2;
    }
);
params.addRelationshipManager(
    "ElementSideNeighborLayers",
    Moose::RelationshipManagerType::COUPLING,
    [](const InputParameters &, InputParameters & rm_params) {
      rm_params.set<unsigned short>("layers") = 1;
    }
);
```

because any coupling-ghosted element is guaranteed to be algebraically ghosted,
and each algebraically ghosted element is guaranteed to be geometrically ghosted
(1 layer coupling ghosting <= 2 layers algebraic ghosting <= 3 layers geometric ghosting).
The following set-up is also valid:

```c++
params.addRelationshipManager("ElementSideNeighborLayers",
                              Moose::RelationshipManagerType::GEOMETRIC |
                                  Moose::RelationshipManagerType::ALGEBRAIC |
                                  Moose::RelationshipManagerType::COUPLING);
```

because there is a (default) 1 layer of side ghosting for all ghosting types
(1 layer coupling ghosting <= 1 layer algebraic ghosting <= 1 layer geometric
ghosting).
The following RM set-up would be +invalid+:

```c++
params.addRelationshipManager(
    "ElementSideNeighborLayers",
    Moose::RelationshipManagerType::GEOMETRIC,
    [](const InputParameters &, InputParameters & rm_params) {
      rm_params.set<unsigned short>("layers") = 1;
    }
);
params.addRelationshipManager(
    "ElementSideNeighborLayers",
    Moose::RelationshipManagerType::ALGEBRAIC,
    [](const InputParameters &, InputParameters & rm_params) {
      rm_params.set<unsigned short>("layers") = 2;
    }
);
```

because there is less geometric ghosting than algebraic. In this scenario we
would likely attempt to access degrees of freedom in the solution vector
corresponding to elements that had been deleted (in a `DistributedMesh`
context), and our simulation would fail.

### Relationship Managers and Actions id=rm_action

As explained above, `RelationshipManagers` are usually added to a simulation
through the `validParams` of `MooseObjects`. However, during simulation setup,
`MooseObjects` themselves do not add the relationship managers because if they
did it would be too late to have any impact on the simulation...remote elements
would already be deleted from the mesh because the mesh is prepared way before
any `MooseObjects` are added (other than `MeshGenerators`). So it is the
`MooseObjectAction` itself that detects whether a `MooseObject` (through its
`validParams`) has signaled that it needs a relationship manager and adds
it. However, if the `MooseObjectAction` is not adding the `MooseObject` , and
the `MooseObject` is being added through a custom `action`, then that custom
action has to be responsible for detecting and adding the associated
relationship managers. The method that the custom `Action` should override to
add relationship managers is
`addRelationshipManagers(Moose::RelationshipManagerType input_rm_type)`. Both
the `ContactAction` in the contact module, and `PorousFlowActionBase` in the
porous flow module provide examples of overriding this method.

# reporters

## AccumulateReporter


### Overview

AccumulateReporter gives the ability to accumulate reporter values over time and assigns it to a vector reporter value. Currently supported reporter value types:

- `int`
- `Real` (this covers [Postprocessors/index.md])
- `std::string`
- `std::vector<int>`
- `std::vector<Real>` (this covers [VectorPostprocessors/index.md])
- `std::vector<std::string>`

If more types need to be supported, they can easily be added by adding a line in the `if` statement in `AccumulateReporter::declareLateValues()`:

         re=void\nAccumulateReporter::declareLateValues.*?^}

The reporter names created by the `AccumulateReporter` match each of the accumulated reporters' names.




## ConstantReporter


### Overview

ConstantReporter gives the ability to produce integer, real number, and string reporter data along with vectors of each type. The user must specify the following parameters for each type:

- `int`: [!param](/Reporters/ConstantReporter/integer_names) and [!param](/Reporters/ConstantReporter/integer_values)
- `Real`: [!param](/Reporters/ConstantReporter/real_names) and [!param](/Reporters/ConstantReporter/real_values)
- `std::string`: [!param](/Reporters/ConstantReporter/string_names) and [!param](/Reporters/ConstantReporter/string_values)
- `std::vector<int>`: [!param](/Reporters/ConstantReporter/integer_vector_names) and [!param](/Reporters/ConstantReporter/integer_vector_values)
- `std::vector<Real>`: [!param](/Reporters/ConstantReporter/real_vector_names) and [!param](/Reporters/ConstantReporter/real_vector_values)
- `std::vector<std::string>`: [!param](/Reporters/ConstantReporter/string_vector_names) and [!param](/Reporters/ConstantReporter/string_vector_values)

The user may specify more than one value of the same type, which will create multiple reporter values of that type.

The reporter names created by the `ConstantReporter` match the names passed in each of the `_names` parameters.

### Example Input File Syntax

  indent=2 header=[Reporters] footer=[]




## ElementVariableStatistics


### Overview

ElementVariableStatistics produces the following statistics for a
variable: Maximum, Minium, Average, Integral, Total Elements. The
[!param](/Reporters/ElementVariableStatistics/base_name) can be used to prepend a
name to each reporter.



### Example Input File Syntax

  indent=2 header=[Reporters] footer=[]




## ExtraIDIntegralReporter



### Overview

The `ExtraIDIntegralReporter` object is a reporter object to integrate input variables based on multiple extra element IDs.
This object internally utilizes the vector postprocessor `ExtraIDIntegralVectorPostprocessor` to evaluate the integral values.
Refer to [ExtraIDIntegralVectorPostprocessor](ExtraIDIntegralVectorPostprocessor.md) for details.

The reporters created by the `ExtraIDIntegralReporter` are the `extra_id_data`, holding the [!param](/Reporters/ExtraIDIntegralReporter/id_name)
requested and map from names to indexes into the integrals, and the `integrals`, holding the integral values.

### Example Syntax





## IterationInfo

A Reporter object for tracking iteration information, such as the number of linear and nonlinear
iterations. The [!param](/Reporters/IterationInfo/items) parameter controls the
items computed. `IterationInfo` will declare reporters for each item requested.

### Example Input Syntax

The following input file snippet demonstrates the use of the `IterationInfo` object.






## MeshInfo

A Reporter object for tracking mesh information, such as the number of elements, nodes, or
degrees-of-freedom. The [!param](/Reporters/MeshInfo/items) parameter controls the items
computed. `MeshInfo` will declare reporters for each item requested.

### Example Input Syntax

The following input file snippet demonstrates the use of the `MeshInfo` object.





## MeshMetaDataReporter

A Reporter object for outputting mesh metadata in a human-readable form. By default, it executes only on initial.

This object is a specialization of [RestartableDataReporter.md], which you can see for a more detailed parameter description.

See [MeshMetaDataInterface.md] for more information on the use of mesh metadata.

### Example Input Syntax

The following input file snippet demonstrates the use of the `MeshMetaDataReporter` object.





## NodalVariableStatistics


### Overview

NodalVariableStatistics produces the following statistics for a
variable: Maximum, Minium, Average, Total Nodes. The
[!param](/Reporters/NodalVariableStatistics/base_name) can be used to prepend a
name to each reporter.



### Example Input File Syntax

  indent=2 header=[Reporters] footer=[]




## PerfGraphReporter

### Description

The [/PerfGraph.md] holds timing and memory usage data for MOOSE applications. This Reporter stores the full performance graph from the [/PerfGraph.md] in the Reporter value `graph`.

The first and only entry in the value `graph` is the root node, where the key is the name of the root node. Each node in the graph contains the following entries:

- `level`: The level defined for the section that generated the node (see [PerfGraph.md#logging-levels])
- `memory`: The amount of memory (in Megabytes) that was allocated (or deallocated) within the node, not including children
- `num_calls`: The number of times the node was called
- `time`: The amount of time spent (in seconds) within the node, not including children

The remaining entries represent key value pairs for each of the children to said node.

When an application is run with multiple processes, the graph for each individual process is reported.

The [PerfGraphReporterReader](PerfGraphReporterReader.md optional=True) is a Python utility which can be used to rebuild and traverse the graph built by this reporter.




## RestartableDataReporter

A Reporter object for outputting [Restartable.md] data in a human-readable form. This includes
restartable metadata, such as mesh metadata. This object is particularly useful for inspecting
restartable data for the purposes of debugging.

Only data types that have a `to_json` specialization support having their values output. If the
[!param](/Reporters/RestartableDataReporter/allow_unimplemented) parameter is set to true,
restartable data with unimplemented specializations will still have their auxiliary information output
(type, whether or not the data is loaded/stored, etc).

The [!param](/Reporters/RestartableDataReporter/include) and [!param](/Reporters/RestartableDataReporter/exclude)
parameters enable the filtering of data by name. With these parameters, you can use `*` as a
wildcard match of any number of characters and `?` as a wildcard match for a single character.

### Example Input Syntax

The following input file snippet demonstrates the use of the `RestartableDataReporter` object.





## SolutionInvalidityReporter

### Description

The [/SolutionInvalidity.md] holds solution invalid warning information for MOOSE. This Reporter stores the summary of solution invalid warning occurrences from the [/SolutionInvalidity.md] in the Reporter value 'solution_invalidity'.

1. *object_type*: shows the moose object name registered for the solution invalid detection and an optional description
2. *converged_counts*: the number of solution invalid warnings for the latest iteration, at convergence
3. *timestep_counts*: shows the number of solution invalid warnings for the latest time step
4. *total_counts*: shows the total number of solution invalid warnings for the entire simulation
5. *Message*: shows the description of the solution invalidity




# restart

## Backup

The Backup object is a simply a `struct` for holding binary blob "checkpoint" data. The object contains a stream for holding
global simulation state data along with a separate vector for holding individual thread state for each thread in the simulation.
The Backup object is part of the larger [Restart/Recovery](restart_recover.md optional=True) system in MOOSE.

The Backup object contains the serialized data from MOOSE's `dataLoad/dataStore` routines found in [DataIO.h](/DataIO.h).

## DataIO

The DataIO.h/.C files contain the declaration and definitions for MOOSE's templated `dataLoad/dataStore` methods. These methods
are scattered around the framework, modules and user applications and are used to store stateful information that cannot be
recalculated during a restore operation. These methods enable MOOSE's checkpointing and restarting operations which enable
several key capabilities in the MOOSE framework including:

- Checkpointing -> the ability to terminate an application and restart it where you left off (useful for batch cluster systems).
- Picard Iteration -> The ability to converge a "tightly" coupled multiApp simulation.
- Restart -> the ability to save stateful data for a [restart](restart_recover.md optional=True) type simulation when using checkpoint format

### What is stateful data?

Stateful data is any value, container of values, or complex data structure that cannot be recomputed from other available
information such as coupled values or field variables. Additionally, it's not any data that is not directly owned by your object.

Here are a couple of examples to consider before defining a dataLoad/dataStore routine:

- If you have an object that produces a value based on an "old" value of a coupled variable, your object does +not+
  contain any stateful data because it is a simple calculation based on a piece of information not owned by your object. No action is
  necessary for your object to be "restartable".
- If your object has a data structure consisting of a vector of pairs of IDs and Real numbers that are computed from a Material
  property, your object does +not+ contain any stateful data and no action is necessary for your object to be "restartable".
- If your object has a simple Boolean used to indicate whether or not you have calculated some quantity before, that you set
  when you run some routine. Your object +does+ contain stateful information since the state of that value depends on internal
  logic in your object. For this scenario, you will need to ask Moose to store your Boolean as "restartableData". See
  [#declareRestartableData].
- If your object contains a dataStructure of some custom type that you produce internally and retrieve existing values from
  over the coarse of the simulation, you have a stateful data and may need to define the dataLoad and dataStore functions
  in your object. See [#declareRestartableData], and [#dataStore_dataLoad].


### declareRestartableData id=declareRestartableData

The declareRestartableData method is used to tell MOOSE that you would like to save some part of your object in a [Backup](Backup.md)
object. This method is templated and declared here:

  re=([^\n]+\n)*[^\n]+declareRestartableData[^\n]*;

This method is templated, so MOOSE will return a reference to the type that you request and manage the data storage for you. For
all built-in types and combinations of containers and built-in types. This is all that needs to be done. If your type or
your container of types is custom, you will have to define the dataLoad and dataStore routines to tell MOOSE how to serialize
your new type.

### dataStore/dataLoad routines id=dataStore_dataLoad

If any object has requested a restartable piece of data that contains or is a custom type, both the dataStore and dataLoad will
need to be defined. These functions describe how to serialize a custom type.

The declarations for the two methods that may need to be specialized for your application take on a form similar to this:

  re=^[^\n]*Global Load Declarations.*?\n\n

  re=^[^\n]*Global Store Declarations.*?\n\n

#### Example

Typically, the serialization routine can be
defined in terms of serializing the individual fields in your custom type. For example. If you had a class `Foo` that contained a
few plain old data types, you'd just define the load and store terms in terms of the combination of those POD types in order.

```language=c++
class Foo
{
  int bar;
  std::string baz;
  std::vector<unsigned int> qux;
};


// Definition
template <>
void
dataStore(std::ostream & stream, Foo & foo, void * context)
{
  // Defined in terms of the simple types that MOOSE already knows how to store
  storeHelper(stream, foo.bar, context);
  storeHelper(stream, foo.baz, context);
  storeHelper(stream, foo.qux, context);
}

template <>
void
dataLoad(std::istream & stream, Foo & foo, void * context)
{
  // Defined in terms of the simple types that MOOSE already knows how to read.
  // Note the order of the calls, they should match the dataStore routine since each
  // type is being read from the stream.
  loadHelper(stream, foo.bar, context);
  loadHelper(stream, foo.baz, context);
  loadHelper(stream, foo.qux, context);
}
```

## Restartable

The Restartable object is a specialized interface object containing the routines that
are used by developers to declare custom data structures as restartable. See the
[DataIO](DataIO.md) and [Restart/Recovery](restart_recover.md optional=True) pages for
more information.

# samplers

## Sampler

The Sampler class is an abstract base class for creating objects for generating a matrix of
random numbers; the matrix is an arbitrary size that must be defined by the child object
by calling the `setNumberOfRows` and `setNumberOfCols` methods within the constructor of the child
class. The other requirement is to override the pure virtual `computeSample` method. This method
has global row and column index as input and must output a single value for populating the
sample data matrix.

Support for Sampler objects within the framework is minimal, please refer to the
[Stochastic Tools](modules/stochastic_tools/index.md optional=True) documentation for more
information and example use.


# scalarkernels

## ADScalarTimeDerivative

This scalar kernel adds the time derivative of the paired scalar variable $u$ to
the nonlinear residual $R_u$:
\begin{equation}
  R_u = \frac{du}{dt} \,.
\end{equation}
The Jacobian of this residual contribution is computed using automatic differentiation.




## AverageValueConstraint

This Kernel implements part of the equation that enforces the constraint of

\begin{equation}
 \int_{\Omega} \phi = V_0
\end{equation}

where $V_0$ is a given constant, using a Lagrange multiplier approach. The residual of the Lagrange multiplier is given as:

\begin{equation}
  F^{(\lambda)} \equiv \int_{\Omega} \phi^h \;\text{d}\Omega - V_0 = 0 \label{eq:eq1}
\end{equation}

In particular, this Kernel implements the residual contribution for
the $\lambda$ in [eq:eq1]. See also [ScalarLagrangeMultiplier](source/kernels/ScalarLagrangeMultiplier.md) for the residual of the variable $\phi$.

The detailed description of the derivation can be found at [scalar_constraint_kernel](https://github.com/idaholab/large_media/blob/master/framework/scalar_constraint_kernel.pdf).




## CoupledODETimeDerivative


The `CoupledODETimeDerivative` is similar to the `ODETimeDerivative` scalar kernel, except that the derivative acts on a different variable than the ODE is solved for.

### Example input syntax

In this example, the scalar variables `f` and `f_times_mult` are the solutions to the coupled ODE problem:

\dfrac{d f\_times\_mult}{d t} -1 = 0

f\_times\_mult -f * g = 0

The time derivative term for the first equation is added using a `CoupledODETimeDerivative` scalar kernel, as the first equation is set to have `f` as its nonlinear variable, even though `f` does not appear in it!





## NodalEqualValueConstraint


The constraint is imposed using a lagrange multiplier variable. The `NodalEqualValueConstraint` forms (part of) the equation for that variable, so its `variable` parameter is set to the lagrange multiplier scalar variable.

Constraining two nodes can be used to impose continuity conditions or to pin
two independent systems on disjoint meshes together. The limitation to two
nodes means that this kernel is not designed to work on sidesets or interfaces, except in 1D.
To impose an equal value constraint on a sideset, please prefer the
[EqualValueConstraint](source/constraints/EqualValueConstraint.md).

### Example input syntax

In this input file, a `NodalEqualValueConstraint` is used to impose an equality constraint between two disjoint line meshes.





## NullScalarKernel


This kernel can be used as a placeholder if a nonlinear scalar variable was added to the simulation but
the kernels for that variable have not yet been created / added to the input file. This kernel
will ensure that the kernel coverage checking of the domain does not flag the variable as problematic.
It will also ensure that the system matrix remains invertible as it contributes a small number times
the identity matrix to the Jacobian for the variable it applies to.

### Alternatives

- Ideally, the non-linear scalar variable should be moved to be an [auxiliary variable](syntax/AuxVariables/index.md). This will reduce the size of the nonlinear system, making it easier to solve.

- The kernel block coverage checking of the domain can also be turned off by setting `kernel_coverage_check=false` in the `[Problem]` block.

- A time derivative kernel can be used for a non-linear scalar variable $v$ with the missing physics kernels, as this describes a valid equation $\dfrac{dv}{dt}=0$.


This scalar kernel should mainly be used for creating small tests and while debugging simulations.




## ODETimeDerivative


A scalar variable can be set to the solution of an ordinary differential equation (ODE), as specified in [the Scalar Kernels syntax page](syntax/ScalarKernels/index.md). This kernel adds a time derivative term. The time integration scheme will be shared with the other non-linear variables. To use a different time integrating scheme, the `ODETimeDerivative` scalar kernel should be replaced with a custom implementation.

### Example input syntax

In this example, the scalar variables `x` and `y` are the solutions to the coupled ODE problem:

\dfrac{d x}{d t} -3*x - 2*y = 0

\dfrac{d y}{d t} -4*x - y = 0

The time derivative terms are added for each variable using two `ODETimeDerivative` scalar kernels.





## ParsedODEKernel

This scalar kernel adds a source term $s(u, \mathbf{v}, \mathbf{p})$:
\begin{equation}
  \frac{d u}{d t} = s(u, \mathbf{v}, \mathbf{p}) \,,
\end{equation}
where $u$ is the variable the source acts upon, $\mathbf{v}$ are other
scalar variables, and $\mathbf{p}$ are post-processor values.

The parameter `expression` is a string expression for the source term $s(u, \mathbf{v}, \mathbf{p})$
+as it appears on the left-hand-side of the equation+; thus it represents $-s(u, \mathbf{v}, \mathbf{p})$.
The expression may use the following quantities:

- the name of the scalar variable upon which the kernel acts,
- the names of any scalar variables specified in the `coupled_variables` parameter,
- the names of any post-processors specified in the `postprocessors` parameter, and
- the names supplied in the `constant_names` parameter, defined to have the
  values provided by the `constant_expressions` parameters.

Currently, the function expression cannot be a function of time.





# splits

## Split


This is an alternative syntax to the [FieldSplitPreconditioner.md].
The field split based preconditioner is entirely set up by defining the relevant PETSc options.
This syntax offers shorthands for some of the parameters that may be passed to PETSc,
such as for splitting between variables, blocks or sidesets.

More information about field split preconditioning may be found in the
[PETSc manual](https://petsc.org/release/manualpages/PC/PCFIELDSPLIT).

### Example input syntax

In this example, a two level field split preconditioning is set up using the `Split` syntax.
A Schur decomposition is used for preconditioning at the top level, and `asm` preconditioning,
with their own sets of PETSc options, is set up for two groups of variables.





# systems

## AuxiliarySystem

The AuxiliarySystem object is used by MOOSE to hold field variables that are not part of the
PDE system that you are solving for. These are explicitly "calculated" quantities that have
full shape function support, access to previous values (old and older).

## DisplacedSystem

`DisplacedSystem` objects mostly use global vector and matrix data from the
undisplaced [nonlinear](NonlinearSystemBase.md) and
[auxiliary](AuxiliarySystem.md) systems. However, it holds distinct variable
warehouses such that residual objects can use variables evaluated using finite
element shape functions reinitialized with displaced mesh elements.

## LinearSystem

### Solving nonlinear problems with customizable linearization in MOOSE

In MOOSE, a `LinearSystem` denotes a linear algebraic equation system that
arises from the spatial discretization of a linearized partial differential equation.
Unlike [NonlinearSystem.md], where Newton's method is used to linearize a nonlinear equation,
the `LinearSystem` allows the user to customize how the system is
linearized using objects that contribute to a system matrix and right hand side.
The simplest case is a Picard-style approach where coupled nonlinear terms are
linearized by evaluating with known solution states. For better clarity an example is provided below.

Currently, `LinearSystem` with a Picard-style solution approach is only supported with the
finite volume spatial discretization.

### Picard-style diffusion problem in MOOSE using a LinearSystem

Considering that at the time this documentation is written only finite volume simulations
utilize this system, this example presents a nonlinear 1D diffusion problem with a fixed source term:

-\nabla \cdot (D(u) \nabla u) = 0,~ \vec{r}\in\Omega, \mathrm{~where~}\Omega\in[0,1]

with the following Dirichlet boundary conditions on the left and right boundaries of the domain:

u(\vec{r}_L) = u_L

u(\vec{r}_R) = u_R

Let's split the domain into 3 cells with the following cell widths: $|d|=0.\dot{3}$.
Considering that the diffusion coefficient ($D(u)$) is a function of the solution, we need to linearize the problem.
In this example we use a Picard-style linearization where the $n$-th iterate is denoted by: $u^n$.
This leads to the following equation:

-\nabla \cdot (D(u^{n-1}) \nabla u^n) = S,

To derive the discretized form of the diffusion term, we first integrate it over the volume of cell $i\in[1,2,3]$
(denoted by $\Omega_i$):

\int\limits_{\Omega_i}-\nabla \cdot (D(u^{n-1}) \nabla u^n)dV = \int\limits_{\partial \Omega_i} -D(u^{n-1}) \nabla u^n \cdot \vec{n} dS

where the divergence theorem was employed to derive a surface integral with $\vec{n}$ being the surface normal.
Now, employing a cell-centered finite volume approximation, we assume that the solution field is cell-wise
constant so we have 3 unknowns: $u_1,~u_2$ and $u_3$ often referred to as degrees of freedom.
Furthermore, $\nabla u^n \vec{n}$ over the faces between cells can be approximated as:

\nabla u^n \cdot \vec{n} \approx \frac{u^n_{i+1}-u^n_i}{|d|}~,

while on boundaries it is approximated as follows:

\nabla u^n \cdot \vec{n}_b \approx 2\frac{u_b-u^n_i}{|d|}~.

One approach to express the diffusion coefficient on the face is to use linear interpolation
using the diffusion coefficients at the cell centers:

D(u^n)_{f,i+{1/2}} = \frac{D(u^n_i)+D(u^n_{i+1})}{2},

whereas the diffusion coefficients on the Dirichlet boundaries can just be evaluated at the boundary value:
$D_b = D(u_b)$. With this in mind, we can write down three equations for the three cells:

- D_L 2\frac{u_L-u^n_0}{|d|} - D(u^{n-1})_{f,3/2} \frac{u^n_2-u^n_1}{|d|} = 0,

- D(u^{n-1})_{f,3/2} \frac{u^n_1-u^n_2}{|d|} - D(u^{n-1})_{f,5/2} \frac{u^n_3-u^n_2}{|d|} = 0,

- D(u^{n-1})_{f,5/2} \frac{u^n_3-u^n_2}{|d|} - D_R 2\frac{u_R-u^n_3}{|d|} = 0.

These provide a linear algebraic equation system for the following three variables: $u^n_1,~u^n_2$ and $u^n_3$.
The algebraic equation system in a matrix notation can be expressed as:

\mathbf{A}(\vec{u}^{n-1})\vec{u}^n = \vec{b},

where $\mathbf{A}(\vec{u^{n-1}})$ is referred to as system matrix (often just matrix) and $\vec{b}$ is the
right hand side vector. In this specific example the system matrix is:

\mathbf{A}(\vec{u}^{n-1})=
\begin{bmatrix}
\frac{2D_L}{|d|} + \frac{D(u^{n-1})_{f,3/2}}{|d|} & \frac{-D(u^{n-1})_{f,3/2}}{|d|} & 0 \\
\frac{-D(u^{n-1})_{f,3/2}}{|d|} & \frac{D(u^{n-1})_{f,3/2}}{|d|} + \frac{D(u^{n-1})_{f,5/2}}{|d|} & \frac{-D(u^{n-1})_{f,5/2}}{|d|} \\
0 & \frac{-D(u^{n-1})_{f,5/2}}{|d|} & \frac{D(u^{n-1})_{f,5/2}}{|d|} + \frac{2D_R}{|d|} \\
\end{bmatrix},

while the right hand side vector can be expressed as:

\vec{b}=
\begin{bmatrix}
\frac{2D_Lu_L}{|d|} \\
0 \\
\frac{2D_Ru_R}{|d|}
\end{bmatrix}.

This equation can be solved for $\vec{u}^{n}$ which can be used to update the diffusion coefficient and
recompute the system matrix to solve the equation for the next iterate, $\vec{u}^{n+1}$ until this process converges to $\vec{u}$ with a given tolerance.

### Populating the system in LinearSystem

At the moment the user can implement new objects derived from [linear finite volume kernels](LinearFVKernels/index.md) and linear [finite volume boundary conditions](LinearFVBCs/index.md) to provide the entries in
system matrix $mathbf{A}$ and right hand side vector $\vec{b}$.

## NonlinearEigenSystem

This is the MOOSE system object that goes along with the [EigenProblem.md] and
[Eigenvalue.md] executioner. It wraps the libMesh `EigenSystem` class. It
inherits important functionality from [NonlinearSystemBase.md].

## NonlinearSystem

The NonlinearSystem object holds the equation system created by the normal FEM process
(e.g. the Matrix and RHS vector) to be solved. Normally MOOSE uses PETSc to store and
solve this system. This object is where you will find the callback routines used
by the PETSc solvers.

- [#newtons_method]
- [#jacobian_definition]
- [#linear_methods]
- [#augmenting_sparsity]

You may find some additional documentation relevant to both `NonlinearSystem`
and `NonlinearEigenSystem` in [NonlinearSystemBase.md].

### Solving Nonlinear Systems id=newtons_method

Application of the finite element method converts PDE(s) into a system of
nonlinear equations, $R_i(u_h)=0, \quad i=1,\ldots, N$
  to solve for the coefficients $u_j, \quad j=1,\dots,N$.

- Newton's method has good convergence properties, we use it to solve this system of nonlinear equations.
- Newton's method is a "root finding" method: it finds zeros of nonlinear equations.
- Newton's Method in "Update Form" for finding roots of the scalar equation $f(x)=0, f(x): \mathbb{R} \rightarrow \mathbb{R}$ is given by:

\begin{equation}
\begin{split}
 f'(x_n) \delta x_{n+1} &= -f(x_n) \\
  x_{n+1} &= x_n + \delta x_{n+1}
\end{split}
\end{equation}

- We don't have just one scalar equation: we have a system of nonlinear equations.
- This leads to the following form of Newton's Method:

\begin{equation}
\begin{split}
\mathbf{J}(\vec{u}_n) \delta\vec{u}_{n+1} &= -\vec{R}(\vec{u}_n) \\
\vec{u}_{n+1} &= \vec{u}_n + \delta\vec{u}_{n+1}
\end{split}
\end{equation}

- Where $\mathbf{J}(\vec{u}_n)$ is the Jacobian matrix evaluated at the current iterate:
    $J_{ij}(\vec{u}_n) = \dfrac{\partial R_i(\vec{u}_n)}{\partial u_j}$

- Note that:

\begin{equation}
\begin{split}
\dfrac{\partial u_h}{\partial u_j} &=
\sum_k\dfrac{\partial }{\partial u_j}\left(u_k \phi_k\right) = \phi_j \\
\dfrac{\partial \left(\nabla u_h\right)}{\partial u_j} &=
\sum_k \dfrac{\partial }{\partial u_j}\left(u_k \nabla \phi_k\right) = \nabla \phi_j
\end{split}
\end{equation}

### Convergence Criteria for the Nonlinear System

The Newton's (or the modified Newton's) method iteratively updates the guess until
a solution to the system of nonlinear equations is found. Therefore, after each solution update,
we need to check if the current guess is "close enough" to being a solution.

There are two primary convergence criteria, and the nonlinear system is said to be converged
if *either* of the two is satisfied:

1. Absolute convergence: The norm of the residual evaluated at the current guess is below
   a certain tolerance, i.e. $\lVert \vec{r} \rVert \leq \mathrm{atol}$ where $\mathrm{atol}$
   is the absolute tolerance. This tolerance is specified via the `nl_abs_tol` parameter in the
   [`Executioner`](Executioner.md) block.
2. Relative convergence: The norm of the residual evaluated at the current guess is sufficiently
   small compared to some "reference" value, i.e.
   $\lVert \vec{r} \rVert \leq \mathrm{rtol} {\lVert \vec{r} \rVert}_0$ where $\mathrm{rtol}$ is
   the relative tolerance, and ${\lVert \vec{r} \rVert}_0$ is the reference residual norm.
   This tolerance is specified via the `nl_rel_tol` parameter in the
   [`Executioner`](Executioner.md) block.

MOOSE supports several definitions of the reference residual:

- Initial residual: The residual evaluated at the 0-th nonlinear iteration. To select this definition,
  set `use_pre_SMO_residual = false` in the [`Executioner`](Executioner.md) block.
- Pre-SMO residual: The residual evaluated before any solution-modifying object is executed, and
  before the 0-th nonlinear iteration. To select this definition, set `use_pre_SMO_residual = true`
  in the [`Executioner`](Executioner.md) block.
- Custom reference residual: To use a custom reference residual, use the
  [`ReferenceResidualProblem`](ReferenceResidualProblem.md).

The default is `use_pre_SMO_residual = false` which uses the initial residual as the reference
residual in relative convergence checks.


### Jacobian Definition id=jacobian_definition

An efficient Newton solve, e.g. one that requires few "nonlinear" iterations,
requires an accurate Jacobian matrix or an accurate approximation of its action
on a vector. When no explicit matrix is formed for the Jacobian and only its
action on a vector is computed, the algorithm is commonly referred to as
matrix-free (PETSc jargon) or [Jacobian-free](#JFNK) (MOOSE jargon). The default
solve algorithm in MOOSE is `PJFNK`, or Preconditioned Jacobian-Free
Newton-Krylov. "Krylov" refers to the *linear* solution algorithm used to solve
each nonlinear iteration of the Newton algorithm. For more information on
solving linear systems, please see [#linear_methods]. Even if a Jacobian-free
nonlinear algorithm is chosen, typically a good preconditioning matrix is still
needed. Building the matrix can be accomplished
[automatically, using automatic differentiation](#AD) and/or [manually](#hand_coded_jac).

#### Automatic Differentiation id=AD

One can elect to sacrifice some computing speed and calculate Jacobians
automatically using
[automatic differentiation (AD)](https://en.wikipedia.org/wiki/Automatic_differentiation). MOOSE
employs the `DualNumber` class from the
[MetaPhysicL](https://github.com/libMesh/MetaPhysicL) package in order to
enable AD. If the application developer wants to make use of AD, they should
inherit from `ADKernel` as opposed to `Kernel`. Additionally, when coupling in
variables, the `adCoupled*` methods should be used. For example, to retrieve a
coupled value, instead of using `coupledValue("v")` in the `ADKernel`
constructor, `adCoupledValue("v")` should be used. `adCoupledGradient` should
replace `coupledGradient`, etc. An example of coupling in an AD variable can be found in
[`ADCoupledConvection.C`](test/src/kernels/ADCoupledConvection.C) and
[`ADCoupledConvection.h`](test/include/kernels/ADCoupledConvection.h). Moreover,
material properties that may depend on the nonlinear variables should be
retrieved using `getADMaterialProperty` instead of `getMaterialProperty`. They
should be declared in materials using `declareADProperty`. Example AD material
source and header files can be found
[here](test/src/materials/ADCoupledMaterial.C) and
[here](test/include/materials/ADCoupledMaterial.h); example kernel source and
header files that use AD material properties can be found
[here](test/src/kernels/ADMatDiffusionTest.C) and
[here](test/include/kernels/ADMatDiffusionTest.h). The object central to AD
computing objects is `ADReal` which is defined in [`MooseTypes`](/MooseTypes.md).

#### Traditional Hand-coded Jacobians id=hand_coded_jac

Finite element shape functions are introduced in the documentation section
[FEProblemBase.md#shape_functions]. There we outline
how our primary variables are summations of those shape functions multiplied by
constant coefficients which are our degrees of freedom. At the end of [#newtons_method]
we gave an explicit illustration of how the derivative of a variable `u` with
respect to its jth degree of freedom ($u_j$) is equal to the jth shape function
$\phi_j$. Similarly the derivative of $\nabla u$ with respect to $u_j$ is
equal to $\nabla \phi_j$. The code expression  `_phi[_j][_qp]` represents
$\dfrac{\partial u}{\partial u_j}$ in any MOOSE framework residual and Jacobian
computing objects such as kernels and boundary conditions.

Any MOOSE kernel may have an arbitrary number of variables coupled into it. If
these coupled variables use the same shape function family and order, then their
associated $\phi_j$s will be equivalent. However, if `u` and `v` use different
shape functions then $\phi_{j,u} \ne \phi_{j,v}$. As a developer, however, you
do not ***in most cases*** have to worry about these differences in $\phi$. MOOSE automatically
updates the object member variable `_phi` to use the shape functions of the
variable for whom the Jacobian is currently being computed. ***However***, if
the primary variable `u` is a scalar-valued (single-component) finite element
variable and the coupled variable `v` is a vector-valued (multi-component)
finite element variable (or visa versa), then you must introduce an additional
member variable to represent the shape functions of the vector-valued
(scalar-valued) variable. The name of this variable is up to the developer, but
we suggest perhaps a `_standard_` prefix for scalar valued finite-element
variables and `_vector_` for vector valued finite-element variables. The
`_standard_` prefix is suggested over `_scalar_` so as not to be confused with a
`MooseVariableScalar`, which only has a single value over the entire spatial
domain. An example constructor for a standard kernel that couples in a
vector-valued FE variable is shown below:

```
EFieldAdvection::EFieldAdvection(const InputParameters & parameters)
  : Kernel(parameters),
    _efield_id(coupled("efield")),
    _efield(coupledVectorValue("efield")),
    _efield_var(*getVectorVar("efield", 0)),
    _vector_phi(_assembly.phi(_efield_var)),
    _mobility(getParam<Real>("mobility"))
{
}
```

The associated declarations are:

```
  const unsigned int _efield_id;
  const VectorVariableValue & _efield;
  VectorMooseVariable & _efield_var;
  const VectorVariablePhiValue & _vector_phi;
  const Real _mobility;
  Real _sgn;
```

Residual, on-diagonal, and off-diagonal methods are respectively

```
Real
EFieldAdvection::computeQpResidual()
{
  return -_grad_test[_i][_qp] * _sgn * _mobility * _efield[_qp] * _u[_qp];
}
```

and

```
Real
EFieldAdvection::computeQpJacobian()
{
  return -_grad_test[_i][_qp] * _sgn * _mobility * _efield[_qp] * _phi[_j][_qp];
}
```

and

```
Real
EFieldAdvection::computeQpOffDiagJacobian(unsigned int jvar)
{
  if (jvar == _efield_id)
    return -_grad_test[_i][_qp] * _sgn * _mobility * _vector_phi[_j][_qp] * _u[_qp];
  else
    return 0;
}

```
An example constructor for a vector kernel that couples in a
scalar-valued FE variable is shown below:

```
VectorCoupledGradientTimeDerivative::VectorCoupledGradientTimeDerivative(
    const InputParameters & parameters)
  : VectorKernel(parameters),
    _grad_v_dot(coupledGradientDot("v")),
    _d_grad_v_dot_dv(coupledDotDu("v")),
    _v_id(coupled("v")),
    _v_var(*getVar("v", 0)),
    _standard_grad_phi(_assembly.gradPhi(_v_var))
{
}

```
The associated declarations are:

```
  const VariableGradient & _grad_v_dot;
  const VariableValue & _d_grad_v_dot_dv;
  const unsigned _v_id;
  MooseVariable & _v_var;
  const VariablePhiGradient & _standard_grad_phi;
```

Residual and off-diagonal Jacobian methods are respectively:

```
Real
VectorCoupledGradientTimeDerivative::computeQpResidual()
{
  return _test[_i][_qp] * _grad_v_dot[_qp];
}
```

and

```
Real
VectorCoupledGradientTimeDerivative::computeQpOffDiagJacobian(unsigned jvar)
{
  if (jvar == _v_id)
    return _test[_i][_qp] * _d_grad_v_dot_dv[_qp] * _standard_grad_phi[_j][_qp];

  else
    return 0.;
}
```

Note that only one member is needed to represent shape functions for standard
    `MooseVariable`s and `VectorMooseVariable`s. For example, if the vector-variables
    `v` and `w` are coupled into a standard kernel for `u`, only a single
    `_vector_phi` member needs to be added; there is not need for both a
    `_v_phi` and `_w_phi`. `_vector_phi` will be automatically updated to
    represent the shape functions for whichever vector variable the Jacobian is
    being computed for.

#### Newton for a Simple Equation id=simple_newton

- Consider the convection-diffusion equation with nonlinear $k$, $\vec{\beta}$, and $f$:

\begin{equation}
- \nabla\cdot k\nabla u + \vec{\beta} \cdot \nabla u = f
\end{equation}

- The $i^{th}$ component of the residual vector is:

\begin{equation}
R_i(u_h) = \left(\nabla\psi_i, k\nabla u_h \right) - \langle\psi_i, k\nabla u_h\cdot \hat{n} \rangle +
\left(\psi_i, \vec{\beta} \cdot \nabla u_h\right) - \left(\psi_i, f\right)
\end{equation}

- Using the previously-defined rules for $\dfrac{\partial u_h}{\partial u_j}$ and $\dfrac{\partial \left(\nabla u_h\right)}{\partial u_j}$, the $(i,j)$ entry of the Jacobian is then:

\begin{equation}
\begin{split}
J_{ij}(u_h) &= \left(\nabla\psi_i, \dfrac{\partial k}{\partial u_j}\nabla u_h \right) + \left(\nabla\psi_i, k \nabla \phi_j \right) - \left \langle\psi_i, \dfrac{\partial k}{\partial u_j}\nabla u_h\cdot \hat{n} \right\rangle \\&- \left \langle\psi_i, k\nabla \phi_j\cdot \hat{n} \right\rangle + \left(\psi_i, \dfrac{\partial \vec{\beta}}{\partial u_j} \cdot\nabla u_h\right) + \left(\psi_i, \vec{\beta} \cdot \nabla \phi_j\right) - \left(\psi_i, \dfrac{\partial f}{\partial u_j}\right)
\end{split}
\end{equation}

- Note that even for this "simple" equation, the Jacobian entries are nontrivial: they depend on the partial derivatives of $k$, $\vec{\beta}$, and $f$, which may be difficult or time-consuming to compute analytically.

- In a multiphysics setting with many coupled equations and complicated material properties, the Jacobian might be extremely difficult to determine.

#### Chain Rule id=chain_rule

- On the previous slide, the term $\dfrac{\partial f}{\partial u_j}$ was used, where $f$ was a nonlinear forcing function.

- The chain rule allows us to write this term as

\begin{equation}
\dfrac{\partial f}{\partial u_j} = \dfrac{\partial f}{\partial u_h} \dfrac{\partial u_h}{\partial u_j}=\dfrac{\partial f}{\partial u_h} \phi_j
\end{equation}

- If a functional form of $f$ is known, e.g. $f(u) = \sin(u)$, this
  formula implies that its Jacobian contribution is given by

\begin{equation}
\dfrac{\partial f}{\partial u_j} = \cos(u_h) \phi_j
\end{equation}

#### Jacobian-Free Newton-Krylov id=JFNK

- $\mathbf{J}(\vec{u}_n)\delta \vec{u}_{n+1} = -\vec{R}(\vec{u}_n)$ is a linear system solved during each Newton step.
- For simplicity, we can write this linear system as $\mathbf{A}\vec{x} = \vec{b}$, where:
    - $\mathbf{A} \equiv \mathbf{J}(\vec{u}_n)$
    - $\vec{x} \equiv \delta \vec{u}_{n+1}$
    - $\vec{b} \equiv -\vec{R}(\vec{u}_n)$
- We employ an iterative Krylov method (e.g. GMRES) to produce a sequence of iterates $\vec{x}_k \rightarrow \vec{x}$, $k=1,2,\ldots$
- $\mathbf{A}$ and $\vec{b}$ remain *fixed* during the iterative process.
- The "linear residual" at step $k$ is defined as

\begin{equation}
\vec{\rho}_k \equiv \mathbf{A}\vec{x}_k - \vec{b}
\end{equation}

- MOOSE prints the norm of this vector, $\|\vec{\rho}_k\|$, at each iteration, if you set `print_linear_residuals = true` in the `Outputs` block.

- The "nonlinear residual" printed by MOOSE is $\|\vec{R}(\vec{u}_n)\|$.

- By iterate $k$, the Krylov method has constructed the subspace

\begin{equation}
\mathcal{K}_k = \text{span}\{ \vec{b}, \mathbf{A}\vec{b}, \mathbf{A}^2\vec{b}, \ldots, \mathbf{A}^{k-1}\vec{b}\}
\end{equation}

- Different Krylov methods produce the $\vec{x}_k$ iterates in different ways:
- Conjugate Gradients: $\vec{\rho}_k$ orthogonal to $\mathcal{K}_k$.
- GMRES/MINRES: $\vec{\rho}_k$ has minimum norm for $\vec{x}_k$ in $\mathcal{K}_k$.
- Biconjugate Gradients: $\vec{\rho}_k$ is orthogonal to $\mathcal{K}_k(\mathbf{A}^T)$

- $\mathbf{J}$ is never explicitly needed to construct the subspace, only the action of $\mathbf{J}$ on a vector is required.


- This action can be approximated by:

\begin{equation}
\mathbf{J}\vec{v} \approx \dfrac{\vec{R}(\vec{u} + \epsilon\vec{v}) - \vec{R}(\vec{u})}{\epsilon}
\end{equation}

- This form has many advantages:
    - No need to do analytic derivatives to form $\mathbf{J}$
    - No time needed to compute $\mathbf{J}$ (just residual computations)
    - No space needed to store $\mathbf{J}$


### Solving Linear Systems id=linear_methods

You will commonly hear of two ways to solve an implicit linear system of
equations: directly or iteratively. A typical direct solve will perform a
[LU factorization](https://en.wikipedia.org/wiki/LU_decomposition). Direct
solves are a great tool for solving small-medium sized systems; however, they
are extremely expensive when applied to large-scale problems. To solve
large-scale systems, iterative methods must be used. The most successful
iterative methods are Krylov methods. Krylov methods are
work by finding a solution to $Ax=b$ within a space
called the [Krylov sub-space](https://en.wikipedia.org/wiki/Krylov_subspace)
which is spanned by images of $b$ under powers of $A$. Two of the most used
Krylov algorithms are
[Conjugate gradient](https://en.wikipedia.org/wiki/Conjugate_gradient_method)
and [GMRES](https://en.wikipedia.org/wiki/GMRES). Conjugate gradient generally
only works for symmetric positive-definite matrices. Because of its greater
flexibility, GMRES is the default linear solution algorithm in PETSc and
consequently for MOOSE.

### Augmenting Sparsity id=augmenting_sparsity

One such routine is `NonlinearSystemBase::augmentSparsity`, which as its name
suggests augments the sparsity pattern of the matrix. Currently this method adds
sparsity coming from MOOSE `Constraint` objects. It does this by querying
geometric connectivity information between secondary and primary boundary pairs, and
then querying the `DofMap` attached to the `NonlinearSystemBase` (through the
libMesh `NonlinearImplicitSystem`) for the dof indices that exist on the
elements attached to the secondary/primary nodes. The geometric connectivity
information comes from [`NearestNodeLocators`](/NearestNodeLocator.md) held by
[`GeometricSearchData`](/GeometricSearchData.md) objects in the
[`FEProblemBase`](/FEProblemBase.md) and
[`DisplacedProblem`](/DisplacedProblem.md) (the latter only if there are mesh
displacements). In the future sparsity augmentation from constraints will occur
through [`RelationshipManagers`](/RelationshipManager.md) instead of through the
`augmentSparsity` method.

### Computing Residual and Jacobian Together id=resid_and_jac_together

The default behavior in MOOSE is to have separate functions compute the residual
and Jacobian. However, with the advent of [NonlinearSystem.md#AD] it can make
sense to use a single function to compute the residual and Jacobian
simultaneously. At the local residual object level, automatic differentiation (AD)
already computes the residual and Jacobian simultaneously, with the dual number
at the core of AD holding value (residual) and derivatives
(Jacobian). Simultaneous evaluation of residual and Jacobian using a single
function can be triggered by setting
[!param](/Executioner/Steady/residual_and_jacobian_together) to `true`. What this does in
the background is funnels the (generally AD) computed local residuals and
Jacobians into the global residual vector and Jacobian
matrix respectively when PETSc calls the libMesh/MOOSE residual/function
evaluation routine. Then when PETSc calls the libMesh/MOOSE Jacobian evaluation
routine, we simply return because the global matrix has already been computed.

Computing the residual and Jacobian together has shown 20% gains for
Navier-Stokes finite volume simulations for which automatic differentiation is
leveraged even during standard residual evaluations. Other areas where computing
the residual and Jacobian together may be advantageous is in simulations in
which there are quite a few nonlinear iterations per timestep, for which the
cost of an additional Jacobian evaluation during the final residual evaluation
is amortized. Also, simulations in which material property calculations are very
expensive may be good candidates for computing the residual and Jacobian together.

### Reusing preconditioners id=reuse_preconditioners

The simple version of GMRES and other iterative methods converge only very
slowly.  To improve convergence, PETSc and other iterative solver packages
apply a [preconditioner](https://en.wikipedia.org/wiki/Preconditioner) to the
system of equations/sparse matrix before applying the iterative solver.

A great number of preconditioners exist, but
[multigrid](https://en.wikipedia.org/wiki/Multigrid_method)
methods are often among the best choices for problems without
significant hyperbolic character.
The [HYPRE](application_development/hypre.md optional=true) package,
specifically the
BoomerAMG preconditioner, is often a good choice for a preconditioner to
condition the system of equations resulting from the MOOSE simulation.

A direct factorization of the sparse system of equations is a *very*
good preconditioner.  An iterative method using the factorized matrix
as a preconditioner will typically converge to machine precision in a single
iteration.  However, as noted above, factorizing the sparse system of equations
for a large simulation is numerically expensive.

One option is to form a preconditioner once and then reuse it to solve
the linearized system many times.  The preconditioner can be carried over
through nonlinear iterations and even across time steps.  MOOSE
allows the user to do this with the `reuse_preconditioner` flag.
Setting

```
  reuse_preconditioner = true
  reuse_preconditioner_max_linear_its = 20
```

in the `[Executioner]` block will reuse the same preconditioner until
the number of linear iterations required to solve the linearized system of
equations exceeds 20.   If the number of linear iterations exceeds
`reuse_preconditioner_max_linear_its`
the system does not immediately stop iterating on the current linearized
system.  Instead it will continue until it either successfully solves
the current system or reaches `l_max_its`.  It will then form a new
preconditioner for the next nonlinear iteration.

Using these parameters in combination with a direct factorization of the
system can be very efficient.  The following is an example of how to
direct PETSc and MOOSE to solve the equations with this combination:

```
  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -ksp_type'
  petsc_options_value = 'lu superlu_dist gmres'

  reuse_preconditioner = true
  reuse_preconditioner_max_linear_its = 20
```

This solver strategy can be very effective when the system Jacobian
does not change very much from nonlinear iteration to nonlinear iteration
and/or from time step to time step.  The heuristic is also most effective
when the cost of solving the linearized system is a large fraction of
the total simulation time.  As such, it can be especially beneficial
when using an expensive preconditioner, like a direct solver, as shown
in this example.

There are two differences between
`reuse_preconditioner` and
setting up preconditioner reuse directly in PETSc with the
`-snes_lag_preconditioner_persists` and `-snes_lag_preconditioner` options:
1. `-snes_lag_preconditioner X` will recalculate a new preconditioner
   every X linear iterations, regardless of the progress of the linear solve.
   `reuse_preconditioner_max_linear_its = X` will continue to reuse
   the same preconditioner until the number of linear iterations
   required to solve the linearized equations exceeds X.
2. By default libMesh deletes the PETSc `SNES` instance after each time
   step.  This means that regardless of how the reuse options are set,
   the solver cannot retain the preconditioner across time steps.  The
   `reuse_preconditioner` alters this behavior to retain the `SNES`
   instance so that preconditioner reuse can be carried across time
   steps.

Preconditioner reuse is also different from modified Newton methods,
which can be configured with the PETSc `-snes_lag_jacobian` and
`-snes_lag_jacobian_persists` options.  Preconditioner reuse
affects how PETSc solves the linearized system of equations formed
at each nonlinear iteration.  Ideally, if the reused preconditioner
achieves the requested `l_tol` precision before iterating more than
`l_max_its` times, preconditioner reuse will not affect the
convergence of the nonlinear iterations compared to a case with the
reuse option off.  As described above,
preconditioner reuse aims to decrease the time required to solve
the linearized equations at each nonlinear iteration by reducing the
number of times the solver needs to setup the potentially-expensive
linear preconditioner.

By contrast, modified Newton methods will affect the nonlinear
convergence of the system without affecting how PETSc solves the
linearized system of equations.  The goal of
modified Newton methods is to reduce the time required to solve
the nonlinear equations by forming a new Jacobian matrix less often.

Put another way, preconditioner reuse aims to speed up solving the
linear system of equations while modified Newton methods aim to
accelerate solving the nonlinear equations.

## NonlinearSystemBase

This class derives from [SystemBase.md] and is the immediate base class for
[NonlinearSystem.md] and NonlinearEigenSystem. In general a simulation will
always have exactly one `NonlinearSystemBase` object that holds and operates on
the simulation's nonlinear variables.

### Scaling id=scaling

A critical part to an efficient nonlinear solve is an efficient and accurate
linear solve. If the linear system has a poor condition number, the linear solve
may be inefficient or in the case of PJFNK, may even be
inaccurate. Preconditioning is meant to combat poor linear system conditioning,
but it may not be helpful if the preconditioning matrix, on which the
preconditioning process relies, is itself poorly conditioned. You can inspect
the condition number of your preconditioning matrix for small problems (should be less
than 1000 degrees of freedom) by running with the PETSc options `-pc_type svd
-pc_svd_monitor`. These options will tell you your condition number as well as how many singular
values you have. If you have any singular values, then you may have omitted a boundary condition,
you may have a null space (all Neumann boundary conditions for example), or you may have very poor
scaling between variables in a multi-physics simulation. You may even have run into issues if you
have nodal boundary conditions (which introduce values of unity on the diagonals) and the Jacobian
entries from your physics (kernels) are very large. You want your condition number to be as close to
unity as possible.

#### Automatic scaling id=auto-scaling

To address a poor condition number, which can often be the result of poor relative scaling between variables, you
can use MOOSE's automatic scaling feature which will bring different physics Jacobians as close to
unity as possible. To turn on this feature, set the `automatic_scaling`
parameter in the `Executioner` block to `true`. Additionally, if you want to update scaling factors
at every time step then set `Executioner/compute_scaling_once=false`. By default this latter
parameter is set to `true` in order to save computational expense.

By default scaling factors are computed solely based on information from
`compute.*Jacobian` methods. However, residual information or a hybrid of
Jacobian and residual information may also be used by setting the `Executioner`
parameter `resid_vs_jac_scaling_param`. The default value is `0`, signaling pure
Jacobian scaling. Setting a value of `1` requests pure residual scaling. Any
value in-between `0` and `1` represents a hybrid of residual and Jacobian.

Another parameter relevant to automatic scaling is the `scaling_group_variables`
parameter. Variables in a group will have a
single common factor applied to them. Multiple groups can be used with
semicolons separating them. An example of this is shown in the `Executioner`
block example below where residual/Jacobian information from all the
displacement (`disp_`) variables would be used to determine a single scaling
factor for themselves, and similarly the residual/Jacobian information from all
the velocity (`vel_`) variables would be used to determine a single scaling
factor for themselves.

```
[Executioner]
:
:
  automatic_scaling = true
  scaling_group_variables = 'disp_x disp_y disp_z; vel_x vel_y vel_z'
:
:
[]
```

The current implementation of automatic scaling in MOOSE is fairly simple and
proceeds according to these steps:

1. Compute the Jacobians and/or residuals for all `Kernels`, `ScalarKernels`,
   `NodalKernels`, and `FVKernels`
    - If `off_diagonals_in_auto_scaling` is set to `true` in the input file,
      then we aggregate all entries in a Jacobian row into a single row value
      taking the absolute value of any value that is submitted to the
      `SparseMatrix::add` method.
    - If `off_diagonals_in_auto_scaling` is not specified or is set to `false`
      in the input file, then only the diagonal entries of the Jacobian matrix
      are considered
    - Regardless of the value of `off_diagonals_in_auto_scaling` the result of
      this operation is a `NumericVector` of data
2. Examine the vector of Jacobian data or residual vector for every row corresponding to a
   given variable (or group of variables; recall the `scaling_group_variables`
   parameter) and then compute a scaling factor such that the maximum absolute
   value of the Jacobian data vector or residual across all of a variable's (or
   group of variables) rows is unity.
3. If a hybrid of residual and Jacobian scaling has been requested, then a
   single scaling factor is computed from the residual scaling factor and
   Jacobian scaling factor. That computation for each variable (group) is done
   with the following code, where `inverse_scaling_factor` actually denotes that
   it is the reciprocal/inverse of the final applied variable scaling factor:

```c++
inverse_scaling_factors[i] =
    std::exp(_resid_vs_jac_scaling_param * std::log(resid_inverse_scaling_factors[i]) +
             (1 - _resid_vs_jac_scaling_param) * std::log(jac_inverse_scaling_factors[i]));
```


We only execute kernel objects because objects like `BoundaryConditions`,
`DGKernels`, `InterfaceKernels`, and `Constraints` may apply penalty factors or
introduce global constraints for things like Dirichlet conditions or hanging
nodes in mesh adaptivity. We want our scaling factors to represent our physics,
not penalties or constraints.

## SystemBase

The SystemBase is an abstract class that represents a system of equations. It is the
basis for the [NonlinearSystem.md], [AuxiliarySystem.md], and DisplacedSystem objects.
Each System contains the necessary objects for holding a mesh, one or more field
variables (discretized on that mesh) and one or more scalar variables (DOFs not directly
associated with the mesh). Access to raw numeric vectors, which contain solution
information all go through this class and its derived objects.

# timeintegrators

## ActuallyExplicitEuler

This time integrator is an implementation of forward/explicit Euler based on
[/ExplicitTimeIntegrator.md], which avoids a nonlinear solve.




## AStableDirk4


This method can be expressed as a Runge-Kutta method with the following Butcher Tableau:

\begin{array}{c|ccc}
\gamma & \gamma & 0 & 0 \\
1/2 & 1/2 - \gamma & \gamma & 0 \\
1 - \gamma & 2 \gamma & 1 - 4 \gamma & \gamma \\
\hline
    &  \dfrac{1}{24(1/2-\gamma)} & 1 - \dfrac{1}{12(1/2-\gamma)^2} & \dfrac{1}{24(1/2-\gamma)^2}
\end{array}

where $\gamma = 1/2 + \dfrac{\sqrt{3}}{3} \cos( \dfrac{\pi}{18}) \approx 1.06857902130162881$

The stability function for this method is:

R(z) = \dfrac{-0.76921266689461 z^3 - 0.719846311954034 z^2 + 2.20573706179581 z - 1.0}{
       1.22016884572716 z^3 - 3.42558337748497 z^2 + 3.20573706551682 z - 1.0}


The method is *not* L-stable; it is only A-stable:

\lim_{z->\infty} R(z) = -0.630414937726258

### Notes

- Method is originally due to [!cite](crouzeix1975)
- Since $\gamma$ is slightly larger than $1$, the first stage involves
  evaluation of the non-time residuals for $t > t_n+\Delta t$, while the
  third stage involves evaluation of the non-time residual for
  $t < t_n$, which may present an issue for the first timestep (if
  e.g. material properties or forcing functions are not defined
  for $t<0$. We could handle this by using an alternate (more
  expensive) method in the first timestep, or by using a
  lower-order method for the first timestep and then switching to
  this method for subsequent timesteps.





## BDF2


The backwards differencing formula of second order, BDF-2, is a linear, two-step, second-order method. It is
A-stable.

### Description

With $U$, the vector of nonlinear variables, and $A$, a nonlinear operator,
we write the PDE of interest as:

\dfrac{\partial U}{\partial t} = A(t, U(t))

Using $t+2\Delta t$ for the current time step, $t+\Delta t$ for the previous step, and $t$ for the one before that,
BDF-2 can be written:

U(t+2\Delta t) = \dfrac{4}{3}U(t+\Delta t) - \dfrac{1}{3}U(t) + \dfrac{2}{3} \Delta t A \left(t + 2\Delta t, U(t + 2\Delta t) \right)




## CentralDifference


### Description

Central difference integration is a common explicit integration scheme, typically used in structural dynamics. For a variable, $u$, at time $t$ with a time step, $\Delta t$, the central difference approximations for the first and second time derivatives, $\dot{u}$ and $\ddot{u}$, are given as,

\begin{equation}
\begin{aligned}
\mathbf{\dot{u}}(t) &=& \frac{\mathbf{u}(t+\Delta t)-\mathbf{u}(t-\Delta t)}{2 \Delta t} \\
\mathbf{\ddot{u}}(t) &=& \frac{\mathbf{u}(t+\Delta t)-2\mathbf{u}(t)+\mathbf{u}(t-\Delta t)}{\Delta t^2}
\end{aligned}
\end{equation}

The central difference time integrator derives from the [`ActuallyExplicitEuler`](ActuallyExplicitEuler.md) class and therefore circumvents the nonlinear solver. It can be used with `consistent`, `lumped` or `lump_preconditioned`, `solve_type` options. Information on these solve options can be found on the [`ActuallyExplicitEuler`](ActuallyExplicitEuler.md) page.




## CrankNicolson


The Crank Nicolson time integration scheme is a second-order implicit method. It is unconditionally stable.

### Description

With $U$, the vector of nonlinear variables, and $A$, a nonlinear operator,
we write the PDE of interest as:

\dfrac{\partial U}{\partial t} = A(t, U(t))

Using $t+\Delta t$ for the current time step, and $t$ for the previous step,
the Crank Nicolson time integration scheme can be written:

U(t+\Delta t) = U(t) + \Delta t \dfrac{1}{2} \left( A(t, U(t)) + A(t+\Delta t, U(t+\Delta t)) \right)

This method can be expressed as a Runge-Kutta method with the following Butcher Tableau:

\begin{array}{c|cc}
0 & 0 & 0 \\
1 & 1/2 & 1/2 \\
\hline
    &  1/2 & 1/2
\end{array}




## ExplicitEuler


The explicit Euler method is only first-order accurate in time.

### Description

With $U$, the vector of nonlinear variables, and $A$, a nonlinear operator,
we write the PDE of interest as:

\dfrac{\partial U}{\partial t} = A(t, U(t))

Using $t+\Delta t$ for the current time step, and $t$ for the previous step,
the explicit Euler method can be written:

U(t+\Delta t) = U(t) + \Delta t A(t, U(t))

This method can be expressed as a Runge-Kutta method with the following Butcher Tableau:

\begin{array}{c|c}
  0 & 0 \\
\hline
    &  1
\end{array}

The [ActuallyExplicitEuler.md] implements the same algorithm but without forming the non linear system,
making it faster and use less memory.

All kernels except time-(derivative)-kernels should have the parameter `implicit=false` to use this
time integrator.




## ExplicitMidpoint


The explicit midpoint method is second-order accurate in time. It is a two-step method and
a special case of the 2nd-order Runge-Kutta method.

### Description

With $U$, the vector of nonlinear variables, and $A$, a nonlinear operator,
we write the PDE of interest as:

\dfrac{\partial U}{\partial t} = A(t, U(t))

Using $t+\Delta t$ for the current time step, and $t$ for the previous step,
the explicit midpoint integration scheme can be written:

U(t+\Delta t) = U(t) + \Delta t A(t+\Delta t/2, U(t) + \dfrac{\Delta t}{2} A(t,U(t)))

This method can be expressed as a Runge-Kutta method with the following Butcher Tableau:

\begin{array}{c|cc}
  0 & 0 \\
1/2 & 1/2 & 0 \\
\hline
    &  0  & 1
\end{array}

All kernels except time-(derivative)-kernels should have the parameter `implicit=false` to use this
time integrator.

ExplicitRK2-derived TimeIntegrators ([ExplicitMidpoint.md], [Heun.md], [Ralston.md]) and other multistage
TimeIntegrators are known not to work with Materials/AuxKernels that accumulate 'state' and
should be used with caution.




## ExplicitSSPRungeKutta

### Introduction

This time integrator includes explicit Strong Stability Preserving (SSP)
Runge-Kutta time integration methods, of orders 1, 2, and 3, deriving from
[/ExplicitTimeIntegrator.md], meaning that no nonlinear solver is invoked. The
key feature of SSP Runge-Kutta methods is that they preserve the strong
stability properties (in any norm or seminorm) of the explicit/forward Euler
method [!cite](gottlieb2005).

### Formulation

For the ODE
\begin{equation}
  \frac{d u}{d t} = f(u(t), t) \,,
\end{equation}
the SSP Runge-Kutta methods up to order 3 can be expressed in the following form
for a time step:
\begin{equation}
  u^{(0)} = u^n \,,
\end{equation}
\begin{equation}
  u^{(s)} = \sum\limits_{k=0}^{s-1} a_{s,k} u^{(k)} + b_s \Delta t f\left(u^{(s-1)}, t^n + c_s\Delta t\right) \,,
    \qquad i = 1,\ldots,N_s \,,
\end{equation}
\begin{equation}
  u^{n+1} = u^{(N_s)} \,,
\end{equation}
where $N_s$ is the number of stages and for methods up to order 3, is also the
order of accuracy. The coefficients $a_{i,j}$, $b_i$, and $c_i$ can be
conveniently expressed in the following tabular form:
\begin{equation}
  \begin{array}{c|c}
    \mathbf{c} & \mathbf{A}\\\hline
    & \mathbf{b}^T\\
  \end{array} \,.
\end{equation}
Respectively, the tables for the methods of orders 1, 2, and 3 are as follows:
\begin{equation}
  \begin{array}{c|c}
    0 & 1\\\hline
    & 1\\
  \end{array} \,,
\end{equation}
\begin{equation}
  \begin{array}{c|c c}
    0 & 1           & \\
    1 & \frac{1}{2} & \frac{1}{2}\\\hline
      & 1           & \frac{1}{2}\\
  \end{array} \,,
\end{equation}
\begin{equation}
  \begin{array}{c|c c}
    0           & 1           &             &\\
    1           & \frac{3}{4} & \frac{1}{4} &\\
    \frac{1}{2} & \frac{1}{3} & 0           & \frac{2}{3}\\\hline
                & 1           & \frac{1}{4} & \frac{2}{3}\\
  \end{array} \,.
\end{equation}
These methods have the following time step size requirement for stability:
\begin{equation}
  \Delta t < \gamma \Delta t_{FE} \,, \quad \gamma = \min\limits_{i,k} \frac{a_{i,k}}{b_i} \,.
\end{equation}
where $\Delta t_{FE}$ is the maximum time step size for stability of the forward
Euler method. For these methods of order 1, 2, 3, $\gamma = 1$.

In MOOSE, generally the system of ODEs to be solved result from discretization
using the finite element method, and thus a mass matrix exists:
\begin{equation}
  \mathbf{M}\frac{d \mathbf{u}}{d t} = \mathbf{f}\left(\mathbf{u}(t), t\right) \,.
\end{equation}
In this case, the stage $s$ solution is actually the following:
\begin{equation}
  \mathbf{u}^{(s)} = \sum\limits_{k=0}^{s-1} a_{s,k} \mathbf{u}^{(k)}
    + \mathbf{M}^{-1} b_s \Delta t \mathbf{f}\left(\mathbf{u}^{(s-1)}, t^n + c_s\Delta t\right) \,.
\end{equation}
As an implementation note, the usual mass matrix entry is
\begin{equation}
  m_{i,j} = (\phi_i, \phi_j) \,.
\end{equation}
However, in MOOSE, the mass matrix includes the time step size:
\begin{equation}
  m_{i,j} = \frac{(\phi_i, \phi_j)}{b_i \Delta t} \,,
\end{equation}
\begin{equation}\label{eq:ssprk_no_bc}
  \mathbf{u}^{(s)} = \sum\limits_{k=0}^{s-1} a_{s,k} \mathbf{u}^{(k)}
    + \mathbf{M}^{-1} \mathbf{f}\left(\mathbf{u}^{(s-1)}, t^n + c_s\Delta t\right) \,.
\end{equation}

### Dirichlet Boundary Conditions Treatment

Now consider the case where one or more degrees of freedom are subject to strong
(Dirichlet) boundary conditions:
\begin{equation}
  u_i(t) = g(\mathbf{x}_i, t) \,, \qquad i \in \mathcal{I}_\text{Dirichlet} \,.
\end{equation}
For a nonlinear solve with Newton's method, each iteration consists of the
solution of a linear system:
\begin{equation}\label{eq:ssprk_newton_update}
  \mathbf{J}^{(\ell-1)}\mathbf{\delta u}^{(\ell)} = -\mathbf{r}^{(\ell-1)} \,,
\end{equation}
and then updating the solution:
\begin{equation}
  \mathbf{u}^{(\ell)} = \mathbf{u}^{(\ell-1)} + \mathbf{\delta u}^{(\ell)} \,.
\end{equation}
In MOOSE, Dirichlet boundary conditions are implemented by modifying the residual
vector $\mathbf{r}$ to replace entries for the affected degrees of freedom:
\begin{equation}
  \tilde{r}_i = \left\{\begin{array}{l l}
    r_i \,,                      & i \notin \mathcal{I}_\text{Dirichlet}\\
    u_i - g(\mathbf{x}_i, t) \,, & i \in \mathcal{I}_\text{Dirichlet}
    \end{array}\right. \,.
\end{equation}
By modifying the Jacobian matrix as follows, one can guarantee that the
boundary conditions are enforced, i.e., $u_i^{(\ell)} = g(\mathbf{x}_i, t)$ for
$i \in \mathcal{I}_\text{Dirichlet}$:
\begin{equation}
  \tilde{J}_{i,j} = \left\{\begin{array}{l l}
    J_{i,j} \,, & i \notin \mathcal{I}_\text{Dirichlet}\\
    1 \,,       & i \in \mathcal{I}_\text{Dirichlet}, \quad j = i\\
    0 \,,       & i \in \mathcal{I}_\text{Dirichlet}, \quad j \ne i
    \end{array}\right. \,.
\end{equation}
To work with MOOSE's Dirichlet boundary condition implementation, [eq:ssprk_no_bc]
must be put in an update form, similar to [eq:ssprk_newton_update]:
\begin{equation}\label{eq:ssprk_stage_update}
  \mathbf{M}\mathbf{\delta u}^{(s)} = \mathbf{b} \,,
\end{equation}
\begin{equation}\label{eq:ssprk_b}
  \mathbf{b} = \mathbf{M}\left(\sum\limits_{k=0}^{s-1} a_{s,k} \mathbf{u}^{(k)}
    - \mathbf{u}^{(s-1)} \right)
    + \mathbf{f}\left(\mathbf{u}^{(s-1)}, t^n + c_s\Delta t\right) \,,
\end{equation}
\begin{equation}
  \mathbf{\delta u}^{(s)} \equiv \mathbf{u}^{(s)} - \mathbf{u}^{(s-1)} \,.
\end{equation}
To impose the Dirichlet boundary conditions, the mass matrix and right-hand
side vector are modified as for the Newton case:
\begin{equation}
  \tilde{m}_{i,j} = \left\{\begin{array}{l l}
    m_{i,j} \,, & i \notin \mathcal{I}_\text{Dirichlet}\\
    1 \,,       & i \in \mathcal{I}_\text{Dirichlet}, \quad j = i\\
    0 \,,       & i \in \mathcal{I}_\text{Dirichlet}, \quad j \ne i
    \end{array}\right. \,,
\end{equation}
\begin{equation}\label{eq:ssprk_b_mod}
  \tilde{b}_i = \left\{\begin{array}{l l}
    b_i \,,                              & i \notin \mathcal{I}_\text{Dirichlet}\\
    g_i^{(s)} - u_i^{(s-1)} \,, & i \in \mathcal{I}_\text{Dirichlet}
    \end{array}\right. \,,
\end{equation}
where $g_i^{(s)}$ is an appropriate value to impose for degree of freedom $i$
in stage $s$. For most cases, this is simply
\begin{equation}
  g_i^{(s)} = g(\mathbf{x}_i, t^{n+1}) \,.
\end{equation}
However, in general, certain conditions must be enforced on the imposed boundary
values for intermediate stages to preserve the formal order of accuracy of the
method. For methods up to order 2, it is safe to impose each stage as shown
above. For the 3rd-order method, the boundary values imposed in each stage
should be as follows, according to [!cite](zhao2019):
\begin{equation}
  u_i^{(1)} = g(\mathbf{x}_i, t^n) + \Delta t g'(\mathbf{x}_i, t^n) \,,
\end{equation}
\begin{equation}
  u_i^{(2)} = g(\mathbf{x}_i, t^n) + \frac{1}{2}\Delta t g'(\mathbf{x}_i, t^n)
    + \frac{1}{4} \Delta t^2 g''(\mathbf{x}_i, t^n) \,,
\end{equation}
\begin{equation}
  u_i^{(3)} = g(\mathbf{x}_i, t^{n+1}) \,.
\end{equation}

The convergence rates for a MMS problem with time-dependent Dirichlet boundary
conditions is shown in [ssprk_convergence_with_bc]. This illustrates the
degradation of the 3rd-order method to 1st-order accuracy in the presence of
time-dependent Dirichlet boundary conditions. Contrast this to
[ssprk_convergence_no_bc], which shows the results for an MMS problem without
time-dependent Dirichlet boundary conditions, demonstrating the expected orders
of accuracy.

       id=ssprk_convergence_with_bc
       caption=Convergence rates for SSPRK methods on an MMS problem with
         time-dependent Dirichlet boundary conditions
       style=width:100%;padding:20px;

       id=ssprk_convergence_no_bc
       caption=Convergence rates for SSPRK methods on an MMS problem without
         time-dependent Dirichlet boundary conditions
       style=width:100%;padding:20px;

### Implementation

[eq:ssprk_stage_update] is implemented as described in the following sections:

#### `computeTimeDerivatives()`

Only the Jacobian `_du_dot_du` is implemented, which is needed by the mass matrix.
The time derivative itself is not needed because only part of it appears in the
residual vector.

#### `solveStage()`

First the mass matrix is computed by calling `computeJacobianTag()` with the
time tag. Because the mass matrix is computed before the call
`computeResidual()`, the call to `computeTimeDerivatives()` must be made before
`computeJacobianTag()`, even though it will be called again in
`computeResidual()`. The Jacobian must be computed before the call to
`computeResidual()` because the mass matrix will be used in `computeResidual()`
via the call to `postResidual()`. In `computeResidual()`, the following steps
occur:

- The steady-state residual $\mathbf{f}\left(\mathbf{u}^{(s-1)}, t^n + c_s\Delta t\right)$
  is computed.
- `postResidual()` is called, which adds the mass matrix product shown in [eq:ssprk_b].
- Dirichlet boundary condition modifications are made to the residual as shown
  in [eq:ssprk_b_mod].

#### `postResidual()`

Here $\mathbf{b}$ is assembled as shown in [eq:ssprk_b]. The mass matrix product
here is responsible for the need to call `computeJacobianTag()` before `computeResidual()`
in `solveStage()`.





## ExplicitTimeIntegrator

### Description

`ExplicitTimeIntegrator` is a base class for explicit time integrators that are
implemented without performing any nonlinear solve, which reduces runtime. Unlike
explicit time integrators that are not derived from this class, it is not
necessary to set `implicit` to `false` for all of the non-time residual objects.

### Methods of Solution

Time integrators deriving from this class have three solve options, provided via
the `solve_type` parameter:

- `consistent`: (the default) A full mass matrix is built and used in a linear solve for the update
- `lumped`: A "lumped" mass matrix is built, inverted, and applied to the RHS, which
  is faster but can possibly be less accurate.
- `lump_preconditioned`: The inversion of the "lumped" mass matrix is used to
  precondition the `consistent` solve.

All three methods are solved similarly: a linear solve is performed to obtain a
solution update $\delta u$ that is added to the existing solution.

Below is some more explanation of each of these `solve_type` options:

#### `consistent`

The `consistent` option builds a full ("consistent") "mass matrix" and uses it
in a linear solve to get the update.  This is done by calling
`FEProblem::computeJacobianTag()` and specifying the `TIME` tag which includes
all of the `TimeKernel` derived Kernels and `NodalBC` derived BoundaryConditions
to compute $\mathbf{M}$:


A residual computation is also completed to use as the RHS ($R$):


Finally, the following linear system is solved to obtain the solution update
$\delta u$ using the default linear solver from libMesh (usually PETSc, including
the application of any command-line parameters specified):

\begin{equation}
\mathbf{M} \delta u = -R
\end{equation}

#### `lumped`

The `lumped` option creates a "lumped" mass matrix to use in the solve.  A lumped mass matrix is a diagonal matrix where the diagonal is the sum of all elements on the row from the original matrix.
Here, to achieve the lumping, a matrix-vector product is performed between the
consistent mass matrix and a vector of all ones.

The inverse of a diagonal matrix is simply the reciprocal of each diagonal entry.
Then the matrix-vector product of the "inverse" lumped diagonal matrix is applied by simply doing a pointwise multiplication with the RHS.

Thus the `lumped` option does not actually solve a system of linear equations,
allowing it be much faster. However, the lumping of the mass matrix may lead to
unacceptable phase errors.

#### `lump_preconditioned`

This option is the combination of the other two options: the consistent mass matrix
is used in the linear system, but the linear solve is preconditioned using the
lumped mass matrix. This compromise retains the accuracy of the `consistent`
option while benefiting from some of the speedup offered by the `lumped` option.

The lumped mass matrix preconditioner is applied with the class, `LumpedPreconditioner`:


This object simply applies the inverse of the diagonal, lumped
mass-matrix as the preconditioner for the linear solve, which is very
efficient. Note that when this option is applied you shouldn't specify any other
preconditioners using command-line syntax or they will override this option.

### Additional Details

Some notes on some of the implementation details of this class follow.

#### Update Form

Note that even though we're doing an explicit solve we are currently doing it in
"update form" similar to a single step Newton solve.  This gives us good parity
with the rest of MOOSE.  We may want to change this in the future to make better
use of the fact that the mass-matrix can be constant for a wider class of
problems if we remove `dt` from it.

#### `_ones`

To get the sum of each row of the mass matrix for "lumping" purposes a vector consisting of all `1`s is used in a matrix-vector product:


This is actually the very same way `MatGetRowSum` is implemented in PETSc; however,
doing it manually cuts down on vector creation/destruction and a few other book-keeping operations.

In the future this could be changed to use `MatGetRowSum` if a specialization for `MPI_Aij` format is created.

#### Time

Time in an explicit solve must be handled carefully. When evaluating the weak
form (the integral parts) of the residual, time needs to be set to be the "old"
time (the time we are solving "from"):


However, `DirichletBC` derived boundary conditions need to use the +final+ time,
since the strong constraints they represent use the final time and are not affected
by the time integrator. To achieve this, time is reset to the `_current_time` after
the weak form residual evaluation and before `NodalBC` boundary condition application,
which makes `postResidual()` the correct place to reset time for this purpose:


After `postResidual()` the `NodalBC` BCs are applied with the time at the final time for the step.

#### `meshChanged()`

When the mesh changes the linear solver needs to be destroyed and recreated.
This is done by simply building a new one and setting it up again.  This happens
automatically just by "overwriting" the `std::unique_ptr` to the LinearSolver.

#### Relevant Executioner solver options

You can ignore this section if using `solve_type = lumped`. No [Executioner.md]
parameters are relevant to you in that case. However, for `consistent` or
`lump_preconditioned` solve types, the `l_tol` and `l_max_its` parameters are
used in the solution process. Nonlinear executioner options are not
relevant. When using PETSc as the default solver package, `pc` and `ksp` options
from the `petsc_options*` parameters will be used while `snes` options will be
ignored.

## ExplicitTVDRK2


### Description

The method [!cite](gottlieb1998) consists of two stages:

Stage 1.

R_{NL} = M(U^{(1)}-U^n)/\Delta t - F(t^n,U^n)

t^{(1)} = t^{n} + \Delta t = t^{n+1}

Stage 2.

R_{NL} = M(2U^{(2)}-U^{(1)}-U^n)/(2\Delta t) - (1/2)F(t^{(1)},U^{(1)})

U^{n+1} = U^{(2)}

The method requires two mass matrix (linear) system solves
per timestep. Although strictly speaking these are "two stage"
methods, we treat the "update" step as a third stage, since in
finite element analysis the update step requires a mass matrix
solve.

To use the explicit TimeIntegrators derived from this
method, you must generally add "implicit=false" to the Kernels,
Materials, etc. used in your simulation, so that MOOSE evaluates
them correctly!  An important exception are TimeDerivative kernels,
which should never be marked "implicit=false".




## Heun


Heun's (or "improved Euler") time integration method is second-order accurate in time. It is a two-step explicit
method and a special case of the 2nd-order Runge-Kutta method.

### Description

With $U$, the vector of nonlinear variables, and $A$, a nonlinear operator,
we write the PDE of interest as:

\dfrac{\partial U}{\partial t} = A(t, U(t))

Using $t+\Delta t$ for the current time step, and $t$ for the previous step,
Heun's method can be written:

U(t+\Delta t) = U(t) + \dfrac{\Delta t}{2} \left(A(t, U(t)) +  A(t,U(t) + \Delta t A(t, U(t)) ) \right)

This method can be expressed as a Runge-Kutta method with the following Butcher Tableau:

\begin{array}{c|cc}
  0 & 0 \\
1 & 1 & 0 \\
\hline
    &  1/2  & 1/2
\end{array}

All kernels except time-(derivative)-kernels should have the parameter `implicit=false` to use this
time integrator.

ExplicitRK2-derived TimeIntegrators ([ExplicitMidpoint.md], [Heun.md], [Ralston.md]) and other multistage
TimeIntegrators are known not to work with Materials/AuxKernels that accumulate 'state' and
should be used with caution.




## ImplicitEuler

This is the default time integrator in MOOSE. It is first-order in time, and L-stable, making it
suitable to integrate stiff equation systems. It is also known as the backwards Euler method.

### Description

With $U$, the vector of nonlinear variables, and $A$, a nonlinear operator,
we write the PDE of interest as:

\dfrac{\partial U}{\partial t} = A(t, U(t))

Using $t+\Delta t$ for the current time step, and $t$ for the previous step,
the implicit Euler time integration scheme can be written:

U(t+\Delta t) = U(t) + \Delta t A(t+\Delta t, U(t+\Delta t))

This is an implicit system with $U(t+\Delta t)$, the variable to solve for, appearing on both sides of the
equation. We solve this system iteratively, usually with a Newton or Newton-Krylov method as described
in the non linear system solve [documentation](systems/NonlinearSystem.md).

### Contributions to linear systems

For [linear systems](systems/LinearSystem.md), on top of creating the
time derivatives of the degrees of freedom, this provides contributions
to the matrix diagonal and the right hand side. Taking a finite volume system for example,
the contributions to the matrix diagonal will be:

\frac{1}{\Delta t}V_C,

where $\Delta t$ and $\frac{V_C}$ are the time step size and cell volume,
respectively. The contribution to the right hand side is:

\frac{u_{old,C}}{\Delta t}V_C,




## ImplicitMidpoint


The implicit midpoint method is second-order accurate. As a Gauss-Legendre method it is A-stable.

### Description

With $U$, the vector of nonlinear variables, and $A$, a nonlinear operator,
we write the PDE of interest as:

\dfrac{\partial U}{\partial t} = A(t, U(t))

Using $t+\Delta t$ for the current time step, and $t$ for the previous step,
the implicit midpoint integration scheme can be written:

U(t+\Delta t) = U(t) + \Delta t A \left(t+\Delta t/2, \dfrac{\Delta t}{2} \left( U(t) +  U(t+\Delta t) \right) \right)


This method can be expressed as a Runge-Kutta method with the following Butcher Tableau:

\begin{array}{c|c}
  1/2 & 1/2 \\
\hline
    &  1
\end{array}




## LStableDirk2


This method can be expressed as a Runge-Kutta method with the following Butcher Tableau:

\begin{array}{c|cc}
  \alpha & \alpha\\
1 & 1 - \alpha & \alpha \\
\hline
    &  1 - \alpha  & \alpha
\end{array}

where $\alpha = 1 - \sqrt{2}/2 \approx 0.29289$

The stability function for this method is:

R(z) = 4 \dfrac{-z(-\sqrt{2} + 2) + z + 1}{z^2(-\sqrt{2} + 2)^2 - 4z(-\sqrt{2} + 2) + 4}

The method is L-stable:

\lim_{z->\infty} R(z) = 0

### Notes

This method is derived in detail in [!cite](alexander1967). This method is
more expensive than Crank-Nicolson, but has the advantage of being
L-stable (the same type of stability as the implicit Euler method)
so may be more suitable for "stiff" problems.




## LStableDirk3


This method can be expressed as a Runge-Kutta method with the following Butcher Tableau:

\begin{array}{c|ccc}
  \gamma & \gamma \\
  (1-\gamma)/2 & \gamma \\
  1 & (1/4)(-6\gamma^2 + 16\gamma - 1) & (1/4)(6\gamma^2 - 20\gamma + 5) & \gamma \\
\hline
    &  (1/4)(-6\gamma^2 + 16\gamma - 1)  & (1/4)(6\gamma^2 - 20 \gamma + 5) & \gamma
\end{array}

where $\gamma = -\sqrt{2} \cos(atan(\sqrt{2}/4)/3)/2 + \sqrt{6} \sin(atan(\sqrt{2}/4)/3)/2 + 1  \approx 0.435866521508459$

This method can be expressed as a Runge-Kutta method with the following Butcher Tableau:

R(z) = \dfrac{1.90128552647780115 z^2 + 2.46079651620301599 z - 8}{
       0.662446064957040178 z^3 - 4.55951098972521484 z^2 + 10.460796516203016 z - 8}

The method is L-stable:

\lim_{z->\infty} R(z) = 0

This method is derived in detail in [!cite](alexander1967). Unlike BDF3,
this method is L-stable and so may be more suitable for "stiff"
problems.




## LStableDirk4


This method can be expressed as a Runge-Kutta method with the following Butcher Tableau:

\begin{array}{c|ccccc}
  \alpha & \alpha\\
1/4 & 1/4 \\
0   & -1/4 & 1/4 \\
1/2 & 1/8 & 1/8 & 1/4 \\
1   & -3/2 & 3/4 & 3/2 & 1/4 \\
1   & 0    & 1/6 & 2/3 & -1/12 & 1/4 \\
\hline
    & 0    & 1/6 & 2/3 & -1/12 & 1/4 \\
\end{array}

The stability function for this method is:

R(z) = -\dfrac{28 z^4 + 32 z^3 - 384 z^2 - 768 z + 3072}{
        3 z^5 - 60 z^4 + 480 z^3 - 1920 z^2 + 3840 z - 3072}

The method is L-stable:

\lim_{z->\infty} R(z) = 0

### Notes

The method was found in [!cite](skvortsov2006) but it may not be the original source.
There is also a 4th-order rule with 5 stages on page 107 of [!cite](hairer1999)
but its coefficients have less favorable "amplification factors" than the present rule.




## NewmarkBeta


### Description

Newmark time integration [!citep](newmark1959amethod) is one of the commonly used time integration methods in structural dynamics problems. In this method, the second ($\ddot{u}$) and first ($\dot{u}$) time derivatives of a variable $u$ at $t+\Delta t$ are written in terms of the $u$, $\dot{u}$ and $\ddot{u}$ at time $t$, and $u$ at $t+\Delta t$ as shown below:

\begin{equation}
\begin{aligned}
\mathbf{\ddot{u}}(t+\Delta t) &=& \frac{\mathbf{u}(t+\Delta t)-\mathbf{u}(t)}{\beta \Delta t^2}- \frac{\mathbf{\dot{u}}(t)}{\beta \Delta t}+\frac{\beta -0.5}{\beta}\mathbf{\ddot{u}}(t) \\
\mathbf{\dot{u}}(t+ \Delta t) &=& \mathbf{\dot{u}}(t)+ (1-\gamma)\Delta t \mathbf{\ddot{u}}(t) + \gamma \Delta t \mathbf{\ddot{u}}(t+\Delta t)
\end{aligned}
\end{equation}

In the above equations, $\beta$ and $\gamma$ are Newmark time integration parameters.

- For $\beta = \frac{1}{4}$ and $\gamma = \frac{1}{2}$, the Newmark time integration method is implicit, unconditionally stable and second order accurate in time. This is the constant average acceleration method with no numerical damping.
- $\beta = \frac{1}{6}$ and $\gamma = \frac{1}{2}$ results in the linear acceleration method where the acceleration is linearly varying between $t$ and $t+\Delta t$. This method is also implicit, unconditionally stable and second order accurate in time. However, there is a small numerical damping when the linear acceleration method is used.
- For $\gamma = \frac{1}{2}$, the method is second order accurate and it is unconditionally stable for $\frac{1}{2} \le \gamma \le 2 \beta$.

When using the constant average acceleration method that has no numerical damping, high frequency noise can sometimes be observed in the velocity and acceleration time histories for a problem with prescribed displacement  [!citep](bathe2012insight). Using other parameters for $\beta$ and $\gamma$ results in non-zero numerical damping that damps out part of the high frequency noise but not all of it. Hilber-Hughes-Taylor (HHT) time integration is a variation of the Newmark method that damps out high frequency noise especially in structural dynamics problems. More details about this Newmark and HHT time integration schemes can be found in these [lecture notes](http://people.duke.edu/~hpgavin/cee541/NumericalIntegration.pdf). HHT time integration requires modification to the equation of motion and is currently implemented only for structural dynamics problems in solid mechanics module.

When using Newmark time integration in structural dynamics problems that require an initial static step (most commonly for gravity analysis), a convenient method in MOOSE is to disable the inertia kernels (which can be done using the [controls system](syntax/Controls/index.md)), the velocity and acceleration calculations, and the stiffness damping (which can be done by setting `static_initialization=true` in the stressdivergence kernels) during the first time step. This leads to solving the equation, Ku = F, in the first time step, which essentially initializes displacements and stresses from gravity loading. When using the Newmark-Beta time integrator (which we most often use for dynamics) or any other time integrator, we cannot switch off time derivatives (velocity and acceleration) calculations through the control system. Therefore, the time integrator will compute velocity and acceleration for the static step. When using the Newmark-Beta time integration for this purpose, this will result in noisy acceleration and velocity responses in the whole simulation. Such spurious responses can be avoided by using the `inactive_tsteps` parameter. This parameter ensures that the NewmarkBeta time integrator returns zero derivatives for the first few time steps and starting the acceleration and velocity calculations after that. The time derivative calculations are started when the time step number is greater than `inactive_tsteps`.

A sample result of using this parameter is shown in [fig:disp], [fig:vel], and [fig:accel] below. The result corresponds to the time derivative of a ramp function, which is typically the displacement response under gravity. The velocities and accelerations calculated for this function without using the `inactive_tsteps` parameter (blue) and using `inactive_tsteps=1` (orange) are shown. The input syntax used to generate the orange plots below is listed after the figures below.


       style=width:30%;float:left;padding-top:2.5%
       id=fig:disp
       caption=Displacement

      style=width:30%;float:left;padding-top:2.5%
      id=fig:vel
      caption=Velocity

       style=width:30%;float:left;padding-top:2.5%
       id=fig:accel
       caption=Acceleration







## Ralston


Ralston's time integration method is second-order accurate in time. It is a two-step explicit
method and a special case of the 2nd-order Runge-Kutta method. It is obtained through an error minimization
process and has been shown to outperform other 2nd-order explicit Runge-Kutta methods, see [!cite](ralston1962).

### Description

With $U$, the vector of nonlinear variables, and $A$, a nonlinear operator,
we write the PDE of interest as:

\dfrac{\partial U}{\partial t} = A(t, U(t))

Using $t+\Delta t$ for the current time step and $t$ for the previous step,
Ralston's method can be written:

U(t+\Delta t) = U(t) + \dfrac{\Delta t}{4} \left(A(t, U(t)\right) +  \dfrac{3\Delta t}{4} A \left(t + \dfrac{2\Delta t}{3},U(t) + \dfrac{2\Delta t}{3} A(t, U(t)) \right)

This method can be expressed as a Runge-Kutta method with the following Butcher Tableau:

\begin{array}{c|cc}
0 & 0 \\
2/3 & 2/3 & 0 \\
\hline
    &  1/4 & 3/4
\end{array}

All kernels except time-(derivative)-kernels should have the parameter `implicit=false` to use this
time integrator.

ExplicitRK2-derived TimeIntegrators ([ExplicitMidpoint.md], [Heun.md], [Ralston.md]) and other multistage
TimeIntegrators are known not to work with Materials/AuxKernels that accumulate 'state' and
should be used with caution.




# times

## CSVFileTimes


All the times should be on the same column within each of the CSV files.
The times will be extracted from all the input CSV files and sorted.




## ExodusFileTimes


The exodus files will only be read on the zeroth parallel process, and the times
will be broadcast to all other ranks.
The times will be extracted from all the input exodus files and sorted.




## FunctorTimes


The functor and its factor will be evaluated in the element containing the (0,0,0) point, the latter of which should lie
inside the mesh. They will be evaluated at the current simulation time, but only at the specified
`execute_on` flags.

The time computed will be appended to the times vector. The times vector is regularly sorted by default.




## InputTimes


This object should be used to specify a few times. A [CSVFileTimes.md] should be preferred
if there are many times.




## ReporterTimes


In order to retrieve a [Reporter](syntax/Reporters/index.md) with the `ReporterTimes`,
it must be a vector of floating point numbers (`std::vector<Real>`).

The times will be extracted from all the reporter vectors and sorted.

### Example File Syntax

In this example, the `ReporterTimes` is combining the times from two other
`Times`, using the fact that `Times` objects are [Reporters](syntax/Reporters/index.md)
in the back-end.





## SimulationTimes


This object collects the current simulation time every time it is executed. If it is
executed with its default `execute_on` of `TIMESTEP_BEGIN`, it will simply collect
the times of every time step.




## TimeIntervalTimes

This object specifies times with a fixed time interval between a start time and
end time. The start time and end time may be provided or if not, taken to be
the start time and end time from the simulation (in this case, the executioner type
must be [Transient.md]). If the end time does not fall exactly at the end of the
end of the last time interval, then the end time is only included if the parameter
[!param](/Times/TimeIntervalTimes/always_include_end_time) is set to `true`.




# timesteppers

## AB2PredictorCorrector


This time stepper first adds an [AdamsPredictor.md] to the problem. The predictor
uses previous solutions to compute a predicted solution vector. This prediction is
then compared using a $L\_infty$ norm to the solution. If the error is lower than
[!param](/Executioner/TimeSteppers/AB2PredictorCorrector/e_max),
then the time step is accepted. If not, then it is reduced.

The time step is regularly increased based on the
[!param](/Executioner/TimeSteppers/AB2PredictorCorrector/steps_between_increase) parameter. The
magnitude of the increase is based on the magnitude of the prediction error.

The `AB2PredictorCorrector` may be used with the following three time integration schemes:
implicit Euler (default in MOOSE), Crank Nicholson and 2nd order backward differences (BDF2).

### Example input syntax

In this example, we solve a simple heating problem with backwards differences and a predictor
corrector scheme. The prediction and correction steps can be observed during the solve.





## CompositionDT


### Description

The `CompositionDT` TimeStepper takes multiple time steppers as input and computes the minimum time step size among all time steppers as output. If any time sequence stepper(s) is supplied for input, CompositionDT will compare the computed minimum time step size with the one needs to hit the time point, then select the smaller value as output. An optional parameter [!param](/Executioner/TimeSteppers/CompositionDT/lower_bound)is provided to set a lower bound for the computed time step size, and enable growth driven by a single time stepper.

The composition rules are listed with priority rank:
1. The time points from time sequence stepper(s) +must+ be hit;
2. The time step size can not go below the [!param](/Executioner/TimeSteppers/CompositionDT/lower_bound);
3. Take the minimum time step value of all input time steppers.

An example of using multiple time steppers:





## ConstantDT


### Description

The `ConstantDT` TimeStepper simply takes a constant time step size
throughout the analysis, unless the solver fails to converge on an iteration.

`ConstantDT` begins the analysis taking the step specified by the user with the
`dt` parameter. If the solver fails to obtain a converged solution for a given
step, the executioner cuts back the step size and attempts to advance the time
from the previous step using a smaller time step. The time step is cut back by
multiplying the time step by 0.5.

If the solution with the cut-back time step is still unsuccessful, the time
step size is repeatedly cut back until a successful solution is obtained. The
user can specify a minimum time step through the `dtmin` parameter in the
`Executioner` block. If the time step must be cut back below the minimum size
without obtaining a solution, the problem exits with an error. If the time step
is cut back using `ConstantDT`, that cut-back step size will be used for the
remainder of the analysis.

### Example Input Syntax





## CSVTimeSequenceStepper

This time stepper derives from [TimeSequenceStepperBase.md] and provides the
sequence of time values from a CSV file or similarly delimited text file.
A [DelimitedFileReader](MooseUtils.md#delimitedfilereader) is used
to read the CSV file.

The file is always read in columns. The column can either be accessed by name
(using the "column_name" parameter, provided that the CSV file has a header
containing the names of the different columns) or by index (using the
"column_index" parameter, with 0 the index of the first column).

See [TimeSequenceStepperBase.md#failed_solves] for information on the behavior
of this time stepper for failed time steps.




## ExodusTimeSequenceStepper

This time stepper derives from [TimeSequenceStepperBase.md] and provides the
sequence of time values from an Exodus file.

The Exodus file is read by the first process (rank 0), and the time step sequence is then broadcast to all other processes.

See [TimeSequenceStepperBase.md#failed_solves] for information on the behavior
of this time stepper for failed time steps.

### Example input file

In this example, the time stepper extracts the time sequence from an exodus output file. This exodus file may not necessarily have been generated using the same input file. The starting and end time of the simulation may still be set independently.





## FixedPointIterationAdaptiveDT

### Description

This time stepper adjusts the time step size according to a target number of fixed
point iterations $m_\text{target}$. This can only be used in apps having one or
more [MultiApps](syntax/MultiApps/index.md).

The time step size for step $n$, $\Delta t_n$, is computed as the product of the
old time step size, $\Delta t_{n-1}$, and a multiplier $\alpha$, which varies
based on the old time step number of fixed point iterations, $m_{n-1}$:

\Delta t_n = \alpha \Delta t_{n-1}

\alpha = \left\{\begin{array}{l l}
  1 & M_\text{min} \leq m_{n-1} \leq M_\text{max}\\
  \alpha_\text{increase} & m_{n-1} < M_\text{min}\\
  \alpha_\text{decrease} & m_{n-1} > M_\text{max}\\
\end{array}\right.

M_\text{min} = m_\text{target} - \delta m_\text{window}

M_\text{max} = m_\text{target} + \delta m_\text{window}

where

- $m_\text{target}$ is the target number of fixed point iterations, provided by
  [!param](/Executioner/TimeStepper/FixedPointIterationAdaptiveDT/target_iterations),
- $\delta m_\text{window}$ is the target window, provided by
  [!param](/Executioner/TimeStepper/FixedPointIterationAdaptiveDT/target_window),
- $\alpha_\text{increase}$ is the increase factor, provided by
  [!param](/Executioner/TimeStepper/FixedPointIterationAdaptiveDT/increase_factor), and
- $\alpha_\text{decrease}$ is the decrease factor, provided by
  [!param](/Executioner/TimeStepper/FixedPointIterationAdaptiveDT/decrease_factor).

The time step size of the first step is provided by
[!param](/Executioner/TimeStepper/FixedPointIterationAdaptiveDT/dt_initial).




## FunctionDT


### Description

The `FunctionDT` type of TimeStepper takes time steps that vary over time
according to a user-defined function.

The time step is controlled by a piecewise linear function defined using the
`time_t` and `time_dt` parameters. A vector of time steps is provided using the
`time_dt` parameter. An accompanying vector of corresponding times is specified
using the `time_t` parameter. These two vectors are used to form a time step vs.
time function. The time step for a given step is computed by linearly
interpolating between the pairs of values provided in the vectors.

The same procedure that is used with
[ConstantDT](/ConstantDT.md) is used to reduce
the time step from the user-specified value if a failed solution occurs.
If a `growth_factor` is given, it will be applied to every time step until the
current time step predicted by the function is smaller than the current time step multiplied by the
`growth_factor`.
In this sense, the `growth_factor` is the upper limit that any function can increase by.
If no `growth_factor` is provided by the user, the time step will only be governed by the function.

### Example Input Syntax





## IterationAdaptiveDT


### Description

The `IterationAdaptiveDT` Time Stepper provides a means to adapt the time step
size based on the difficulty of the solution.

`IterationAdaptiveDT` grows or shrinks the time step based on the number of iterations taken
to obtain a converged solution in the last converged step. The required `optimal_iterations`
parameter controls the number of nonlinear iterations per time step that provides optimal solution
efficiency. If more iterations than that are required to obtain a converged solution, the time step
may be too large, resulting in undue solution difficulty, while if fewer iterations are required, it
may be possible to take larger time steps to obtain a solution more quickly.

A second parameter, `iteration_window`, is used to control the size of the region in which
the time step is held constant. As shown in [fig:adaptive_dt_criteria], if the number of nonlinear iterations
for convergence is lower than (`optimal_iterations-iteration_window`), the time step is
increased, while if more than (`optimal_iterations+iteration_window`), iterations are required,
the time step is decreased. The `iteration_window` parameter is optional. If it is not
specified, it defaults to 1/5 the value specified for `optimal_iterations`.

The decision on whether to grow or shrink the time step is based both on the number of nonlinear
iterations and the number of linear iterations. The parameters mentioned above are used to
control the optimal iterations and window for nonlinear iterations. The same criterion is applied
to the linear iterations. Another parameter, `linear_iteration` ratio, which defaults to 25, is
used to control the optimal iterations and window for the linear iterations. These are calculated
by multiplying `linear_iteration_ratio` by optimal iterations and iteration window,
respectively.

To grow the time step, the growth criterion must be met for both the linear iterations and nonlinear
iterations. If the time step shrinkage criterion is reached for either the linear or nonlinear
iterations, the time step is decreased. To control the time step size only based on the number of
nonlinear iterations, set `linear_iteration_ratio` to a large number.

If the time step is to be increased or decreased, that is done using the factors specified with the
`growth_factor` and `cutback_factor`, respectively. If a solution fails to converge when adaptive
time stepping is active, a new attempt is made using a smaller time step in the same manner
as with the fixed time step methods. The maximum and minimum time steps can be optionally
specified in the `Executioner` block using the `dtmax` and `dtmin` parameters, respectively.

In addition to controlling the time step based on the iteration count, `IterationAdaptiveDT`
also has an option to limit the time step based on the behavior of a time-dependent function,
optionally specified by providing the function name in `timestep_limiting_function`. This
is typically a function that is used to drive boundary conditions of the model. The step is
cut back if the change in the function from the previous step exceeds the value specified in
`max_function_change`. This allows the step size to be changed to limit the change in the boundary
conditions applied to the model over a step. In addition to that limit, the boolean parameter
`force_step_every_function_point` can be set to `true` to force a time step at every point in a
`Piecewise` function. The time step size post function sync can be reset via the [!param](/Executioner/TimeStepper/IterationAdaptiveDT/post_function_sync_dt)
input parameter as well.


The `IterationAdaptiveDT` is often simply used to have an exponentially growing time step. For this
purpose, the iteration related parameters are not required.

### Example Input Syntax





## LogConstantDT

Sets the time step so that it is constant in the logarithmic space.
The initial time step must be set up independently.





## PostprocessorDT


The postprocessor can be computing a global metric, like the Courant Friedrich Levy criterion
with the [CFLTimeStepSize](CFLTimeStepSize.md optional=True) or the
[LevelSetCFLCondition](LevelSetCFLCondition.md optional=true) postprocessor. In those cases,
the postprocessor computes the maximum value of the timestep that should ensure stability.
Variations in numerical schemes may impact the accuracy of this postprocessor, so the
`PostprocessorDT` allows for a scaling factor and an offset to modify the time step.

If the application using the `PostprocessorDT` is a sub-app, its time step may also be
received through a [MultiAppPostprocessorTransfer.md] using a [Receiver.md] postprocessor.

### Example input syntax

In this example, we set the time step to be the maximum value allowable under a CFL criterion for
a fluid flow simulation in a shock tube.





## SolutionTimeAdaptiveDT


The idea is to find the simulation time step such as the computational cost of a step is the lowest.
The computational cost of a time step solve depends on many factors, this time stepper studies the
time step dependence.

This time stepper tries to decrease the simulation time in every time step by reacting
to changes in computational time. If the computational cost of a time step increases two steps
in a row, then it will either lower or increase the time step, depending on what it did for those
two previous steps. For example, if it increased the time steps twice in a row and the solve time
increased, then it will attempt to decrease the time steps, for at least two steps, until the
dynamic is reversed.

When changing the time step, it is modified using this equation

dt^{n+1}= dt^n ( 1 + \text{percent change} * \pm 1)

The sign of the update is chosen as explained above.

### Example input syntax





## TimeSequenceFromTimes


The time sequence of times to hit is retrieved every time the time stepper is asked to step in
time. This lets the times to hit evolve dynamically if the times in the [Times](syntax/Times/index.md)
object are changing.




## TimeSequenceStepper

This time stepper derives from [TimeSequenceStepperBase.md] and provides the
sequence of time values from a user-specified list, given by
[!param](/Executioner/TimeSteppers/TimeSequenceStepper/time_sequence).

See [TimeSequenceStepperBase.md#failed_solves] for information on the behavior
of this time stepper for failed time steps.

### Example input syntax

In this example, the numerical problem is solved at four specified points in time using
a `TimeSequenceStepper`.





## TimeSequenceStepperBase

`TimeSequenceStepperBase` is a base class for time steppers that use a sequence
time values $t_i$ to produce time step sizes.

### Failed solves id=failed_solves

If the solver fails to obtain a converged solution for a given
step, the executioner cuts back the step size and attempts to advance the time
from the previous step using a smaller time step. The time step is cut back by
multiplying the time step by the cutback factor, defaulting to 0.5. If this is successful,
the time stepper will then attempt to use the next time in the sequence,
adjusting the time step to "get back on track".

### Choosing the time step size past the final time value

Suppose that $t_N$ is the maximum time value provided in the sequence. This value
may be less than the simulation end time $t_\text{end}$ given by the
[!param](/Executioner/Transient/end_time) parameter. If this is true and the current simulation
time $t$ is past $t_N$, then by default, there will be a single, final time step
that jumps to the end time:

\Delta t = t_\text{end} - t_N \,.

However, in many cases this is undesirable, such as when a steady state condition
is used to terminate a transient, in which case an arbitrarily large end time
is specified, leading to a very large time step size. This behavior can be
altered with [!param](/Executioner/TimeSteppers/TimeSequenceStepper/use_last_dt_after_last_t).
If set to `true`, this uses the final time step size in the sequence instead
for all time past $t_N$:

\Delta t = t_N - t_{N-1} \,.

# transfers

## MultiAppCloneReporterTransfer


### Overview

This transfer is very similar to [MultiAppReporterTransfer.md] with a few key differences. The first is that this object can only transfer from sub-application(s) to the main app. The second is that reporter values are declared on-the-fly, i.e. the reporter values from the sub-app are "cloned" onto the main app, with out an already existing value on the main app. The third is that when there are multiple sub-applications, the values are collected into a vector of that reporter type on the main app.

It is not possible to transfer a reporter value that has already been cloned with this object. For instance, let's say there is a hierarchical structure of multiapps with a primary (main), secondary, and tertiary app. If this object is used to clone values from the tertiary to secondary, it cannot again be used to clone the same values from the secondary to the primary.

### Example Input Syntax

#### Multiple Sub Applications

This example shows a multi-app with multiple sub applications. It uses the same input file, but with different reporter values controlled by [!param](/MultiApps/TransientMultiApp/cli_args):


The transfer syntax is pretty minimal giving reporter value names (can be found in [sub0.i](reporter_transfer/sub0.i)) on the sub-app and reporter object name on main app, the object name is used to associate the cloned value to an object.


When run in serial, a single output file is produced which shows the vectors of the reporter values created:


In parallel, the sub app reporter values are split into different files, one for each processor. This example was run with 6 processors which split the 4 sub apps. So the root processor for each sub app ([clone_out.json](reporter_transfer/gold/clone_out.json), [clone_out.json.1](reporter_transfer/gold/clone_out.json.1), [clone_out.json.2](reporter_transfer/gold/clone_out.json.2), and [clone_out.json.4](reporter_transfer/gold/clone_out.json.4)) will show the value, while the other processors ([clone_out.json.3](reporter_transfer/gold/clone_out.json.3) and [clone_out.json.5](reporter_transfer/gold/clone_out.json.5)) will be empty:



#### Single Sub Application

When there is a only a single sub-application in the multi-app, the reporter value is directly cloned (versus creating a vector):



The resulting output in serial and the root processor in parallel will contain the transferred values, while the non-root processors will have the default constructor of the value type:






## MultiAppConservativeTransfer

It is essential to preserve a physics quantity during the transfer process for specific applications. For instance, neutron calculations' total power needs to be preserved when the power density is transferred to thermal calculations. That was implemented in the conservative transfer. The transfer is performed in the following steps:

- Users get a solution in the source app ready and calculate to-be-preserved physics quantity based on the solution.  The physics quantity is calculated using a postprocessor where users determine how they want to compute this quantity.

- The solution is transferred to the target domain. A new physics quantity is calculated using the target solution. Again, that calculation is implemented as a postprocessor, where users should compute that according to the physics.

- The target solution will be adjusted according to the source physics quantity and the target physics quantity.

- The conservative quantity will be calculated again based on the adjusted target solution. The value is often printed on the screen for users' convenience.

The main picture of the conservative transfer can be explained mathematically as follows

$Q_1(u_1) = Q_2(u_2)$,

where $Q_1$ is a function used to compute a quantity of interest on the source domain and $u_1$
is a source physics field. $Q_1$ is implemented as a postprocessor. $Q_2$ and $u_2$ are corresponding
counterparts on the target side.  We emphasize that users are free to implement any postprocessor for $Q_i$ according to the physics of interest.

### Example Input File Syntax

The following examples demonstrate the use of the MultiAppConservativeTransfer for transferring
solution.






## MultiAppCopyTransfer

The MultiAppCopyTransfer allows for copying variables (both [nonlinear](syntax/Variables/index.md)
and [auxiliary](/AuxVariables/index.md)) between [MultiApps](/MultiApps/index.md). All types
of variables, including higher order, elemental, and nodal are supported. The only limitation is that
the meshes in the parent and sub application must be identical.

### Siblings transfer behavior

This transfer supports sending data from a MultiApp to a MultiApp if and only if the number of subapps
in the source MultiApp matches the number of subapps in the target MultiApp, and they are distributed
the same way on the parallel processes. Each source app is then matched to the target app with the same
subapp index.

### Example Syntax





## MultiAppGeneralFieldNearestLocationTransfer


The nearest neighbor may be the nearest node or the nearest element centroid
(approximated by the vertex average), depending on the context
such as the finite element/volume types of the source and target variables.
This object derives from the [MultiAppGeneralFieldTransfer.md] family of transfers and inherits
many of its features and characteristics.

Nearest node transfers may be preferred to [shape evaluation transfers](MultiAppGeneralFieldShapeEvaluationTransfer.md)
when extrapolation of data is required, e.g. when the target domain extends beyond the source domain.
It may also be preferred if evaluating shape functions or projecting variables is too expensive or
unnecessary for the target application.

This is a re-implementation of [MultiAppNearestNodeTransfer.md] using a more flexible algorithm.

Nearest-node algorithms are vulnerable to finite precision round-offs if multiple neighbors are exactly at the
same distance. This can affect repeatability of results. Use the [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/search_value_conflicts)
parameter to uncover these issues.

The [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/num_nearest_points) allows for a
simple geometric mixing of values of several nearest nodes to the target points. This mixing is performed
in every origin problem independently, values from different child applications
(or from different processes within each application) will not be mixed together.

If [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/num_nearest_points) is more than 1, the results
will differ in parallel if the target locations are near the parallel process boundaries
on the origin app mesh. Use the [!param](/Debug/SetupDebugAction/output_process_domains) parameter to examine
process boundaries on Exodus/Nemesis output.

### Example Input File Syntax

In this example, a `MultiAppGeneralFieldNearestLocationTransfer` is used to transfer a variable `to_sub` from
block '1' in the main app to block '1' in the child app `sub`, filling the variable `from_main`.





## MultiAppGeneralFieldShapeEvaluationTransfer


`MultiAppGeneralFieldShapeEvaluationTransfer` uses the most natural way to transfer fields from one application to
another without extrapolation. It evaluates the shape function of the source variable at the desired transfer location
the reconstructs the target variable with the desired finite element type using those values.
This object derived from the [MultiAppGeneralFieldTransfer.md] family of transfers and inherits
many of its features and characteristics.

If the origin and target meshes are the same, if there is only a single child app involved on both sides,
and if the variables involved are of the same type, the [MultiAppCopyTransfer.md] will
provide better performance with the same results.

This is a re-implementation of [MultiAppShapeEvaluationTransfer.md] using a more flexible algorithm.

Indetermination due to overlapping origin mesh is only detected reliably if
[!param](/Transfers/MultiAppGeneralFieldShapeEvaluationTransfer/greedy_search) is set to true.

### Example Input File Syntax

In this example, a `MultiAppGeneralFieldShapeEvaluationTransfer` is used to transfer a variable `to_sub` from
block '1' in the main app to block '1' in the child app `sub`, filling the variable `from_main`.





## MultiAppGeneralFieldTransfer

Base class for all `GeneralField` transfers. It holds most setup and communication routines, leaving
to the derived classes the charge of computing the transferred values.

### General description

A `GeneralField` transfer proceeds as follows:

Each process first looks to find which source application it will be talking to.
This is based on geometric proximity, leveraging bounding boxes enclosing each application's
domain. The bounding boxes may need to be extended using the
[!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/bbox_factor)
parameter to expand the domain considered for transfers with wider stencils.

Then each process shares the list of target points, locations it needs data for, with
each of the processes owning the source applications of interest. These other processes
then, using the behavior defined in the derived class, compute the local value of the source
variable. They also share geometric information about where this evaluation of the source
variable was located, which can be used for interpolation for example.

Finally, the data received is placed in the solution vector of the target variable(s).
This is performed using a local projection with the shape function of the target variable(s) in
order to support higher order variables.

### Features supported

All transfers derived from this base class should be able to support:

- block restriction in both the source and target application
- boundary restriction in both the source and target application
- [mesh division](syntax/MeshDivisions/index.md) restriction in both the source and target application
- arbitrary number of parallel processes for both the source and target application
- support for replicated and distributed meshes in both applications involved
- transfers between parent and child applications
- transfers between sibling applications (child to child)
- transfers between parent and multiple child applications in different locations
- transfers to and from a displaced mesh
- transfers of nodal and elemental variables
- transfers between variables of different finite element/volume family and type
- transfers between regular and array variables
- transfers from multiple variables to multiple variables
- interpolation and extrapolation transfers, as defined by the derived class
- detection of indetermination due to source points equidistant to a target point
- limitation of transfer source to the nearest position (see [Positions](syntax/Positions/index.md)) of target point
- limitation of transfer source to the matching [mesh division](syntax/MeshDivisions/index.md) index between the source and target mesh divisions
- limitation of transfer source to subapps at the same index as the target mesh division
- limitation of transfer target to subapps at the same index as the source mesh division
- general coordinate transformations. Coordinate system changes (RZ to XYZ, for example) are not
  fully supported for the "floating point precision indetermination" detection.

Examine each derived object's respective documentation for feature support.

Floating point equidistance detection is turned on by default and will limit the scalability
of the transfer. Please set [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/search_value_conflicts)
to `false` for large cases.


### Features not supported

The following features cannot be supported by general field transfers, as a limitation of
the `MultiAppGeneralFieldTransfer` base class.

- bi-directional transfer, a single transfer that send data to an app and from that same application
- reduction operations, sum/average/min/max, on data transferred from multiple child apps
- transfers between vector variables


These features are currently unsupported, but could be enabled if necessary with reasonable efforts:

- caching optimizations for when both the target and origin mesh are constant

### Siblings transfer behavior

This transfer supports sending data from a MultiApp to a MultiApp with an arbitrary number
of source subapps in the source MultiApp and an arbitrary, possibly non-matching, number
of target subapps in the target MultiApp. It is the user's responsibility to ensure the
transfer is well defined, for example by avoiding overlaps between source multiapps which cause
multiple valid values for a target point.

### Use of bounding boxes

Bounding boxes are used in general field transfers to perform very fast checks on
whether a point could belong to an origin mesh. If the point is not inside the bounding
box of an application's mesh, then it clearly cannot be inside that mesh. This allows to
disqualify a majority of origin meshes very fast in situations where the transfer
obtains data from multiple applications.

This process fails in several situations. When seeking to extrapolate from a source
application (or interpolate between non-overlapping source applications), the target points
can naturally be outside the bounding box of the source applications. In order to resolve this,
the `Transfer`'s [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/bbox_factor) and
[!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/fixed_bounding_box_size) may be
used to inflate the bounding boxes.
Note that the center of the bounding box is taken to be the center of the origin mesh's bounding box.

[!param](/MultiApps/TransientMultiApp/bounding_box_inflation) and
[!param](/MultiApps/TransientMultiApp/bounding_box_padding) parameters of the origin `MultiApp` are ignored.
Only the `MultiAppGeneralFieldTransfer` [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/bbox_factor)
and [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/fixed_bounding_box_size)
parameters are taken into account.

### Using the Positions system to restrict transfer sources

In addition to block and boundary restriction, the [Positions system](syntax/Positions/index.md) may
be used to match origin and target points. When specified with the
[!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/use_nearest_position) parameter, each target
point of a transfer will only be matched with sources that are closest to the same `Position` as the
target point. The sources are simply the applications for:

- [MultiAppGeneralFieldUserObjectTransfer.md]
- [MultiAppGeneralFieldShapeEvaluationTransfer.md]

and nodes or centroids for:

- [MultiAppGeneralFieldNearestLocationTransfer.md]


Unlike block and boundary restriction which are inclusive (more origin blocks/boundaries specified
means a larger source), specifying more `Positions` further restricts the considered source for
a given target point.

The "nearest position" criterion for the source of a transfer is obeyed strictly. If closer,
an invalid value (triggering the use of the [!param](/Transfers/MultiAppGeneralFieldUserObjectTransfer/extrapolation_constant))
should and will be preferred over a valid value.

The origin and target locations for transferred data are both considered in the reference
domain (the one obtained by applying the coordinate transformation) when using the nearest positions
transfer options.

### Using mesh divisions in transfers

[Mesh divisions](syntax/MeshDivisions/index.md)
may be leveraged in several ways by specifying the [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/from_mesh_division_usage)
and the [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/to_mesh_division_usage)
parameters.

- Mesh divisions for spatial transfer restriction (usage = `spatial_restriction`)

Source and target mesh divisions, specified using the [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/from_mesh_division) and [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/to_mesh_division) parameters respectively, can be used
to limit the spatial domain that will provide data for the transfer (origin spatial restriction)
and the target spatial domain. The exclusion of a region is simply the region that is indexed with an invalid
index in the mesh division.

The spatial restriction effect of the mesh divisions is active for all usages!
If some data lies outside the source mesh division, it will not be transferred.

- Matching regions using a source and target mesh divisions (usage = `matching_division`)

The source domain for the values to be transferred and the target domain can also be matched on
a one-to-one basis using the [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/from_mesh_division) and [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/to_mesh_division) parameters.
Each region of a given index into a division is matched to the region of the same index into the other
division.

It is advised to keep the number of mesh divisions the same in the two mesh divisions for simplicity.

- Matching source applications and target regions using a mesh division

Set [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/to_mesh_division_usage) to `matching_subapp_index`

The application providing values to transfer to a target region can be restricted to the
index of the points in the target region given by a mesh division specified by the [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/to_mesh_division) parameter.

It is advised to keep the number of target mesh divisions the same as the number of source subapps for simplicity.

- Matching target applications and source regions using a mesh division

Set [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/from_mesh_division_usage) to `matching_subapp_index`

The spatial region providing values to transfer to a target application can be restricted using a mesh division specified by the [!param](/Transfers/MultiAppGeneralFieldNearestLocationTransfer/from_mesh_division) parameter.
The target subapp will then only receive data that comes from the region at the same index, as the subapp,
in the source mesh division.

It is advised to keep the number of source mesh divisions the same as the number of target subapps for simplicity.

### Overlap and floating point precision indetermination detection

The derived classes of `MultiAppGeneralFieldTransfer` may keep track of indetermination in origin values.
In the event of indetermination in origin values, a single value is still selected, usually the one from
the process with the lowest rank. These indetermination occur when for example:

- multiple points in the origin mesh(es) are equidistant to the target location, for nearest-node type transfers
- multiple child apps have an equidistant point to the target location, for nearest-node type transfers
- multiple child apps can compute a valid value for a target location because their meshes overlap

`MultiAppGeneralFieldTransfer` itself keeps track of indetermination by examining received values for each
target point. This occurs when multiple values are received for a single target point. Some transfers
examine the distance between origin and target points to select a value, but this can still lead to
indetermination if the distances are the same.

Mesh, block or boundary restriction can sometimes be used to alleviate these indeterminations
in the origin values. Other times, either remeshing one of the apps or using the
[!param](/MultiApps/TransientMultiApp/positions) parameter to create a very small offset can help
remove the indetermination.

## MultiAppGeneralFieldUserObjectTransfer


### Description

`MultiAppGeneralFieldUserObjectTransfer` transfers information from a `UserObject` in an application to a variable in another.
This transfer is a [General Field](MultiAppGeneralFieldTransfer.md) version of the [MultiAppUserObjectTransfer.md]. As such it
supports numerous additional features (various spatial restrictions, higher order variables, etc), listed in the base class documentation.

If the target domain is not fully enclosed inside the source app meshes, the user objects will still be queried at each target point,
and, only if the values is valid, will be used. This is the case both for interpolating between source domains and extrapolating.

The user object must implement the `spatialValue` routine, which is used to obtain the UO value at candidate origin points in
the source application.




## MultiAppGeometricInterpolationTransfer

The `MultiAppGeometricInterpolationTransfer` transfers the nearest node's source variables to the nearest node on the
target mesh using mesh interpolation, including the ability to utilize the displaced
configuration for either or both the source and target.  
The `MultiAppGeometricInterpolationTransfer` also offers extrapolation on non-overlapping domains where the target data
can be computed from source nodes not inside the target mesh.
Other interpolation transfers like the [MultiAppShapeEvaluationTransfer.md] are not able to extrapolate data and will only work for fully overlapping domains.

Nodal transfers using the default settings for this interpolation scheme, `interp_type=inverse_distance`
and `num_points=3`, will find the three closest points on the source mesh to a node on the target mesh.  
The source data from the three closest nodes will then be interpolated to the target node using [inverse distance weighting](https://en.wikipedia.org/wiki/Inverse_distance_weighting).   
Inverse distance interpolation is best suited for the interpolation of point cloud data in the source mesh onto a target mesh.  

The [MultiAppShapeEvaluationTransfer.md] may be a better choice for nodal transfers
between two meshes with fully overlapping domains because the element shape functions will be used in the transfer.
However, as mentioned above, only the `MultiAppGeometricInterpolationTransfer` can be used to extrapolate data between meshes on domains that do not fully overlap.

Using `MultiAppGeometricInterpolationTransfer` with the default interpolation settings for mesh to mesh nodal transfers of data
is not deterministic when the point being interpolated to on the
target mesh is exactly the same distance away from more than `num_points` on the source mesh.  
This nondeterministic behavior in the `MultiAppGeometricInterpolationTransfer` node-to-node transfer
can lead to different data being transferred when the numerics
of a problem are changed by something like the parallel decomposition or compiler settings.  

This inconsistency can occur on structured meshes when the target mesh is a refined version of the source mesh.  
In this scenario, a target node will be placed equidistant from several source nodes.  
For a 2D structured mesh of quadrilaterals, the refined mesh's target node would be equidistant from 4 nodes on the source mesh.  
With the default `num_points=3`, the three points chosen from the four equidistant
nodes on the source mesh will be arbitrary and has been shown to be dependent on
the parallel decomposition of the mesh.  
This problem can be made deterministic by increasing `num_points=4` so that
all of the nodes in the element are used for the interpolation.


### Example Syntax





## MultiAppInterpolationTransfer

This object has been renamed, please see [MultiAppGeometricInterpolationTransfer.md]

## MultiAppNearestNodeTransfer


The projection mapping may be cached at the first execution of the transfer for better performance in later executions using the [!param](/Transfers/MultiAppNearestNodeTransfer/fixed_meshes) parameter. This is incompatible with adaptivity and refinement of the mesh.

This transfer has been re-implemented to be more flexible. Please consider using [MultiAppGeneralFieldNearestLocationTransfer.md]

### Example Input File Syntax

The following examples demonstrate the use the MultiAppNearestNodeTransfer for transferring data
to ([tosub]) and from ([fromsub]) sub-applications.






## MultiAppPostprocessorInterpolationTransfer


### Overview

Performs a transfer of a PostProcessor value from sub-applications to a field variable on the
parent application using interpolation based on the location of each sub-application.

### Example Input File Syntax

The following input file snippet demonstrates the use of the
MultiAppPostprocessorInterpolationTransfer to interpolate the average value from two sub-applications
to a field variable in the parent application.





## MultiAppPostprocessorToAuxScalarTransfer


### Siblings transfer behavior

This transfer supports sending data from a MultiApp to a MultiApp if and only if the number of subapps
in the source MultiApp matches the number of subapps in the target MultiApp, and they are distributed
the same way on the parallel processes. Each source app is then matched to the target app with the same
subapp index.

### Example Input File Syntax

The MultiAppPostprocessorToAuxScalarTransfer transfers a Postprocessor value to an scalar
AuxVariable. In the following example, a Postprocessor value from the parent application
is transferred to a scalar AuxVariable on each of the sub-applications.





## MultiAppPostprocessorTransfer


### Siblings transfer behavior

This transfer supports sending data from a multiapp to a multiapp. There are two supported configurations:

- only one subapp in the source multiapp, the source postprocessor value is sent to all target multiapps.
- the same number of subapps in the source and target multiapp, the source postprocessor is matched to a target postprocessor based on a matching subapp index.

### Example Input File Syntax

The MultiAppPostprocessorTransfer allows for a Postprocessor value to be transfer between the
parent application and sub-application(s). For example, the input file snippet below
sets up a transfer of a Postprocessor value from the parent application to a Postprocessor on
each of the sub-applications.





## MultiAppProjectionTransfer


The projection mapping may be cached at the first execution of the transfer for better performance in later executions using the [!param](/Transfers/MultiAppProjectionTransfer/fixed_meshes) parameter. This is incompatible with adaptivity and refinement of the mesh.

### Example Input File Syntax

The following examples demonstrate the use the MultiAppProjectionTransfer for transferring data
to ([tosub]) and from ([fromsub]) sub-applications.






## MultiAppReporterTransfer


### Overview

This MultiAppReporterTransfer provides a method to transfer a reporter value (see [reporters](/Reporters/index.md)) of any type between the main application and the sub-application(s).  This includes vectors of real numbers from [vectorpostprocessors](/VectorPostprocessors/index.md) as well as real numbers from [postprocessors](/Postprocessors/index.md).

[!param](/Transfers/MultiAppReporterTransfer/from_reporters) specifies where the data is coming from, and [!param](/Transfers/MultiAppReporterTransfer/to_reporters) specifies where the data going to. These are a list of reporter names that must be the same length, as they directly correspond to each other. For [vectorpostprocessors](/VectorPostprocessors/index.md) the syntax is "vpp_name"/"vector_name" and for [reporters](/Reporters/index.md) the syntax is "reporter_name"/"value_name".

When transferring data from the main application the data from the main is copied to each sub-application. If the [!param](/Transfers/MultiAppReporterTransfer/subapp_index) is used then data is only transferred to the specified sub-application. When transferring data to the main application the [!param](/Transfers/MultiAppReporterTransfer/subapp_index) must be supplied if there is more than one sub-application.

### Siblings transfer behavior

This transfer supports sending data from a MultiApp to a MultiApp if and only if the number of subapps
in the source MultiApp matches the number of subapps in the target MultiApp, and they are distributed
the same way on the parallel processes. Each source app is then matched to the target app with the same
subapp index.

### Distributed Vector Transfer

The MultiAppReporterTransfer also supports transferring reporter vectors in a distributed fashion using the [!param](/Transfers/MultiAppReporterTransfer/distribute_reporter_vector) parameter.
In this mode, the transfer assumes a one-to-many or many-to-one relationship
between the reporter values in the main application and the sub-applications.
The reporter value in the main application is expected to be a vector with a
size matching the number of sub-applications. Each sub-application will
send/receive its respective component of the vector based on its index. The main
app reporter is assumed to be replicated while the subapp reporters are assumed
to be root or replicated.

| Main App | Sub App 1 | Sub App 2 | Sub App 3 | Sub App 4 |
|---|---|---|---|---|
| $\begin{pmatrix}1\\2\\3\\4\end{pmatrix}$ | 1 | 2 | 3 | 4 |
|
| $\begin{pmatrix}1\\2\end{pmatrix}$ $\begin{pmatrix}3\\4\\5\end{pmatrix}$ $\begin{pmatrix}6\\7\\8\\9\end{pmatrix}$ $\begin{pmatrix}10\\11\\12\end{pmatrix}$ | $\begin{pmatrix}1\\2\end{pmatrix}$ | $\begin{pmatrix}3\\4\\5\end{pmatrix}$ | $\begin{pmatrix}6\\7\\8\\9\end{pmatrix}$ | $\begin{pmatrix}10\\11\\12\end{pmatrix}$ |

The main
app reporter is assumed to be `REPORTER_MODE_REPLICATED` while the subapp reporters are assumed
to be `REPORTER_MODE_ROOT` or `REPORTER_MODE_REPLICATED`. This operation will
error out with any reporter that
are `REPORTER_MODE_DISTRIBUTED`.

### Example Input File Syntax


You can initialize arbitrary data containers for [!param](/Transfers/MultiAppReporterTransfer/to_reporters) with the following objects:

- Postprocessor: [Receiver.md]
- VectorPostprocessor: [ConstantVectorPostprocessor.md]
- Reporter: [ConstantReporter.md]


#### Transferring VectorPostprocessors

Here, we are transferring data between vectorpostprocessors:



   indent=2 header=[Transfers] footer=[]

#### Transferring Reporter Vectors

Here, we are transferring data between a reporter vector and vectorpostprocessors:



   indent=2 header=[Transfers] footer=[]

#### Transferring Reporter Real Numbers

Here, we are transferring data between a reporter real number and postprocessors:



   indent=2 header=[Transfers] footer=[]

#### Transferring Reporter Integers and Strings

Here, we are transferring integer and string data between reporters:



   indent=2 header=[Transfers] footer=[]



#### Distribution of a vector Reporter

##### Scatter vector Reporter

Here we are transferring a vector reporter and a vector of vectors reporter in a
scatter fashion. The main application holds a vector of vectors and a
single vector, while each subapp has a vector and a Real (scalar) reporter.
During the transfer the subapp's reporters are populated from the scattering of
the main app's vector reporter. The main app can also use a vector of vectors reporter, in which case those vectors
are distributed to the subapps.



   indent=2 header=[Transfers] footer=[]


##### Gather vector Reporter

Here we are transferring a vector reporter and a vector of vectors reporter in a gather fashion. The main application holds a vector of vectors and a single vector, while each subapp has a vector and a Real (scalar) reporter. This test shows the gather operation by aggregating the same values from each subapp into a vector of reporters in the main application.



   indent=2 header=[Transfers] footer=[]




## MultiAppScalarToAuxScalarTransfer


### Siblings transfer behavior

This transfer supports sending data from a MultiApp to a MultiApp if and only if the number of subapps
in the source MultiApp matches the number of subapps in the target MultiApp, and they are distributed
the same way on the parallel processes. Each source app is then matched to the target app with the same
subapp index.

### Example Input File Syntax

The following examples demonstrate the use the MultiAppScalarToAuxScalarTransfer for transferring data
to ([tosub]) and from ([fromsub]) sub-applications.






## MultiAppShapeEvaluationTransfer


Evaluations of the origin variable shape functions provide the actual value of the origin variable
at the target location.

This transfer does not support extrapolation, the evaluation of nodes/elements in the target mesh that do not map back to the origin mesh.
Please use [MultiAppGeometricInterpolationTransfer.md] or [MultiAppNearestNodeTransfer.md]

This transfer has been re-implemented to be more flexible. Please consider using [MultiAppGeneralFieldShapeEvaluationTransfer.md]

### Example Input File Syntax

The following examples demonstrate the use the `MultiAppShapeEvaluationTransfer` for transferring data
to ([tosub]) and from ([fromsub]) sub-applications.






## MultiAppUserObjectTransfer


### Description

MultiAppUserObjectTransfer transfers information from a UserObject in the parent/sub application to an AuxVariable in the sub/parent application based on the direction of transfer (to_multiapp/from_multiApp).

The transfer can be restricted to a subdomain using the [!param](/Transfers/MultiAppUserObjectTransfer/block) parameter or a boundary using the [!param](/Transfers/MultiAppUserObjectTransfer/boundary) parameter.

### To MultiApp

If the AuxVariable in the sub applications is a nodal AuxVariable, for each node in the sub application the value at the corresponding position in the parent application is queried from the parent UserObject, and this value is set to the AuxVariable at that node. A similar approach is followed for the elemental AuxVariable but with the centroid of the  element instead of nodal position.

### From MultiApp

For nodal AuxVariable in the parent application, it is first determined whether the node is contained within the bounding box of the sub application. If the parent node lies within a sub application's bounding box, the value of the sub application UserObject at that location is transferred to the parent AuxVariable. A similar approach is followed for the elemental AuxVariable but with the centroid of the parent element instead of nodal position.

When `all_parent_nodes_contained_in_sub_app` option is set to true, an error is generated if the parent node/element does not lie within the bounding boxes of any of the sub applications. An error is also generated if the parent node/element lies within the bounding boxes of 2 or more sub applications.





## MultiAppVariableValueSamplePostprocessorTransfer


### Description

This transfer supports data transfers between a variable on the main application and a postprocessor on the sub-applications.
The variable can be a standard field variable, a component of an array variable, or all components of an array variable.

When transferring a variable to a postprocessor on the sub-applications of a MultiApp, the positions of sub-applications are used to sample the values of the variable and the sampled values are used to set the postprocessor values.

When transferring a postprocessor on the sub-applications of a MultiApp to a variable, the postprocessor value of a sub-application whose position is closest to an element is used to set the variable at the element.
Because of this, this transfer object works just with `CONSTANT` `MONOMIAL` variables and is meant to be used mainly with `CentroidMultiapp`.
Interpolating `FIRST` (or higher) order variables using the Multiapp postprocessors values centered in the multiapp position is not possible close to the variable domain edge and do not ensure the preservation of conserved quantities.
The target variable must be an auxiliary variable.

For array variables, one can specify the specific component of the variable using [!param](/Transfers/MultiAppVariableValueSamplePostprocessorTransfer/source_variable_component).
Another option is to set [!param](/Transfers/MultiAppVariableValueSamplePostprocessorTransfer/map_array_variable_components_to_child_apps) to `true`, which will split the sub-applications into groups based on component of the array variable.
This is useful when creating a set of positions for each component of an array variable.
See the parameter description on how the sub-applications and components are associated.

In case the sub-applications are not defined in the whole variable domain (e.g. the CentroidMultiApp blocks group is a subgroup of the variable blocks group), the elements in the blocks without a multiapp will get the value of the nearest sub-application's postprocessor in the closest block in which sub-applications are defined.

### Example Input File Syntax

The following input file snippet demonstrates the use of the
MultiAppVariableValueSamplePostprocessorTransfer to transfer the value of a field variable
at the sub-application positions to a Postprocessor on each sub-application.


An example showing how to transfer all the components of an array variable is shown below. Note that the source variables have 2 components and the MultiApp has two sets of 4 positions, so 8 child apps. The first four child applications, tied to the first set of positions, receive the first variable component (at index 0). The second set of child applications receive the second variable component.





## MultiAppVariableValueSampleTransfer


### Example Input File Syntax

The following input file snippet demonstrates the use of the
MultiAppVariableValueSampleTransfer to transfer the value of a field variable
at the sub-application positions to a field variable on each sub-application.





## MultiAppVectorPostprocessorTransfer

MultiAppVectorPostprocessorTransfer transfers values from parent [VectorPostprocessors] to sub-app
[Postprocessors] or vice versa. The number of entries in the [VectorPostprocessors] data vector must
be equal to the number of sub-apps associated with the provided [MultiApps](/MultiApps/index.md). The transfer
sends/receives the n-th entry of the VectorPostprocessor to/from the n-th sub-app.


For direct VectorPostprocessor-to-VectorPostprocessor transfers see [MultiAppReporterTransfer](MultiAppReporterTransfer.md#vector_transfer).




# userobjects

## BatchMaterial

`BatchMaterial` implements a generic base class for a userobject that can gather MaterialProperties and Variables from all QPs in the local domain to perform a computation in a single batch (offloaded to a GPU for example).

The number and types of properties and variables is flexible and will be resolved at compile time through templating.

The resulting userobject will generate an "array of structs" for optimal cache locality in the batch computation. The input data "struct" is a tuple. The base class is templated on a tuple wrapper class. This allows use of either `std::tuple` or `cuda::std::tuple` (which has corresponding implementations on the host and the device with identical memory layouts!).

The output data type is a user specified template parameter (it could be a struct or a simple number, etc.). A map is maintained by the user object to enable easy lookup of element/qp data in the output array.

The user must write a simple glue material class that uses the `getOutputData()`/`getIndex(elem_id)` interface of the derived batch material user object.


## ElementIntegralVariableUserObject


The `ElementIntegralVariableUserObject` is used to apply an integration operation
to a variable when creating other user objects. It takes care of multiplying by the
quadrature weights, the element volumes and performing the reduction operation, including
when using threads.

This is done by either:

- specializing user object class templates with this integration operation, for example the
  [NearestPointLayeredIntegral.md] specializes the `NearestPointBase` with this class and the
  [LayeredIntegral.md] to perform nearest point layered integration.
- inheriting both this class, for the integration operation, and another class that defines how
  to interact with the mesh to create a custom spatial integration user object, such as the
  [LayeredIntegral.md].


Used on its own, this user object performs a similar role as the [ElementIntegralVariablePostprocessor.md],
except that it does not set up the default output to console and CSV. Using the postprocessor is the
preferred way of performing this spatial variable integration.




## ElementQualityChecker


### Description

UserObject based on available libMesh quality metrics to check the quality of each element. It works for both uniform or mixed element types.

### Example Input Syntax





## ElemSideNeighborLayersGeomTester


### Overview

A user object to test whether or not geometric ghost elements are correctly reserved.
`element_side_neighbor_layers` is used to specify the number of layers of
geometric ghosting elements that will be preserved via a geometric relationship manager.





## ElemSideNeighborLayersTester


### Overview

A user object to test whether or not ghost elements are correctly reserved.
`element_side_neighbor_layers` is used to specify the number of layers of
 ghosting elements that will be preserved via either a geometric
or an algebraic relationship manager.





## FunctionElementIntegralUserObject


The `FunctionElementIntegralUserObject` is mostly used to apply an integration operation
to a function when creating other user objects by inheriting from both this class, for
the integration operation, and another class that defines how to interact with the mesh to
create custom spatial integration user objects, such as the
[FunctionLayeredIntegral](/userobjects/FunctionLayeredIntegral.md).

Used on its own, this user object performs a similar role as the [FunctionElementIntegral.md],
except that it does not set up the default output to console and CSV. Using the postprocessor is the
preferred way of performing this spatial function integration.




## FunctionLayeredIntegral


### How to define the layers

The parameters to define layers are explained in the
[LayeredAverage](/userobjects/LayeredAverage.md) documentation.

### How to retrieve the result

The result of a `FunctionLayeredIntegral` computation can be saved in an auxiliary variable using a
[SpatialUserObjectAux](/auxkernels/SpatialUserObjectAux.md).
It can be output to a CSV file using a [SpatialUserObjectVectorPostprocessor](/vectorpostprocessors/SpatialUserObjectVectorPostprocessor.md).

### Example Input File Syntax

In this example, the integral of a function `sin(y)` is taken over the
whole domain in the `y` direction over 20 layers. The result of the integral is stored
in the variable `layered_integral` using a
[SpatialUserObjectAux](/auxkernels/SpatialUserObjectAux.md), and output to a
CSV file using a [SpatialUserObjectVectorPostprocessor](/vectorpostprocessors/SpatialUserObjectVectorPostprocessor.md).

  start=AuxKernels
  end=Executioner




## GeneralUserObject

The GeneralUserObject intermediate base class is for creating custom algorithms that are not associated with
any mesh entity.

## GhostingUserObject

The GhostingUserObject maintains local data structures of elements involved in both
"Geometric" and "Algebraic" ghosting. This object is normally setup automatically through the
[DisplayGhostingAction.md].

### Example Input Syntax:






## InterfaceQpMaterialPropertyRealUO

### IMPORTANT NOTES
*** This userobject only support multiprocessing. Threading is not supported at this time  ***


### Description

InterfaceQpMaterialPropertyRealUO is a user object computing and storing average `real` material property values, rates, or increments across an interface for each quadrature point. The kind of average value are the one available in [InterfaceValueTools](/InterfaceValueTools.md).
The value type stored by this userobject is selected via the `value_type` input parameter. For example to get both the material property value and material property rate the user must add two separate user objects in the input file.

The InterfaceQpMaterialPropertyRealUO can provide two types of values to other MOOSE systems:

- a qp value by calling `getQpValue`
- an element side average value by calling `getSideAverageValue`

The stored value can be converted into an AuxVariable by using [InterfaceValueUserObjectAux](/InterfaceValueUserObjectAux.md) AuxKernel.


### Example Input File Syntax





## InterfaceQpValueUserObject

### IMPORTANT NOTES
*** This userobject only support multiprocessing. Threading is not supported at this time  ***


### Description

InterfaceQpValueUserObject is a user object computing and storing average variable values or rates across an interface for each quadrature. The kind of average value are the one available in [InterfaceValueTools](/InterfaceValueTools.md).
The value type stored by this userobject is selected via the `value_type` input parameter. For example to get both the variable value and variable rate the user must add two separate user objects in the input file.

The InterfaceQpValueUserObject can provide two types of values to other MOOSE systems:

-  a qp value by calling `getQpValue`
-  an element side average value by calling `getSideAverageValue`

The stored value can be converted into an AuxVariable by using [InterfaceValueUserObjectAux](/InterfaceValueUserObjectAux.md) AuxKernel.


### Example Input File Syntax





## InternalSideUserObject

InternalSideUserObjects are for creating algorithms that execute on all sides (edges between elements) of the mesh or a
subdomain of the mesh.

## JSONFileReader


This user object loads JSON file into a `nlohmann::json` object. The data can then be accessed programmatically
using the right key (if directly at the root level of the JSON) or group of keys through the APIs provided by the `JSONFileReader`.

There is currently no search feature implemented. The exact path through the JSON tree to the data of interest
must be used.





## LayeredAverage


### How to define the layers

The layer definition is handled by the `LayeredBase` class. It is summarized here.
One, or multiple, layers are defined by their direction (normal or axis), their number,
and their thicknesses.

The direction of the layers currently may only be along the three Cartesian axes, and can be
set using the [!param](/UserObjects/LayeredAverage/direction) parameter.

The number of layers is set using the [!param](/UserObjects/LayeredAverage/num_layers) parameter,
unless the [!param](/UserObjects/LayeredAverage/bounds) parameter (see below) is set.

The thicknesses of the layers can be set in three different, and separate, ways:

- they can be set directly with coordinates along the specified direction using the
  [!param](/UserObjects/LayeredAverage/bounds) parameter. This will simultaneously set the number
  of layers, equal to the number of bounds minus one.

- the minimum and maximum coordinates along the specified directions can be both specified to specify
  the total extent of equal thickness layers, using the [!param](/UserObjects/LayeredAverage/direction_min)
  and [!param](/UserObjects/LayeredAverage/direction_max) parameters

- a vector of bounding domains may be specified using the [!param](/UserObjects/LayeredAverage/layer_bounding_block).
  The minimum and maximum coordinates along specified direction, which sets the thickness for each layer,
  are then obtained by looking at the maximum coordinate in the specified bounding block (to set the layers' minimum)
  and the minimum coordinate in the bounding blocks (to set the layers' maximum).


The layers may be restricted to elements in certain subdomains using the
[!param](/UserObjects/LayeredAverage/block) parameter.

### How to retrieve the result

The result of a `LayeredAverage` computation can be saved in an auxiliary variable using a
[SpatialUserObjectAux.md]. It can be output to a CSV file using a [SpatialUserObjectVectorPostprocessor.md].

### Additional computation options

Sampling parameters may be specified to :

- obtain the layer average directly, by setting the [!param](/UserObjects/LayeredAverage/sample_type) to
  `direct` (default)

- interpolate between layer averages, by setting the [!param](/UserObjects/LayeredAverage/sample_type) to
  `interpolate`.

- average between layers, by setting the [!param](/UserObjects/LayeredAverage/sample_type) to
  `average`. The [!param](/UserObjects/LayeredAverage/average_radius) parameter can be specified
  to tune the distance over which to average results.


Additionally, cumulative averages over layers, in the positive direction, can be computed by setting
the [!param](/UserObjects/LayeredAverage/cumulative) to `true`.

### Example input syntax

In this example, the average of variable `u` is taken over the whole domain in direction `y` over
two layers. The result of this averaging is stored in the variable `layered_average` using a
[SpatialUserObjectAux.md], and output to a CSV file using a [SpatialUserObjectVectorPostprocessor.md].





## LayeredBase

Is a low-level base class containing the common logic for computing and storing spatial partial sums in a given cardinal direction.
It is intended to be derived from in any "Layered" calculation. The [LayeredIntegral.md] and derived classes compute and store
data structures for use in producing field values suitable for transfer where domains may not overlap or even represent similar areas,
but that contain some similar geometric relationship. For example, a "Layered" calculation may be useful for transferring heat produced
within a cylindrical object to the surrounding "outside", which may be a different shape or might just be represented by a 1D line.

The LayeredBase object derives from [Restartable.md] so it maintains stateful data across time steps.

## LayeredExtremumMaterialProperty


### How to define the layers

See the [LayeredAverage.md] documentation.

### How to retrieve the result

The result of a `LayeredExtremumMaterialProperty` computation can be saved in an auxiliary variable using a
[SpatialUserObjectAux.md]. It can be output to a CSV file using a [SpatialUserObjectVectorPostprocessor.md].

### Additional computation options

See the [LayeredAverage.md] documentation for more sampling option. The averaging operation is replaced by
an extremum (min or max) operation.


### Example input syntax

In this example, the minimum of material property `mat` is taken over the whole domain in direction `y` over
ten layers. The result of this averaging in stored in the variable `layered_extremum` using a
[SpatialUserObjectAux.md], and output to a CSV file using a [SpatialUserObjectVectorPostprocessor.md]





## LayeredIntegral


### How to define the layers

The parameters to define layers are explained in the [LayeredAverage.md] documentation.

### How to retrieve the result

The result of a `LayeredIntegral` computation can be saved in an auxiliary variable using a
[SpatialUserObjectAux.md]. It can be output to a CSV file using a [SpatialUserObjectVectorPostprocessor.md].

### Additional computation options

Additional options for performing averages, interpolations and cumulative sums are explained in the
[LayeredAverage.md] documentation.

### Example input syntax

In this example, the integral of variable `u` is taken over the whole domain in direction `y` over
three layers, on every linear iteration. The result of this averaging is stored in the variable
`layered_integral` using a [SpatialUserObjectAux.md] at the end of every timestep, and output to a
CSV file using a [SpatialUserObjectVectorPostprocessor.md].





## LayeredSideAverage


### How to define the layers

The parameters to define layers are explained in the [LayeredAverage.md] documentation.
The "block" parameter is no longer allowed to define the layers, unless the "boundary"
parameter is not set.

### How to retrieve the result

The result of a `LayeredSideAverage` computation can be saved in an auxiliary variable using a
[SpatialUserObjectAux.md]. It can be output to a CSV file using a [SpatialUserObjectVectorPostprocessor.md].

### Additional computation options

Additional options for performing averages, interpolations and cumulative sums are explained in the
[LayeredAverage.md] documentation.

### Example input syntax

In this example, the average of variable `u` is taken over the boundary `right` in the `y` direction over
three layers, on every linear iteration. The result of this averaging is stored in the variable
`layered_integral` using a [SpatialUserObjectAux.md] at the end of every time step, and output to a CSV
file using a [SpatialUserObjectVectorPostprocessor.md].





## LayeredSideAverageFunctor

This object is the same as [LayeredSideAverage.md], but the average may be taken
of any [functor](Functors/index.md), not just a variable.

This object requires the `ElemSideQpArg` [functor spatial argument](Functors/index.md) to be
implemented for the [!param](/UserObjects/LayeredSideAverageFunctor/functor) parameter.




## LayeredSideDiffusiveFluxAverage


The diffusive flux $\phi$ is computed with the following equation:

\phi = \int_{\partial \Omega} D(\vec{r}) \nabla u(\vec{r}) \cdot \vec{n}(\vec{r}) d\partial \Omega

where $\partial \Omega$ is the boundary of integration, $D$ the diffusion coefficient, $u$ the variable
of interest, $\vec{n}$ the normal to the boundary, and $\vec{r}$ indicates the position.

### Example Input File Syntax

         caption=Example input file snippet with a LayeredSideDiffusiveFluxAverage.




## LayeredSideIntegral


### How to define the layers

The parameters to define layers are explained in the [LayeredAverage.md] documentation.
The "block" parameter is no longer allowed to define the layers, unless the "boundary"
parameter is not set.

### How to retrieve the result

The result of a `LayeredSideIntegral` computation can be saved in an auxiliary variable using a
[SpatialUserObjectAux.md]. It can be output to a CSV file using a [SpatialUserObjectVectorPostprocessor.md].

### Additional computation options

Additional options for performing averages, interpolations and cumulative sums are explained in the
[LayeredAverage.md] documentation.

### Example input syntax

In this example, the integral of variable `u` is taken over the boundary `right` in the `y` direction over
three layers, on every linear iteration. The result of this averaging is stored in the variable
`layered_integral` using a [SpatialUserObjectAux.md] at the end of every time step, and output to a CSV file using a [SpatialUserObjectVectorPostprocessor.md].





## LayeredSideIntegralFunctor

This object is the same as [LayeredSideIntegral.md], but the side integral may be taken
of any [functor](Functors/index.md), not just a variable.

This object requires the `ElemSideQpArg` [functor spatial argument](Functors/index.md) to be
implemented for the [!param](/UserObjects/LayeredSideIntegralFunctor/functor) parameter.




## MessageFromInput


### Description

This user object provides an option to print a message to the screen during the simulation. The message can be written in the input file. The user can customize *when* the message should print, the default option is to print it at the initialization of the simulation, with `execute_on = INITIAL`.

### Example Input Syntax





## NearestNodeNumberUO

This UserObject computes the closest node to a given point.  (If there is a tie, then the node with the smallest ID is used.)  It is used by the [GeochemistryConsoleOutput](http://mooseframework.org/docs/doxygen/modules/GeochemistryConsoleOutput.html) object to identify the node at which output is required.

You will probably want to set execute_on to initial to avoid unnecessary computations, unless you have adaptive meshing, in which case set execute_on to initial and timestep_begin.




## NearestPointAverage


The domain is virtually divided into a number of subdomains according to
the nearest points provided by the users. For each provided point, a virtual
subdomain is created around that point and consists of all regions of space
that are closer to that point than any of the other provided points. Then,
the variable average is computed over each individual subdomain separately.




## NearestPointIntegralVariablePostprocessor

The domain is virtually divided into a number of subdomains according to the
nearest points provided by users. And then the variable integral is taken over
each individual subdomain separately.






## NearestPointLayeredAverage

The domain is virtually divided into a number of subdomains according to the
nearest points provided by users. And then the variable average
is taken over each individual subdomain separately with the ability to decompose
each subdomain in layers along a particular direction. If the number of layers is
larger than one, it is recommended that the interface between two layers align
with the mesh.






## NearestPointLayeredIntegral

The domain is virtually divided into a number of subdomains according to the
nearest points provided by users. And then the variable integral
is taken over each individual subdomain separately with the ability to decompose
each subdomain in layers along a particular direction. If the number of layers is
larger than one, it is recommended that the interface between two layers align
with the mesh.






## NearestPointLayeredSideAverage

The domain is virtually divided into a number of subdomains according to the
nearest points provided by users. And then the layered side average
is computed for the sides on each individual subdomain separately.






## NearestPointLayeredSideAverageFunctor

This object is the same as [NearestPointLayeredSideAverage.md], but the layered average may be taken
of any [functor](Functors/index.md), not just a variable.

This object requires the `ElemSideQpArg` [functor spatial argument](Functors/index.md) to be
implemented for the [!param](/UserObjects/NearestPointLayeredSideAverageFunctor/functor) parameter.




## NearestPointLayeredSideDiffusiveFluxAverage

The domain is virtually divided into a number of layered subdivision according
to the nearest points and the layering direction provided by users. And then
the layered side average diffusive flux is computed for the sides on each
individual subdivision separately.






## NearestPointLayeredSideIntegral

The domain is virtually divided into a number of subdomains according to the
nearest points provided by users. And then the layered side integral
is computed for the sides on each individual subdomain separately.






## NearestPointLayeredSideIntegralFunctor

This object is the same as [NearestPointLayeredSideIntegral.md], but the layered integral may be taken
of any [functor](Functors/index.md), not just a variable.

This object requires the `ElemSideQpArg` [functor spatial argument](Functors/index.md) to be
implemented for the [!param](/UserObjects/NearestPointLayeredSideIntegralFunctor/functor) parameter.




## NearestRadiusLayeredAverage

The domain is virtually divided into a number of rings according to the
points provided by users. For each point provided, the radius, or
distance to the origin in the plane perpendicular to the direction provided
is computed. Any point of the domain with a radius closest to that radius
contributes to that ring. It is thus recommended to input points along a straight
 line, with each point being located in the middle of the ring.  And then the
variable average is taken over each individual ring separately with the ability
 to decompose each subdomain in layers along a particular direction. If the
number of layers is larger than one, it is recommended that the interface between
 two layers align with the mesh.






## NodalNormalsCorner


The `NodalNormalsCorner` is added automatically by the [AddNodalNormalsAction.md].
This object is created for the corners specified in the [!param](/NodalNormals/AddNodalNormalsAction/corner_boundary)
parameter of the action.
See the [syntax/NodalNormals/index.md] for more information.

The corner normal is saved in the `nodal_normal_x`, `nodal_normal_y` and `nodal_normal_z` variables.




## NodalNormalsEvaluator


The `NodalNormalsEvaluator` is added automatically by the [AddNodalNormalsAction.md].
This object is created for the boundaries specified in the [!param](/NodalNormals/AddNodalNormalsAction/boundary)
parameter. See the [syntax/NodalNormals/index.md] for more information.

The nodal normal is computed from the `nodal_normal_x`, `nodal_normal_y` and `nodal_normal_z`
variables, then it is used to divide the values for that node by the norm of the normal.

### Example input syntax

In this example, the `NodalNormals` system uses a `NodalNormalsEvaluator`, added behind the
scene by the action, to smooth the distance computation between two disjoint surfaces.





## NodalNormalsPreprocessor


The `NodalNormalsPreprocessor` populates the `nodal_normal_x`, `nodal_normal_y` and `nodal_normal_z`
variables with the local quadrature weight times the gradient of the shape function.
This object is created by the by [AddNodalNormalsAction.md]
for the boundaries specified in the [!param](/NodalNormals/AddNodalNormalsAction/boundary)
parameter. See [syntax/NodalNormals/index.md] for more information.




## NodalPatchRecoveryMaterialProperty

This user object performs the calculations and parallel communication to perform
the Zienkiewicz-Zhu nodal patch recovery for a scalar component of a provided
material property. Supported material property types are listed in
[IndexableProperty](IndexableProperty.md).





## NodalUserObject

The NodalUserObject is a [UserObject](syntax/UserObjects/index.md) that executes on each node in the domain.
When running in parallel, each processor will execute over a subset of the total nodes so parallel aggregation
may be necessary.

### Executing one or more times on a single node

NodalUserObjects may be made [BlockRestrictable](BlockRestrictable.md). When restricted to
two or more blocks, users may set a parameter in the respective input file block to choose whether or not
MOOSE should "visit" (execute on) nodes on shared block boundaries only once or multiple times.
Default: execute multiple times.

## PostprocessorSpatialUserObject

The `PostprocessorSpatialUserObject` stores a postprocessor value inside a user object such that it gains a spatial position and can be used via `spatialValue()` API.
This can be useful in a multi-app setup when we need to transfer postprocessor values from sub apps and have them live at a position where
the sub-app exists.

### Example of a Multi-App Setup







## ProjectedStatefulMaterialNodalPatchRecovery...

This user object performs patch recovery for a material property component. At step zero this object will compute the material QP values by explicitly calling `initStatefulProperties` in order to project the state that will correspond to the *old state* in the first time step.

Variants include:

- `ProjectedStatefulMaterialNodalPatchRecoveryReal`
- `ProjectedStatefulMaterialNodalPatchRecoveryRealVectorValue`
- `ProjectedStatefulMaterialNodalPatchRecoveryRankTwoTensor`
- `ProjectedStatefulMaterialNodalPatchRecoveryRankFourTensor`
- `ADProjectedStatefulMaterialNodalPatchRecoveryReal`
- `ADProjectedStatefulMaterialNodalPatchRecoveryRealVectorValue`
- `ADProjectedStatefulMaterialNodalPatchRecoveryRankTwoTensor`
- `ADProjectedStatefulMaterialNodalPatchRecoveryRankFourTensor`

This object is set up by the [ProjectedStatefulMaterialStorageAction](ProjectedStatefulMaterialStorageAction.md).





## PropertyReadFile


This user object may load data sorted in four different ways. The read modes are toggled using the
[!param](/UserObjects/PropertyReadFile/read_type) parameter.

- In +element+ mode, the file read contains [!param](/UserObjects/PropertyReadFile/nprop) values for each element in the mesh.
- In +grain+/+voronoi+ mode, a Voronoi tessellation with [!param](/UserObjects/PropertyReadFile/nvoronoi) random centers is either created randomly or read from the first three columns of the `CSV` file, depending on the [!param](/UserObjects/PropertyReadFile/use_random_voronoi) parameter. The file read should still contain [!param](/UserObjects/PropertyReadFile/nprop) columns, even though the three first columns may be used for the Voronoi tessellation positions.
- In +block+ mode, the file read contains [!param](/UserObjects/PropertyReadFile/nprop) values for each block in the mesh. [!param](/UserObjects/PropertyReadFile/nblock) is the number of blocks in the mesh.
- In +node+ mode, the file read contains [!param](/UserObjects/PropertyReadFile/nprop) values for each node in the mesh.

For the `element` (`block` and `node` respectively) modes, both the elements
(blocks and nodes respectively) in the mesh and the data in the `CSV` file must be ordered consecutively.
The element (block and node respectively) IDs must be contiguous and usually start from 1.

The [!param](/UserObjects/ElementPropertyReadFile/use_zero_based_block_indexing)
parameter indicates whether the block numbers start with zero (`true`)
or one (`false`).

### Object use

Values can be queried from the object by passing in a property ID and an element
pointer. In +element+ mode a direct lookup from the data table based on
element ID is performed. In +grain+ mode the centroid of the passed in element
is taken and the grain ID is determined as the ID of the Voronoi center closest
to the element centroid.

An example of a MOOSE object using the `PropertyReadFile` is the [PiecewiseConstantFromCSV.md] function.

If specifying multiple files to the [!param](/UserObjects/PropertyReadFile/prop_file_name)
parameter, a new file will be read every time the object is initialized, which happens right before
user objects are executed. The [!param](/UserObjects/PropertyReadFile/execute_on) parameter should be used to control the frequency of these executions. The user object will always read the first file at construction time, and, as an exception, will not read a new file on its first execution.
If all data files have been read, the last file specified is used.

When using multiple files, please note the data from the files is not concatenated. Every time a new file is read, the old data is removed from consideration.

### Example input syntax

In this example input file, the `PropertyReadFile` user object is used to load data from a CSV file
then a [PiecewiseConstantFromCSV.md] function and a [FunctionIC.md] are used to populate a field with this data.
This is done for each [!param](/UserObjects/PropertyReadFile/read_type).

- Data sorted by element



- Data sorted by nearest-neighbor



- Data sorted by block


In this example, the same CSV file as the nearest neighbor case is used. It is however processed and used differently.

- Data sorted by node







## RadialAverage


Given a material property and a radius for averaging, the RadialAverage object
computes the spatial average value of the property over the radius.

### Applications

This can be used for nonlocal damage models in the `SolidMechanics` module
where the damage_index that is used for computing the damage stress is average
over a certain radius $r_0$. This can help alleviate mesh sensitivity in certain
cases. This can be accomplished by running the RadialAverage object on a local
damage material property. Then using the `NonlocalDamage` model in conjunction
with the `ComputeDamageStress` the damage index used for updating the stress is
averaged over a certain radius.

### Design

The RadialAverage user object is derived from `ElementUserObject` and
works in two stages.

1. In the element loop (in the `execute()` method) a list of all quadrature
   points, their locations, indices, and selected material property value is compiled.

2. In the `finalize()` method

    1. the list is communicated in parallel

    2. a KD-tree is filled with all quadrature point entries (utilizing the
        [nanoflann](https://github.com/jlblancoc/nanoflann) library bundled with
        libMesh)

    3. a loop over all QPs is performed and at each QP a (`radius`)
        radius search in the KD-tree is performed

    4. the results from the search are used to spatially averaged


The [!param](/UserObjects/RadialAverage/weights) parameter determines the distance
based weight function to be used in the averaging process. `constant` assigns an equal weight
to all material points, `linear` weights each point by $r_0-r$ (a linear fall-off with distance),
and `cosine` weights each point by $1+\cos (\frac{r}{r_0} \pi)$.

The weights mentioned above currently do not take into account the quadrature point weight.





## ShapeElementUserObject

ShapeElementUserObject is an intermediate base class that should be derived from for any user object
needing to evaluate shape functions (`_phi` or `_grad_phi`).

## SolutionUserObject


### Description

A solution user object reads a variable from a mesh in one simulation to another.  In
order to use a `SolutionUserObject` three additional parameters are required, an
[AuxVariable](/AuxVariables/index.md) , a [Function](/Functions/index.md) and an [AuxKernel](/AuxKernels/index.md).  The `AuxVariable` represents the
variable to be read by the solution user object.  The `SolutionUserObject` is set up to
read the old output file.  A `SolutionFunction` is required to interpolate in time and
space the data from the `SolutionUserObject`.  Finally, the `Function` is required that
will query the function and write the value into the `AuxVariable`.

### Example Input Syntax





## Terminator


The parsed logical expression is specified with the [!param](/UserObjects/Terminator/expression). More information about parsed expressions
may be found on the [function parser documentation](http://warp.povusers.org/FunctionParser/).

The `Terminator` can act in two modes, specified by the [!param](/UserObjects/Terminator/fail_mode) :

- `HARD` stop, the default, will terminate the simulation when the conditions are met

- `SOFT` stop, will stop the ongoing solve and let the solver try again using a smaller time step, for
  transient simulations.


To use the `Terminator` as if it were in a `PASS` mode, where it stops the simulation and accepts the result, use the `HARD` fail_mode with the `INFO` error_level.

The message output by the `Terminator` when the condition for termination is met is specified using the
[!param](/UserObjects/Terminator/error_level) parameter. It may be output as:

- an error, forcing a hard failure

- a warning, to raise attention to an issue or abnormal solve conditions

- an information message, to indicate that while the `Terminator` is acting on the solve, the conditions
  met are expected or normal. This can be used to make the `Terminator` stop the simulation but accept the result.


### Example input syntax

In this example, the `Terminator` is used to fail a time step solve, based on a criterion
`dt > 20`. Once the solve is soft-failed for this time step, the solver tries again by cutting
the time step. This happens to make the `Terminator` parsed criterion pass, so it does not act again
on this time step.


In this example, the `Terminator` is used to stop a simulation and accept the result once the following criterion is met:
`dt > 20`. Stopping simulation is done with the `HARD` failure mode, and the solve is considered as converged because the error level is set to `info`.





## ThreadedGeneralUserObject

ThreadedGeneralUserObjects are "UserObjects" (custom objects or algorithms) that are not associated with any mesh
entity, but where n-thread copies are created for the purpose of running threaded calculations or avoiding
thread-locks for lookup operations.

## UserObject

Base class for all user objects.
See [syntax/UserObjects/index.md] for more information.

## VerifyElementUniqueID


This object is used for debugging mesh issues.

For distributed mesh, this will perform an `MPI_AllGather` operation, sending all ids to all processes, operation which may require a lot of memory on all processes.




## VerifyNodalUniqueID


This object is used for debugging mesh issues.

For distributed mesh, this will perform an `MPI_AllGather` operation, sending all ids to all processes, which may require a lot of memory on all processes.




# utils

## ADReal

`ADReal` is the type underpinning all of MOOSE's automatic differentiation (AD)
capabilities.

[#overview]
[#timings]

### Overview id=overview

`ADReal` is a MOOSE typedef defined from the
[MetaPhysicL](https://github.com/libMesh/MetaPhysicL) template class
`DualNumber`. `DualNumber` takes two template arguments `T` and `D`; `T`
represents the "value" type of the `DualNumber`, e.g. the type of $f(\vec{x})$,
while `D` represents the derivative type of the `DualNumber`, e.g. the type of
$\nabla f = \frac{\partial f}{\partial\vec{x}}$. MetaPhysicL offers several
options for `D` types, including:

1. `NumberArray`
    - C-array as underlying derivative vector storage for data
    - Fast because of static storage
    - Inflexible; no storage of indices so no sparse support. Essentially pick a
      maximum possible storage size and hope for the best. Doesn't work out for
      many 3D problems or problems with a lot of variables
2. `DynamicSparseNumberArray`
    - `std::vector` as underlying storage for derivative data and indices
    - Maximum flexibility
    - Slow because of continual dynamic allocation of memory
3. `SemiDynamicSparseNumberArray`
    - `std::array` as underlying storage for derivative data and indices
    - Fast because of static storage
    - Indices storage allows sparse operations and hence flexibility
    - Avoid looping over the whole size of the std::array by
      maintaining a dynamic size data member

Currently, MOOSE uses `SemiDynamicSparseNumberArray` for derivative storage
because it is much more flexible than `NumberArray` and more performant than
`DynamicSparseNumberArray`.
The underlying derivative storage array size for `SemiDynamicSparseNumberArray`
can be modified by running `configure` with the option
`--with-derivative-size=<n>` where `<n>` is the desired size of the container.
By default, MOOSE is configured `--with-derivative-size=64`.

### AD-Related Timings id=timings

[#stabilized_ins]

#### Stabilized Incompressible Navier Stokes id=stabilized_ins

##### Test specs

- Navier-Stokes test directory input file: `ad_lid_driven_stabilized.i`
- 200x200 mesh
- default backing array size of 50
- Computer specs:
    - MacBook Pro running Mojave 10.14.5
    - 2.4 GHz Intel Core i9
    - 32 GB 2400 MHz DDR4

##### SNESComputeJacobian timing

- MOOSE non-sparse config: 9.61 seconds (MOOSE's old config, no longer available)
- MOOSE sparse config: 9.22 seconds (MOOSE's current config)

## BilinearInterpolation

The BilinearInterpolation utility applies the Least Squares algorithm to a set of points to provide a piecewise reconstruction
of a surface in 2D. A set of points in both x and y must be provided in conjunction with a set of dependent values (z-values)
to construct the surface. This object is normally not used directly. Instead it is used through the [PiecewiseBilinear.md] object.

## Compile-time Derivatives

`CompileTimeDerivatives` (CTD) is a C++ namespace containing classes, functions, and operators to implement mathematical expressions with the ability to perform symbolic automatic differentiation at compile time. It is a replacement for the runtime automatic differentiation in [`ExpressionBuilder`](/ExpressionBuilder.md optional=true) which uses a convoluted process to arrive at compiled mathematical expressions and their derivatives.

### Uses

The intended uses for the CTD framework are the implementation of empirical or analytical models with closed form expressions that compute quantities of which derivatives are required. Examples are

1. Thermodynamic free energies, the derivatives of which are chemical potentials, which are required to solve the phase field equations.
2. A thermal conductivity as a function of temperature, where the derivative w.r.t. temperature is required in the heat transfer equations.

CTD is not meant to replace runtime AD using dual numbers (which computes derivatives w.r.t. degrees of freedom). Any application that requires the construction of symbolic derivatives of equations w.r.t. known coupled variables, can be simplified with CTD.

### Examples

Constructing an expression and taking its derivative.

Create a _tag_ that will identify the variable

```C++
  enum
  {
    dX
  };
```

Connect a C++ variable and a _tag_ to obtain a compile time derivative reference object that will evaluate as the C++ variable value:

```C++
  Real x;
  const auto X = makeRef<dX>(x);
```

Build an expression for `x^2+100`:

```C++
  const auto result = X * X + 100.0;
```

Evaluate the expression for x=5:

```
  x = 5;
  Moose::out << result() << '\n'; // 125.0
```

And evaluate the derivative w.r.t. `x` at x=5:

```
  Moose::out << result.D<dX>()() << '\n'; // 10.0
```

Note that there is no runtime cost to calling `.D<dX>()`. The derivatives are taken at compile time.

The unit tests contain more examples on how to use the system.


## FillBetweenPointVectorsTools Namespace

`FillBetweenPointVectorsTools` contains tools that can be used to generate a triangular element transition layer mesh to connect two given curves (i.e., vectors of points) in the XY plane. It was originally developed for `PeripheralModifyGenerator` of the `Reactor` module. As these tools may also be useful for other applications, they are made available in this namespace. In this document, the algorithm of the tools are described.

### Fundamentals

This tool set was designed to create a mesh for a transition layer. A transition layer accommodates the shape and node placement of two pre-existing boundaries and fills the gap between them with elements. The most important input data needed to generate a transition layer is the node positions of the two boundaries. The generated mesh conforms to these two boundaries and connects the end nodes of each boundary using a straight line, as indicated in [Figure 1](#transition).

      style=display: block;margin-left:auto;margin-right:auto;width:50%;
      id=transition
      caption=A schematic drawing showing the fundamental functionality of the `FillBetweenPointVectorsTools`

### Single-Layer Transition Layer Meshing

The most straightforward solution is to create a single layer of triangular elements as the transition layer. A triangular element is created by selecting three vertices from the two sets of boundary nodes. One node is selected from one of the two pre-existing boundaries and two nodes are selected from the other boundary. The selection of the nodes should minimize the length of sides connecting the two boundaries. This algorithm is illustrated in [Figure 2](#single_layer).

      style=display: block;margin-left:auto;margin-right:auto;width:50%;
      id=single_layer
      caption=A schematic drawing showing the principle of single-layer transition layer meshing algorithm.

Starting from the first nodes of the two given boundaries, the first side is trivially created by connecting the first nodes of the two boundaries. Then, the two possible options of the next side of the triangle are examined, and the shorter length segment between the two boundaries is selected. This kind of selection is repeated until reaching the other side of the two boundaries.

### Multi-Layer Transition Layer Meshing

In many cases, more than one layer of triangular elements is desired to improve mesh quality. The generation of a transition layer containing multiple sublayers can be done by repeating the single-layer transition layer meshing steps once the nodes of the intermediate sublayers are generated. Thus, the key procedure here is to create those intermediate nodes based on the two given vectors of nodes on the input boundaries. Here, the algorithm to generate the nodes for each sublayer is described from the simplest case to the most generalized scenario.

#### Surrogate Node Interpolation Algorithm

Surrogate node interpolation algorithm is the most fundamental method used in this tool set for intermediate node generation. For simplicity, assume a case where all the nodes on each boundary are uniformly distributed. (Namely, the distance between neighboring nodes within a boundary is equal.) Assume that the two boundaries have $M$ nodes (Side 1) and $N$ nodes (Side 2), respectively, and that there are $K$ sublayers of elements in between. From Side 1 to Side 2, using arithmetic progression, the $k$th layer of intermediate nodes have $S=\lceil M+k(N-M)/K \rfloor$ nodes. To get the positions of these nodes, surrogate nodes are first calculated on the two input boundaries using interpolation leveraging MOOSE's [`LinearInterpolation`](framework/src/utils/LinearInterpolation.C) utility.

         start= LinearInterpolationTempl(const std::vector<Real> & X,
         end= LinearInterpolationTempl() : _x(std::vector<Real>()), _y(std::vector<Real>()), _extrap(false) {}

Here, take Side 1 as an example. As mentioned above, Side 1 has $M$ nodes, the coordinates of which are $(x_0,y_0,z_0)$, $(x_1,y_1,z_1)$, ..., $(x_{M-1},y_{M-1},z_{M-1})$. To get interpolated coordinates of the nodes on Side 1, the coordinate parameters $\{x_i\}$ and $\{y_i\}$ will be the dependent variables of interpolation (i.e., $Y$ in the [`LinearInterpolation`](framework/src/utils/LinearInterpolation.C) of MOOSE), while the $X$ was set as {$0$, $1/(M-1)$, $2/(M-1)$,...,$(M-2)/(M-1)$, $1$} (equal intervals). Note that $\{z_i\}$ does not need interpolation as we are working in the XY plane. For an intermediate layer with $S$, $S$ surrogate nodes are created on Side 1 using the aforementioned interpolation data and the following $X$ values {$0$, $1/(S-1)$, $2/(S-1)$,...,$(S-2)/(S-1)$, $1$}. Meanwhile, another $S$ surrogate nodes are created on Side 2 using a similar approach. Finally, the positions of the $S$ intermediate nodes can be calculated by further interpolating the surrogate nodes created on the two boundaries. In [Figure 3](#multi_layer_uniform), an example of applying surrogate node interpolation algorithm to a boundary with 9 uniformly distributed nodes and a boundary with 4 uniformly distributed nodes to generate an intermediate node layer with six nodes is illustrated.

      style=display: block;margin-left:auto;margin-right:auto;width:50%;
      id=multi_layer_uniform
      caption=A schematic drawing showing an example of surrogate node interpolation algorithm. Blue and green nodes belong to the original boundaries; yellow nodes are surrogate nodes generated by linear interpolation on the two original boundaries; and orange nodes are the produced intermediate layer nodes calculated by interpolating the surrogate nodes on the two boundaries.

#### Weighted Surrogate Nodes

A more general scenario is that the nodes on the two original boundaries are not uniformly distributed. In that case, weights need to be used during the linear interpolation for surrogate node generation. Again, given a boundary (Side 1) with $M$ nodes, {$^1p_0$, $^1p_1$,...,$^1p_{M-2}$, $^1p_{M-1}$}, the distance between the neighboring nodes are {$^1l_1$, $^1l_2$,...,$^1l_{M-2}$,$^1l_{M-1}$}. The total length of Side 1 is $L=\Sigma_{i=1}^{M-1}{l_i}$. This boundary can be mapped to a boundary with uniformly distributed nodes. For the new boundary, each segment has a weight $^1w_i=(M-1)l_i/L$. Surrogated nodes can then be generated on the new boundary using the same approach as mentioned in the previous subsection. After that, using the weights calculated before, the surrogate nodes are derived to weighted surrogate nodes. After repeating these steps on Side 2, the intermediate nodes can be generated. These procedures are visualized in [Figure 4](#weighted_surrogate).

      style=display: block;margin-left:auto;margin-right:auto;width:80%;
      id=weighted_surrogate
      caption=A schematic drawing showing an example of weighted surrogate node interpolation algorithm used for intermediate nodes generation when non-uniform distributed nodes are involved on the two original boundaries.

#### Quadrilateral Element Transition Layer in a Special Case

`FillBetweenPointVectorsTools` is generally designed for meshing with triangular elements because of their flexibility in accommodating complex node distribution. However, if Side 1 and Side 2 boundaries have the same number of nodes, then the transition layer can be meshed using quadrilateral elements straightforwardly. `FillBetweenPointVectorsTools` is equipped with this special quadrilateral meshing capability.

### Applications

In `FillBetweenPointVectorsTools`, the transition layer generation functionality is provided as a method shown as follows:

         start= void fillBetweenPointVectorsGenerator(ReplicatedMesh & mesh,
         end= /**

Here, `mesh` is a reference `ReplicatedMesh` to contain the generated transition layer mesh; `boundary_points_vec_1` and `boundary_points_vec_2` are vectors of nodes for Side 1 and Side 2 boundaries; `num_layers` is the number of element sublayers; `transition_layer_id` is the subdomain ID of the generated transition layer elements; `input_boundary_1_id` and `input_boundary_2_id` are the IDs of the boundaries of the generated transition layer mesh corresponding to the input Sides 1 and 2, respectively; `begin_side_boundary_id` and `end_side_boundary_id` are the IDs of the other two boundaries of the generated transition layer mesh that connect the starting and ending points of the two input Sides; and `type` and `name` are the class type and object name of the mesh generator calling this method for error message generation purpose. If `boundary_points_vec_1` and `boundary_points_vec_2` have the same size, `quad_elem` can be set as `true` so that quadrilateral elements instead of triangular elements are used to construct the transition layer mesh. In addition, `bias_parameter` can be used to control the meshing biasing of the element sublayers. By default, a non-biased sublayer meshing (i.e., equally spaced) is selected by setting `bias_parameter` as 1.0. Any positive `bias_parameter` is used as the manually set biasing factor, while a zero or negative `bias_parameter` activates automatic biasing, where the local node density values on the two input boundaries are used to determine the local biasing factor. If automatic biasing is selected, `sigma` is used as the Gaussian parameter to perform Gaussian blurring to smoothen the local node density to enhance robustness of the algorithm.

      style=display: block;margin-left:auto;margin-right:auto;width:80%;
      id=examples
      caption=Some representative meshes generated by `FillBetweenPointVectorsTools`: (left) a transition layer mesh defined by two oppositely oriented arcs; (middle) a transition layer mesh defined by one arc and a complex curve; (right) a half-circle mesh.

One application of this tool is to generate a mesh with two curves and two straight lines as its external boundaries. As shown in [Figure 5](#examples), a series of simple and complex shapes can be meshed. Users can leverage [`FillBetweenPointVectorsGenerator`](/FillBetweenPointVectorsGenerator.md) and [`FillBetweenSidesetsGenerator`](/FillBetweenSidesetsGenerator.md) as testing tools.

## IndexableProperty

The `IndexableProperty` is a helper (proxy) object to obtain a scalar component
from a material property. Use it in objects that process a scalar quantity
instead of a `Real` material property to allow the user to supply any material
property of a type from the list below along with a component index parameter to
select a scalar component from the property value.

| Material property type | `component` parameter example |
| - | - |
| `Real` | _none_ |
| `RealVectorValue` | `component = 1` |
| `std::vector<Real>` | `component = 7` |
| `RankTwoTensor` | `component = "0 2"` |
| `RankThreeTensor` | `component = "1 2 0"` |
| `RankFourTensor` | `component = "1 0 1 2"` |

To use this utility class declare a member in your class header

```c++
const IndexableProperty<Parent, is_ad> _prop;
```

where `Parent` is the current class' parent class. `IndexableProperty` provides
a  helper method to add the default parameters for coupling a material property
(`property`) and its component index (`component`). Use it as follows

```c++
InputParameters params = IndexableProperty<Parent, is_ad>::validParams();
```

This also adds the `Parent` class parameters to `params`. You may also choose to
add your own parameters of type `MaterialPropertyName` and `std::vector<unsigned int>`
with custom names and documentation strings.

```c++
params.addRequiredParam<MaterialPropertyName>("first_property",
                                              "The name of the first material property");
params.addRequiredParam<MaterialPropertyName>("second_property",
                                              "The name of the second material property");
params.addParam<std::vector<unsigned int>>(
    "first_component", "Index of the component of the first property");
params.addParam<std::vector<unsigned int>>(
    "second_component", "Index of the component of the second property");
```

To initialize the `IndexableProperty` object put

```c++
  _prop(this)
```

in your objects initializer list. If you chose custom names for the property
name and component parameters, pass them in as the second and third arguments,
like so

```
  _first_prop(this, "first_property", "first_component")
  _second_prop(this, "second_property", "second_component")
```

An `IndexableProperty` object can be implicitly cast to `bool` to check if _any_
of the supported indexable properties was found.

```
if (!_prop)
  paramError("property", "No suitable material property was found");
```

## InputParameters

To simplify and unify the creation of all simulation objects in MOOSE, all input parameters must be declared and populated through
a single "InputParameters" object. This ensures that every constructor in MOOSE is uniform and ensures that every object
can be created through MOOSE's Factory pattern. The InputParameters object is a collection of parameters, each one with
separate attributes that can be used to finely control the behavior of the underlying object. For example, parameters can be
marked as required or optional, be provided with a default or not, and be used to enhance GUI interfaces that may be used to
programmatically generate input files for MOOSE.

The complete list of attributes for each input parameter:


### Applying or Transferring Common Parameters

When building a custom Action, it is often useful to read in several parameters that will be used to directly set
parameters on objects being built by the custom Action. The `InputParameters` object contains a few useful methods for
applying or transferring common parameters to avoid several manual lines for setting these parameters. See the utility methods
and corresponding documentation here:


### Range Checked Parameters

The InputParameters object supports parsed expressions for various bounds checking of the user input so that
custom logic does not need to be implemented in every end-user object. The range checking expression is always
the second to last parameter right before the doc string.


### Deprecating coupled variables

The `InputParameters` class provides a convenient method for deprecating coupled
variable names called `addDeprecatedCoupledVar`. The method takes three
arguments. The first corresponds to the deprecated name; the second argument is
the new, blessed name that users should use. This name should have a
corresponding `params.addCoupledVar('blessed_name', 'blessed_name_doc_string')`
in the relevant `Class::validParams()` block. The final optional argument is the
date that the deprecated variable name will be removed.

## InterfaceValueTools

### Description

Basic utility file to compute a single quantity given values on both side of an interface. The value to compute is selected via the input parameter
interface_value_type. This function is not registered and as such should only be used for simplifying the development of other objects.
An example of an object using this utility is  [InterfaceAverageVariableValuePostprocessor](/InterfaceAverageVariableValuePostprocessor.md).

Available outputs are:
* average: (value_m-value_s)/2
* jump_primary_minus_secondary: value_m-value_s
* jump_secondary_minus_primary: value_s-value_m
* jump_abs: abs(value_m-value_s)
* primary: value_m
* secondary: value_s

where value_m is the value on the primary side of the interface (e.g. where the boundary is defined) and value_s is the value on the secondary side of the interface.

## JvarMapInterface

The `JvarMapKernelInterface` and `JvarMapIntegratedBCInterface` interface
classes (veneers), for Kernels and integrated boundary conditions respectively,
provide a mapping from the value of the `jvar` parameter passed into
`computeQpOffDiagJacobian` method to

- an index into the `_coupled_moose_vars` vector
- a `coupledValue(var_name, i)` index `i` for a given `var_name` using the `getParameterJvarMap` method

This class is useful in conjunction with
[`DerivativeMaterialInterface`](DerivativeMaterialInterface.md), where vectors
of material property derivatives with respect to coupled variables are pulled in.

### Mapping `jvar` to a `_coupled_moose_vars` index

In case an index into the vector of *all* coupled variables for the current object
(`_coupled_moose_vars` vector) is requested

```c++
  unsigned int cvar = mapJvarToCvar(jvar);
```

should be used. When called from `computeQpOffDiagJacobian` with the method's
`jvar` parameter passed in, `mapJvarToCvar` is guaranteed to return a valid index
into `_coupled_moose_vars`. The off diagonal Jacobian method is only called for
variable numbers that are found in the `_coupled_moose_vars` vector, and those
are mapped in the global jvar map which the `JvarMapInterface` classes construct
automatically.

### Mapping `jvar` to a `coupledValue(parameter_name, index)` index

In case an index is requested that can be passed into `coupledValue` for a given
input parameter name (vector variable coupling), a parameter specific map has to
be obtained. This map can be build and fetched (by reference) in the initializer
list of the class constructor using

```c++
  _myvar_map(getParameterJvarMap("myvar"))
```

where the class should have a member

```c++
  const JvarMap & _myvar_map;
```

and an input parameter

```c++
  params.addCoupledValue("myvar", "Vector of coupled variables");
```


The index into a specific coupled variable vector for a given `jvar` can then be
obtained using

```c++
  int pvar = mapJvarToCvar(jvar, _myvar_map);
  if (pvar >= 0)
  {
    // jvar points to an entry in the myvar vector
  }
```

A negative return value indicates that the `jvar` value does not point to a
variable in the couple variable vector corresponding to the mapped parameter.

## KDTree

The [KDTree](https://en.wikipedia.org/wiki/K-d_tree) is a binary tree in which every node is a k-dimensional spatial point. Every non-leaf node implicitly generates a splitting hyperplane that partitions the space into two parts. The left points to the partitioning hyperplane are represented as the left subtree, and similarly, the right points are allocated in the right subtree. The partitioning hyperplane if often 
chosen to be perpendicular to a dimension's axis.

This class implements KDTree by leveraging [nanoflann](https://github.com/jlblancoc/nanoflann). The primary usage is to do the nearest neighbor search. The nearest neighbor search (NN) algorithm aims to find the points in the tree that are nearest to a given input point. This search can be done efficiently by using the tree properties to eliminate large portions of the search space in O(log N) time quickly. More details can be found [here](https://en.wikipedia.org/wiki/K-d_tree).

## MathUtils Namespace

MOOSE includes a number of C++ utility classes and functions that may be useful for developing
applications with mathematical expressions.

### Polynomial evaluations

`MathUtils::poly` evaluates a polynomial for any integer order $n>0$ using the Horner's method of evaluation,
\begin{equation}
  p(x) = c_0 + c_1 x + c_2 x^2 + ... + a_n x^n
\end{equation}
\begin{equation}
  p(x) = c_0 + x * (a_1 + x(a_2 + ... + x (a_{n-1} + x a_n)))
\end{equation}

### Clamp

`MathUtils::clamp` returns a clamped value $y$ between an upper and lower bound, $L_{lower}$ and $L_{higher}$ respectively,
\begin{equation}
  y =
  \begin{cases}
    L_{lower}  & x < L_{lower}  \\
    L_{higher} & x > L_{higher} \\
    x & \text{Otherwise}
  \end{cases}
\end{equation}

### SmootherStep

`MathUtils::smootherStep` returns a smoothed step transition between a starting and ending bounds, $B_{lower}$ and $B_{higher}$ respectively, for a given value $u$,
\begin{equation}
  x = \frac{u - B_{lower}}{B_{higher} - B_{lower}}
\end{equation}
\begin{equation}
  y =
  \begin{cases}
    0 & u <= B_{lower}  \\
    1 & u >= B_{higher} \\
    6x^5 - 15 x^4 + 10x^3 & \text{Otherwise}
  \end{cases}
\end{equation}
This method ensures a smooth transition from 0 to 1 between the two bounds, while also ensuring the first and second derivatives are zero at the two bounds.
Use of this method is especially useful when transitioning between two non-smooth regimes.
The derivative with respect to the passed value $u$ is returned using the optional derivative bool. Note that if $u = B_{lower} = B_{higher}$, then zero will be returned.

## MooseTypes

The `MooseTypes` header contains several names central to automatic
differentiation in MOOSE. It defines the following macros:

- `ADReal`
- `ADRealVectorValue`
- `ADPoint`
- `ADRealTensorValue`
- `ADRankTwoTensor`
- `ADRankFourTensor`

which resolve to either `Real` or [`ADReal`](/ADReal.md) based objects
depending on whether `compute_stage` is equivalent to `RESIDUAL` or
`JACOBIAN`. `compute_stage` is a template argument to AD consuming and producing
objects like `ADKernel` and `ADMaterial` respectively.

## MooseUtils Namespace

MOOSE includes a number of C++ utility classes and functions that may be useful for developing
applications. These utilities are within the MooseUtils C++ namespace. The following summarized
some of the available items.


### DelimitedFileReader id=delimitedfilereader

It is often necessary to read data from files during a simulation and often this data is in
a delimited format such as [CSV](https://en.wikipedia.org/wiki/Comma-separated_values). The
DelimitedFileReader is designed for reading this data into application objects.

The DelimitedFileReader can read data organized into columns or rows. It assumes that all data,
outside of the header, is numeric and can be converted to a C++ double. Additionally, it is also
assumed that the first row or column defines the number of columns for the entire file, if the
number of columns differs from the first row an error will be produced.

Within MOOSE this utility is utilized by the [CSVReaderVectorPostprocessor](/CSVReaderVectorPostprocessor.md), which is part of
the [VectorPostprocessors] system. This object will be used to explain the use of the utility.

Using the DelimitedFileReader is very simple and requires three steps. First, include the
utility header file with `#include "DelimitedFileReader.h"`. Then the object
is instantiated and read method is called, as shown in the unit test snippet below.

         start=reader("data/csv/example.csv")
         end=getData strip-leading-whitespace=True

This class is required to include the filename upon construction. Optionally, a second argument
providing a pointer to a [libMesh] Communicator object may be provided. This argument should be
used when the reader is used within a MooseObject. For example, as shown in [csv_reader_ctor],
the `CSVReaderVectorPostprocessor` object passes a Communicator object to the reader. If not provided the reader will
read the data on all processors. If provided it will only read on single processor and broadcast
the data to the others.

It is also possible to configure how file is formatted via the various set methods, as listed below.
The set methods must be called prior to the read method.

- +setIgnoreEmptyLines+<br>
  By default this all empty lines are ignored, when set to `false` the presence of an empty line will
  cause an error.

- +setFormat+<br>
  The reader is capable of reading data organized into columns or rows, this method allows for the
  format to be changed.

- +setDelimiter+<br>
  By default the reader will attempt to infer the delimiter from the file; however, the detection is
  fairly rudimentary. It inspects the file for a comma, if a comma exists then a comma is the
  delimiter. If it does not exist then space is the delimiter. The setDelimiter method can be used to
  explicitly set string to use for a delimiter.

- +setHeader+<br>
  By default the reader will attempt to detect the presence of header strings for both the row and
  column data formats. The setHeader method can be used to explicitly control whether header data
  exists. If headers exist the each data row or column will be labeled using the header and it will be
  accessible via the getData method by name. If no headers exist the header names are generated as
  "column_0", "column_1", etc. or "row_0", "row_1", etc. depending on the format settings.

- +setComment+<br>
  The string provided to this method marks content that will be ignored. Any line beginning with the
  character(s) will be ignored and all characters on a line that follow the character(s) will also
  be ignored.

           start=CSVReaderVectorPostprocessor::
           end=&_communicator
           include-end=True id=csv_reader_ctor
           caption=Construction of DelimitedFileReader object within a MooseObject initialization list.

After the data is read using the "read" method, there are two methods used for accessing the data:

- `getNames`: This method returns a vector of the column names as read from the header or
  generated based on the number of columns when a header-less file is being examined.
- `getData`: There are three overloaded versions of this method. One returns a reference to the
- entire data set as a vector of vectors. The others access a single vector by name or index.



### Tensor Operators

#### RankTwoTensor Operators

The following operators are available for RankTwoTensor, with the values in parentheses indicating
what the type of the other object to be subject to the operation.

```text
=
+= (RankTwoTensor)
-= (RankTwoTensor)
*= (Real, RankTwoTensor)
/= (Real)
+ (RankTwoTensor)
- (RankTwoTensor)
* (Real, RankTwoTensor, TypeTensor<Real>)
/ (Real)
```

In addition, many methods are available for additional matrix operations:

- `zero()`
- `print()`
- `transpose()`
- `L2norm()`
- `row(int)` returns a TypeVector<Real>
- `rotate(RealTensorValue)`
- `rotate(RankTwoTensor)`
- `rotateXyPlane(Real)`
- `doubleContraction()`
- `deviatoric()` traceless part
- `trace()`
- `dtrace()` derivatives of `trace()` wrt tensor entries
- `secondInvariant()` second invariant of the symmetric part of `deviatoric()`
- `dsecondInvariant()`  derivatives of `secondInvariant()` wrt tensor entries
- `d2secondInvariant()`  second derivatives of `secondInvariant()` wrt tensor entries
- `thirdInvariant()` third invariant of the symmetric part of deviatoric, i.e. `((deviatoric() + deviatoric().transpose())/2).det()`
- `dthirdInvariant()`  derivatives of `thirdInvariant()` wrt tensor entries
- `d2thirdInvariant()`  second derivatives of `thirdInvariant()` wrt tensor entries
- `sin3Lode()`  sine of three times the Lode angle
- `dsin3Lode()`  derivatives of `sin3Lode()` wrt tensor entries
- `d2sin3Lode()`  second derivatives of `sin3Lode()` wrt tensor entries
- `det()` determinant
- `ddet()` derivatives of `det()` wrt tensor entries
- `inverse()`
- `symmetricEigenvalues()`  eigenvalues of symmetric part of tensor
- `dsymmetricEigenvalues()`  derivatives of symmetricEigenvalues wrt the tensor entries
- `d2symmetricEigenvalues()` second derivatives of symmetricEigenvalues wrt the tensor entries

These methods are thoroughly tested using CPPUNIT.

#### RankThreeTensor Operators

The following operators are available for RankThreeTensor, with the values in parentheses indicating
what the type of the other object to be subject to the operation.

```text
=
+= (RankThreeTensor)
-= (RankThreeTensor)
*= (Real)
/= (Real)
+ (RankThreeTensor)
- (RankThreeTensor)
* (RankThreeTensor, RankTwoTensor, Real)
/ (Real)
```

In addition, many methods are available for additional matrix operations:

- `zero()`
- `print()`
- `L2norm()`
- `rotate(Real)`
- `rotate(RealTensorValue)`
- `rotate(RankTwoTensor)`
- fillFromInputVector(TypeVector<Real>)
- `fillFromPlaneNormal(TypeVector<Real>)`
- `mixedProjectRankFour(RankTwoTensor)` creates a Rank-4 tensor from the contraction $D_{ijkl} = T_{mij}b_{mn}T_{nkl}$
- `doubleContraction(RankTwoTensor)` creates a vector from the contraction $v_i = T_{ijk}b_{jk}$

#### RankFourTensor Operators

The following operators are available for RankFourTensor, with the values in parentheses indicating
what the type of the other object to be subject to the operation.

```text
=
+= (RankFourTensor)
-= (RankFourTensor)
*= (Real)
/= (Real)
+ (RankFourTensor)
- (RankFourTensor)
* (RankFourTensor, RankTwoTensor, RealTensorValue, Real)
/ (Real)
```

In addition, many methods are available for additional matrix operations:

- `zero()`
- `print()`
- `L2norm()`
- `invSymm()` returns A$_{ijkl}$ from the input C$_{ijkl}$ such that $C_{ijkl} \cdot A_{ijkl} = 0.5 \left( \delta_{im} \delta_{jn} + \delta_{in} \delta_{jm} \right)$
- `rotate(RealTensorValue)`
- `rotate(RankTwoTensor)`
- `transposeMajor()` witch first pair and second pair of indices
- `surfaceFillFromInputVector(TypeVector<Real>)` Fills tensor entries by ignoring the last dimension
- `fillFromInputVector(TypeVector<Real>, FillMethod)` used to build elasticity tensors
- `fillGeneralIsotropic(TypeVector<Real>)`
- `fillAntisymmetricIsotropic(Real)`
- `fillSymmetricIsotropic(Real, Real)`
- `fillSymmetricIsotropicEandNu(Real, Real)`
- `innerProductTranspose`
- `sum3x3()` calculates the sum of C$_{iijj}$ over $i$ and $j$
- `sum1x3()` calculates the vector from summing over $j$ in C$_{iijj}$
- `isSymmetric()`
- `isIsotropic()`

## NestedSolve

### Overview

The `NestedSolve` utility class implements a nonlinear solve for NxN systems.
It can be used in Kernels, Materials, and UserObjects to compute quantities
given by the solution of a nonlinear equation system rather than a closed form
expression.

Such a nonlinear equation system is defined by a residual function and a
Jacobian function. These functions are provided as C++11 lambda expression. A
lambda expression can access all local and member variables from the enclosing
scope. In this application that mainly refers to coupled variable values and
material properties available in the class the NestedSolve is utilized.

#### Basic API

`NestedSolve` is a C++ class object needs to be instantiated (constructed) to
set up a solver environment. This solver environment can be a local or member
variable of the object it is used within.

The purpose of the solve environment is to store *solver options*, such as
tolerances, and *solver state*, such as convergence reason or failure state of
the previous solve. A solve environment can be reused for multiple solves.

The main API of `NestedSolve` is the `nonlinear` member function, which exists in two flavors:

1. `NestedSolve::nonlinear(T & guess, L compute)`, which takes a writable reference to a variable if type `T` that contains an initial guess for the solution going into the function, and the solution once the call completes. `compute` is a lambda expression that takes references to the current solution value, the residual, and the Jacobian, and needs to update the latter two.
2. `NestedSolve::nonlinear(T & guess, LR computeResidual, LJ computeJacobian)` behaves largely similar to the first overload, but it takes two separate lambdas for computing the residual and the Jacobian independently. This enables the efficient use of line search and trust region algorithms internally.

#### Supported data types

The recommended data types for the solution/residual (`T`) and Jacobian are Eigen's
dynamic size Matrix objects. the `NestedSolve::Value<>` and
`NestedSolve::Jacobian<>` typedefs are available as shortcuts for those types.

Specializations and overloads exist for the `nonlinear` solve API to deal with
the special cases of 1x1 systems (with the solution,residual, and Jacobians
being `Real` scalars), and for 3x3 systems (with the solution and residual being
`RealVectorValues` and Jacobians being `RankTwoTensor` values). The correct
overload is picked based on the type `T` of the initial `guess` parameter.

#### Checking convergence state

The state of a solve can be checked using the `getSolve()` method. This returns
an enumeration describing how the solve converged or if it did not converge. The
enumeration can take the following values:

- `NestedSolve::State::NONE`: No solve has begun. This is the initial value.
- `NestedSolve::State::CONVERGED_ABS`: The solve converged due to meeting an absolute tolerance.
- `NestedSolve::State::CONVERGED_REL`: The solve converged due to meeting a relative tolerance.
- `NestedSolve::State::EXACT_GUESS`: The solve converged due to the initial guess giving a
  zero residual.
- `NestedSolve::State::NOT_CONVERGED`: The solve did not converge.

Note that in the case that both the absolute and relative tolerances being met
simultaneously, the value `NestedSolve::State::CONVERGED_REL` will be returned.

### Example

#### Basic usage

We first construct a `NestedSolve` object. This object can be reused for
multiple solves, and could be a member of the class you are using it in.

```
NestedSolve solver;
```

Next we set the solution (vector) type. `NestedSolve::Value<>` is a dynamically
sized vector class from the Eigen library. Eigen uses the `<<` operator to
initialize such a vector (two components in this case).

```
NestedSolve::Value<> solution(2);
solution << 1.98, 1.02;
```

Next we set a custom relative tolerance. The default value here is 1e-8.

```
solver.setRelativeTolerance(1e-10);
```

Next we define the residual and Jacobian functions. Here we use a single lambda
with three arguments:

1. The first argument is the current guess for the solution and is the _input_ to the functions, it is a vector of length N (or a scalar).
2. Argument two is a writable reference to the residual vector (of the same size as the current guess), the value of which is to be calculated by the lambda.
3. This is followed by the Jacobian matrix of the system, the derivative of the residual vector with respect to the guess/solution.

```
auto compute = [&](const NestedSolve::Value<> & guess,
                   NestedSolve::Value<> & residual,
                   NestedSolve::Jacobian<> & jacobian) {
  residual(0) = guess(0) + guess(0) * guess(1) - 4;
  residual(1) = guess(0) + guess(1) - 3;

  jacobian(0, 0) = 1 + guess(1);
  jacobian(0, 1) = guess(0);
  jacobian(1, 0) = 1;
  jacobian(1, 1) = 1;
};
```

Note that `jacobian(i,j)` is the derivative of `residual(i)` with respect to `guess(j)`.

Lastly we pass the initial guess along with the residual/Jacobian `compute`
lambda to the `NestedSolve::nonlinear` method.

```
solver.nonlinear(solution, compute);
```

`solution` will now be updated from the initial guess to the actual solution of
the system.

Then to check that the solve was successful, one can do the following:

```
if (solver.getState() == NestedSolve::State::NOT_CONVERGED)
{
  // Take some action for the case of no convergence.
}
```

#### Powell's Dogleg method solver

While the previous example used a single lambda to compute residual and Jacobian
at the same time, we can instead change the code to have separate lambdas to
allow independent calculation of residual and Jacobian. This facilitates the use
of solver methods that evaluate the residual more frequently than the Jacobian,
such as line search and trust region strategies.

```
auto computeResidual = [&](const NestedSolve::Value<> & guess,
                           NestedSolve::Value<> & residual) {
  residual(0) = guess(0) + guess(0) * guess(1) - 4;
  residual(1) = guess(0) + guess(1) - 3;
};

auto computeJacobian = [&](const NestedSolve::Value<> & guess,
                           NestedSolve::Jacobian<> & jacobian) {
  jacobian(0, 0) = 1 + guess(1);
  jacobian(0, 1) = guess(0);
  jacobian(1, 0) = 1;
  jacobian(1, 1) = 1;
};
```

We then use the three argument version of the `nonlinear` method

```
solver.nonlinear(solution, computeResidual, computeJacobian);
```

## PerfGraph

### Overview

Note: this is API/developer documentation intended for those developing code using MOOSE.  For end-user focused documentation see [/PerfGraphOutput.md].

The `PerfGraph` object holds timing data for MOOSE.  The idea behind the design is to create a nested set of timing data that faithfully represents the call structure in MOOSE.

The performance graph is part of an ecosystem of objects:

- `PerfGraph`: Holds the full graph and the routines for printing it out
- `PerfNode`: Makes up each node in the graph and holds timing information for each section of code
- `PerfGuard`: Scope guard used to active and deactivate timers
- `PerfGraphInterface`: An interface class for gaining access to the `PerfGraph` for adding timers and pulling timing data
- [/PerfGraphOutput.md]: Responsible for printing out the graph
- [/PerfGraphData.md]: `Postprocessor` for outputting time from the graph
- [/PerfGraphLivePrint.md]: Object responsible for printing performance information during the run

The `PerfGraph` works by utilizing the `TIME_SECTION` macro to specify that the current scope should be timed (see below for more information).  The timed sections are placed in an execution tree and the current "stack" of sections is kept up to date.  When timing starts, a snapshot of both the memory and current time are taken then these are compared when the current scope ends in order to tally time for that section of code.  The `PerfGraphLivePrint` object is watching the stream of what is executing and possibly printing out what is happening if it takes too long (or uses too much memory).  At the end of the run the `PerfGraphOutput` object is responsible for dumping out the relevant information.

`PerfGraph` based timing should NOT be used inside tight compute loops or anything called inside a tight compute loop (i.e. don't use it in `computeQpResidual()`).  It takes about 1e-6 seconds for the timing itself to happen.  That's in the 1 MHz range... meaning that your calculation can't run any faster than that wherever this timer is!  As a general rule... that means that you should have >1000 operations going on inside a timed section.

### Inheriting From `PerfGraphInterface`

To use for timing, make sure that your system inherits from `PerfGraphInterface`.  There are a couple of different constructors for `PerfGraphInterface`:

The first one allows you to pass in a `MooseObject*` and *infer* a "prefix" based on the `type()` of the object (the name of the object).  The "prefix" is prepended to the name of the timed sections to give uniform naming from each object


The second one allows you to pass in a `MooseObject*` and explicitly set a `prefix`:


The final one is for when your object is NOT a `MooseObject` inherited object.  You explicitly pass in the `PerfLog &` (usually by retrieving it from the `MooseApp`) and explicitly set a `prefix`.


### Logging Levels

The `PerfGraph` relies on logging "levels" to determine how verbose the output should be.  When timing a section, be sure to set the level appropriately so that users are not inundated with too much noise.  The levels are:

- 0: Just the "root" - the whole application time
- 1: Minimal set of the most important routines (residual/jacobian computation, etc.)
- 2: Important initialization routines (setting up the mesh, initializing the systems, etc.)
- 3: More detailed information from levels `1` and `2`
- 4: This is where the Actions will start to print
- 5: Fairly unimportant, or less used routines
- 6: Routines that rarely take up much time

### Performance Data Types

The data provided in regards to a section or a node in the `PerfGraph` is as follows:

- `SELF`: The time taken (not including children) in seconds
- `CHILDREN`: The time taken by children in seconds
- `TOTAL` The total (self plus children) time taken in seconds
- `SELF_AVG`: The average time taken (not including children) in seconds over all calls
- `CHILDREN_AVG`: The average time taken by children in seconds over all calls
- `TOTAL_AVG`: The total time taken (self plus children) in seconds over all calls
- `SELF_PERCENT`: The percentage of time taken (not including children) relative to the total application time
- `CHILDREN_PERCENT`: The percentage of time taken by children relative to the total application time
- `TOTAL_PERCENT`: The percentage of time taken (self plus children) relative to the total application time
- `SELF_MEMORY`: The memory added (not including children) in Megabytes
- `CHILDREN_MEMORY`: The memory added by children in Megabytes
- `TOTAL_MEMORY`: The total memory added (self plus children) in Megabytes
- `CALLS`: The number of calls

### Timing a Section

There are two different methods for timing: on-the-fly registration and pre-registration.  On-the-fly registration is the preferred method and should be used whenever possible.

#### On-The-Fly Section Timing

Timing a section is as simple as using the `TIME_SECTION` macro within a C++ scope.  `TIME_SECTION` can take between one and four arguments.  The single argument version is used when doing pre-registration of sections.  For on-the-fly you invoke `TIME_SECTION` like so:

`TIME_SECTION(section_name, level, live_message="", print_dots=true)`

- `section_name`: The short name of the section.  This is the name used in the final table.  It is normally the function name or some other short name.
- `level`: The logging level
- `live_message`: OPTIONAL - but highly recommended.  This is the message `PerfGraphLivePrint` will print to the screen (if necessary).  It should be descriptive, title-cased, and written in an active way, e.g. "Calculating Lama Heights"
- `print_dots`: OPTIONAL - defaults to true.  This controls whether or not progress dots will be printed for this section.  Only turn this off if printing dots would intermingle with some screen output that is out of MOOSE's control (for instance, in a library that you are calling into).

An example showing the most-often use-case for `TIME_SECTION`:

```c++
void
Dog::clean()
{
  TIME_SECTION("clean", 2, "Cleaning the Dog");
  ...

  {
    TIME_SECTION("soap", 3, "Soaping the Dog");
    ...
  }

  {
    TIME_SECTION("rinse", 3, "Rinsing the Dog");
    ...
  }
  ...
}
```

What `TIME_SECTION` is doing is creating a static variable to hold a `PerfID` that is initialized by registering the section with the `PerfGraphRegistry`.  Since this is a static variable the registration only happens the very first time that line of code is hit .  Every time after that it simply creates `PerfGuard` object using the passed in `PerfID`.  The `PerfGuard` tells the `PerfGraph` about the new scope and the timing is then started for that section.  At the end of the function the `PerfGuard` dies and in the destructor it tells the `PerfGraph` to remove that scope.  Timing this way means that it is exception safe and impossible to "foul up" because there are no "push/pop" methods to match.

##### Early Retrieval

Sections that are registered using the on-the-fly timing method described above (which are the overwhelming majority of sections in the MOOSE framework and modules) are not registered in the `PerfGraph` until the moment they are ran.

This poses a challenge when obtaining data pertaining to said sections: error checking on whether or not a section exists is dependent on whether or not the section has ran yet. The default behavior for obtaining `PerfGraph` section data via `PerfGraph::sectionData()` is to error if a section with that name has not been found.

Let's say you are trying to time Jacobian evaluation time after every timestep, which is stored in the section `FEProblem::computeJacobianInternal`. But, your system only evaluates the Jacobian after the second timestep. If you try to pull section data on `FEProblem::computeJacobianInternal` on `TIMESTEP_END`, the system will error by default after the first evaluation because such a section has not ran (even though it is a valid section). With this, `Perfgraph::sectionData()` takes an optional boolean argument `must_exist` (which defaults to `true`). Setting `must_exist = false` will return zero if the section is not found.

#### Pre-registered Timing

This type of timing should _only_ be utilized when absolutely necessary.  The main case where this comes up is timing in base classes that main get instantiated multiple times through different derived classes.  An example is the `Action` base class.

Timing a section using pre-registration is a two part process:

1.  Register the section and save off the `PerfID`
2.  Using the `TIME_SECTION` macro to start timing a `PerfID`

##### Registration

Registering the section of code to be timed is accomplished by calling:


The `section_name` names the section of code.  The `prefix + section_name` must be globally unique.  `level` is the "log level" of the section.  A higher number represents a more detailed log level.  Here are some quick guidelines for selecting `level`:

`registerTimedSection()` returns a `PerfID` that is a unique identifier that identifies that code section.  This `PerfID` should typically get saved as a member variable of the class that is registering the section... this is normally done by initializing a `PerfID` member variable using `registerTimedSection()` in the initialization list of a constructor like so:

```c++
MyClass::MyClass() : _slow_function_timer(registerTimedSection("slowFunction")) {}
```

##### Timing

Once a timed section is registered and a `PerfID` is captured the section can be timed using the `TIME_SECTION` macro like so:

```c++

void slowFunction()
{
  TIME_SECTION(_slow_function_timer);

  // do all the things
}
```

What `TIME_SECTION` is doing is creating a `PerfGuard` object using the passed in `PerfID`.  The `PerfGuard` tells the `PerfGraph` about the new scope and the timing is then started for that section.  At the end of the function the `PerfGuard` dies and in the destructor it tells the `PerfGraph` to remove that scope.  Timing this way means that it is exception safe and impossible to "foul up" because there are no "push/pop" methods to match.

### Retrieving Section Data

An object that inherits from `PerfGraphInterface` can retrieve the data pertaining to a registered section by calling `perfGraph().sectionData()`. Note the various available data types in [#performance-data-types].

### The `PerfGraph` Internals

The `PerfGraph` object's main purpose is to store the complete call-graph of `PerfNode`s and the current call-stack of `PerfNode`s.  The graph is held by holding onto the `_root_node`.  All other scopes that are pushed into the graph are then children/descendants of the `_root_node`.

The call-stack is held within the `_stack` variable.  The `_stack` is statically allocated to `MOOSE_MAX_STACK_SIZE` and `_current_position` is used to point at the most recent node on the stack.  When a `PerfGuard` tells the `PerfStack` about a new scope, the new scope is added a child to the `PerfNode` that is in the `_current_position`.  `_current_position` is then incremented and the new `PerfNode` is put there. When a scope is removed by the `PerfGuard` the `_current_position` is simply decremented - with no other action being necessary.

In addition, the `_execution_list` is keeping a running list of every section that executes.  This is utilized by `PerfGraphLivePrint` to print messages out that are multiple levels deep.

### Printing

Some other capability the `PerfGraph` has is the ability to print formatted tables displaying the values held in the graph.  These normally shouldn't be called directly, but instead should be accessed using a [/PerfGraphOutput.md] output object.

The `print()` method prints out an indented set of section names and shows their timing like so:

```
Performance Graph:
----------------------------------------------------------------------------------------------------------------------------------------------
|                  Section                 | Calls |   Self(s)  |   Avg(s)   |    %   | Mem(MB) |  Total(s)  |   Avg(s)   |    %   | Mem(MB) |
----------------------------------------------------------------------------------------------------------------------------------------------
| MooseTestApp (main)                      |     1 |      0.008 |      0.008 |   0.66 |       1 |      1.259 |      1.259 | 100.00 |      67 |
|   FEProblem::outputStep                  |     2 |      0.001 |      0.000 |   0.04 |       0 |      0.064 |      0.032 |   5.09 |       8 |
|   Steady::PicardSolve                    |     1 |      0.000 |      0.000 |   0.01 |       0 |      0.717 |      0.717 |  56.92 |      32 |
|     FEProblem::solve                     |     1 |      0.134 |      0.134 |  10.61 |      29 |      0.716 |      0.716 |  56.89 |      32 |
|       FEProblem::computeResidualInternal |    14 |      0.000 |      0.000 |   0.01 |       0 |      0.458 |      0.033 |  36.34 |       1 |
|       FEProblem::computeJacobianInternal |     2 |      0.000 |      0.000 |   0.00 |       0 |      0.125 |      0.062 |   9.91 |       2 |
|     FEProblem::outputStep                |     1 |      0.000 |      0.000 |   0.02 |       0 |      0.000 |      0.000 |   0.02 |       0 |
|   Steady::final                          |     1 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.02 |       0 |
|     FEProblem::outputStep                |     1 |      0.000 |      0.000 |   0.01 |       0 |      0.000 |      0.000 |   0.02 |       0 |
----------------------------------------------------------------------------------------------------------------------------------------------
```

`Calls` is the number of times that section was run. `Self` time is the time actually taken by the section while `Children` time is the cumulative time of all of the sub-sections below that section and `Total` is the sum of the two.  The `Avg` and `%` columns represent the average and percent of the total run-time of the app for the number in the column to the left. `Mem` is the memory (in Megabytes) for the column to the left (Self or Total).

There are also two other ways to print information out about the graph using `printHeaviestBranch()` and `printHeaviestSections()`.  These are described well over on the [/PerfGraphOutput.md] page.

## PerfGraphLivePrint

### Overview

The `PerfGraphLivePrint` (PGLP) object is responsible for printing information to the screen as a code is executing.  To perform this action PGLP is executing on a separate thread from the main thread.  This thread will be referred to as the "print thread".  The main thread keeps track of what is executing using the `TIME_SECTION` macro as part of [/PerfGraph.md].  PGLP then reads this information and decides whether or not to print information about what is currently happening.

By default, PGLP prints information any time a section takes longer than five seconds to execute.  It will print out the "live print message" at that point, then it will print a single `.` every five seconds until the section ends.  When the section ends, both the memory and the time will be printed. By default, the total memory used (by the simulation at this point) and the increment in time (e.g. the time for this section only) are printed. The time limit is configurable from the input file (see [CommonOutputAction.md]).

The other reason that PGLP prints is for a large increase in memory (by default 100MB).  If, after a section executes, the memory usage increased by more than the limit, then PGLP will print the live print message and show the current total memory consumption as well as the time used by the section.  The memory limit is configurable from the input file (see [CommonOutputAction.md]).

The PGLP primarily works by waking up every five seconds and inspecting what the program has done / is currently doing, printing any necessary information and then going back to sleep.  It should be lightweight enough that it should not significantly disrupt the operation of the program.

### Objects/Data Structures Used By PerfGraphLivePrint

The PGLP utilizes several different objects and data structures for reading the current state of the execution and for storing the current state of what's been printed.

#### PerfGraphSectionInfo

The `PerfGraphRegistry` keeps track of which sections have been registered, including their unique id, short name, verbosity level, live message, and whether or not to print dots for that section.  This is all kept in a `PerfGraphSectionInfo` object that is part of the `PerfGraphRegistry`.

This information is heavily utilized by the PGLP to know what to print and when.  Due to the main thread registering this information and the print thread using it, the accessors surrounding `PerfGraphSectionInfo` have locks in them.  However, the `PerfGraph` executes on the main thread and therefore utilizes a protected member function on `PerfGraphRegistry` to access `PerfGraphSectionInfo` without a lock.

#### PerfGraph::SectionIncrement

A `SectionIncrement` represents either the starting or ending state of a section.  `SectionIncrement`s are stored in an "execution list" (explained below) inside of `PerfGraph` as well as a `_print_thread_stack` in the PGLP.  The PGLP reads those in order to determine what the application is currently doing (and has done).

The `SectionIncrement` objects are stored in a `std::array` called `_execution_list` in the `PerfGraph`.  This means they are all allocated up-front.  When a timed section is started, the next available `SectionIncrement` in the execution list is filled with the current time, current memory, and an `IncrementState` of `STARTED`.  When the PGLP wakes up it inspects the execution list to determine what the program has done and is doing and whether or not it needs to print anything.  Note that there is zero memory allocation during the execution of the program.

#### PerfGraph::_execution_list

The execution list is stored in the `PerfGraph` and keeps a running list of every timed section starting and stopping.  As mentioned above, it is a `std::array` of `SectionIncrement` objects that are statically allocated at the start of execution.  The execution list works as a "circular buffer"... when the end of the list is reached, filling continues by wrapping around to the beginning of the list.  To do this, a simple counter is kept for where the beginning and ending of the current execution list are.  The beginning and ending are kept in atomic variables so that they are threadsafe since they will be read and written to by both the main thread and the print thread.

The entire execution history is necessary because the PGLP only wakes up every five seconds - and it needs to be able to see everything that transpired.  This allows it to know what has finished so that it can print finishing information and gives it the ability to keep track of what is currently executing by developing a print thread stack.

#### PerfGraphLivePrint::_print_thread_stack

While `PerfGraph` keeps a stack, that stack is changing all the time during the execution of the code.  The PGLP needs to keep a stack of what is currently printed on the screen so that it knows how much to indent and how to "unfold" after sections end (i.e. how to print the "finished" statements for several sections that are nested).  This information is kept in the `PerfGraphLivePrint::_print_thread_stack`.

The print thread stack is developed by the PGLP by reading the execution list from the `PerfGraph` and "pushing" and "popping" `SectionInfo`.  An important detail is that the print thread stack must _copy_ from the execution list.  This is because the execution list is a circular array... meaning that old entries will get overwritten.  Things on the bottom of the stack could be there a long time (e.g. the entire execution of the program) - so to preserve that information it must be copied to the stack.

### Threading and Thread Safety

Threading is accomplished using C++ threading mechanisms.  The PGLP is started as a `std::thread`.  The destructor of `PerfGraph` tells the PGLP to finish and calls `join()` on it to delete it.

#### Memory Synchronization

With the main thread writing to the execution list and the PGLP reading from it on its own thread, memory synchronization is critical.  In `PerfGraph:addToExecutionList` a `SectionIncrement` has its data filled in, then a `std::atomic_thread_fence()` is used to make sure the changes to that `SectionIncrement`'s data is "published" to all threads _before_ incrementing the end of the execution list.  That thread fence "synchronizes with" a thread fence in `PerfGraphLivePrint::start()`.  This means that if the PGLP wakes up as the `SectionInfo` is being written to, that it won't ever access the data mid-change.  All of this is achieved without any locking on the main thread.

#### Waiting and Waking Up

The main execution loop for PGLP is in `start()` and is a `while()` loop that is dependent on the object-local `_currently_destructing` variable.  Details about `_currently_destructing` are below - but the gist is that the loop will continue until `PerfGraph` tells it not to.

PGLP waits on a section completing so that we can instantly print the finishing info for it.  To do this, we use a `std::condition_variable`.  A `condition_variable` can be used to wait for a notification from the main thread.  By using `wait_for()` it is possible to wait until either the specified amount of time has passed or the thread is signaled to wakeup.  This allows the PGLP to sleep for 5 seconds, or until the main thread tells it that a section is complete.

However, the actual workings of a `condition_variable` are complex.  There are actually three reasons why a `wait_for()` may wakeup:

1. The timeout is over
2. The notification is sent
3. A "spurious wakeup"

The third type of wakeup occurs when an OS wakes the thread up early, which can happen randomly.  This is ok with us, because it gives us a moment to check to see if sections have completed while the thread has been asleep.  To do that, there is a predicate functor passed to `wait_for` that does exactly this check.  In addition, it also checks to see if the `PerfGraph` is `_destructing`... which would mean the PGLP should stop waiting and print the final info.

I want to take a moment and talk about locking and `condition_variable`.  Usually, you want to use a lock to guard the evaluation of the predicate and the setting of variable values in the main thread.  In our case, we really don't want locking in the execution pathway of the main thread because it could slow down execution.  To get around this, the variables used in the predicate are atomic.  However, this isn't without its own flaws.  There is a tiny chance that the predicate can be evaluated when it is false, but then, in-between checking the predicate and waiting for the signal the main thread signals, then the PGLP starts looking for a signal.  In this case, the PGLP may wait five seconds more before finding out that there is work to be done.  This is incredibly rare, and is not worth fixing by having a lock on the main thread.

#### Destructing

As mentioned above, the PGLP is looping until the `PerfGraph` signals that it is destructing.  The `_destructing` variable in `PerfGraph` is guarded by a mutex that is also utilized when checking the predicate of the condition variable mentioned above.  This is done because we don't want to accidentally miss the destructing signal and wait for 5 more seconds - delaying the ending of the program.  That could be hugely detrimental to a run that is running thousands of cases (like a stochastic sampling or even just running tests).

One more small detail about destructing is that the value of it needs to be captured _before_ capturing the value of the end of the execution list.  This is to make sure that the final end of the execution list is available for the last run-through of the PGLP... so that everything can be completely printed.

### Printing

After making it past the condition variable mentioned above, the PGLP then needs to read the execution list, build the print stack, and decide if anything should be printed.

The simplest case is that the execution is still in the "same place" - meaning that the execution list is has not been changed.  In that case, either the current sections live print message needs to be printed or dots need to be printed.

If the execution list is not in the same place, then it must be iterated through.  Note that the current end of the execution list is only captured one time, during the condition_variable predicate.  This same ending is utilized throughout the entire time the PGLP is executing for that iteration.  The main thread may be moving on past that point - but for an entire cycle of the PGLP the ending of the execution list is held constant.  This is required to make sure there are no race conditions.

The different reasons (ways) things are printed are:

1. Has been running for 5 seconds (print live message)
2. Is still running (print dots)
3. Was the current thing running that had already been printed and finished (print stats)
4. Is continuing to run after an internal scope was running and was printed (print "Still")
5. Finished running, hasn't been printed, but is over the memory limit (print "Finished")

In each case the entire "stack" is printed up to where the current section that needs to be printed is.  This is to give context to inner scopes and get proper indenting.

## Tensors

MOOSE provides the following types of tensors.

- `RankTwoTensor`/`ADRankTwoTensor`
- `RankThreeTensor`/`ADRankThreeTensor`
- `RankFourTensor`/`ADRankFourTensor`
- `SymmetricRankTwoTensor`/`ADSymmetricRankTwoTensor`
- `SymmetricRankFourTensor`/`ADSymmetricRankFourTensor`

These tensor classes provide a rich set of methods for commonly used algebraic operations. For a complete list of supported operations, please refer to the corresponding Doxygen documentation.

### RankTwoTensor / ADRankThreeTensor

A `RankTwoTensor` is a second order tensor containing 9 components. No symmetry is assumed. An `ADRankTwoTensor` provides additional information for automatic differentiation. The complete list of available methods and operators can be found in the [RankTwoTensor Doxygen documentation](https://mooseframework.inl.gov/docs/doxygen/moose/classRankTwoTensorTempl.html).

### RankThreeTensor / ADRankThreeTensor

A `RankThreeTensor` is a third order tensor containing 27 components. No symmetry is assumed. An `ADRankThreeTensor` provides additional information for automatic differentiation. The complete list of available methods and operators can be found in the [RankThreeTensor Doxygen documentation](https://mooseframework.inl.gov/docs/doxygen/moose/classRankThreeTensorTempl.html).

### RankFourTensor / ADRankFourTensor

A `RankFourTensor` is a fourth order tensor containing 81 components. No symmetry is assumed. An `ADRankFourTensor` provides additional information for automatic differentiation. The complete list of available methods and operators can be found in the [RankFourTensor Doxygen documentation](https://mooseframework.inl.gov/docs/doxygen/moose/classRankFourTensorTempl.html).

### SymmetricRankTwoTensor / ADSymmetricRankTwoTensor

A `SymmetricRankTwoTensor` is a symmetric second order tensor containing 6 components. [Mandel notation](https://en.wikipedia.org/wiki/Voigt_notation#Mandel_notation) is used internally to store and access the components. An `ADSymmetricRankTwoTensor` provides additional information for automatic differentiation. The complete list of available methods and operators can be found in the [SymmetricRankTwoTensor Doxygen documentation](https://mooseframework.inl.gov/docs/doxygen/moose/classSymmetricRankTwoTensorTempl.html).

### SymmetricRankFourTensor / ADSymmetricRankFourTensor

A `SymmetricRankFourTensor` is a fourth order tensor with minor symmetry containing 36 components. [Mandel notation](https://en.wikipedia.org/wiki/Voigt_notation#Mandel_notation) is used internally to store and access the components. An `ADSymmetricRankFourTensor` provides additional information for automatic differentiation. The complete list of available methods and operators can be found in the [SymmetricRankFourTensor Doxygen documentation](https://mooseframework.inl.gov/docs/doxygen/moose/classSymmetricRankFourTensorTempl.html).

## MooseUnits

`MooseUnits` is a physical units parsing and conversion helper class.
A unit object can be constructed form a string (e.g. `N*m`, `eV/at`, `kg*(m/s)^2`, `1/s`, `m^-3`).
The unit parser supports the `*`,`/`, and `^` operators as well as parenthesis `(`, `)`.
The argument of the `^` operator is expected to be a positive or negative integer.

Upon parsing all units are resolved to a combination of the
[seven base SI units](https://en.wikipedia.org/wiki/SI_base_unit) (`m`, `g`,
`s`, `A`, `K`, `mol`, `cd`) with their respective exponents and a prefactor. A
canonical form is generated that permits unit comparisons to determine
conformity (i.e. whether two units can be converted between).

`MooseUnits` supports prefixing all units with a
[metric prefix](https://en.wikipedia.org/wiki/Metric_prefix) ranging from `Y` (yotta)
to `y` (yocto).

### Supported derived units

The following units are currently supported

| Symbol | Base units | Name | Description |
| - | - | - | - |
| `Ohm` | $\text{kg}\cdot \text{m}^{2}\cdot \text{s}^{-3}\cdot \text{A}^{-2}$ | Ohm | resistance, impedance, reactance |
| `atm` | $101325\, \text{kg}\cdot \text{m}^{-1}\cdot \text{s}^{-2}$ | Standard atmosphere | pressure |
| `eV` | $1.60218\cdot10^{-19}\, \text{kg}\cdot \text{m}^{2}\cdot \text{s}^{-2}$ | electron Volt | energy |
| `erg` | $10^{-7}\, \text{kg}\cdot \text{m}^{2}\cdot \text{s}^{-2}$ | Erg | energy |
| `degC` | $\text{K}$ | Celsius | temperature - As long as this unit stands alone the additive shift in the scale is taken into account. In all other cases this unit behaves like Kelvin |
| `degF` | $\frac59\,\text{K}$ | Fahrenheit | temperature - As long as this unit stands alone the additive shift in the scale is taken into account. In all other cases this unit behaves like Rankine |
| `degR` | $\frac59\,\text{K}$ | Rankine | temperature |
| `Ang` | $10^{-10}\, \text{m}$ | Angstrom | length |
| `m` | $\text{m}$ | meter | length |
| `g` | $0.001\, \text{kg}$ | gram | mass |
| `s` | $\text{s}$ | second | time |
| `A` | $\text{A}$ | Ampere | electric current |
| `K` | $\text{K}$ | Kelvin | temperature |
| `mol` | $6.02214076e23\cdot10^{23}\, \text{at}$ | mole | amount of substance |
| `cd` | $\text{cd}$ | candela | luminous intensity |
| `N` | $\text{kg}\cdot \text{m}\cdot \text{s}^{-2}$ | Newton | force, weight |
| `Pa` | $\text{kg}\cdot \text{m}^{-1}\cdot \text{s}^{-2}$ | Pascal | pressure, stress |
| `J` | $\text{kg}\cdot \text{m}^{2}\cdot \text{s}^{-2}$ | Joule | energy, work, heat |
| `cal` | $4.184\text{kg}\cdot \text{m}^{2}\cdot \text{s}^{-2}$ | Calorie | energy, work, heat |
| `W` | $\text{kg}\cdot \text{m}^{2}\cdot \text{s}^{-3}$ | Watt | power, radiant flux |
| `C` | $\text{A}\cdot \text{s}$ | Coulomb | electric charge |
| `V` | $\text{kg}\cdot \text{m}^{2}\cdot \text{s}^{-3}\cdot \text{A}^{-1}$ | Volt | voltage (electrical potential), emf |
| `F` | $\text{kg}^{-1}\cdot \text{m}^{-2}\cdot \text{s}^{4}\cdot \text{A}^{2}$ | Farad | capacitance |
| `S` | $\text{kg}^{-1}\cdot \text{m}^{-2}\cdot \text{s}^{3}\cdot \text{A}^{2}$ | Siemens | electrical conductance |
| `Wb` | $\text{kg}\cdot \text{m}^{2}\cdot \text{s}^{-2}\cdot \text{A}^{-1}$ | Weber | magnetic flux |
| `T` | $\text{kg}\cdot \text{s}^{-2}\cdot \text{A}^{-1}$ | Tesla | magnetic flux density |
| `H` | $\text{kg}\cdot \text{m}^{2}\cdot \text{s}^{-2}\cdot \text{A}^{-2}$ | Henry | inductance |
| `Ba` | $0.1\, \text{kg}\cdot \text{m}^{-1}\cdot \text{s}^{-2}$ | barye | Pressure |
| `dyn` | $10^{-5}\, \text{kg}\cdot \text{m}\cdot \text{s}^{-2}$ | dyne | force, weight |
| `ft` | $0.3048\, \text{m}$ | Foot | length |
| `in` | $0.0254\, \text{m}$ | Inch | length |
| `lb` | $0.45359237\, \text{kg}$ | pound  | mass |
| `lbf` | $4.4482216152605\, \text{kg}\cdot \text{m}\cdot \text{s}^{-2}$ | pound-force | force |
| `psi` | $6894.757\, \text{kg}\cdot \text{m}^{-1}\cdot \text{s}^{-2}$ | pound-force per square inch | pressure, stress |
| `BTU` | $1055.06\, \text{kg}\cdot \text{m}^{2}\cdot \text{s}^{-2}$ | ISO 31-4 British thermal unit | heat |
| `bar` | $10^5\, \text{kg}\cdot \text{m}^{-1}\cdot \text{s}^{-2}$ | Bar | pressure, stress |
| `h` | $3600\, \text{s}$ | hour | time |
| `day` | $86400\, \text{s}$ | day | time (`d` would create an ambiguity between centi-day and candela) |
| `year` | $365.25\cdot86400\, \text{s}$ | annum | time (Julian calendar year, `a` would create an ambiguity between Peta-annum and Pascal) |
| `l` | $0.001\, \text{m}^{3}$ | liter | volume |
| `u` | $1.6605390666\cdot10^{-27}\, \text{kg}^{3}$ | unified atomic mass unit | mass |
| `at` | $\text{at}$ | atom | single count of substance |

### Operators

Unit objects support the `*` and `/` operators to multiply and divide units
respectively. An overload of `std::pow` is provided to exponentiate units.

The `==` equal operator is implemented for comparison of two units and a unit
and a real number. It returns true if the two units are exactly identical
including the prefactor. A comparison that omits the prefactor is provided by
the `conformsTo` method.

A unit is considered equal to a real number if all its base
unit exponents are zero and the prefactor matches the real number.

## Dimension check

In addition to the `conformsTo` check a few `bool` member functions are provided
to check if the unit represents a given physical dimension.

- `isLength()`
- `isTime()`
- `isMass()`
- `isCurrent()`
- `isTemperature()`

### Output

`MooseUnits` objects can be output to streams using the `<<` operator. The output
consists of the prefactor and the SI base units with their respective exponents. Two
stream manipulators are provided to toggle between plain text and LaTeX formatted
output of the units.

### See also

Unit conversion using `MooseUnits` is available in input files through the
`${units ...}` [Brace Expression](input_syntax.md optional=True).

## ValueCache

The `ValueCache<T>` class can cache value of type `T` indexed by n-dimensional vectors. Retrieval is performed using a kd-tree data structure (using nanoflann).

### Persistence

When the object is constructed using the

```C++
ValueCache(const std::string & file_name, std::size_t in_dim, std::size_t max_leaf_size = 10);
```

constructor, the state of the cache is saved to a file upon destruction of the cache object (usually at the end of a simulation), and read in at construction of the cache object. Thus the cached knowledge from a previous simulation will be available in future runs.

It is up to the developer to ensure that the cache state from previous runs is applicable to the following runs when the persistence feature is used!

Note that overloads for `dataLoad` and `dataStore` for type `T` must be implemented. If full persistence is not desired the cache object can still be declared as restartable.

# variables

## ArrayMooseVariable


### Overview

An array variable is define as a set of standard field variables with the same finite element family and order.
Each standard variable of an array variable is referred to as a component of the array variable.
An array kernel is a MOOSE kernel operating on an array variable and assembles the residuals and Jacobians for all the components of the array variable.
A sample array kernel can be found at [ArrayDiffusion.md].
The purpose of having array kernels is to reduce the number of kernels when the number of components of an array variable is large (potentially hundreds or thousands) and to avoid duplicated operations otherwise with lots of standard kernels.
Array kernel can be useful for radiation transport where an extra independent direction variable can result into large number of standard variables.
Similarly as array kernel, we have array initial conditions, array boundary conditions, array DG kernels, array interface kernels, array constraints, etc.

The design:

- to use variable groups in [libMesh] to group components in an array variable together.
- to use template to avoid code duplication with standard and vector variables.
- to use [Eigen](https://eigen.tuxfamily.org/dox/group__QuickRefPage.html)::Matrix to hold local dofs, solutions on quadrature points for an array variable to ease the local operations.
- to use dense matrices or vectors as standard or vector variables with proper sizes for holding the local Jacobians and residuals that are to be assembled into a global Jacobian matrix and a global residual vector.

The following map is useful for understanding the template:

| OutputType          | OutputShape           | OutputData |
| :- | :- | :- |
| Real                | Real                  | Real |
| RealVectorValue     | RealVectorValue       | Real |
| RealEigenVector     | Real                  | RealEigenVector |

The three rows correspond to standard, vector and array variables.
OutputType is the data type used for templating.
RealEigenVector is a typedef in [MooseTypes.h] as *Eigen::Matrix<Real, Eigen::Dynamic, 1>*.
OutputShape is for the type of shape functions and OutputData is the type of basis function expansion coefficients that are stored in the moose array variable grabbed from the solution vector.

### Kernels for Array Variables

Since array variables have a different OutputData type, standard Kernels cannot be used on array variables. Kernels for array variables, or ArrayKernels, must derive from `ArrayKernel` which have different virtual functions for `computeQpResidual`, `computeQpJacobian`, and `computeQpOffDiagJacobian`. The declaration of these functions are below:

virtual void computeQpResidual(RealEigenVector & residual) = 0;
virtual RealEigenVector computeQpJacobian();
virtual RealEigenMatrix computeQpOffDiagJacobian(const MooseVariableFEBase & jvar);

When defining a `computeQpResidual` in a derived class, this function +must+ define the residual in the input argument (`residual`). This input is already properly sized when called in ArrayKernel.C. `computeQpJacobian` must return a vector defining the on-diagonal terms of the Jacobian. `computeQpOffDiagJacobian` must return a matrix with number of rows equal to the number of components and number of columns being the number of components in `jvar.`

Using [ArrayDiffusion.md] as an example. The `computeQpResidual` function has


where `_grad_u[_qp]` is an `Eigen::Matrix` with number of rows being equal to the number of components of the array variable and number of columns being `LIBMESH_DIM`. `_array_grad_test[_i][_qp]` is an `Eigen::Map` of classic `_grad_test[_i][_qp]` which is in type of `Gradient`. Thanks to the Eigen matrix arithmetic operators, we can have a simple multiplication expression here. `_d` is a pointer of a material property of `Real` type for scalar diffusion coefficient. Here we assume the diffusion coefficient is the same for all components. `_d_array` is a pointer to a `RealEigenVector` material
property, here we assume there is a diffusion coefficient for each component with no
coupling. `_d_2d_array` is a pointer to a `RealEigenMatrix` material property, where
the diffusion coefficient is represented as dense matrix. See [ArrayDiffusion.md] for more details.

Correspondingly the `computeQpJacobian` has


It is noted that only the diagonal entries of the diffusion coefficients are used in the fully-coupled case because `computeQpJacobian` is supposed to only assemble the block-diagonal part of the Jacobian.
The full local Jacobian is assembled in function `computeQpOffDiagJacobian`, where when the off-diagonal variable is the array variable, we have

  re=RealEigenMatrix\sArrayDiffusion::computeQpOffDiagJacobian.*?^}

The retuned value is in type of an Eigen matrix with number of rows and columns equal to the number of components.

`ArrayKernel` also has virtual functions including:

virtual void initQpResidual();
virtual void initQpJacobian();
virtual void initQpOffDiagJacobian(const MooseVariableFEBase & jvar);

Which are functions that are called inside the quadrature point loop, but outside the test/shape function loop. This is useful to perform operations that depend on position (quadrature point) but do not depend on the test/shape function. For instance, [ArrayDiffusion.md] uses `initQpResidual` to check if the size of the vector or matrix diffusion coefficient matches the number of components in the variable:


Future work:

- To change the current dof ordering for elemental variables so that we can avoid bunch of if statements with `isNodal()` in `MooseVariableFE.C`, (refer to [libMesh Issue 2114](https://github.com/libMesh/libmesh/issues/2114)).
- To use Eigen::Map for faster solution vector access.
- To implement ArrayInterfaceKernel and ArrayConstraints.

### Useful Eigen API

Linear algebra is very easy using Eigen, it has a lot of API for matrix arithmetic and manipulation that simplifies code and helps developers avoid writing their own loops. For a full list of functions, visit the [Eigen matrix doxygen](http://eigen.tuxfamily.org/dox/classEigen_1_1Matrix.html), which is relevant to the `RealEigenVector` and `RealEigenMatrix` types in MOOSE. Below is a list of commonly used functions for residual and jacobian evaluations. For exposition here is a definition of a vector and matrix:

\vec{v} =
\begin{bmatrix}
v_1 \\ v_2 \\ \vdots \\ v_n
\end{bmatrix}
\quad , \quad
M =
\begin{bmatrix}
m_{11} & m_{12} & \dots & m_{1n} \\
m_{21} & m_{22} & \dots & m_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
m_{n1} & m_{n2} & \dots & m_{nn}
\end{bmatrix}
.

- Set all elements to same value:

  \vec{v}\texttt{.setZero()} \rightarrow v_i = 0, i=1,...,n

  \vec{v}\texttt{.setOnes()} \rightarrow v_i = 1, i=1,...,n

  \vec{v}\texttt{.setConstant(}a\texttt{)} \rightarrow v_i = a, i=1,...,n

- Change matrix representation:

  \vec{v}\texttt{.asDiagonal()} \rightarrow
  \begin{bmatrix}
  v_1 &     &        &     \\
      & v_2 &        &     \\
      &     & \ddots &     \\
      &     &        & v_n \\
  \end{bmatrix}

  M\texttt{.diagonal()} \rightarrow
  \begin{bmatrix}
  m_{11} \\ m_{22} \\ \vdots \\ m_{nn}
  \end{bmatrix}

- Element-wise operations:

  \vec{v} \texttt{ = } \vec{v}\texttt{.cwiseProduct(}\vec{w}\texttt{)} \rightarrow v_i = v_iw_i, i=1,...,n

  \vec{v}\texttt{.array() /= } \vec{w}\texttt{.array()} \rightarrow v_i = v_i/w_i, i=1,...,n

### Eigen Tips and Tricks (Advanced)

Eigen has some unique features that, when used properly, can significantly impact performance. Here are some recommendations that can improve code performance.

- [Aliasing](http://eigen.tuxfamily.org/dox/group__TopicAliasing.html) is a technique in Eigen that constructs temporary objects when performing matrix multiplications, this is to avoid overriding data that needs to be used later in the computation. For instance `vec = mat * vec` will create a temporary vector for `mat * vec` then assign it to `vec` at the end. However, `vec2 = mat * vec1` does not need this temporary object and assign the result to `vec2` directly, this aliasing can be avoided by doing `vec2.noalias()`. The `noalias()` function should be used with extreme caution since it can cause erroneous results.

- Eigen uses what's known as [expression templates](https://en.wikipedia.org/wiki/Expression_templates), enabling operations to be known at compile time. This allows multiple operations to occur in a single element loop, providing more compiler optimization and improved cache efficiency. With this in mind, it is often better to write multiple Eigen operations in a single line or assignment. For instance, with the following syntax:

  a = 3*b + 4*c + 5*d

  Eigen will compile to a single for loop:

  for (unsigned int i = 0; i < b.size(); ++i)
    a[i] = 3*b[i] + 4*c[i] + 5*d[i];

- Eigen also has a interface for accessing raw buffers using its [Map class](http://eigen.tuxfamily.org/dox/group__TutorialMapClass.html).

For a better understanding of Eigen and using it to its full potential, it is highly recommended to go through Eigen's [tutorials](http://eigen.tuxfamily.org/dox/modules.html).





## AuxVariable


Auxiliary variables are used to compute or store intermediate quantities that are not the main variables,
the ones being solved for, of the equation system.

A detailed description of the MOOSE variable system is given in the [base class documentation](MooseVariableBase.md).




## MooseVariableLinearFVReal

### Overview

This variable is used for finite volume simulations where a linear system is solved
with the following form:

A\vec{x} = \vec{b}~,

where $\vec{x}$ is the vector containing the degrees of freedom for the declared variable,
while $A$ and $\vec{b}$ are the corresponding system matrix and right hand side, respectively.

This variable can only be used with linear systems and cannot be used for systems which need
Jacobian and residual evaluations, such as nonlinear systems being solved by Newton or
quasi-Newton methods.

Similarly to [MooseVariableFV.md], this variable describes a field which has been discretized
using the cell-centered finite volume method and can be evaluated using the
[functor system in MOOSE](Functors/index.md).


### Example Input File Syntax

To create a `MooseLinearVariableFVReal`, users can do the following in their
input files:

```
[Variables]
  [v]
    type = MooseLinearVariableFVReal
  []
[]
```

Note that unlike the case of finite element variables, the user needs to
explicitly define the type of the variable.




## MooseVariable


A detailed description of the MOOSE variable system is given in the [base class documentation](MooseVariableBase.md).

Some of the major classes for contributing to the residual and Jacobian equations for spatial
variables are: [Kernels](syntax/Kernels/index.md), [DGKernels](syntax/DGKernels/index.md),
[InterfaceKernels](syntax/InterfaceKernels/index.md), [Boundary Conditions](syntax/BCs/index.md),
and [Constraints](syntax/Constraints/index.md).

For coupling with scalar variables,
then augmentations of the base classes, such as the `KernelScalarBase`
for the `Kernel` class, can be used as described here:
[ScalarKernels/index.md#couple-spatial].




## MooseVariableBase


The current class hierarchy for Moose variables is shown below:

       caption=Moose variable hierarchy.
       style=width:50%;

`MooseVariableBase` is the primitive base class from which all variables
inherit. It includes methods for accessing the variable finite element type and
order, degrees of freedom, scaling factor, name, and associated
[SystemBase](syntax/Systems/index.md). Two classes inherit directly from
`MooseVariableBase`: [MooseVariableFEBase](MooseVariable.md)
and [MooseVariableScalar](MooseVariableScalar.md). `MooseVariableScalar` represents a
Moose variable that is constant over the spatial domain. It has a number of
degrees of freedom equal to the order of the variable, e.g. the following
variable block would declare a `MooseVariableScalar` with two associated degrees
of freedom:

```
[AuxVariables]
  [aux_scalar]
    order = SECOND
    family = SCALAR
  []
[]
```

`MooseVariableFEBase` is an abstract class that encompasses all finite-element type
variables; all variables that vary spatially ultimately inherit from
`MooseVariableFEBase`. The class implements all the relevant variable methods other
than those that return the actual variable solution or variable shape functions,
since the return type in
the latter case depends on whether the finite-element variable is scalar-valued
(single-component) or vector-valued (multi-component) in nature. The existence
of the `MooseVariableFEBase` class allows construction of containers that hold both single- and
multi-component finite element variables. This is useful for instance in the
`Assembly` class where we can abstract the coupling matrix entries or in
Jacobian computing
objects like `Kernels` when we want to fetch the numerical ID of the variable
using `coupled`. Moreover, this design structure mirrors that of the `FE`
design in LibMesh, where `FEAbstract` is an abstract base class that implements
all methods independent of `FE` type and the class
template `FEGenericBase<T>` implements the type dependent methods analogous to
`MooseVariableFE<T>`.

`MooseVariableFE<T>` implements methods that return the variable's solution
and its associated shape functions. Additionally, it contains the methods
responsible for computing the variable solution at quadrature points given the
degree of freedom values computed from the previous nonlinear
solution. "Standard" or "traditional" finite element variables that are
single-component are instantiated with the template argument `Real`; these hold
variables of finite element families `LAGRANGE`, `MONOMIAL`, `HERMITE`,
etc. Multi-component vector finite element variables are instantiated with the
template argument `RealVectorValue` and currently encompass the finite element
families `LAGRANGE_VEC`, `MONOMIAL_VEC`, `NEDELEC_ONE` and `RAVIART_THOMAS`.
`NEDELEC_ONE` and `RAVIART_THOMAS` are useful for electromagnetic applications
or for general PDEs that involve a curl or a divergence operation, respectively.
`LAGRANGE_VEC` is potentially useful for solid mechanics or Navier-Stokes
simulations where historically displacement or velocity variables have been
broken up component-wise. To hide the templating of the Moose variable system
from other framework code, `MooseVariableFE<Real>` and
`MooseVariableFE<RealVectorValue>` have been aliased to `MooseVariable` and
`VectorMooseVariable` respectively.

Finally, `MooseVariableConstMonomial` is a class that takes advantage of its
finite element type (constant value on an element) to optimize its solution
computing routines. Consequently, it overrides the `computeElemValues` and
similar methods of `MooseVariableFE<Real>`.

### Accessors

There are a myriad of ways to access Moose variables from user interfaces. We'll
outline a few below.

### Restart

Variables can be restarted/initialized from variable values in a file on disk by
setting the parameter `initial_from_file_var = source_var_name` in the variable
sub-block, where `source_var_name` is the name of the source variable in the
file. Note that the user will also have to set parameters in the `[Mesh]` block
in order for this to work, as described for example in the documentation of the
[FileMeshGenerator.md].

#### SystemBase

It's common for interface objects (`Kernel` objects for example) to have a `_sys`
member. The `_sys` member has the following variable accessor methods which take
a `THREAD_ID` and either a `std::string` variable name or `unsigned` variable ID
as arguments:

- `getVariable`: returns a reference to a `MooseVariableFEBase`. Useful when access
  to the variable finite element solution or shape functions is not needed
- `getFieldVariable`: this is a templated method that takes as its template
  argument either `Real` or `RealVectorValue` and returns a reference to a
  `MooseVariable` or a `VectorMooseVariable` respectively. Useful when the user
  knows and needs the complete type
- `getScalarVariable`: returns a reference to a `MooseVariableScalar`

These getter methods ultimately query different map containers in the `VariableWarehouse`.

#### SubProblem

Another common interface object member is `_subproblem`. `_subproblem` has the
following accessors methods which take `THREAD_ID` and a `std::string` variable
name as arguments (note that accessors through variable IDs do not exist through
`SubProblem`):

- `getVariable`: returns a reference to a `MooseVariableFEBase`. Useful when access
  to the variable finite element solution or shape functions is not
  needed. Calls `SystemBase::getVariable`
- `getStandardVariable`: returns a reference to a
  `MooseVariable`. Useful when the user
  knows and needs the complete type. Calls `SystemBase::getFieldVariable<Real>`
- `getVectorVariable`: returns a reference to a
  `VectorMooseVariable`. Useful when the user
  knows and needs the complete type. Calls `SystemBase::getFieldVariable<RealVectorValue>`
- `getScalarVariable`: returns a reference to a `MooseVariableScalar`

Note that the template abstraction available in `SystemBase` is not available in
`SubProblem`. This is because the accessor methods in `SubProblem` are pure
virtual, i.e. their implementations are made in derived classes which eliminates
the choice of a templated accessor method in the base `SubProblem` class.

#### Coupleable

Since most interface objects already supply the user with the primary variable,
the most common way a user should be accessing Moose variables is through
`Coupleable` methods. The following accessor methods return actual Moose
variable objects and take as arguments the variable name and the "component"
which is used when the user passes in multiple variables to a single
`CoupledVar` parameter:

- `getFEVar`: returns a pointer to a `MooseVariableFEBase`. Useful when access
  to the variable finite element solution or shape functions is not
  needed
- `getVar`: returns a pointer to a `MooseVariable`. Useful when the complete
  type is needed
- `getVectorVar`: returns a pointer to a `VectorMooseVariable`. Useful when the complete
  type is needed

When the user/developer wants access to multiple/all coupled variables, they can
call the following methods which take no arguments:

- `getCoupledMooseVars`: returns +all+ coupled Moose variables, i.e. both
  single-component `MooseVariables` and multi-component
  `VectorMooseVariables`. Consequently the return type is
  `std::vector<MooseVariableFEBase *>`
- `getCoupledStandardMooseVars`: returns all coupled single-component
  `MooseVariables` as a `std::vector<MooseVariable *>`
- `getCoupledVectorMooseVars`: returns all coupled multi-component
  `VectorMooseVariables` as a `std::vector<VectorMooseVariable *>`
- `getCoupledMooseScalarVars`: returns all coupled
  `MooseVariableScalars` as a `std::vector<MooseVariableScalar *>`

Often times there is no need for the user/developer to access the actual Moose
variable object. Instead they require the variable finite element solution or
gradient. Some of these methods are exemplified below:

- `coupledValue`: takes a variable name (should correspond to a
  +single-component+ `MooseVariable`) and returns the finite element solution
  at the quadrature points (`VariableValue`)
- `coupledVectorValue`: takes a variable name (should correspond to a
  +multi-component+ `VectorMooseVariable`) and returns the finite element solution
  at the quadrature points (`VectorVariableValue`)
- `coupledGradient`: takes a variable name (should correspond to a
  +single-component+ `MooseVariable`) and returns the finite element solution gradient
  at the quadrature points (`VariableGradient`)
- `coupledCurl`: takes a variable name (should correspond to a
  +multi-component+ `VectorMooseVariable`) and returns the curl of the finite element solution
  at the quadrature points (`VectorVariableCurl`)


#### Variable functor evaluation id=functor-vars

Derived field classes of `MooseVariableBase`, e.g. derivatives of the class
template `MooseVariableField<T>` inherit from the
[`Moose::Functor`](syntax/Functors/index.md). Quadrature-based overloads of the `evaluate` method are
implemented in `MooseVariableField<T>`. The `ElemQpArg` and `ElemSideQpArg` `evaluate` overloads do
true on-the-fly computation of the solution based on the information contained
within the argument, e.g. they perform calls to libMesh `FE::reinit` methods
after attaching the quadrature rule provided within the calling argument. The
`ElementType` overload, however, simply queries methods like `adSln()`,
`slnOld()`, `slnOlder()`, `adSlnNeighbor()`, and `slnOldNeighbor()`. The success
of this latter overload depends on the fact that the variable has already been
reinit'd on the requested element or neighbor type. If a user is unsure whether
this precondition will be met, then they should call the likely slower but more
flexible `ElemQpArg` overload. For an overview of the different spatial
overloads available for functors, please see [syntax/Functors/index.md#spatial-overloads].

Finite-volume-centric `evaluate` overloads are individually implemented in
`MooseVariableFE<T>` and `MooseVariableFV<T>` class templates. The finite
element "implementations" currently just error out at run-time if called, but
these could be non-trivially implemented if on-the-fly evaluation of FE
variables coupled into FV physics becomes important. `MooseVariableFV<T>`
implementations of the finite-volume-centric `evaluate` overloads leverage
pre-existing methods like `getExtrapolatedBoundaryFaceValue`,
`getInternalFaceValue`, and `getDirichletBoundaryFaceValue` when called with
face-like arguments, and `getElemValue` and `getNeighborValue` when called with
element-like arguments.




## MooseVariableConstMonomial


Specialization for constant monomial variables.  It skips the interpolation into quadrature points
and just copies the solution values there.

A detailed description of the MOOSE variable system is given in the [base class documentation](MooseVariableBase.md).




## MooseVariableFE


A `MooseVariableFE` is a derived class of a `MooseVariableField`. It is a finite element field variable.
Depending on the finite element family (chosen with [!param](/Variables/MooseVariable/family) parameter)
or the [!param](/Variables/MooseVariable/components) parameter,
it can be a regular, vector or array variable.

A `MooseVariableFE` can be a nonlinear variable, in which case it should be created in the [`[Variables]`](syntax/Variables/index.md)
block, or an auxiliary variable, in which case it should be created in the [`[AuxVariables]`](syntax/AuxVariables/index.md) block.

A `MooseVariableFE` is a [Functor](syntax/Functors/index.md). As such it may be specified in the `functor` parameter of
numerous polyvalent objects.




## MooseVariableFVReal


### Overview

The `MooseVariableFV` template supports creation of finite volume variable
types. At the time of writing there is only one used instantiation of the
template which is `MooseVariableFVReal`. MOOSE uses cell-centered finite volumes
which can be conveniently supported by the `CONSTANT MONOMIAL` finite element
type in the background.

One important parameter for `MooseVariableFV` objects is
`two_term_boundary_expansion`. By default this is `false`. When `false`,
boundary faces which do not have associated
[Dirichlet boundary conditions](FVDirichletBC.md) simply use the cell centroid
value as the face value. However, when `two_term_boundary_expansion` is set to
`true` in the `Variables` sub-block of the finite volume variable, then the cell
centroid value *and* the reconstructed cell centroid gradient (hence the
two-term name) will be used to compute the extrapolated boundary face
value. Note that care should be taken when setting this parameter to
`true`. Solving for a two-term extrapolated boundary face value requires
simultaneously solving for the attached cell centroid gradient. This creates a
system of equations. This system has the potential to be singular if there are
multiple extrapolated boundary faces per cell; see
[MOOSE issue](https://github.com/idaholab/moose/issues/16822). The only time
it's reasonable to expect a cell with multiple extrapolated boundary faces to
yield a nonsingular system is if the vectors from the cell centroid to face
centroid are parallel to the surface normals *and* none of the surface normals
are parallel to themselves (e.g. imagine an orthogonal quad with three extrapolated
boundary faces).

### Example Input File Syntax

To create a `MooseVariableFVReal` a user can do one of the following in their
input file:

```
[Variables]
  [u]
    family = MONOMIAL
    order = CONSTANT
    fv = true
  []
  [v]
    type = MooseVariableFVReal
  []
[]
```

Note that a user *must* specify the `type` if they want to be able to set finite
volume variable specific parameters like `two_term_boundary_expansion`.

### Functor spatial evaluation description

For background on the functor system see [Functors/index.md].

- `ElemArg`: returns the cell center value
- `ElemPointArg`: returns a two term expansion that is the sum of the cell
  center value and the product of the distance of the point from the cell center
  times the cell center gradient
- `FaceArg`: on internal faces this will return an interpolation defined by the
  `FaceArg` `limiter_type`. On external faces this will generally return a two
  term expansion using the cell center value and gradient unless
  `two_term_boundary_expansion` has been set to `false`. On Dirichlet faces this
  will return the Dirichlet value
- `ElemQpArg`: this forwards to `ElemPointArg` where the `point` is simply the
  quadrature point location
- `ElemSideQpArg`: same as `ElemQpArg`
- `NodeArg`: loops over connected elements, calling to the `ElemPointArg`
  overload for each element with the node's location as the `point` value,
  and performs an inverse distance weighting of the results




## MooseVariableScalar


A detailed description of the MOOSE variable system is given in the [base class documentation](MooseVariableBase.md).

This variable type is very useful for solving ODEs where the independent
variable is time, e.g. the variable does not have any spatial dependence.

Typically, contribution to the residual and Jacobian equations for scalar
variables are handled using `ScalarKernels`. For coupling with spatial variables,
then augmentations of the base classes, such as the `KernelScalarBase`
for the `Kernel` class, can be used as described here:
[ScalarKernels/index.md#couple-spatial].




## PhiZero

MOOSE has helper zero objects for shape functions and shape function gradients that can be accessed by all MOOSE objects. The names of the zero objects are: `_phi_zero`, `_grad_phi_zero` and `_second_phi_zero`.
These object first two dimensions are: (i) the maximum number of degree of freedom per variable per element, and (ii) the maximum number of quadrature points per element.
The `PhiZeroKernel` test object checks that the first two dimensions of `_phi_zero`, `_grad_phi_zero` and `_second_phi_zero` are
consistent with the maximum number of shape functions and quadrature points in the simulation.

## VectorMooseVariable


A detailed description of the MOOSE variable system is given in the [base class documentation](MooseVariableBase.md).




# vectorpostprocessors

## ConstantVectorPostprocessor


The constant data is specified with a vector names, and a vector of vectors of values for each name. The vectors of values are separated by semicolons.

A constant vector postprocessor is not generally used for output or postprocessing, but more to isolate part of the system using constant inputs. For example, if a subapp communicates with the main app by transferring a vector postprocessor, a `ConstantVectorPostprocessor` may be used to replace that transfer for debugging or parametric study purposes.

### Example input syntax

In this example, two `ConstantVectorPostprocessor` are used to specify three vectors `a b c`. They are tied to each vector postprocessor, so the two do not conflict despite their similar name.





CSVReaderVectorPostprocessor.md

## CSVReaderVectorPostprocessor

The CSVReaderVectorPostprocessor reads [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) data from a file and
converts each column into a VectorPostprocessor vector. This object uses the
[DelimitedFileReader](MooseUtils.md#delimitedfilereader) utility to perform the reading of the file.

The names of the vectors declared by the `CSVReaderVectorPostprocessor` are the names of the columns in the CSV file.

### Example Input Syntax

In this example, the `example.csv` file containing data for year/month/day is being read by
the `CSVReaderVectorPostprocessor`.






## CylindricalAverage


### Description

CylindricalAverage computes the average of a variable over cylindrical
shells. The cylinder is defined by the midpoint and a vector along the cylinder
axis. The cylindrical shells are defined by a maximum radius and the number
of desired shells.

The average is an average over quadrature points! The specific weight / volume associated with each quadrature point is not taken into account. The `SpatialAverageBase::execute` routine should be modified for that purpose.

`CylindricalAverage` declares a vector for the average cylindrical shell radii, named `radius`, and a vector for each variable requested, named with the variable name.




## Eigenvalues


This vector postprocessor returns the real and imaginary part of each eigenvalue that was computed by `Eigen`. These form the two columns when output to CSV, and the eigenvalues are sorted by rows.

The vectors declared by the `Eigenvalues` vector postprocessor object are named `eigen_values_real` and `eigen_values_imag` for, respectively, the real and imaginary parts of the eigenvalues.

### Example input syntax

In this input file, the variable `u` is the solution of an eigenvalue diffusion-reaction problem. An `Eigenvalue` executioner is used to compute the eigenvalue of the system, which is retrieved by the `Eigenvalues` vector postprocessor.





## ElementMaterialSampler


The `ElementMaterialSampler` output to CSV is sorted as follows:

- the first column is the element ID, the last column is the quadrature point, and the columns in between are all the material properties from the requested [`Material`](syntax/Materials/index.md).

- the rows are major (outer) sorted by element ID and minor (inner) sorted by quadrature point. Quadrature points are sorted by increasing order. Element IDs are also sorted by increasing order, with no regards to the user ordering in the `elem_ids` parameter.

`ElementMaterialSampler` declares vectors named `elem_ids`, `qp_ids`, and a vector for each property requested with the name of the property.

Only scalar-valued (floating point and integer-valued) material properties are supported by the vector postprocessor. Vector-valued material properties are not currently supported, though this addition would not be difficult and would be a welcome contribution.

### Example input syntax

In this example, we request in a `ElementMaterialSampler` the output of the three material properties defined by the `mat` material.





## ElementsAlongLine


### Description

The `ElementsAlongLine` class is a VectorPostprocessor that outputs the element ID of
every element intersected by a line. The IDs are provided in a vector named `elem_ids`.

The user defines the line using a start and end point. The line terminates at those points,
so elements on the line beyond those points are not output.

The IDs output from this class use the MOOSE internal numbering scheme, which starts
with 0, so 1 should be added to them to translate them to the equivalent numbering in
formats such as Exodus that start with 1.




## ElementsAlongPlane


### Description

The `ElementsAlongPlane` class is a VectorPostprocessor that outputs the element ID of
every element intersected by a plane. The IDs are provided in a vector named `elem_ids`.

The user defines the plane using a combination of a point on the plane and a normal to
the plane, and the plane extends infinitely.

The IDs output from this class use the MOOSE internal numbering scheme, which starts
with 0, so 1 should be added to them to translate them to the equivalent numbering in
formats such as Exodus that start with 1.




## ElementValueSampler


This `VectorPostprocessor` is similar to [NodalValueSampler](NodalValueSampler.md),
but is used for sampling elemental variables instead of nodal variables. The
coordinate used for each sampling point is the centroid (vertex-average approximation) of the associated
element.

`ElementValueSampler` declares a vector for each spatial coordinate, (`x`, `y`, `z`), of the centroid of the element
along with its ID as well as a vector named after each variable sampled, containing the variable values.

The `ElementValueSampler` samples elemental variables at the element centroids. For more flexible sampling,
use the [PositionsFunctorValueSampler.md].




## ElementVariablesDifferenceMax


This postprocessor can find the maximum of the difference or the absolute difference if the
[!param](/VectorPostprocessors/ElementVariablesDifferenceMax/furthest_from_zero) parameter is set to `true`.
This vector postprocessor output to CSV has the following columns, in this order by default:

- the maximum difference between the two variables

- the value of variable A at the location of the maximum difference

- the value of variable B at the location of the maximum difference

- the first (X in Cartesian) coordinate of the location of the maximum difference

- the second (Y in Cartesian) coordinate of the location of the maximum difference

- the third (Z in Cartesian) coordinate of the location of the maximum difference

The names of the vectors declared are `Difference`, the name of the [!param](/VectorPostprocessors/ElementVariablesDifferenceMax/compare_a) variable,
the name of the [!param](/VectorPostprocessors/ElementVariablesDifferenceMax/compare_b) variable, and finally `X`, `Y`, `Z` for the location of the maximum difference.

### Example input syntax

In this example, we compare variable `u` and `v` using a `ElementVariablesDifferenceMax` vector postprocessor.





## ExtraIDIntegralVectorPostprocessor



### Overview

The `ExtraIDIntegralVectorPostprocessor` object is a vector postprocessor to integrate or average input variables or material properties based on multiple extra element integer IDs.
First, it finds unique combinations of extra IDs, and then it computes separate integral values over input variables and material properties for elements with these unique combinations.
For reactor applications, component-wise values such as pin-by-pin power distribution can be easily tallied using this object when the mesh contains the appropriate IDs.

The `ExtraIDIntegralVectorPostprocessor` object needs the following parameter:

- [!param](/VectorPostprocessors/ExtraIDIntegralVectorPostprocessor/id_name): list of extra IDs by which to separate integrals

The following parameters are optional, but at least one of them should be specified:

- [!param](/VectorPostprocessors/ExtraIDIntegralVectorPostprocessor/variable): variables that this VectorPostprocessor operates on.

- [!param](/VectorPostprocessors/ExtraIDIntegralVectorPostprocessor/mat_prop): material properties that this VectorPostprocessor operates on.

Additionally, a user can control whether volume-integrated values or volume-averaged values are computed by setting the following parameter:

- [!param](/VectorPostprocessors/ExtraIDIntegralVectorPostprocessor/average): whether or not to compute volume average.

`ExtraIDIntegralVectorPostprocessor` declares a vector for each variable or material property, named after the variable or material property, holding the values of the integrals computed.

### Example Syntax





## HistogramVectorPostprocessor

### Short Description


### Description

Used to compute the histogram for all columns of another VectorPostprocessor (VPP).  The only inputs are the other VPP (`vpp`) and the number of bins to use in the histogram (`num_bins`).

This will actually generate three columns for each column in the original VPP. The `column_name` is the name of the vector considered in the histogram and is also the
name used to declare the vector containing the histogram data.

- column_name: The histogram data for the vector in the original VPP
- column_name_lower: The lower bound for each bin
- column_name_upper: The upper bound for each bin


### Plotting

MOOSE comes with built-in plotting capabilities that can help plot the output of a HistogramVectorPostprocessor.  These plotting capabilities are part of the `Chigger` suite of visualization tools located in the `moose/python` directory.  To use them you must add the full path of your `moose/python` directory to the environment variable called `$PYTHONPATH` using something like:

```bash
export PYTHONPATH=/full/path/to/moose/python:$PYTHONPATH
```

Once that is completed a script such as the following will plot your data:

```python
import matplotlib.pyplot as plt
import mooseutils

## Create Figure and Axes
figure = plt.figure(facecolor='white')
axes0 = figure.add_subplot(111)

## Read Postprocessor Data
data = mooseutils.PostprocessorReader('histogram_vector_postprocessor_out_histo_0001.csv')

## Grab upper and lower bin bounds
lower = data('value_lower')
upper = data('value_upper')

## Compute the midpoint and width of each bin
mid = (lower + upper) / 2.0
width = upper - lower

## Grab the data to be plotted
y = data('value')

## Plot everything
axes0.bar(mid, y, width=width)

## Show the plot and save it
plt.show()
figure.savefig("output.pdf")
```




## IntersectionPointsAlongLine


The CSV output consists of the X, Y and Z coordinates of the intersection points between the faces/sides of the elements and the line.
The `IntersectionPointsAlongLine` vector postprocessor declares a vector for each coordinate of the intersection points, named `x`, `y` and `z`.

This object only supports replicated meshes. A distributed version of this object may be created using the [ray tracing module](modules/ray_tracing/index.md optional=True).




## LeastSquaresFit


### Description

`LeastSquaresFit` is used perform a polynomial least squares fit of data provided through another VectorPostprocessor. It computes the coefficients for a polynomial of arbitrary, user-specified order that minimize the error using a standard least-squares procedure.  This object provides the option of either outputting the polynomial coefficients of the least squares fit as a single vector, or outputting a user-defined number of samples from the polynomial using the fitted coefficients.

This VectorPostprocessor is closely related to the [LeastSquaresFitHistory](/LeastSquaresFitHistory.md) VectorPostprocessor, which performs the same type of least squares fit, but stores the results in a set of vectors that store the full history of the individual coefficients over a transient analysis.

The vectors of values of the independent ($x$) and dependent ($y$) variables on which the least squares fit is performed are provided through another VectorPostprocessor, which must provide two equally-sized vectors of data upon which to operate.  The name of this VectorPostprocessor is provided using the `vectorpostprocessor` parameter, and the names of the data vectors are provided with the `x_name` and `y_name` parameters. The vectors of data can be shifted and/or scaled through the use of optional parameters.

By default, if an insufficient number of points is provided in these data vectors, the order of the polynomial will be truncated to one less than the number of points. If the `truncate_order   parameter is set to `false`, an error will be generated in this case.

The user must define whether the output should be in the form of polynomial coefficients or samples using the `output` parameter. If the option to output polynomial coefficients is used, they are stored in a vector named `coefficients`. If samples are requested, the names of the sample vectors are the same as those of the data specified by `x_name` and `y_name`.




## LeastSquaresFitHistory


### Description

`LeastSquaresFitHistory` is used perform a polynomial least squares fit of data provided through another VectorPostprocessor. It computes the coefficients for a polynomial of arbitrary, user-specified order that minimize the error using a standard least-squares procedure.This object stores the polynomial coefficients in a set of vectors that contain the full history of those values for a transient analysis.

This VectorPostprocessor is closely related to the [LeastSquaresFit](/LeastSquaresFit.md) VectorPostprocessor, which performs the same type of least squares fit, but stores the results in a single vector, the history of which is not stored.

The polynomial coefficients are stored in a set of vectors named `coef_0` through `coef_n`, where $n$ is the specified order of the polynomial. Each of these vectors stores the full history of its coefficient in time, so that the combination of component $i$ for each of these vectors defines the polynomial fit for time step $i$. In addition, a vector named `time` stores the values of the solution time for each step of a transient analysis.

The vectors of values of the independent ($x$) and dependent ($y$) variables on which the least squares fit is performed are provided through another VectorPostprocessor, which must provide two equally-sized vectors of data upon which to operate.  The name of this VectorPostprocessor is provided using the `vectorpostprocessor` parameter, and the names of the data vectors are provided with the `x_name` and `y_name` parameters. The vectors of data can be shifted and/or scaled through the use of optional parameters.

By default, if an insufficient number of points is provided in these data vectors, the order of the polynomial will be truncated to one less than the number of points. If the `truncate_order   parameter is set to `false`, an error will be generated in this case.




## LineFunctionSampler


The output to CSV is by default ordered as follows:

- rows are ordered by point sampled along the line

- columns are ordered by alphabetical order of the functions sampled. The distance along the sampled line, and the x, y and z coordinates of the sampled points are added to the output as additional columns.


The order can be changed using the `sort_by` parameter.

`LineFunctionSampler` declares a vector for each spatial coordinate, (`x`, `y`, `z`), of the sampled points,
the distance along the sampled line in a vector called `id`,
and a vector named after each function sampled, containing the function values at each point.

### Example input syntax

In this example, the `LineFunctionSampler` is used to sample two functions across a line from '0 0 0' to '1 1 0'. The functions are specified directly in the `functions` parameter as their simple definition in terms of the x and y coordinates can be parsed directly. Functions are usually specified in the `[Functions]` block.





## LineMaterialRealSampler


### Overview

This class samples Real material properties for the integration points
in all elements that are intersected by a user-defined line.

The output to CSV is +by default+ ordered as follows:

- rows are ordered by point sampled along the line

- columns are ordered by alphabetical order of the properties sampled. The distance along the sampled line and the x, y and z coordinates of the sampled points are added to the output as additional columns.

`LineMaterialSampler` declares a vector for each spatial coordinate, (`x`, `y`, `z`), of the sampled points,
the distance along the sampled line in a vector called `id`,
and a vector named after each material property sampled, containing the material property values at each point.

### Example Input File Syntax

In this example, the material property `matp` is being sampled along the segment between
'0.125 0.375 0.0' and '0.875 0.375 0.0'. The output is then sorted by the element ids along
this line.





## LineValueSampler


### Description

LineValueSampler samples the given variables/auxvariables at equally spaced points between the start and end points of a user provided line segment. The sampled points and the values are written to a csv file at every time step. The sorting order of the points can be changed using the `sort_by` parameter which takes `x`, `y`, `z` or `id` (increasing distance from start point) as input.

LineValueSampler could also be used as an UserObject with the [MultiAppUserObjectTransfer.md] to transfer values to AuxVariables in the master or sub application. When using the LineValueSampler with the [MultiAppUserObjectTransfer.md], an error is generated if more than one variable is supplied as input to the LineValueSampler as the transfer currently works only with one variable. Also, when calculating the value of the UserObject (LineValueSampler in this case) at a given point, the point is first projected onto the user defined line segment and the interpolated value at the projected point is returned as output. If the projected point falls outside the line segment, infinity is returned as output.

If the variable to be plotted needs to be scaled, this can be done by supplying a postprocessor. Caution should be used to make sure that the postprocessor is being evaluated in such a way that its value will not be lagged when being called by LineValueSampler.

If the line value sampler is used with a discontinuous variable on the edge/face of a 2D/3D element, then the value from the element with the lowest ID will be returned.

`LineValueSampler` declares a vector for each spatial coordinate, (`x`, `y`, `z`), of the sampled points,
the distance along the sampled line in a vector called `id`,
and a vector named after each value sampled, containing the variable values at each point.

The `LineValueSampler` samples variables on the specified line. For more flexible sampling,
use the [PositionsFunctorValueSampler.md].




## MeshDivisionFunctorReductionVectorPostprocessor


This object is designed to allow a lot of flexibility in its uses.
Because it leverages [Functors](syntax/Functors/index.md), it can perform reductions on many different quantities/fields.
Because it uses a [MeshDivision](syntax/MeshDivisions/index.md), it can split the mesh in many different ways.
Because it uses a [!param](/VectorPostprocessors/MeshDivisionFunctorReductionVectorPostprocessor/reduction) parameter
instead of hard-coding a reduction, it can perform several operations like element integrations, averages, or the search
for an extrema.

For example, this object is strictly equivalent to a [NearestPointIntegralVariablePostprocessor.md] with:
- a variable for its [!param](/VectorPostprocessors/MeshDivisionFunctorReductionVectorPostprocessor/functors) parameter
- a [NearestPositionsDivision.md] for its [!param](/VectorPostprocessors/MeshDivisionFunctorReductionVectorPostprocessor/mesh_division) parameter (and the Positions object should be selected to match the points wanted for the nearest-point regions)
- and 'integral' for the [!param](/VectorPostprocessors/MeshDivisionFunctorReductionVectorPostprocessor/reduction) parameter


### Out-of-bounds behavior

If there are no elements within the subdomains of the `MeshDivisionFunctorReductionVectorPostprocessor`
for some of the bins of the user-specified [!param](/VectorPostprocessors/MeshDivisionFunctorReductionVectorPostprocessor/mesh_division),
the returned value of the reduction will be:

- 0 for an average and an integral reduction
- the maximum floating point number (a very large positive number, depending on the `Real` floating point number type used) for a minimum
- the minimum floating point number (minus the number mentioned above) for a maximum

If there are elements within the subdomains of the `MeshDivisionFunctorReductionVectorPostprocessor` that
are outside the user-specified [!param](/VectorPostprocessors/MeshDivisionFunctorReductionVectorPostprocessor/mesh_division),
a warning will be output and the elements will be ignored.




## NodalValueSampler


This `VectorPostprocessor` is used for sampling nodal variables at each node
in the domain, selection of blocks, or selection of boundaries.

`NodalValueSampler` declares a vector for each spatial coordinate, (`x`, `y`, `z`), of the sampled nodes,
the IDs of the nodes in a vector named `id`,
and a vector named after each variable sampled, containing the variable values at each point.

The `NodalValueSampler` samples nodal variables at the mesh nodes. For more flexible sampling,
use the [PositionsFunctorValueSampler.md].




## PointValueSampler


If the point value sampler is used with a discontinuous variable on the edge/face of a 2D/3D element, then the value from the element with the lowest ID will be returned.

The CSV output, with rows for each sampled point, contains the columns listed below. The vectors declared by `PointValueSampler`
share the same names as the column headers.

- the id of the elements containing the sampled points, with the convention mentioned above

- the values of the variable(s) requested

- the x, y and z coordinates of the requested sampled points

The `PointValueSampler` samples variables at the specified points. For more flexible sampling,
use the [PositionsFunctorValueSampler.md].

### Example input syntax

In this example, the variables `u` and `v` are sampled at three points, `(0.1 0.1 0)`, `(0.23 0.4 0)` and `(0.78 0.2 0)` using a `PointValueSampler`.





## PositionsFunctorValueSampler


If the point value sampler is used with a functor that is discontinuous at the edge/face of a 2D/3D element, then the value from the element with the lowest ID will be returned, if and only if the user declared the functor as discontinuous using the [!param](/VectorPostprocessors/PositionsFunctorValueSampler/discontinuous) parameter.

The CSV output, with rows for each sampled point, contains the columns listed below. The vectors declared by `PositionsFunctorValueSampler`
share the same names as the column headers.

- the id of the elements containing the sampled points, with the convention mentioned above

- the values of the functor(s) requested

- the x, y and z coordinates of the requested sampled points




## SidesetInfoVectorPostprocessor


### Description

`SidesetInfoVectorPostprocessor` assembles information from sidesets and prints them to
a csv file. Currently, it allows to obtain `area`, `centroid`, and the bounding box
via `min` and `max`. `min` contains the minimum x, y, z coordinates of the
sideset, while `max` contains the respective maximum values. Note that `centroid`
is not guaranteed to be a point contained in the sideset.

`SidesetInfoVectorPostprocessor` uses the following names for the vectors / CSV column headers: 
`Boundary IDs`, `centroid_x`, `centroid_y`, `min_x`, `min_y`, `max_x`, `max_y`, `area`.




## SideValueSampler


The data output to CSV is output with the columns listed below. The declared vectors use the same
names.

- the id of the element that the quadrature point, on the side, belongs to

- the values of the requested variables, with a column named after each variable

- the X, Y, Z coordinates of the quadrature points on the side

The `SideValueSampler` samples variables on the specified boundary on element side quadrature points. For more flexible sampling,
use the [PositionsFunctorValueSampler.md].

### Example input syntax

In this example, variable `u` and `v` are the solutions of two boundary value diffusion problems. Their value along the `top` boundary and along the `center` internal sidesets are reported using two `SideValueSampler`. The rows in the CSV output are sorted according the `x` coordinate along the boundary for the former, and the element `id` for the latter.





## SpatialUserObjectVectorPostprocessor


### Overview

This VectorPostprocessor evaluates a spatial user object at a set of points
and sets each postprocessor to the spatial value of the user object at each point.
This postprocessor may be used to convert spatial user objects such as
[NearestPointLayeredAverage](/userobjects/NearestPointLayeredAverage.md) to a
postprocessor that can be transferred to another application with a
[MultiAppVectorPostprocessorTransfer](/transfers/MultiAppVectorPostprocessorTransfer.md).

If neither [!param](/VectorPostprocessors/SpatialUserObjectVectorPostprocessor/points)
or [!param](/VectorPostprocessors/SpatialUserObjectVectorPostprocessor/points_file) are
provided, this object will attempt to get the spatial points directly from the user object.
These points will represent locations in space where the user object obtains a unique value.
To use this feature, the user object must define the `spatialPoints()` interface.

`SpatialUserObjectVectorPostprocessor` declares a vector with its own name. The full reporter name ends up being `<vpp_object_name>/<vpp_object_name>`.

### Example Input File Syntax

  start=UserObjects
  end=Executioner




## SphericalAverage


The distance computed for the binning is based on the location of the quadrature points.

The average is an average over quadrature points! The specific weight / volume associated with each quadrature point is not taken into account. The `SpatialAverageBase::execute` routine should be modified for that purpose.

The CSV data output consists of the following columns, ordered by column name:

- variable average value

- average of inner and outer radius of each shell of the sphere

`SphericalAverage` declares a vector for the average shell radii, named `radius`, and a vector for each variable requested, named with the variable name.
Prepend with the name of the `SphericalAverage` object to obtain the reporter name of each vector.

### Example input syntax

In this example, the average of the variable `c` is computed for `10` layers (=bins) of a sphere of radius `5` around the origin `0 0 0` (default).





## VariableValueVolumeHistogram


This VectorPostprocessor lets you tabulate the volumes in the simulation domain where a given variable has certain values.

The CSV output contains the two columns for:

- the variable value bins upper values, with the name of the variable in the first row (header)

- the volume in which the variable holds the values within the bins, with the name `n` in the first row

The names of the vectors declared by `VariableValueVolumeHistogram` match the CSV output column header names.

### Example input syntax




## VectorMemoryUsage


This vector postprocessor generates multiple output columns with one row per MPI rank

| Column name   | Description |
|---------------|--------------|
| `hardware_id` | Ranks with a common hardware ID share common RAM (i.e. are located on the same compute node) |
| `total_ram`   | Total available RAM on the compute node the respective MPI rank is located on. |
| `physical_mem` | Physical memory the current rank uses (default unit: MBs). |
| `virtual_mem` | Virtual memory the current rank uses (the amount returned strongly depends on the operating system and does not reflect the physical RAM used by the simulation - default unit: MBs). |
| `page_faults` | Number of hard page faults encountered by the MPI rank. This number is only available on Linux systems and indicates the amount of swap activity (indicating low performance due to insufficient available RAM) |
| `node_utilization` | Indicates which fraction of the total RAM available on the compute node is occupied by MOOSE processes of the current simulation. |

For a Postprocessor that provides min/max/average memory statistics see
[`MemoryUsage`](/MemoryUsage.md).

### Example visualizations

This VectorPostprocessor can be visualized using the
[`VectorPostprocessorVisualizationAux`](/VectorPostprocessorVisualizationAux.md)
AuxKernel.
Both the IDs:


    caption=Refined grid

    caption=Processor id (using [`ProcessorIDAux`](/ProcessorIDAux.md))

    caption=Hardware id (i.e. compute node)


and the memory used:


    caption=Physical memory used by rank

    caption=Fraction of RAM used by the current simulation on the compute node


Due to differences in the data collection method, the memory consumption may be slightly different from
the [PerfGraphOutput.md].




## VectorOfPostprocessors


This vector postprocessor is mainly used for two purposes:

- to output only a selection of postprocessors to a desired CSV file, similarly to a `CSV` output. The CSV output of the `VectorOfPostprocessors` is then column-ordered by the order of postprocessor specified in the `postprocessors` parameter.

- to combine postprocessors to match the expected vector postprocessor input of a kernel, a user object, etc

`VectorOfPostprocessors` declares a vector with its own name. The full reporter name ends up being `<vpp_object_name>/<vpp_object_name>`.

### Example input syntax

In this example, the `min` and `max` postprocessors are combined in the `min_max` `VectorOfPostprocessors`.





## WorkBalance

### Short Description


### Description

The idea here is to compute per-processor metrics to help in determining the quality of a partitioning.

Currently computes: number of local elements, nodes, dofs and partition sides.  The partition sides are the sides of elements that are on processor boundaries (also known as the "edge-cuts" in partitioner lingo).  Also computes the "surface area" of each partition (physically, how much processor boundary each partitioning has).

The names of the vectors declared by `WorkBalance` are the names of the [!param](/VectorPostprocessors/WorkBalance/balances) requested.

#### HardwareID

`WorkBalance` will now also compute the number of sides and the surface area for the partition on each compute node (called "hardware_id" here) in the cluster.  This gives the amount of "inter-node" communication.  Use of a hierarchical partitioner (like the one available in [PetscExternalPartitioner](PetscExternalPartitioner.md)) can help reduce inter-node communication.

For instance, here is a 1600x1600 mesh partitioned to run on 64 nodes, each having 36 processors (2304 processors total).  Using `WorkBalance` and [VectorPostprocessorVisualizationAux](VectorPostprocessorVisualizationAux.md) we can visually see how much inter-node communication there is and quantify it.





