'This is the overall description of the simulation:\n### Simulation Description\n\n#### Geometry and Mesh\n- The geometry is a 2D rectangular plate with dimensions 2 m × 1 m.\n- The plate is modeled in a Cartesian coordinate system.\n- The mesh is structured, with a uniform grid spacing. For example, the plate can be divided into 200 elements along the length (2 m) and 100 elements along the height (1 m), resulting in a total of 20,000 quadrilateral elements.\n\n#### Physical Processes\n- The simulation involves linear elastic mechanics.\n- The goal is to compute the stress and strain fields in the plate under the given loading and boundary conditions.\n\n#### Boundary Conditions\n- The left edge of the plate (x = 0) is fixed, meaning both horizontal and vertical displacements are zero (Dirichlet boundary condition).\n- The right edge of the plate (x = 2 m) is subjected to a uniform tensile stress of 5 MPa in the horizontal direction.\n- The top and bottom edges are free of stress (Neumann boundary condition).\n\n#### Material Properties\n- The material is linear elastic with the following properties:\n  - Young’s modulus, E = 200 GPa\n  - Poisson’s ratio, ν = 0.3\n\n#### Solution Settings\n- The simulation is static, solving for equilibrium under the applied loads.\n- A finite element method (FEM) solver is used.\n- Convergence criteria: The solution is considered converged when the residual force norm is below 1e-6.\n\n#### Post-Processing\n- Compute and visualize the stress and strain fields in the plate.\n- Extract the maximum principal stress and strain values from the results.\n\nPlease confirm if the above simulation description meets your requirements.\n\nThe input file provided by the Writer Agent is as follows:\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 200\n  ny = 100\n  xmin = 0.0\n  xmax = 2.0\n  ymin = 0.0\n  ymax = 1.0\n[]\n\n[GlobalParams]\n  displacements = \'disp_x disp_y\'\n[]\n\n[Physics/SolidMechanics/QuasiStatic]\n  [./all]\n    strain = SMALL\n    add_variables = true\n    generate_output = \'stress_xx stress_xy stress_yy\'\n  [../]\n[]\n\n[Materials]\n  [./elastic_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 200e9\n    poissons_ratio = 0.3\n  [../]\n  [./stress]\n    type = ComputeLinearElasticStress\n  [../]\n[]\n\n[BCs]\n  [./fixed_left]\n    type = DirichletBC\n    variable = disp_x\n    boundary = left\n    value = 0.0\n  [../]\n  [./fixed_bottom]\n    type = DirichletBC\n    variable = disp_y\n    boundary = left\n    value = 0.0\n  [../]\n  [./tensile_right]\n    type = NeumannBC\n    variable = disp_x\n    boundary = right\n    value = 5e6\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  nl_rel_tol = 1e-6\n  nl_abs_tol = 1e-10\n  nl_max_its = 15\n  l_tol = 1e-6\n  l_max_its = 100\n  start_time = 0.0\n  end_time = 1.0\n  dt = 1.0\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nAnd this is similar simulation cases if json format:\n{"input_card_name": "solid_mechanics_neml2_rate_independent_plasticity_isoharden.i", "overall_description": "This input card is designed for simulating solid mechanics behavior using the MOOSE framework, specifically focusing on rate-independent plasticity with isotropic hardening. The simulation involves a cubic mesh generated with 2 elements in each dimension, resulting in a total of 8 elements. The physics of the simulation is governed by small strain theory, and it employs a quasi-static formulation. Essential boundary conditions are applied to fix displacements at three boundaries (left, bottom, and back) while allowing a time-dependent displacement on the right boundary. The NEML2 app is utilized to handle the material model, which includes various inputs and outputs related to stress and strain. The executioner is set to transient, solving the system using Newton\'s method over 5 time steps with a specified time step size. The outputs are configured to be saved in Exodus format.", "annotated_input_card": "# The input card for a finite element simulation using MOOSE, specifically for rate-independent plasticity with isotropic hardening.\\nneml2_input = rate_independent_plasticity_isoharden  # Specifies the NEML2 model to be used for the simulation.\\nN = 2  # Defines the number of elements in each dimension of the mesh.\\n\\n[GlobalParams]  # Section defining global parameters for the simulation.\\n  displacements = \'disp_x disp_y disp_z\'  # Specifies the displacement variables to be used in the simulation.\\n[]\\n\\n[Mesh]  # Section defining the mesh for the simulation.\\n  [gmg]  # Using the GeneratedMeshGenerator to create the mesh.\\n    type = GeneratedMeshGenerator  # Specifies the type of mesh generator.\\n    dim = 3  # Indicates that the mesh is three-dimensional.\\n    nx = ${N}  # Number of elements in the x-direction, set to the value of N.\\n    ny = ${N}  # Number of elements in the y-direction, set to the value of N.\\n    nz = ${N}  # Number of elements in the z-direction, set to the value of N.\\n  []\\n[]\\n\\n[Physics]  # Section defining the physics of the simulation.\\n  [SolidMechanics]  # Using the SolidMechanics app for simulating solid mechanics behavior.\\n    [QuasiStatic]  # Specifies that the simulation is quasi-static.\\n      [all]  # Applies settings to all components of the quasi-static simulation.\\n        strain = SMALL  # Indicates that small strain theory is used.\\n        new_system = true  # Indicates that a new system of equations is being solved.\\n        add_variables = true  # Allows additional variables to be added to the system.\\n        formulation = TOTAL  # Specifies that the total formulation is used.\\n        volumetric_locking_correction = true  # Enables correction for volumetric locking in the formulation.\\n      []\\n    []\\n  []\\n[]\\n\\n[NEML2]  # Section defining the NEML2 model parameters.\\n  input = \'models/${neml2_input}.i\'  # Specifies the input file for the NEML2 model.\\n  [all]  # Applies settings to all components of the NEML2 model.\\n    model = \'model\'  # Name of the model to be used.\\n    verbose = true  # Enables verbose output for debugging purposes.\\n    device = \'cpu\'  # Specifies that the computation will be performed on the CPU.\\n\\n    moose_input_types = \'MATERIAL     POSTPROCESSOR POSTPROCESSOR MATERIAL              MATERIAL\'  # Defines the types of inputs for MOOSE.\\n    moose_inputs = \'     neml2_strain time          time          plastic_strain        equivalent_plastic_strain\'  # Specifies the MOOSE inputs.\\n    neml2_inputs = \'     forces/E     forces/t      old_forces/t  old_state/internal/Ep old_state/internal/ep\'  # Specifies the NEML2 inputs.\\n\\n    moose_output_types = \'MATERIAL     MATERIAL          MATERIAL\'  # Defines the types of outputs for MOOSE.\\n    moose_outputs = \'     neml2_stress plastic_strain    equivalent_plastic_strain\'  # Specifies the MOOSE outputs.\\n    neml2_outputs = \'     state/S      state/internal/Ep state/internal/ep\'  # Specifies the NEML2 outputs.\\n\\n    moose_derivative_types = \'MATERIAL\'  # Defines the types of derivatives for MOOSE.\\n    moose_derivatives = \'neml2_jacobian\'  # Specifies the MOOSE derivatives.\\n    neml2_derivatives = \'state/S forces/E\'  # Specifies the NEML2 derivatives.\\n  []\\n[]\\n\\n[Postprocessors]  # Section defining postprocessors for the simulation.\\n  [time]  # A postprocessor to report the current time.\\n    type = TimePostprocessor  # Specifies the type of postprocessor.\\n    execute_on = \'INITIAL TIMESTEP_BEGIN\'  # Indicates when this postprocessor should execute.\\n  []\\n[]\\n\\n[Materials]  # Section defining materials used in the simulation.\\n  [convert_strain]  # A material object to convert strain types.\\n    type = RankTwoTensorToSymmetricRankTwoTensor  # Specifies the type of conversion.\\n    from = \'mechanical_strain\'  # Indicates the source strain variable.\\n    to = \'neml2_strain\'  # Indicates the target strain variable.\\n  []\\n  [stress]  # A material object to compute stress.\\n    type = ComputeLagrangianObjectiveCustomSymmetricStress  # Specifies the type of stress computation.\\n    custom_small_stress = \'neml2_stress\'  # Specifies the custom stress variable.\\n    custom_small_jacobian = \'neml2_jacobian\'  # Specifies the custom Jacobian variable.\\n  []\\n[]\\n\\n[BCs]  # Section defining boundary conditions for the simulation.\\n  [xfix]  # Boundary condition fixing displacement in the x-direction.\\n    type = DirichletBC  # Specifies the type of boundary condition.\\n    variable = disp_x  # Indicates the variable affected by this boundary condition.\\n    boundary = left  # Specifies the boundary where this condition applies.\\n    value = 0  # Sets the value of the boundary condition to zero.\\n  []\\n  [yfix]  # Boundary condition fixing displacement in the y-direction.\\n    type = DirichletBC  # Specifies the type of boundary condition.\\n    variable = disp_y  # Indicates the variable affected by this boundary condition.\\n    boundary = bottom  # Specifies the boundary where this condition applies.\\n    value = 0  # Sets the value of the boundary condition to zero.\\n  []\\n  [zfix]  # Boundary condition fixing displacement in the z-direction.\\n    type = DirichletBC  # Specifies the type of boundary condition.\\n    variable = disp_z  # Indicates the variable affected by this boundary condition.\\n    boundary = back  # Specifies the boundary where this condition applies.\\n    value = 0  # Sets the value of the boundary condition to zero.\\n  []\\n  [xdisp]  # Boundary condition applying a function in the x-direction.\\n    type = FunctionDirichletBC  # Specifies the type of boundary condition.\\n    variable = disp_x  # Indicates the variable affected by this boundary condition.\\n    boundary = right  # Specifies the boundary where this condition applies.\\n    function = t  # Specifies the function to apply for the boundary condition.\\n    preset = false  # Indicates that this condition should not be preset before solving.\\n  []\\n[]\\n\\n[Executioner]  # Section defining the executioner for the simulation.\\n  type = Transient  # Specifies that the simulation is transient.\\n  solve_type = NEWTON  # Specifies the type of solver to use (Newton\'s method).\\n  petsc_options_iname = \'-pc_type\'  # Specifies the PETSc options for the solver.\\n  petsc_options_value = \'lu\'  # Specifies the value for the PETSc options.\\n  automatic_scaling = true  # Enables automatic scaling of variables.\\n  dt = 1e-3  # Sets the time step size for the simulation.\\n  dtmin = 1e-3  # Sets the minimum time step size.\\n  num_steps = 5  # Specifies the number of time steps to take in the simulation.\\n  residual_and_jacobian_together = true  # Indicates that the residual and Jacobian should be computed together.\\n[]\\n\\n[Outputs]  # Section defining the outputs of the simulation.\\n  file_base = \'${neml2_input}\'  # Base name for the output files.\\n  exodus = true  # Specifies that the output should be in Exodus format.\\n[]\\n\\n"}{"input_card_name": "solid_mechanics_generalized_plane_strain_out_of_plane_pressure.i", "overall_description": "This input card is designed for simulating the application of out-of-plane pressure in a generalized plane strain scenario using the MOOSE framework. The mesh is generated as a 2D square with 2 elements in each direction, and it incorporates displacement variables for both the X and Y directions. The physics module focuses on solid mechanics, specifically generalized plane strain, where the out-of-plane strain is considered. The boundary conditions are defined as Dirichlet conditions, fixing the displacements on the left and bottom boundaries. The material properties are defined for isotropic elasticity, small strain, and linear elastic stress. The executioner is set for transient analysis, allowing for time-dependent simulations. The output is configured to be in Exodus format, facilitating post-processing of the results. The main applications used in this input card include the SolidMechanics, ComputeIsotropicElasticityTensor, ComputePlaneSmallStrain, and ComputeLinearElasticStress apps, which collectively enable the simulation of mechanical behavior under specified loading conditions.", "annotated_input_card": "# Tests for application of out-of-plane pressure in generalized plane strain.\\n\\n[Mesh]\\n  [./square]\\n    type = GeneratedMeshGenerator  # Specifies the type of mesh generator to use, in this case, a generated mesh.\\n    dim = 2  # The dimension of the mesh, here it is 2D.\\n    nx = 2  # Number of elements in the X direction.\\n    ny = 2  # Number of elements in the Y direction.\\n  [../]\\n  displacements = \'disp_x disp_y\'  # Specifies the displacement variables for the mesh.\\n[]\\n\\n[Variables]\\n  [./disp_x]  # Displacement in the X direction.\\n  [../]\\n  [./disp_y]  # Displacement in the Y direction.\\n  [../]\\n  [./scalar_strain_zz]  # Scalar variable for out-of-plane strain.\\n    order = FIRST  # Specifies the order of the variable, here it is first order.\\n    family = SCALAR  # Indicates that this variable is a scalar.\\n  [../]\\n[]\\n\\n[AuxVariables]\\n  [./saved_x]  # Auxiliary variable to save the X displacement.\\n    order = FIRST  # First order auxiliary variable.\\n    family = LAGRANGE  # Lagrange family for the variable.\\n  [../]\\n  [./saved_y]  # Auxiliary variable to save the Y displacement.\\n    order = FIRST  # First order auxiliary variable.\\n    family = LAGRANGE  # Lagrange family for the variable.\\n  [../]\\n\\n  [./stress_xx]  # Component of stress tensor in the X direction.\\n    order = CONSTANT  # Constant order for this variable.\\n    family = MONOMIAL  # Monomial family for the variable.\\n  [../]\\n  [./stress_xy]  # Component of stress tensor in the XY plane.\\n    order = CONSTANT  # Constant order for this variable.\\n    family = MONOMIAL  # Monomial family for the variable.\\n  [../]\\n  [./stress_yy]  # Component of stress tensor in the Y direction.\\n    order = CONSTANT  # Constant order for this variable.\\n    family = MONOMIAL  # Monomial family for the variable.\\n  [../]\\n  [./stress_zz]  # Component of stress tensor in the Z direction.\\n    order = CONSTANT  # Constant order for this variable.\\n    family = MONOMIAL  # Monomial family for the variable.\\n  [../]\\n\\n  [./strain_xx]  # Component of strain tensor in the X direction.\\n    order = CONSTANT  # Constant order for this variable.\\n    family = MONOMIAL  # Monomial family for the variable.\\n  [../]\\n  [./strain_xy]  # Component of strain tensor in the XY plane.\\n    order = CONSTANT  # Constant order for this variable.\\n    family = MONOMIAL  # Monomial family for the variable.\\n  [../]\\n  [./strain_yy]  # Component of strain tensor in the Y direction.\\n    order = CONSTANT  # Constant order for this variable.\\n    family = MONOMIAL  # Monomial family for the variable.\\n  [../]\\n  [./strain_zz]  # Component of strain tensor in the Z direction.\\n    order = CONSTANT  # Constant order for this variable.\\n    family = MONOMIAL  # Monomial family for the variable.\\n  [../]\\n[]\\n\\n[Postprocessors]\\n  [./react_z]  # Postprocessor to compute the reaction force in the Z direction.\\n    type = MaterialTensorIntegral  # Type of postprocessor to compute an integral of a material tensor.\\n    rank_two_tensor = stress  # Specifies the stress tensor to be used.\\n    index_i = 2  # Index for the tensor component in the Z direction.\\n    index_j = 2  # Index for the tensor component in the Z direction.\\n  [../]\\n[]\\n\\n[Physics]\\n  [SolidMechanics]  # Solid mechanics physics module.\\n    [./GeneralizedPlaneStrain]  # Generalized plane strain formulation.\\n      [./gps]  # Generalized plane strain settings.\\n        use_displaced_mesh = true  # Indicates that the displaced mesh should be used for calculations.\\n        displacements = \'disp_x disp_y\'  # Specifies the displacement variables.\\n        scalar_out_of_plane_strain = scalar_strain_zz  # Scalar variable for out-of-plane strain.\\n        out_of_plane_pressure_function = traction_function  # Function to define out-of-plane pressure.\\n        pressure_factor = 1e5  # Factor to scale the pressure applied.\\n      [../]\\n    [../]\\n  [../]\\n[]\\n\\n[Kernels]\\n  [SolidMechanics]  # Solid mechanics kernel.\\n    use_displaced_mesh = false  # Indicates that the undisplaced mesh should be used for calculations.\\n    displacements = \'disp_x disp_y\'  # Specifies the displacement variables.\\n    save_in = \'saved_x saved_y\'  # Specifies where to save the displacement variables.\\n  [../]\\n[]\\n\\n[AuxKernels]\\n  [./stress_xx]  # Auxiliary kernel for stress in the X direction.\\n    type = RankTwoAux  # Type of auxiliary kernel to access a component of a rank two tensor.\\n    rank_two_tensor = stress  # Specifies the stress tensor to be accessed.\\n    variable = stress_xx  # Variable to store the stress in the X direction.\\n    index_i = 0  # Index for the X component of the stress tensor.\\n    index_j = 0  # Index for the X component of the stress tensor.\\n  [../]\\n  [./stress_xy]  # Auxiliary kernel for stress in the XY plane.\\n    type = RankTwoAux  # Type of auxiliary kernel to access a component of a rank two tensor.\\n    rank_two_tensor = stress  # Specifies the stress tensor to be accessed.\\n    variable = stress_xy  # Variable to store the stress in the XY plane.\\n    index_i = 0  # Index for the X component of the stress tensor.\\n    index_j = 1  # Index for the Y component of the stress tensor.\\n  [../]\\n  [./stress_yy]  # Auxiliary kernel for stress in the Y direction.\\n    type = RankTwoAux  # Type of auxiliary kernel to access a component of a rank two tensor.\\n    rank_two_tensor = stress  # Specifies the stress tensor to be accessed.\\n    variable = stress_yy  # Variable to store the stress in the Y direction.\\n    index_i = 1  # Index for the Y component of the stress tensor.\\n    index_j = 1  # Index for the Y component of the stress tensor.\\n  [../]\\n  [./stress_zz]  # Auxiliary kernel for stress in the Z direction.\\n    type = RankTwoAux  # Type of auxiliary kernel to access a component of a rank two tensor.\\n    rank_two_tensor = stress  # Specifies the stress tensor to be accessed.\\n    variable = stress_zz  # Variable to store the stress in the Z direction.\\n    index_i = 2  # Index for the Z component of the stress tensor.\\n    index_j = 2  # Index for the Z component of the stress tensor.\\n  [../]\\n\\n  [./strain_xx]  # Auxiliary kernel for strain in the X direction.\\n    type = RankTwoAux  # Type of auxiliary kernel to access a component of a rank two tensor.\\n    rank_two_tensor = total_strain  # Specifies the total strain tensor to be accessed.\\n    variable = strain_xx  # Variable to store the strain in the X direction.\\n    index_i = 0  # Index for the X component of the strain tensor.\\n    index_j = 0  # Index for the X component of the strain tensor.\\n  [../]\\n  [./strain_xy]  # Auxiliary kernel for strain in the XY plane.\\n    type = RankTwoAux  # Type of auxiliary kernel to access a component of a rank two tensor.\\n    rank_two_tensor = total_strain  # Specifies the total strain tensor to be accessed.\\n    variable = strain_xy  # Variable to store the strain in the XY plane.\\n    index_i = 0  # Index for the X component of the strain tensor.\\n    index_j = 1  # Index for the Y component of the strain tensor.\\n  [../]\\n  [./strain_yy]  # Auxiliary kernel for strain in the Y direction.\\n    type = RankTwoAux  # Type of auxiliary kernel to access a component of a rank two tensor.\\n    rank_two_tensor = total_strain  # Specifies the total strain tensor to be accessed.\\n    variable = strain_yy  # Variable to store the strain in the Y direction.\\n    index_i = 1  # Index for the Y component of the strain tensor.\\n    index_j = 1  # Index for the Y component of the strain tensor.\\n  [../]\\n  [./strain_zz]  # Auxiliary kernel for strain in the Z direction.\\n    type = RankTwoAux  # Type of auxiliary kernel to access a component of a rank two tensor.\\n    rank_two_tensor = total_strain  # Specifies the total strain tensor to be accessed.\\n    variable = strain_zz  # Variable to store the strain in the Z direction.\\n    index_i = 2  # Index for the Z component of the strain tensor.\\n    index_j = 2  # Index for the Z component of the strain tensor.\\n  [../]\\n[]\\n\\n[Functions]\\n  [./traction_function]  # Function to define the traction applied.\\n    type = PiecewiseLinear  # Type of function for piecewise linear interpolation.\\n    x = \'0  2\'  # Abscissa values for the piecewise function.\\n    y = \'0  1\'  # Ordinate values for the piecewise function.\\n  [../]\\n[]\\n\\n[BCs]\\n  [./leftx]  # Dirichlet boundary condition on the left boundary.\\n    type = DirichletBC  # Type of boundary condition.\\n    boundary = 3  # Boundary ID for the left boundary.\\n    variable = disp_x  # Variable to apply the boundary condition to.\\n    value = 0.0  # Value of the boundary condition.\\n  [../]\\n  [./bottomy]  # Dirichlet boundary condition on the bottom boundary.\\n    type = DirichletBC  # Type of boundary condition.\\n    boundary = 0  # Boundary ID for the bottom boundary.\\n    variable = disp_y  # Variable to apply the boundary condition to.\\n    value = 0.0  # Value of the boundary condition.\\n  [../]\\n[]\\n\\n[Materials]\\n  [./elastic_tensor]  # Material properties for elasticity tensor.\\n    type = ComputeIsotropicElasticityTensor  # Type of material to compute isotropic elasticity tensor.\\n    poissons_ratio = 0.3  # Poisson\'s ratio for the material.\\n    youngs_modulus = 1e6  # Young\'s modulus for the material.\\n  [../]\\n  [./strain]  # Material properties for strain computation.\\n    type = ComputePlaneSmallStrain  # Type of material to compute small strain under generalized plane strain assumptions.\\n    displacements = \'disp_x disp_y\'  # Displacement variables for the material.\\n    scalar_out_of_plane_strain = scalar_strain_zz  # Scalar variable for out-of-plane strain.\\n  [../]\\n  [./stress]  # Material properties for stress computation.\\n    type = ComputeLinearElasticStress  # Type of material to compute stress using elasticity for small strains.\\n  [../]\\n  # This material is not used for anything in the base version of this test,\\n  # but is used in a variant of the test with cli_args\\n  [./traction_material]  # Material for traction function.\\n    type = GenericFunctionMaterial  # Type of material to declare properties populated by evaluation of Function object.\\n    prop_names = traction_material  # Names of the properties this material will have.\\n    prop_values = traction_function  # Corresponding names of the functions that will provide the values for the variables.\\n  [../]\\n[]\\n\\n[Executioner]\\n  type = Transient  # Executioner type for time-varying simulations.\\n\\n  solve_type = PJFNK  # Specifies the solver type to use.\\n  line_search = none  # Specifies the line search type.\\n\\n# controls for linear iterations\\n  l_max_its = 100  # Maximum linear iterations allowed.\\n  l_tol = 1e-4  # Linear relative tolerance.\\n\\n# controls for nonlinear iterations\\n  nl_max_its = 15  # Maximum nonlinear iterations allowed.\\n  nl_rel_tol = 1e-14  # Nonlinear relative tolerance.\\n  nl_abs_tol = 1e-11  # Nonlinear absolute tolerance.\\n\\n# time control\\n  start_time = 0.0  # Start time of the simulation.\\n  dt = 1.0  # Time step size.\\n  dtmin = 1.0  # Minimum time step size.\\n  end_time = 2.0  # End time of the simulation.\\n  num_steps = 5000  # Number of time steps to take.\\n[]\\n\\n[Outputs]\\n  exodus = true  # Specifies whether to output results in Exodus format.\\n[]\\n"}{"input_card_name": "solid_mechanics_lagrangian_cartesian_updated_convergence-auto_1D_neumann.i", "overall_description": "This input card defines a simple 1D plane strain test using the MOOSE framework. The simulation involves a one-dimensional mesh with 10 elements, where the displacement in the x-direction is modeled. The initial conditions for displacement are randomly generated within a specified range. The boundary conditions include a Dirichlet condition on the right boundary (fixed displacement) and a Neumann condition on the left boundary (applied load as a function of time). The material properties are defined using an isotropic elasticity tensor with specified Young\'s modulus and Poisson\'s ratio. The simulation is transient, utilizing a Newton solver with specified tolerances and iteration limits. Key apps used include the UpdatedLagrangianStressDivergence for stress calculations, RandomIC for initial conditions, and DirichletBC and FunctionNeumannBC for boundary conditions.", "annotated_input_card": "# Simple 1D plane strain test\\n\\n[GlobalParams]\\n  displacements = \'disp_x\'  # Specifies the variable representing displacements in the x-direction.\\n  large_kinematics = true  # Enables large kinematics, allowing for large deformations in the simulation.\\n  stabilize_strain = true  # Activates strain stabilization to improve numerical stability during the simulation.\\n[]\\n\\n[Variables]\\n  [disp_x]  # Declares a variable for displacements in the x-direction.\\n  []\\n[]\\n\\n[ICs]\\n  [disp_x]  # Initial conditions for the displacement variable.\\n    type = RandomIC  # Specifies that the initial condition will be randomly generated.\\n    variable = disp_x  # The variable to which the initial condition applies.\\n    min = -0.1  # Minimum value for the random initial condition.\\n    max = 0.1  # Maximum value for the random initial condition.\\n  []\\n[]\\n\\n[Mesh]\\n  [msh]  # Mesh generation block.\\n    type = GeneratedMeshGenerator  # Specifies the type of mesh generator to use.\\n    dim = 1  # Indicates that the mesh is one-dimensional.\\n    nx = 10  # Number of elements in the x-direction.\\n  []\\n[]\\n\\n[Kernels]\\n  [sdx]  # Kernel for stress divergence in the updated Lagrangian formulation.\\n    type = UpdatedLagrangianStressDivergence  # Specifies the kernel type for stress divergence.\\n    variable = disp_x  # The variable this kernel operates on.\\n    component = 0  # Specifies the component of the variable to use (0 for x-direction).\\n    use_displaced_mesh = true  # Indicates that the displaced mesh should be used for calculations.\\n  []\\n[]\\n\\n[Functions]\\n  [pull]  # Function definition for external loading.\\n    type = ParsedFunction  # Specifies that the function will be parsed from a string expression.\\n    expression = \'200 * t\'  # Defines the function as a linear function of time.\\n  []\\n[]\\n\\n[BCs]\\n  [leftx]  # Boundary condition for the left boundary.\\n    type = DirichletBC  # Specifies a Dirichlet boundary condition.\\n    preset = true  # Indicates that the boundary condition should be applied before the solve begins.\\n    boundary = right  # Specifies the boundary where this condition applies (right boundary).\\n    variable = disp_x  # The variable this boundary condition applies to.\\n    value = 0.0  # The value of the boundary condition (fixed displacement at the boundary).\\n  []\\n  [pull]  # Neumann boundary condition for the left boundary.\\n    type = FunctionNeumannBC  # Specifies a Neumann boundary condition based on a function.\\n    boundary = left  # Specifies the boundary where this condition applies (left boundary).\\n    variable = disp_x  # The variable this boundary condition applies to.\\n    function = pull  # The function defining the Neumann boundary condition.\\n  []\\n[]\\n\\n[Materials]\\n  [elastic_tensor]  # Material properties block for elasticity tensor.\\n    type = ComputeIsotropicElasticityTensor  # Specifies the type of material property calculation.\\n    youngs_modulus = 100000.0  # Young\'s modulus for the material, defining its stiffness.\\n    poissons_ratio = 0.3  # Poisson\'s ratio for the material, defining its volumetric response.\\n  []\\n  [compute_stress]  # Stress computation block.\\n    type = ComputeLagrangianLinearElasticStress  # Specifies the type of stress computation.\\n  []\\n  [compute_strain]  # Strain computation block.\\n    type = ComputeLagrangianStrain  # Specifies the type of strain computation.\\n  []\\n[]\\n\\n[Preconditioning]\\n  [smp]  # Preconditioning block for the solver.\\n    type = SMP  # Specifies the type of preconditioner to use.\\n    full = true  # Indicates that a full set of couplings between variables should be used.\\n  []\\n[]\\n\\n[Executioner]\\n  type = Transient  # Specifies that the executioner is for transient simulations.\\n\\n  solve_type = \'newton\'  # Specifies the type of solver to use (Newton\'s method).\\n  line_search = none  # Specifies that no line search will be performed during solving.\\n\\n  petsc_options_iname = \'-pc_type\'  # PETSc options for preconditioning type.\\n  petsc_options_value = \'lu\'  # Specifies the use of LU decomposition for the preconditioner.\\n\\n  l_max_its = 2  # Maximum linear iterations allowed.\\n  l_tol = 1e-14  # Tolerance for linear solver convergence.\\n  nl_max_its = 15  # Maximum nonlinear iterations allowed.\\n  nl_rel_tol = 1e-8  # Relative tolerance for nonlinear solver convergence.\\n  nl_abs_tol = 1e-10  # Absolute tolerance for nonlinear solver convergence.\\n\\n  start_time = 0.0  # Start time for the simulation.\\n  dt = 5.0  # Time step size for the simulation.\\n  dtmin = 5.0  # Minimum time step size allowed.\\n  end_time = 5.0  # End time for the simulation.\\n[]\\n"}{"input_card_name": "combined_phase_field_fracture_crack2d_computeCrackedStress_finitestrain_elastic.i", "overall_description": "This input card is designed for simulating phase field fracture mechanics in a 2D solid mechanics context using the MOOSE framework. It generates a mesh with 40 elements in the X direction and 20 elements in the Y direction, creating a rectangular domain. The simulation incorporates finite strain theory and applies boundary conditions that fix displacements on certain edges while allowing time-dependent displacement on the top edge. The physics module includes solid mechanics and phase field fracture mechanics, with specific kernels for calculating stress and strain in the material. The material properties are defined for both elastic and cracked states, and the simulation is set to run transiently over two time steps. The output is configured to be saved in Exodus format.", "annotated_input_card": "# This input uses PhaseField-Nonconserved Action to add phase field fracture bulk rate kernels\\n[Mesh]  \\n  [gen]  \\n    type = GeneratedMeshGenerator  # Specifies the type of mesh generator to use, here it generates a mesh based on specified dimensions and grid sizes.\\n    dim = 2  # The dimension of the mesh, in this case, 2D.\\n    nx = 40  # Number of elements in the X direction.\\n    ny = 20  # Number of elements in the Y direction.\\n    ymax = 0.5  # The maximum Y coordinate of the generated mesh.\\n  []  \\n  [./noncrack]  \\n    type = BoundingBoxNodeSetGenerator  # This generator creates a nodeset based on a bounding box.\\n    new_boundary = noncrack  # Name of the new boundary created for nodes that are not cracked.\\n    bottom_left = \'0.5 0 0\'  # The coordinates of the bottom left corner of the bounding box.\\n    top_right = \'1 0 0\'  # The coordinates of the top right corner of the bounding box.\\n    input = gen  # The input mesh to modify, which is the generated mesh.\\n  [../]  \\n[]\\n\\n[GlobalParams]  \\n  displacements = \'disp_x disp_y\'  # Specifies the displacement variables used in the simulation.\\n[]\\n\\n[AuxVariables]  \\n  [./strain_yy]  \\n    family = MONOMIAL  # The family of the auxiliary variable, here it is a monomial.\\n    order = CONSTANT  # The order of the polynomial, here it is constant.\\n  [../]  \\n[]\\n\\n[Physics]  \\n  [./SolidMechanics]  \\n    [./QuasiStatic]  \\n      [./All]  \\n        add_variables = true  # Indicates that additional variables should be added to the simulation.\\n        strain = FINITE  # Specifies that finite strain theory is used.\\n        planar_formulation = PLANE_STRAIN  # Indicates that a plane strain formulation is used.\\n        additional_generate_output = \'stress_yy\'  # Additional output variable to generate, here it is stress in the Y direction.\\n        strain_base_name = uncracked  # Base name for the strain variable when the material is uncracked.\\n      [../]  \\n    [../]  \\n  [../]  \\n[]\\n\\n[Modules]  \\n  [./PhaseField]  \\n    [./Nonconserved]  \\n      [./c]  \\n        free_energy = E_el  # Name of the material property storing the elastic energy.\\n        kappa = kappa_op  # Name of the interfacial parameter kappa.\\n        mobility = L  # Name of the mobility property.\\n      [../]  \\n    [../]  \\n  [../]  \\n[]\\n\\n[Kernels]  \\n  [./solid_x]  \\n    type = PhaseFieldFractureMechanicsOffDiag  # Kernel type for phase-field fracture mechanics in the X direction.\\n    variable = disp_x  # The variable this kernel operates on, here it is the X displacement.\\n    component = 0  # Specifies the component direction (0 for X).\\n    c = c  # Phase field damage variable.\\n  [../]  \\n  [./solid_y]  \\n    type = PhaseFieldFractureMechanicsOffDiag  # Kernel type for phase-field fracture mechanics in the Y direction.\\n    variable = disp_y  # The variable this kernel operates on, here it is the Y displacement.\\n    component = 1  # Specifies the component direction (1 for Y).\\n    c = c  # Phase field damage variable.\\n  [../]  \\n  [./off_disp]  \\n    type = AllenCahnElasticEnergyOffDiag  # Kernel for calculating off-diagonal Jacobian of elastic energy in Allen-Cahn.\\n    variable = c  # The variable this kernel operates on, here it is the phase field variable.\\n    displacements = \'disp_x disp_y\'  # The displacement variables used in this kernel.\\n    mob_name = L  # The mobility name used with this kernel.\\n  [../]  \\n[]\\n\\n[AuxKernels]  \\n  [./strain_yy]  \\n    type = RankTwoAux  # Auxiliary kernel to access a component of a rank two tensor.\\n    variable = strain_yy  # The variable this auxiliary kernel operates on.\\n    rank_two_tensor = uncracked_mechanical_strain  # The name of the rank two tensor variable.\\n    index_i = 1  # The index i of ij for the tensor to output (1 for Y component).\\n    index_j = 1  # The index j of ij for the tensor to output (1 for Y component).\\n    execute_on = TIMESTEP_END  # Indicates when this auxiliary kernel should be executed.\\n  [../]  \\n[]\\n\\n[BCs]  \\n  [./ydisp]  \\n    type = FunctionDirichletBC  # Type of boundary condition that imposes a function value.\\n    variable = disp_y  # The variable this boundary condition applies to.\\n    boundary = top  # The boundary where this condition is applied.\\n    function = \'t\'  # The function defining the boundary condition, here it is time dependent.\\n  [../]  \\n  [./yfix]  \\n    type = DirichletBC  # Type of boundary condition that imposes a constant value.\\n    variable = disp_y  # The variable this boundary condition applies to.\\n    boundary = noncrack  # The boundary where this condition is applied.\\n    value = 0  # The value of the boundary condition, here it is fixed at 0.\\n  [../]  \\n  [./xfix]  \\n    type = DirichletBC  # Type of boundary condition that imposes a constant value.\\n    variable = disp_x  # The variable this boundary condition applies to.\\n    boundary = right  # The boundary where this condition is applied.\\n    value = 0  # The value of the boundary condition, here it is fixed at 0.\\n  [../]  \\n[]\\n\\n[Materials]  \\n  [./pfbulkmat]  \\n    type = GenericConstantMaterial  # Material type that declares properties based on names and values.\\n    prop_names = \'gc_prop l visco\'  # Names of the properties this material will have.\\n    prop_values = \'1e-3 0.05 1e-4\'  # Values associated with the named properties.\\n  [../]  \\n  [./elasticity_tensor]  \\n    type = ComputeElasticityTensor  # Computes the elasticity tensor for the material.\\n    C_ijkl = \'120.0 80.0\'  # Stiffness tensor for the material.\\n    fill_method = symmetric_isotropic  # Method to fill the elasticity tensor.\\n    base_name = uncracked  # Base name for the elasticity tensor when the material is uncracked.\\n  [../]  \\n  [./elastic]  \\n    type = ComputeFiniteStrainElasticStress  # Computes stress using elasticity for finite strains.\\n    base_name = uncracked  # Base name for the stress variable when the material is uncracked.\\n  [../]  \\n  [./cracked_stress]  \\n    type = ComputeCrackedStress  # Computes energy and modifies the stress for phase field fracture.\\n    c = c  # Phase field damage variable.\\n    kdamage = 1e-5  # Stiffness of the damaged matrix.\\n    F_name = E_el  # Name of material property storing the elastic energy.\\n    use_current_history_variable = true  # Use the current value of the history variable.\\n    uncracked_base_name = uncracked  # Base name used to calculate the original stress.\\n    finite_strain_model = true  # Indicates that the model is using finite strain.\\n  [../]  \\n[]\\n\\n[Postprocessors]  \\n  [./av_stress_yy]  \\n    type = ElementAverageValue  # Computes the volumetric average of a variable.\\n    variable = stress_yy  # The variable this postprocessor operates on.\\n  [../]  \\n  [./av_strain_yy]  \\n    type = SideAverageValue  # Computes the average value of a variable on a sideset.\\n    variable = disp_y  # The variable this postprocessor integrates.\\n    boundary = top  # The boundary where this postprocessor applies.\\n  [../]  \\n[]\\n\\n[Preconditioning]  \\n  [./smp]  \\n    type = SMP  # Single matrix preconditioner.\\n    full = true  # Set to true to include the full set of couplings between variables.\\n  [../]  \\n[]\\n\\n[Executioner]  \\n  type = Transient  # Executioner for time varying simulations.\\n\\n  solve_type = PJFNK  # Specifies the type of solver to use.\\n  petsc_options_iname = \'-pc_type -pc_factor_mat_solving_package\'  # PETSc options for the solver.\\n  petsc_options_value = \'lu superlu_dist\'  # Values for the PETSc options.\\n\\n  nl_rel_tol = 1e-8  # Nonlinear relative tolerance for convergence.\\n  l_tol = 1e-4  # Linear tolerance for convergence.\\n  l_max_its = 100  # Maximum linear iterations allowed.\\n  nl_max_its = 10  # Maximum nonlinear iterations allowed.\\n\\n  dt = 3e-5  # The timestep size between solves.\\n  num_steps = 2  # The number of timesteps in the transient run.\\n[]\\n\\n[Outputs]  \\n  exodus = true  # Enables output in Exodus format.\\n[]\\n\\n"}{"input_card_name": "solid_mechanics_tensile_small_deform4.i", "overall_description": "This input card is designed for a finite element simulation of small deformation in solid mechanics using the MOOSE framework. The simulation involves a single cubic element subjected to small displacements in the x and z directions, with specific boundary conditions applied to these displacements. The physics of the problem is modeled under quasi-static conditions, allowing for the calculation of stress components and yield functions. The mesh is generated in a 3D space with a single element, and various material properties, including elasticity and plasticity, are defined. The executioner is set to transient, indicating that the simulation will evolve over time, and outputs are configured to be saved in CSV format. The main applications used in this input card include SolidMechanics for modeling the mechanical behavior of materials, and ComputeElasticityTensor and ComputeMultiPlasticityStress for defining material properties and stress responses.", "annotated_input_card": "# checking for small deformation\\n# This comment indicates that the simulation is set up to analyze small deformation behavior of the material.\\n# A single element is stretched by 0.75E-6m in the z and x directions\\n# This comment describes the applied displacement in the x and z directions, which is a small deformation.\\n# This causes the return direction to be along the hypersurface sigma_I = sigma_II\\n# This comment refers to the stress state of the material, indicating that the stress components are equal along certain directions.\\n# tensile_strength is set to 1Pa, tip_smoother = 0, edge_smoother = 25degrees\\n# This line sets the tensile strength of the material and defines the smoothing parameters for the tip and edges of the stress distribution.\\n# Then A + B + C = 0.609965\\n# This comment likely refers to a specific calculation or constraint related to the simulation.\\n# The final stress should have meanstress = 0.680118 and bar(sigma) = 0.52443, and sigma_zz = sigma_xx = 0.982896\\n# This comment provides expected results for the stress state after the simulation.\\n\\n[Mesh]\\n  type = GeneratedMesh\\n  dim = 3\\n  nx = 1\\n  ny = 1\\n  nz = 1\\n  xmin = -0.5\\n  xmax = 0.5\\n  ymin = -0.5\\n  ymax = 0.5\\n  zmin = -0.5\\n  zmax = 0.5\\n[]\\n# This section defines the mesh for the simulation. A single cubic element is generated in 3D space with specified dimensions.\\n\\n[GlobalParams]\\n  displacements = \'disp_x disp_y disp_z\'\\n[]\\n# This section specifies the global parameters for the simulation, particularly the displacement variables to be tracked.\\n\\n[Physics/SolidMechanics/QuasiStatic]\\n  [./all]\\n    add_variables = true\\n    incremental = true\\n    strain = finite\\n    generate_output = \'stress_xx stress_xy stress_xz stress_yy stress_yz stress_zz\'\\n  [../]\\n[]\\n# This section sets up the physics for solid mechanics under quasi-static conditions, enabling finite strain calculations and outputting stress components.\\n\\n[BCs]\\n  [./x]\\n    type = FunctionDirichletBC\\n    variable = disp_x\\n    boundary = \'front back\'\\n    function = \'0.75E-6*x\'\\n  [../]\\n  [./y]\\n    type = FunctionDirichletBC\\n    variable = disp_y\\n    boundary = \'front back\'\\n    function = \'0\'\\n  [../]\\n  [./z]\\n    type = FunctionDirichletBC\\n    variable = disp_z\\n    boundary = \'front back\'\\n    function = \'0.75E-6*z\'\\n  [../]\\n[]\\n# This section defines boundary conditions for the simulation, applying specific displacement functions to the boundaries of the mesh in the x, y, and z directions.\\n\\n[AuxVariables]\\n  [./yield_fcn]\\n    order = CONSTANT\\n    family = MONOMIAL\\n  [../]\\n[]\\n# This section defines auxiliary variables, specifically for the yield function, which is constant across the domain.\\n\\n[AuxKernels]\\n  [./yield_fcn_auxk]\\n    type = MaterialStdVectorAux\\n    property = plastic_yield_function\\n    index = 0\\n    variable = yield_fcn\\n  [../]\\n[]\\n# This section sets up an auxiliary kernel to extract the yield function as an auxiliary variable from the material properties.\\n\\n[Postprocessors]\\n  [./s_xx]\\n    type = PointValue\\n    point = \'0 0 0\'\\n    variable = stress_xx\\n  [../]\\n  [./s_xy]\\n    type = PointValue\\n    point = \'0 0 0\'\\n    variable = stress_xy\\n  [../]\\n  [./s_xz]\\n    type = PointValue\\n    point = \'0 0 0\'\\n    variable = stress_xz\\n  [../]\\n  [./s_yy]\\n    type = PointValue\\n    point = \'0 0 0\'\\n    variable = stress_yy\\n  [../]\\n  [./s_yz]\\n    type = PointValue\\n    point = \'0 0 0\'\\n    variable = stress_yz\\n  [../]\\n  [./s_zz]\\n    type = PointValue\\n    point = \'0 0 0\'\\n    variable = stress_zz\\n  [../]\\n  [./f]\\n    type = PointValue\\n    point = \'0 0 0\'\\n    variable = yield_fcn\\n  [../]\\n[]\\n# This section defines postprocessors to evaluate stress components and the yield function at the origin point of the mesh.\\n\\n[UserObjects]\\n  [./ts]\\n    type = SolidMechanicsHardeningConstant\\n    value = 1\\n  [../]\\n  [./mc]\\n    type = SolidMechanicsPlasticTensile\\n    tensile_strength = ts\\n    yield_function_tolerance = 1E-6\\n    tensile_tip_smoother = 0.0\\n    internal_constraint_tolerance = 1E-5\\n  [../]\\n[]\\n# This section defines user objects for hardening and plasticity models, setting parameters for tensile strength and tolerances.\\n\\n[Materials]\\n  [./elasticity_tensor]\\n    type = ComputeElasticityTensor\\n    block = 0\\n    fill_method = symmetric_isotropic\\n    C_ijkl = \'0 2.0E6\'\\n  [../]\\n  [./mc]\\n    type = ComputeMultiPlasticityStress\\n    block = 0\\n    ep_plastic_tolerance = 1E-5\\n    plastic_models = mc\\n    debug_fspb = crash\\n  [../]\\n[]\\n# This section defines material properties, including the elasticity tensor and multi-plasticity stress models.\\n\\n[Executioner]\\n  end_time = 1\\n  dt = 1\\n  type = Transient\\n[]\\n# This section sets up the execution parameters for the simulation, defining the end time and time step size for a transient analysis.\\n\\n[Outputs]\\n  file_base = small_deform4\\n  exodus = false\\n  [./csv]\\n    type = CSV\\n    [../]\\n[]\\n# This section specifies the output settings for the simulation, including the file base name and output format as CSV."}{"input_card_name": "solid_mechanics_2D_geometries_2D-RZ_finiteStrain_resid.i", "overall_description": "This input card is designed for a finite element simulation of a 2D axisymmetric solid mechanics problem using the MOOSE framework. The simulation involves a cylinder with a height of 1 and a radius of 1, created using a generated mesh with 5 elements in both the X and Y directions. The problem is set up to analyze the effects of a displacement of 0.1 applied to the top of the cylinder while constraining the other surfaces. The physics of the problem is governed by the SolidMechanics QuasiStatic application, which utilizes finite strain theory to compute stress and strain in the material. The boundary conditions are defined such that the radial displacement is fixed on the left and right sides, and the bottom is also fixed in the vertical direction. The top boundary is subjected to a time-dependent displacement. The simulation outputs include the average stress and strain values, as well as the nodal sums of forces in both the radial and vertical directions. The results can be visualized through post-processing, particularly focusing on the force exerted on the top surface of the cylinder.", "annotated_input_card": "# This tests the save_in_disp residual aux-variables for\\n# ComputeAxisymmetricRZFiniteStrain, which is generated through the use of the\\n# SolidMechanics QuasiStatic Physics. The GeneratedMesh is 1x1, rotated via axisym to\\n# create a cylinder of height 1, radius 1.\\n#\\n# PostProcessor force_z plots the force on the top surface of the cylinder.\\n#\\n# Displacement of 0.1 is applied to top of cylinder while other surfaces are\\n# constrained. Plotting force_z vs stress_z will show a slope of 3.14159 (pi),\\n# consistent with formula for normal stress:\\n#\\n# Stress = force / area\\n#\\n# where area is A = pi * r^2 for a circle.\\n\\n[Mesh]\\n  type = GeneratedMesh  # Specifies the type of mesh to be generated, in this case, a generated mesh.\\n  dim = 2  # The dimension of the mesh, set to 2 for 2D simulations.\\n  nx = 5  # Number of elements in the X direction.\\n  ny = 5  # Number of elements in the Y direction.\\n  xmin = 0.0  # Minimum X coordinate of the mesh.\\n  xmax = 1.0  # Maximum X coordinate of the mesh.\\n  ymin = 0.0  # Minimum Y coordinate of the mesh.\\n  ymax = 1.0  # Maximum Y coordinate of the mesh.\\n[]\\n\\n[GlobalParams]\\n  displacements = \'disp_r disp_z\'  # Specifies the displacement variables to be used globally.\\n[]\\n\\n[Problem]\\n  coord_type = RZ  # Specifies the coordinate type as RZ for axisymmetric problems.\\n[]\\n\\n[Physics/SolidMechanics/QuasiStatic]\\n  [./all]\\n    strain = FINITE  # Specifies that finite strain theory is to be used.\\n    add_variables = true  # Indicates that additional variables should be added to the simulation.\\n    save_in = \'force_r force_z\'  # Specifies the auxiliary variables to save the forces in.\\n  [../]\\n[]\\n\\n[AuxVariables]\\n  [./stress_r]\\n    order = CONSTANT  # Specifies that the stress variable is constant across the elements.\\n    family = MONOMIAL  # Specifies the polynomial family for the variable.\\n  [../]\\n  [./strain_r]\\n    order = CONSTANT  # Specifies that the strain variable is constant across the elements.\\n    family = MONOMIAL  # Specifies the polynomial family for the variable.\\n  [../]\\n  [./stress_z]\\n    order = CONSTANT  # Specifies that the stress variable is constant across the elements.\\n    family = MONOMIAL  # Specifies the polynomial family for the variable.\\n  [../]\\n  [./strain_z]\\n    order = CONSTANT  # Specifies that the strain variable is constant across the elements.\\n    family = MONOMIAL  # Specifies the polynomial family for the variable.\\n  [../]\\n  [./force_r]\\n    order = FIRST  # Specifies that the force variable is linear across the elements.\\n    family = LAGRANGE  # Specifies the polynomial family for the variable.\\n  [../]\\n  [./force_z]\\n    order = FIRST  # Specifies that the force variable is linear across the elements.\\n    family = LAGRANGE  # Specifies the polynomial family for the variable.\\n  [../]\\n[]\\n\\n[AuxKernels]\\n  [./stress_r]\\n    type = RankTwoAux  # Specifies that this auxiliary kernel accesses a component of a rank two tensor.\\n    rank_two_tensor = stress  # Specifies the rank two tensor to access.\\n    index_i = 0  # Specifies the first index of the tensor component to access.\\n    index_j = 0  # Specifies the second index of the tensor component to access.\\n    variable = stress_r  # The variable to which this auxiliary kernel applies.\\n    execute_on = timestep_end  # Specifies when this kernel should be executed.\\n  [../]\\n  [./strain_r]\\n    type = RankTwoAux  # Specifies that this auxiliary kernel accesses a component of a rank two tensor.\\n    rank_two_tensor = total_strain  # Specifies the rank two tensor to access.\\n    index_i = 0  # Specifies the first index of the tensor component to access.\\n    index_j = 0  # Specifies the second index of the tensor component to access.\\n    variable = strain_r  # The variable to which this auxiliary kernel applies.\\n    execute_on = timestep_end  # Specifies when this kernel should be executed.\\n  [../]\\n  [./stress_z]\\n    type = RankTwoAux  # Specifies that this auxiliary kernel accesses a component of a rank two tensor.\\n    rank_two_tensor = stress  # Specifies the rank two tensor to access.\\n    index_i = 1  # Specifies the first index of the tensor component to access.\\n    index_j = 1  # Specifies the second index of the tensor component to access.\\n    variable = stress_z  # The variable to which this auxiliary kernel applies.\\n    execute_on = timestep_end  # Specifies when this kernel should be executed.\\n  [../]\\n  [./strain_z]\\n    type = RankTwoAux  # Specifies that this auxiliary kernel accesses a component of a rank two tensor.\\n    rank_two_tensor = total_strain  # Specifies the rank two tensor to access.\\n    index_i = 1  # Specifies the first index of the tensor component to access.\\n    index_j = 1  # Specifies the second index of the tensor component to access.\\n    variable = strain_z  # The variable to which this auxiliary kernel applies.\\n    execute_on = timestep_end  # Specifies when this kernel should be executed.\\n  [../]\\n[]\\n\\n[Materials]\\n  [./elasticity_tensor]\\n    type = ComputeIsotropicElasticityTensor  # Specifies the material model to compute isotropic elasticity tensor.\\n    youngs_modulus = 1e6  # Young\'s modulus for the material.\\n    poissons_ratio = 0.3  # Poisson\'s ratio for the material.\\n  [../]\\n\\n  [./_elastic_strain]\\n    type = ComputeFiniteStrainElasticStress  # Specifies the material model to compute finite strain elastic stress.\\n  [../]\\n[]\\n\\n[BCs]\\n  [./no_disp_r_left]\\n    type = DirichletBC  # Specifies a Dirichlet boundary condition.\\n    variable = disp_r  # The variable to which this boundary condition applies.\\n    boundary = left  # The boundary where this condition is applied.\\n    value = 0.0  # The value of the boundary condition.\\n  [../]\\n  [./no_disp_r_right]\\n    type = DirichletBC  # Specifies a Dirichlet boundary condition.\\n    variable = disp_r  # The variable to which this boundary condition applies.\\n    boundary = right  # The boundary where this condition is applied.\\n    value = 0.0  # The value of the boundary condition.\\n  [../]\\n  [./no_disp_z_bottom]\\n    type = DirichletBC  # Specifies a Dirichlet boundary condition.\\n    variable = disp_z  # The variable to which this boundary condition applies.\\n    boundary = bottom  # The boundary where this condition is applied.\\n    value = 0.0  # The value of the boundary condition.\\n  [../]\\n  [./top]\\n    type = FunctionDirichletBC  # Specifies a Dirichlet boundary condition that is a function of time.\\n    variable = disp_z  # The variable to which this boundary condition applies.\\n    boundary = top  # The boundary where this condition is applied.\\n    function = \'t\'  # The function defining the boundary condition.\\n  [../]\\n[]\\n\\n[Debug]\\n    show_var_residual_norms = true  # Enables the display of variable residual norms for debugging purposes.\\n[]\\n\\n[Executioner]\\n  type = Transient  # Specifies that the executioner is for transient simulations.\\n\\n  petsc_options_iname = \'-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter\'  # PETSc options for solver configuration.\\n  petsc_options_value = \'  201               hypre    boomeramg      10\'  # Corresponding values for the PETSc options.\\n\\n  line_search = \'none\'  # Specifies the type of line search to be used.\\n\\n  #Preconditioned JFNK (default)\\n  solve_type = \'PJFNK\'  # Specifies the type of solver to be used.\\n\\n  nl_rel_tol = 5e-9  # Nonlinear relative tolerance for convergence.\\n  nl_abs_tol = 1e-10  # Nonlinear absolute tolerance for convergence.\\n  nl_max_its = 15  # Maximum number of nonlinear iterations allowed.\\n\\n  l_tol = 1e-3  # Linear tolerance for convergence.\\n  l_max_its = 50  # Maximum number of linear iterations allowed.\\n\\n  start_time = 0.0  # Start time for the simulation.\\n  end_time = 0.1  # End time for the simulation.\\n  dt = 0.01  # Time step size for the simulation.\\n[]\\n\\n[Postprocessors]\\n  [./strainR]\\n    type = ElementAverageValue  # Computes the average value of strain over elements.\\n    variable = strain_r  # The variable to which this postprocessor applies.\\n  [../]\\n  [./stressR]\\n    type = ElementAverageValue  # Computes the average value of stress over elements.\\n    variable = stress_r  # The variable to which this postprocessor applies.\\n  [../]\\n  [./strainZ]\\n    type = ElementAverageValue  # Computes the average value of strain over elements.\\n    variable = strain_z  # The variable to which this postprocessor applies.\\n  [../]\\n  [./stressZ]\\n    type = ElementAverageValue  # Computes the average value of stress over elements.\\n    variable = stress_z  # The variable to which this postprocessor applies.\\n  [../]\\n  [./force_r]\\n    type = NodalSum  # Computes the sum of nodal values for force in the r direction.\\n    variable = force_r  # The variable to which this postprocessor applies.\\n    boundary = top  # The boundary where this postprocessor applies.\\n  [../]\\n  [./force_z]\\n    type = NodalSum  # Computes the sum of nodal values for force in the z direction.\\n    variable = force_z  # The variable to which this postprocessor applies.\\n    boundary = top  # The boundary where this postprocessor applies.\\n  [../]\\n[]\\n\\n[Outputs]\\n  exodus = true  # Enables output in Exodus format.\\n  #csv = true  # Uncomment to enable CSV output.\\n  print_linear_residuals = false  # Disables printing of linear residuals.\\n  perf_graph = true  # Enables performance graph output.\\n[]\\n"}\n\nThis is an error message for running this input card (if any):\n\n\nPlease perform the following review tasks:\n1. You should pay more attention to error messages if there are any, reply to "fail" and provide solutions for this error.\n2. Check each module\'s code one by one to see if it is syntactically correct and meets corresponding requirements.\nYou should reply "pass" or "fail", and provide feedback if "fail".\n\nHere is the documentation of the apps of moose used in the input file:\n# Here is the documentation of GeneratedMesh\n# "Create a line, square, or cube mesh with uniformly spaced or biased elements."\nadd_sideset_ids                    = (no_default)  # "The listed sideset ids will be assumed valid\n# for the mesh. This permits setting up boundary\n# restrictions for sidesets initially containing\n# no sides. Names for this sidesets may be provided\n# using add_sideset_names. In this case this list\n# and add_sideset_names must contain the same number\n# of items."\n# Group: ""\nadd_sideset_names                  = (no_default)  # "The listed sideset names will be assumed valid\n# for the mesh. This permits setting up boundary\n# restrictions for sidesets initially containing\n# no sides. Ids for this sidesets may be provided\n# using add_sideset_ids. In this case this list\n# and add_sideset_ids must contain the same number\n# of items."\n# Group: ""\nadd_subdomain_ids                  = (no_default)  # "The listed subdomain ids will be assumed valid\n# for the mesh. This permits setting up subdomain\n# restrictions for subdomains initially containing\n# no elements, which can occur, for example, in\n# additive manufacturing simulations which dynamically\n# add and remove elements. Names for this subdomains\n# may be provided using add_subdomain_names. In\n# this case this list and add_subdomain_names must\n# contain the same number of items."\n# Group: ""\nadd_subdomain_names                = (no_default)  # "The listed subdomain names will be assumed valid\n# for the mesh. This permits setting up subdomain\n# restrictions for subdomains initially containing\n# no elements, which can occur, for example, in\n# additive manufacturing simulations which dynamically\n# add and remove elements. IDs for this subdomains\n# may be provided using add_subdomain_ids. Otherwise\n# IDs are automatically assigned. In case add_subdomain_ids\n# is set too, both lists must contain the same\n# number of items."\n# Group: ""\nallow_renumbering                  = 1             # "If allow_renumbering=false, node and element\n# numbers are kept fixed until deletion"\n# Group: ""\nalpha_rotation                     = (no_default)  # "The number of degrees that the domain should\n# be alpha-rotated using the Euler angle ZXZ convention\n# from https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix\n# in order to align with a canonical physical space\n# of your choosing."\n# Group: "Transformations relative to parent application\n# frame of reference"\nbeta_rotation                      = (no_default)  # "The number of degrees that the domain should\n# be beta-rotated using the Euler angle ZXZ convention\n# from https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix\n# in order to align with a canonical physical space\n# of your choosing."\n# Group: "Transformations relative to parent application\n# frame of reference"\nbias_x                             = 1             # "The amount by which to grow (or shrink) the\n# cells in the x-direction."\n# Group: ""\nbias_y                             = 1             # "The amount by which to grow (or shrink) the\n# cells in the y-direction."\n# Group: ""\nbias_z                             = 1             # "The amount by which to grow (or shrink) the\n# cells in the z-direction."\n# Group: ""\nblock                              = (no_default)  # "Block IDs for the coordinate systems."\n# Group: "Coordinate system"\nbuild_all_side_lowerd_mesh         = 0             # "True to build the lower-dimensional mesh for\n# all sides."\n# Group: ""\ncentroid_partitioner_direction     = (no_default)  # "Specifies the sort direction if using the centroid\n# partitioner. Available options: x, y, z, radial"\n# Group: "Partitioning"\nconstruct_node_list_from_side_list = 1             # "Whether or not to generate nodesets from the\n# sidesets (usually a good idea)."\n# Group: "Advanced"\ncontrol_tags                       = (no_default)  # "Adds user-defined labels for accessing object\n# parameters via control logic."\n# Group: "Advanced"\ncoord_block                        = (no_default)  # "Block IDs for the coordinate systems. If this\n# parameter is specified, then it must encompass\n# all the subdomains on the mesh."\n# Group: ""\ncoord_type                         = XYZ           # "Type of the coordinate system per block param"\n# Group: "Coordinate system"\ndim                                = (required)    # "The dimension of the mesh to be generated"\n# Group: "Required"\nelem_type                          = (no_default)  # "The type of element from libMesh to generate\n# (default: linear element for requested dimension)"\n# Group: ""\nenable                             = 1             # "Set the enabled status of the MooseObject."\n# Group: "Advanced"\ngamma_rotation                     = (no_default)  # "The number of degrees that the domain should\n# be gamma-rotated using the Euler angle ZXZ convention\n# from https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix\n# in order to align with a canonical physical space\n# of your choosing."\n# Group: "Transformations relative to parent application\n# frame of reference"\ngauss_lobatto_grid                 = 0             # "Grade mesh into boundaries according to Gauss-Lobatto\n# quadrature spacing."\n# Group: ""\nghosting_patch_size                = (no_default)  # "The number of nearest neighbors considered for\n# ghosting purposes when \'iteration\' patch update\n# strategy is used. Default is 5 * patch_size."\n# Group: ""\nlength_unit                        = (no_default)  # "How much distance one mesh length unit represents,\n# e.g. 1 cm, 1 nm, 1 ft, 5inches"\n# Group: "Transformations relative to parent application\n# frame of reference"\nmax_leaf_size                      = 10            # "The maximum number of points in each leaf of\n# the KDTree used in the nearest neighbor search.\n# As the leaf size becomes larger,KDTree construction\n# becomes faster but the nearest neighbor searchbecomes\n# slower."\n# Group: ""\nnemesis                            = 0             # "If nemesis=true and file=foo.e, actually reads\n# foo.e.N.0, foo.e.N.1, ... foo.e.N.N-1, where\n# N = # CPUs, with NemesisIO."\n# Group: "Advanced"\nnx                                 = 1             # "Number of elements in the X direction"\n# Group: ""\nny                                 = 1             # "Number of elements in the Y direction"\n# Group: ""\nnz                                 = 1             # "Number of elements in the Z direction"\n# Group: ""\nparallel_type                      = DEFAULT       # "DEFAULT: Use libMesh::ReplicatedMesh unless\n# --distributed-mesh is specified on the command\n# line REPLICATED: Always use libMesh::ReplicatedMesh\n# DISTRIBUTED: Always use libMesh::DistributedMesh"\n# Group: ""\npartitioner                        = default       # "Specifies a mesh partitioner to use when splitting\n# the mesh for a parallel computation."\n# Group: "Partitioning"\npatch_size                         = 40            # "The number of nodes to consider in the NearestNode\n# neighborhood."\n# Group: "Advanced"\npatch_update_strategy              = never         # "How often to update the geometric search \'patch\'.\n# The default is to never update it (which is the\n# most efficient but could be a problem with lots\n# of relative motion). \'always\' will update the\n# patch for all secondary nodes at the beginning\n# of every timestep which might be time consuming.\n# \'auto\' will attempt to determine at the start\n# of which timesteps the patch for all secondary\n# nodes needs to be updated automatically.\'iteration\'\n# updates the patch at every nonlinear iteration\n# for a subset of secondary nodes for which penetration\n# is not detected. If there can be substantial\n# relative motion between the primary and secondary\n# surfaces during the nonlinear iterations within\n# a timestep, it is advisable to use \'iteration\'\n# option to ensure accurate contact detection."\n# Group: "Advanced"\nrz_coord_axis                      = Y             # "The rotation axis (X | Y) for axisymmetric coordinates"\n# Group: "Coordinate system"\nrz_coord_blocks                    = (no_default)  # "Blocks using general axisymmetric coordinate\n# systems"\n# Group: "Coordinate system"\nrz_coord_directions                = (no_default)  # "Axis directions for each block in \'rz_coord_blocks\'"\n# Group: "Coordinate system"\nrz_coord_origins                   = (no_default)  # "Axis origin points for each block in \'rz_coord_blocks\'"\n# Group: "Coordinate system"\nskip_refine_when_use_split         = 1             # "True to skip uniform refinements when using\n# a pre-split mesh."\n# Group: ""\ntype                               = GeneratedMesh # ""\n# Group: ""\nup_direction                       = (no_default)  # "Specify what axis corresponds to the up direction\n# in physical space (the opposite of the gravity\n# vector if you will). If this parameter is provided,\n# we will perform a single 90 degree rotation of\n# the domain--if the provided axis is \'x\' or \'z\',\n# we will not rotate if the axis is \'y\'--such that\n# a point which was on the provided axis will now\n# lie on the y-axis, e.g. the y-axis is our canonical\n# up direction. If you want finer grained control\n# than this, please use the \'alpha_rotation\', \'beta_rotation\',\n# and \'gamma_rotation\' parameters."\n# Group: "Transformations relative to parent application\n# frame of reference"\nxmax                               = 1             # "Upper X Coordinate of the generated mesh"\n# Group: ""\nxmin                               = 0             # "Lower X Coordinate of the generated mesh"\n# Group: ""\nymax                               = 1             # "Upper Y Coordinate of the generated mesh"\n# Group: ""\nymin                               = 0             # "Lower Y Coordinate of the generated mesh"\n# Group: ""\nzmax                               = 1             # "Upper Z Coordinate of the generated mesh"\n# Group: ""\nzmin                               = 0             # "Lower Z Coordinate of the generated mesh"\n# Group: ""\n\n# Here is the documentation of ComputeIsotropicElasticityTensor\n# "Compute a constant isotropic elasticity tensor."\nbase_name                   = (no_default)                     # "Optional parameter that allows\n# the user to define multiple mechanics\n# material systems on the same block,\n# i.e. for multiple phases"\n# Group: ""\nblock                       = (no_default)                     # "The list of blocks (ids or names)\n# that this object will be applied"\n# Group: ""\nboundary                    = (no_default)                     # "The list of boundaries (ids or\n# names) from the mesh where this\n# object applies"\n# Group: ""\nbulk_modulus                = -1                               # "The bulk modulus for the material."\n# Group: ""\ncompute                     = 1                                # "When false, MOOSE will not call\n# compute methods on this material.\n# The user must call computeProperties()\n# after retrieving the MaterialBase\n# via MaterialBasePropertyInterface::getMaterialBase().\n# Non-computed MaterialBases are\n# not sorted for dependencies."\n# Group: ""\nconstant_on                 = NONE                             # "When ELEMENT, MOOSE will only\n# call computeQpProperties() for\n# the 0th quadrature point, and then\n# copy that value to the other qps.When\n# SUBDOMAIN, MOOSE will only call\n# computeQpProperties() for the 0th\n# quadrature point, and then copy\n# that value to the other qps. Evaluations\n# on element qps will be skipped"\n# Group: ""\ncontrol_tags                = (no_default)                     # "Adds user-defined labels for accessing\n# object parameters via control logic."\n# Group: "Advanced"\ndeclare_suffix              = (no_default)                     # "An optional suffix parameter that\n# can be appended to any declared\n# properties. The suffix will be\n# prepended with a \'_\' character."\n# Group: ""\nelasticity_tensor_prefactor = (no_default)                     # "Optional function to use as a\n# scalar prefactor on the elasticity\n# tensor."\n# Group: ""\nenable                      = 1                                # "Set the enabled status of the\n# MooseObject."\n# Group: "Advanced"\nimplicit                    = 1                                # "Determines whether this object\n# is calculated using an implicit\n# or explicit form"\n# Group: "Advanced"\nlambda                      = -1                               # "Lame\'s first constant for the\n# material."\n# Group: ""\noutput_properties           = (no_default)                     # "List of material properties, from\n# this material, to output (outputs\n# must also be defined to an output\n# type)"\n# Group: "Outputs"\noutputs                     = \'none \'                          # "Vector of output names where you\n# would like to restrict the output\n# of variables(s) associated with\n# this object"\n# Group: "Outputs"\npoissons_ratio              = -1                               # "Poisson\'s ratio for the material."\n# Group: ""\nprop_getter_suffix          = (no_default)                     # "An optional suffix parameter that\n# can be appended to any attempt\n# to retrieve/get material properties.\n# The suffix will be prepended with\n# a \'_\' character."\n# Group: ""\nseed                        = 0                                # "The seed for the master random\n# number generator"\n# Group: "Advanced"\nshear_modulus               = -1                               # "The shear modulus of the material."\n# Group: ""\ntype                        = ComputeIsotropicElasticityTensor # ""\n# Group: ""\nuse_displaced_mesh          = 0                                # "Whether or not this object should\n# use the displaced mesh for computation.\n# Note that in the case this is true\n# but no displacements are provided\n# in the Mesh block the undisplaced\n# mesh will still be used."\n# Group: "Advanced"\nuse_interpolated_state      = 0                                # "For the old and older state use\n# projected material properties interpolated\n# at the quadrature points. To set\n# up projection use the ProjectedStatefulMaterialStorageAction."\n# Group: ""\nyoungs_modulus              = -1                               # "Young\'s modulus of the material."\n# Group: ""\n\n# Here is the documentation of ComputeLinearElasticStress\n# "Compute stress using elasticity for small strains"\nbase_name              = (no_default)               # "Optional parameter that allows the user to\n# define multiple mechanics material systems\n# on the same block, i.e. for multiple phases"\n# Group: ""\nblock                  = (no_default)               # "The list of blocks (ids or names) that this\n# object will be applied"\n# Group: ""\nboundary               = (no_default)               # "The list of boundaries (ids or names) from\n# the mesh where this object applies"\n# Group: ""\ncompute                = 1                          # "When false, MOOSE will not call compute methods\n# on this material. The user must call computeProperties()\n# after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase().\n# Non-computed MaterialBases are not sorted\n# for dependencies."\n# Group: ""\nconstant_on            = NONE                       # "When ELEMENT, MOOSE will only call computeQpProperties()\n# for the 0th quadrature point, and then copy\n# that value to the other qps.When SUBDOMAIN,\n# MOOSE will only call computeQpProperties()\n# for the 0th quadrature point, and then copy\n# that value to the other qps. Evaluations on\n# element qps will be skipped"\n# Group: ""\ncontrol_tags           = (no_default)               # "Adds user-defined labels for accessing object\n# parameters via control logic."\n# Group: "Advanced"\ndeclare_suffix         = (no_default)               # "An optional suffix parameter that can be\n# appended to any declared properties. The suffix\n# will be prepended with a \'_\' character."\n# Group: ""\nenable                 = 1                          # "Set the enabled status of the MooseObject."\n# Group: "Advanced"\nimplicit               = 1                          # "Determines whether this object is calculated\n# using an implicit or explicit form"\n# Group: "Advanced"\noutput_properties      = (no_default)               # "List of material properties, from this material,\n# to output (outputs must also be defined to\n# an output type)"\n# Group: "Outputs"\noutputs                = \'none \'                    # "Vector of output names where you would like\n# to restrict the output of variables(s) associated\n# with this object"\n# Group: "Outputs"\nprop_getter_suffix     = (no_default)               # "An optional suffix parameter that can be\n# appended to any attempt to retrieve/get material\n# properties. The suffix will be prepended with\n# a \'_\' character."\n# Group: ""\nseed                   = 0                          # "The seed for the master random number generator"\n# Group: "Advanced"\ntype                   = ComputeLinearElasticStress # ""\n# Group: ""\nuse_interpolated_state = 0                          # "For the old and older state use projected\n# material properties interpolated at the quadrature\n# points. To set up projection use the ProjectedStatefulMaterialStorageAction."\n# Group: ""\n\n# Here is the documentation of DirichletBC\n# "Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value."\nabsolute_value_vector_tags = (no_default)  # "The tags for the vectors this residual object should\n# fill with the absolute value of the residual contribution"\n# Group: "Tagging"\nboundary                   = (required)    # "The list of boundary IDs from the mesh where this\n# object applies"\n# Group: ""\ncontrol_tags               = (no_default)  # "Adds user-defined labels for accessing object parameters\n# via control logic."\n# Group: "Advanced"\ndiag_save_in               = (no_default)  # "The name of auxiliary variables to save this BC\'s\n# diagonal jacobian contributions to.  Everything about\n# that variable must match everything about this variable\n# (the type, what blocks it\'s on, etc.)"\n# Group: ""\ndisplacements              = (no_default)  # "The displacements"\n# Group: ""\nenable                     = 1             # "Set the enabled status of the MooseObject."\n# Group: "Advanced"\nextra_matrix_tags          = (no_default)  # "The extra tags for the matrices this Kernel should\n# fill"\n# Group: "Tagging"\nextra_vector_tags          = (no_default)  # "The extra tags for the vectors this Kernel should\n# fill"\n# Group: "Tagging"\nimplicit                   = 1             # "Determines whether this object is calculated using\n# an implicit or explicit form"\n# Group: "Advanced"\nmatrix_tags                = \'system time\' # "The tag for the matrices this Kernel should fill"\n# Group: "Tagging"\npreset                     = 1             # "Whether or not to preset the BC (apply the value before\n# the solve begins)."\n# Group: ""\nsave_in                    = (no_default)  # "The name of auxiliary variables to save this BC\'s\n# residual contributions to.  Everything about that variable\n# must match everything about this variable (the type,\n# what blocks it\'s on, etc.)"\n# Group: ""\nseed                       = 0             # "The seed for the master random number generator"\n# Group: "Advanced"\ntype                       = DirichletBC   # ""\n# Group: ""\nuse_displaced_mesh         = 0             # "Whether or not this object should use the displaced\n# mesh for computation.  Note that in the case this is\n# true but no displacements are provided in the Mesh\n# block the undisplaced mesh will still be used."\n# Group: "Advanced"\nvalue                      = (required)    # "Value of the BC"\n# Group: ""\nvariable                   = (required)    # "The name of the variable that this residual object\n# operates on"\n# Group: ""\nvector_tags                = residual      # "The tag for the vectors this Kernel should fill"\n# Group: "Tagging"\n\n# Here is the documentation of DirichletBC\n# "Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value."\nabsolute_value_vector_tags = (no_default)  # "The tags for the vectors this residual object should\n# fill with the absolute value of the residual contribution"\n# Group: "Tagging"\nboundary                   = (required)    # "The list of boundary IDs from the mesh where this\n# object applies"\n# Group: ""\ncontrol_tags               = (no_default)  # "Adds user-defined labels for accessing object parameters\n# via control logic."\n# Group: "Advanced"\ndiag_save_in               = (no_default)  # "The name of auxiliary variables to save this BC\'s\n# diagonal jacobian contributions to.  Everything about\n# that variable must match everything about this variable\n# (the type, what blocks it\'s on, etc.)"\n# Group: ""\ndisplacements              = (no_default)  # "The displacements"\n# Group: ""\nenable                     = 1             # "Set the enabled status of the MooseObject."\n# Group: "Advanced"\nextra_matrix_tags          = (no_default)  # "The extra tags for the matrices this Kernel should\n# fill"\n# Group: "Tagging"\nextra_vector_tags          = (no_default)  # "The extra tags for the vectors this Kernel should\n# fill"\n# Group: "Tagging"\nimplicit                   = 1             # "Determines whether this object is calculated using\n# an implicit or explicit form"\n# Group: "Advanced"\nmatrix_tags                = \'system time\' # "The tag for the matrices this Kernel should fill"\n# Group: "Tagging"\npreset                     = 1             # "Whether or not to preset the BC (apply the value before\n# the solve begins)."\n# Group: ""\nsave_in                    = (no_default)  # "The name of auxiliary variables to save this BC\'s\n# residual contributions to.  Everything about that variable\n# must match everything about this variable (the type,\n# what blocks it\'s on, etc.)"\n# Group: ""\nseed                       = 0             # "The seed for the master random number generator"\n# Group: "Advanced"\ntype                       = DirichletBC   # ""\n# Group: ""\nuse_displaced_mesh         = 0             # "Whether or not this object should use the displaced\n# mesh for computation.  Note that in the case this is\n# true but no displacements are provided in the Mesh\n# block the undisplaced mesh will still be used."\n# Group: "Advanced"\nvalue                      = (required)    # "Value of the BC"\n# Group: ""\nvariable                   = (required)    # "The name of the variable that this residual object\n# operates on"\n# Group: ""\nvector_tags                = residual      # "The tag for the vectors this Kernel should fill"\n# Group: "Tagging"\n\n# Here is the documentation of NeumannBC\n# "Imposes the integrated boundary condition $\\\\frac{\\\\partial u}{\\\\partial n}=h$, where $h$ is\n# a constant, controllable value."\nabsolute_value_vector_tags = (no_default) # "The tags for the vectors this residual object should\n# fill with the absolute value of the residual contribution"\n# Group: "Tagging"\nboundary                   = (required)   # "The list of boundary IDs from the mesh where this object\n# applies"\n# Group: ""\ncontrol_tags               = (no_default) # "Adds user-defined labels for accessing object parameters\n# via control logic."\n# Group: "Advanced"\ndiag_save_in               = (no_default) # "The name of auxiliary variables to save this BC\'s diagonal\n# jacobian contributions to.  Everything about that variable\n# must match everything about this variable (the type,\n# what blocks it\'s on, etc.)"\n# Group: "Advanced"\ndisplacements              = (no_default) # "The displacements"\n# Group: ""\nenable                     = 1            # "Set the enabled status of the MooseObject."\n# Group: "Advanced"\nextra_matrix_tags          = (no_default) # "The extra tags for the matrices this Kernel should\n# fill"\n# Group: "Tagging"\nextra_vector_tags          = (no_default) # "The extra tags for the vectors this Kernel should fill"\n# Group: "Tagging"\nimplicit                   = 1            # "Determines whether this object is calculated using\n# an implicit or explicit form"\n# Group: "Advanced"\nmatrix_tags                = system       # "The tag for the matrices this Kernel should fill"\n# Group: "Tagging"\nprop_getter_suffix         = (no_default) # "An optional suffix parameter that can be appended to\n# any attempt to retrieve/get material properties. The\n# suffix will be prepended with a \'_\' character."\n# Group: ""\nsave_in                    = (no_default) # "The name of auxiliary variables to save this BC\'s residual\n# contributions to.  Everything about that variable must\n# match everything about this variable (the type, what\n# blocks it\'s on, etc.)"\n# Group: "Advanced"\nseed                       = 0            # "The seed for the master random number generator"\n# Group: "Advanced"\ntype                       = NeumannBC    # ""\n# Group: ""\nuse_displaced_mesh         = 0            # "Whether or not this object should use the displaced\n# mesh for computation.  Note that in the case this is\n# true but no displacements are provided in the Mesh block\n# the undisplaced mesh will still be used."\n# Group: "Advanced"\nuse_interpolated_state     = 0            # "For the old and older state use projected material\n# properties interpolated at the quadrature points. To\n# set up projection use the ProjectedStatefulMaterialStorageAction."\n# Group: ""\nvalue                      = 0            # "For a Laplacian problem, the value of the gradient\n# dotted with the normals on the boundary."\n# Group: ""\nvariable                   = (required)   # "The name of the variable that this residual object\n# operates on"\n# Group: ""\nvector_tags                = nontime      # "The tag for the vectors this Kernel should fill"\n# Group: "Tagging"\n\n# Here is the documentation of Transient\n# "Executioner for time varying simulations."\nabort_on_solve_fail                     = 0              # "abort if solve not converged rather than\n# cut timestep"\n# Group: "Advanced"\naccept_on_max_fixed_point_iteration     = 0              # "True to treat reaching the maximum number\n# of fixed point iterations as converged."\n# Group: "Fixed point iterations"\naccept_on_max_picard_iteration          = 0              # "True to treat reaching the maximum number\n# of Picard iterations as converged."\n# Group: ""\nauto_advance                            = (no_default)   # "Whether to automatically advance sub-applications\n# regardless of whether their solve converges,\n# for transient executioners only."\n# Group: "Fixed point iterations"\nautomatic_scaling                       = (no_default)   # "Whether to use automatic scaling for the\n# variables."\n# Group: "Solver variable scaling"\ncheck_aux                               = 0              # "Whether to check the auxiliary system\n# for convergence to steady-state. If false,\n# then the nonlinear system is used."\n# Group: "Steady State Detection"\ncompute_scaling_once                    = 1              # "Whether the scaling factors should only\n# be computed once at the beginning of the\n# simulation through an extra Jacobian evaluation.\n# If this is set to false, then the scaling\n# factors will be computed during an extra\n# Jacobian evaluation at the beginning of\n# every time step."\n# Group: "Solver variable scaling"\ncontact_line_search_allowed_lambda_cuts = 2              # "The number of times lambda is allowed\n# to be cut in half in the contact line search.\n# We recommend this number be roughly bounded\n# by 0 <= allowed_lambda_cuts <= 3"\n# Group: "Solver line search"\ncontact_line_search_ltol                = (no_default)   # "The linear relative tolerance to be used\n# while the contact state is changing between\n# non-linear iterations. We recommend that\n# this tolerance be looser than the standard\n# linear tolerance"\n# Group: "Solver line search"\ncontrol_tags                            = (no_default)   # "Adds user-defined labels for accessing\n# object parameters via control logic."\n# Group: "Advanced"\ncustom_abs_tol                          = 1e-50          # "The absolute nonlinear residual to shoot\n# for during fixed point iterations. This\n# check is performed based on postprocessor\n# defined by the custom_pp residual."\n# Group: "Fixed point iterations"\ncustom_pp                               = (no_default)   # "Postprocessor for custom fixed point convergence\n# check."\n# Group: "Fixed point iterations"\ncustom_rel_tol                          = 1e-08          # "The relative nonlinear residual drop to\n# shoot for during fixed point iterations.\n# This check is performed based on the postprocessor\n# defined by custom_pp residual."\n# Group: "Fixed point iterations"\ndirect_pp_value                         = 0              # "True to use direct postprocessor value\n# (scaled by value on first iteration). False\n# (default) to use difference in postprocessor\n# value between fixed point iterations."\n# Group: "Fixed point iterations"\ndisable_fixed_point_residual_norm_check = 0              # "Disable the residual norm evaluation thus\n# the three parameters fixed_point_rel_tol,\n# fixed_point_abs_tol and fixed_point_force_norms."\n# Group: "Fixed point iterations"\ndisable_picard_residual_norm_check      = 0              # "Disable the Picard residual norm evaluation\n# thus the three parameters picard_rel_tol,\n# picard_abs_tol and picard_force_norms."\n# Group: ""\ndt                                      = 1              # "The timestep size between solves"\n# Group: ""\ndtmax                                   = 1e+30          # "The maximum timestep size in an adaptive\n# run"\n# Group: "Advanced"\ndtmin                                   = 1e-12          # "The minimum timestep size in an adaptive\n# run"\n# Group: "Advanced"\nenable                                  = 1              # "Set the enabled status of the MooseObject."\n# Group: "Advanced"\nend_time                                = 1e+30          # "The end time of the simulation"\n# Group: ""\nerror_on_dtmin                          = 1              # "Throw error when timestep is less than\n# dtmin instead of just aborting solve."\n# Group: ""\nfixed_point_abs_tol                     = 1e-50          # "The absolute nonlinear residual to shoot\n# for during fixed point iterations. This\n# check is performed based on the main app\'s\n# nonlinear residual."\n# Group: "Fixed point iterations"\nfixed_point_algorithm                   = picard         # "The fixed point algorithm to converge\n# the sequence of problems."\n# Group: "Fixed point iterations"\nfixed_point_force_norms                 = 0              # "Force the evaluation of both the TIMESTEP_BEGIN\n# and TIMESTEP_END norms regardless of the\n# existence of active MultiApps with those\n# execute_on flags, default: false."\n# Group: "Fixed point iterations"\nfixed_point_max_its                     = 1              # "Specifies the maximum number of fixed\n# point iterations."\n# Group: "Fixed point iterations"\nfixed_point_min_its                     = 1              # "Specifies the minimum number of fixed\n# point iterations."\n# Group: "Fixed point iterations"\nfixed_point_rel_tol                     = 1e-08          # "The relative nonlinear residual drop to\n# shoot for during fixed point iterations.\n# This check is performed based on the main\n# app\'s nonlinear residual."\n# Group: "Fixed point iterations"\nignore_variables_for_autoscaling        = (no_default)   # "List of variables that do not participate\n# in autoscaling."\n# Group: "Solver variable scaling"\nl_abs_tol                               = 1e-50          # "Linear Absolute Tolerance"\n# Group: "Linear Solver"\nl_max_its                               = 10000          # "Max Linear Iterations"\n# Group: "Linear Solver"\nl_tol                                   = 1e-05          # "Linear Relative Tolerance"\n# Group: "Linear Solver"\nline_search                             = default        # "Specifies the line search type (Note:\n# none = basic)"\n# Group: "Solver line search"\nline_search_package                     = petsc          # "The solver package to use to conduct the\n# line-search"\n# Group: "Solver line search"\nmax_xfem_update                         = 4294967295     # "Maximum number of times to update XFEM\n# crack topology in a step due to evolving\n# cracks"\n# Group: "XFEM fixed point iterations"\nmffd_type                               = wp             # "Specifies the finite differencing type\n# for Jacobian-free solve types. Note that\n# the default is wp (for Walker and Pernice)."\n# Group: "PETSc"\nn_max_nonlinear_pingpong                = 100            # "The maximum number of times the nonlinear\n# residual can ping pong before requesting\n# halting the current evaluation and requesting\n# timestep cut"\n# Group: "Nonlinear Solver"\nn_startup_steps                         = 0              # "The number of timesteps during startup"\n# Group: "Advanced"\nnl_abs_div_tol                          = 1e+50          # "Nonlinear Absolute Divergence Tolerance.\n# A negative value disables this check."\n# Group: "Nonlinear Solver"\nnl_abs_step_tol                         = 0              # "Nonlinear Absolute step Tolerance"\n# Group: "Nonlinear Solver"\nnl_abs_tol                              = 1e-50          # "Nonlinear Absolute Tolerance"\n# Group: "Nonlinear Solver"\nnl_div_tol                              = 1e+10          # "Nonlinear Relative Divergence Tolerance.\n# A negative value disables this check."\n# Group: "Nonlinear Solver"\nnl_forced_its                           = 0              # "The Number of Forced Nonlinear Iterations"\n# Group: "Nonlinear Solver"\nnl_max_funcs                            = 10000          # "Max Nonlinear solver function evaluations"\n# Group: "Nonlinear Solver"\nnl_max_its                              = 50             # "Max Nonlinear Iterations"\n# Group: "Nonlinear Solver"\nnl_rel_step_tol                         = 0              # "Nonlinear Relative step Tolerance"\n# Group: "Nonlinear Solver"\nnl_rel_tol                              = 1e-08          # "Nonlinear Relative Tolerance"\n# Group: "Nonlinear Solver"\nnormalize_solution_diff_norm_by_dt      = 1              # "Whether to divide the solution difference\n# norm by dt. If taking \'small\' time steps\n# you probably want this to be true. If taking\n# very \'large\' timesteps in an attempt to\n# *reach* a steady-state, you probably want\n# this parameter to be false."\n# Group: ""\nnum_grids                               = 1              # "The number of grids to use for a grid\n# sequencing algorithm. This includes the\n# final grid, so num_grids = 1 indicates\n# just one solve in a time-step"\n# Group: "Nonlinear Solver"\nnum_steps                               = 4294967295     # "The number of timesteps in a transient\n# run"\n# Group: ""\noff_diagonals_in_auto_scaling           = 0              # "Whether to consider off-diagonals when\n# determining automatic scaling factors."\n# Group: "Solver variable scaling"\noutputs                                 = (no_default)   # "Vector of output names where you would\n# like to restrict the output of variables(s)\n# associated with this object"\n# Group: "Advanced"\npetsc_options                           = (no_default)   # "Singleton PETSc options"\n# Group: "PETSc"\npetsc_options_iname                     = (no_default)   # "Names of PETSc name/value pairs"\n# Group: "PETSc"\npetsc_options_value                     = (no_default)   # "Values of PETSc name/value pairs (must\n# correspond with \\"petsc_options_iname\\""\n# Group: "PETSc"\npicard_abs_tol                          = 1e-50          # "The absolute nonlinear residual to shoot\n# for during Picard iterations. This check\n# is performed based on the Master app\'s\n# nonlinear residual."\n# Group: ""\npicard_force_norms                      = 0              # "Force the evaluation of both the TIMESTEP_BEGIN\n# and TIMESTEP_END norms regardless of the\n# existence of active MultiApps with those\n# execute_on flags, default: false."\n# Group: ""\npicard_max_its                          = 1              # "Specifies the maximum number of Picard\n# iterations. Mainly used when  wanting to\n# do Picard iterations with MultiApps that\n# are set to execute_on timestep_end or timestep_begin.\n# Setting this parameter to 1 turns off the\n# Picard iterations."\n# Group: ""\npicard_rel_tol                          = 1e-08          # "The relative nonlinear residual drop to\n# shoot for during Picard iterations. This\n# check is performed based on the Master\n# app\'s nonlinear residual."\n# Group: ""\nrelaxation_factor                       = 1              # "Fraction of newly computed value to keep.Set\n# between 0 and 2."\n# Group: "Fixed point iterations"\nrelaxed_variables                       = (no_default)   # "List of main app variables to relax during\n# fixed point iterations"\n# Group: ""\nreset_dt                                = 0              # "Use when restarting a calculation to force\n# a change in dt."\n# Group: ""\nresid_vs_jac_scaling_param              = 0              # "A parameter that indicates the weighting\n# of the residual vs the Jacobian in determining\n# variable scaling parameters. A value of\n# 1 indicates pure residual-based scaling.\n# A value of 0 indicates pure Jacobian-based\n# scaling"\n# Group: "Solver variable scaling"\nresidual_and_jacobian_together          = 0              # "Whether to compute the residual and Jacobian\n# together."\n# Group: "Nonlinear Solver"\nrestart_file_base                       = (no_default)   # "File base name used for restart"\n# Group: "Restart"\nreuse_preconditioner                    = 0              # "If true reuse the previously calculated\n# preconditioner for the linearized system\n# across multiple solves spanning nonlinear\n# iterations and time steps. The preconditioner\n# resets as controlled by reuse_preconditioner_max_linear_its"\n# Group: "Linear Solver"\nreuse_preconditioner_max_linear_its     = 25             # "Reuse the previously calculated preconditioner\n# for the linear system until the number\n# of linear iterations exceeds this number"\n# Group: "Linear Solver"\nscaling_group_variables                 = (no_default)   # "Name of variables that are grouped together\n# for determining scale factors. (Multiple\n# groups can be provided, separated by semicolon)"\n# Group: "Solver variable scaling"\nscheme                                  = implicit-euler # "Time integration scheme used."\n# Group: ""\nskip_exception_check                    = 0              # "Specifies whether or not to skip exception\n# check"\n# Group: "Advanced"\nsnesmf_reuse_base                       = 1              # "Specifies whether or not to reuse the\n# base vector for matrix-free calculation"\n# Group: "Nonlinear Solver"\nsolve_type                              = (no_default)   # "PJFNK: Preconditioned Jacobian-Free Newton\n# Krylov JFNK: Jacobian-Free Newton Krylov\n# NEWTON: Full Newton Solve FD: Use finite\n# differences to compute Jacobian LINEAR:\n# Solving a linear problem"\n# Group: "Nonlinear Solver"\nsplitting                               = (no_default)   # "Top-level splitting defining a hierarchical\n# decomposition into subsystems to help the\n# solver."\n# Group: ""\nss_check_tol                            = 1e-08          # "Whenever the relative residual changes\n# by less than this the solution will be\n# considered to be at steady state."\n# Group: "Advanced"\nss_tmin                                 = 0              # "Minimum amount of time to run before checking\n# for steady state conditions."\n# Group: "Advanced"\nstart_time                              = 0              # "The start time of the simulation"\n# Group: "Advanced"\nsteady_state_detection                  = 0              # "Whether or not to check for steady state\n# conditions"\n# Group: "Steady State Detection"\nsteady_state_start_time                 = 0              # "Minimum amount of time to run before checking\n# for steady state conditions."\n# Group: "Steady State Detection"\nsteady_state_tolerance                  = 1e-08          # "Whenever the relative residual changes\n# by less than this the solution will be\n# considered to be at steady state."\n# Group: "Steady State Detection"\ntime_period_ends                        = (no_default)   # "The end times of time periods"\n# Group: "Time Periods"\ntime_period_starts                      = (no_default)   # "The start times of time periods"\n# Group: "Time Periods"\ntime_periods                            = (no_default)   # "The names of periods"\n# Group: "Time Periods"\ntimestep_tolerance                      = 1e-12          # "the tolerance setting for final timestep\n# size and sync times"\n# Group: "Advanced"\ntrans_ss_check                          = 0              # "Whether or not to check for steady state\n# conditions"\n# Group: "Advanced"\ntransformed_postprocessors              = (no_default)   # "List of main app postprocessors to transform\n# during fixed point iterations"\n# Group: "Fixed point iterations"\ntransformed_variables                   = (no_default)   # "List of main app variables to transform\n# during fixed point iterations"\n# Group: "Fixed point iterations"\ntype                                    = Transient      # ""\n# Group: ""\nupdate_xfem_at_timestep_begin           = 0              # "Should XFEM update the mesh at the beginning\n# of the timestep"\n# Group: "XFEM fixed point iterations"\nuse_multiapp_dt                         = 0              # "If true then the dt for the simulation\n# will be chosen by the MultiApps.  If false\n# (the default) then the minimum over the\n# master dt and the MultiApps is used"\n# Group: "Advanced"\nuse_pre_SMO_residual                    = 0              # "Compute the pre-SMO residual norm and\n# use it in the relative convergence check.\n# The pre-SMO residual is computed at the\n# begining of the time step before solution-modifying\n# objects are executed. Solution-modifying\n# objects include preset BCs, constraints,\n# predictors, etc."\n# Group: "Nonlinear Solver"\nverbose                                 = 0              # "Set to true to print additional information"\n# Group: ""\n\n\n'
