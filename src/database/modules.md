# Chemical Reactions Module

The chemical reactions module provides a set of tools for the calculation of multicomponent aqueous
reactive transport in porous media, originally developed as the [MOOSE] application RAT
[!citep](guo2013).

## Theory

The first part of defining the chemistry of a problem is to choose a set of independent *primary*
species from which every other species (including minerals) can be expressed in terms of. Other
chemical species that can be expressed as combinations of primary species are termed *secondary*
species.

Following [!cite](lichtner1996), the mass conservation equation is formulated in terms of the total
concentration of a primary species $j$, $\Psi_j$, and has the form

\begin{equation}
\frac{\partial}{\partial t} \left(\phi \Psi_j \right) + \nabla \cdot \left(\mathbf{q}
  - \phi D \nabla \right)\Psi_j + \sum_{m=1}^{N_m} \nu_{jm} I_m - Q_j= 0,  \quad j = 1, 2, \ldots, N_c,
\end{equation}
where $\phi$ is porosity, $D$ is the hydrodynamic dispersion tensor, $N_m$ is the number of minerals
formed by kinetic reactions, $\nu_{jm}$ is the stoichiometric coefficient for the $j^{\mathrm{th}}$
species in the $m^{\mathrm{th}}$ kinetic reaction, $I_m$ is the reaction rate for the
$m^{\mathrm{th}}$ mineral, and $Q_j$ is a source (sink) of the $j^{\mathrm{th}}$ species, and
$\mathbf{q}$ is the Darcy flux

\begin{equation}
\mathbf{q} = - \frac{K}{\mu} \left(\nabla P - \rho \mathbf{g}\right),
\end{equation}
where $K$ is permeability, $\mu$ is fluid viscosity, $P$ is pressure, $\rho$ is fluid density, and
$\mathbf{g}$ is gravity.

The total concentration of the $j^{\mathrm{th}}$ primary species, $\Psi_j$, is defined as

\begin{equation}
\Psi_j = C_j + \sum_{i=1}^{N_s} \nu_{ji} C_i,
\end{equation}
where $C_j$ is the concentration of the primary species, $C_i$ is the concentration of the
$i^{\mathrm{th}}$ secondary species, $N_s$ is the total number of secondary species, and $\nu_{ji}$
are the stoichiometric coefficients.

### Aqueous equilibrium reactions

The concentration of the $i^{\mathrm{th}}$ secondary species, $C_i$, is calculated from mass action
equations corresponding to equilibrium reactions

\begin{equation}
\sum_j \nu_{ji} \mathcal{A}_j \rightleftharpoons \mathcal{A}_i,
\end{equation}
where $\mathcal{A}_j$ refers to the $j^{\mathrm{th}}$ species. This yields

\begin{equation}
C_i = \frac{K_i}{\gamma_i} \prod_{j=1}^{N_c} \left(\gamma_j C_j\right)^{\nu_{ji}},
\end{equation}
where $K_i$ is equilibrium constant, $\gamma_i$ is the activity coefficient, and $N_c$ is the number
of primary species.

### Solid kinetic reactions

Mineral precipitation/dissolution is possible via kinetic reactions of the form

\begin{equation}
\sum_j \nu_{ji} \mathcal{A}_j \rightleftharpoons \mathcal{M}_m,
\end{equation}
where $\mathcal{M}_m$ refers to the $m^{\mathrm{th}}$ mineral species.

The reaction rate $I_m$ is based on transition state theory, a simple form of which gives

\begin{equation}
I_m = \pm k_m a_m \left|1 - \Omega_m^{\theta}\right|^{\eta},
\end{equation}
where $I_m$ is positive for dissolution and negative for precipitation, $k_m$ is the rate constant,
$a_m$ is the specific reactive surface area, $\Omega_m$ is termed the mineral saturation ratio,
expressed as

\begin{equation}
\Omega_m = \frac{1}{K_m} \prod_{j}(\gamma_j C_j)^{\nu_{jm}},
\end{equation}
where $K_m$ is the equilibrium constant for mineral $m$.

The rate constant $k_m$ is typically reported at a reference temperature (commonly
25$^{\circ}$C). Using an Arrhenius relation, the temperature dependence of $k_m$ is given as

\begin{equation}
k_m(T) = k_{m,0} \exp\left[\frac{E_a}{R} \left(\frac{1}{T_0} - \frac{1}{T}\right)\right],
\end{equation}
where $k_{m,0}$ is the rate constant at reference temperature $T_0$, $E_a$ is the activation energy,
$R$ is the gas constant.

The exponents $\theta$ and $\eta$ in the reaction rate equation are specific to each mineral
reaction, and should be measured experimentally. For simplicity, they are set to unity in this
module.

The rate of change in molar concentration, $C_m$, of the $m^{\mathrm{th}}$ mineral species is

\begin{equation}
\frac{\partial C_m}{\partial t} = I_m.
\end{equation}

This can be expressed in terms of the mineral volume fraction

\begin{equation}
\phi_m = \overline{V}_m C_m,
\end{equation}
where $\overline{V}_m$ is the molar volume of the $m^{\mathrm{th}}$ mineral species,
\begin{equation}
\frac{\partial \phi_m}{\partial t} = \overline{V}_m I_m.
\end{equation}

The total porosity, $\phi_t$, can be defined in terms of the volume fraction of all mineral species

\begin{equation}
\phi_t = 1 - \sum_m \phi_m.
\end{equation}

In this way, the change in porosity due to mineral precipitation or dissolution can be calculated,
which can then be used to calculate changes in other material properties such as permeability.

## Implementation details

The physics described above is implemented in a number of `Kernels` and `AuxKernels`

### Kernels

The transport of each primary species is calculated using the following `Kernels`:

- [`PrimaryTimeDerivative`](/PrimaryTimeDerivative.md) Rate of change of
  primary species concentration
- [`PrimaryConvection`](/PrimaryConvection.md) Convective flux of primary
  species
- [`PrimaryDiffusion`](/PrimaryDiffusion.md) Diffusion of primary species

The transport of primary species present in a secondary species is included using:

- [`CoupledBEEquilibriumSub`](/CoupledBEEquilibriumSub.md) Rate of change of
  primary species concentration in an equilibrium secondary species
- [`CoupledConvectionReactionSub`](/CoupledConvectionReactionSub.md)
  Convection of primary species concentration in an equilibrium secondary species
- [`CoupledDiffusionReactionSub`](/CoupledDiffusionReactionSub.md) Diffusion
  of primary species concentration in an equilibrium secondary species

The amount of primary species converted to an immobile mineral phase is given by

- [`CoupledBEKinetic`](/CoupledBEKinetic.md) Rate of change of primary
  species concentration in mineral species due to dissolution or precipitation

The Darcy flux is calculated using

- [`DarcyFluxPressure`](/DarcyFluxPressure.md) Darcy flux

### AuxKernels

The following `AuxKernels` are used to calculate secondary species and mineral concentrations, as
well as total primary species concentration and solution pH.

- [`AqueousEquilibriumRxnAux`](/AqueousEquilibriumRxnAux.md) The concentration
  of secondary species $C_i$ for the $i^{\mathrm{th}}$ equilibrium reaction
- [`KineticDisPreRateAux`](/KineticDisPreRateAux.md) The kinetic rate $I_m$
  of the $m^{\mathrm{th}}$ kinetic reaction
- [`KineticDisPreConcAux`](/KineticDisPreConcAux.md) The concentration of mineral species
- [`TotalConcentrationAux`](/TotalConcentrationAux.md) The total concentration of a given primary species
- [`PHAux`](/PHAux.md) The pH of the solution
- [`EquilibriumConstantAux`](/EquilibriumConstantAux.md) Temperature-dependent equilibrium constant

### Material properties

The `Kernels` above require several material properties to be defined using the following names:
porosity, diffusivity and conductivity. These can be defined using one of the `Materials` available
in the framework. For example, constant properties can be implemented using a
[`GenericConstantMaterial`](/GenericConstantMaterial.md) with the following:

[Materials]
[./porous]
    type = GenericConstantMaterial
    prop_names = 'diffusivity conductivity porosity'
    prop_values = '1e-4 1e-4 0.2'
  [../]
[]
 caption=Required material properties

More complicated formulations can be added by creating new `Materials` as required.

### Boundary condition

A flux boundary condition, [`ChemicalOutFlowBC`](/ChemicalOutFlowBC.md) is
provided to define $\nabla u$ on a boundary.

### Postprocessors

The total volume fraction of a given mineral species can be calculated using a
[`TotalMineralVolumeFraction`](/TotalMineralVolumeFraction.md) postprocessor.

## Reaction network parser id=parser

The chemical reactions module includes a reaction network parser in the `Actions` system that enables
chemical reactions to be specified in a natural form in the input file. The parser then adds all
required `Variables`, `AuxVariables`, `Kernels` and `AuxKernels` to represent the total geochemical
model. To use the reaction network parser, a `ReactionNetwork` block can be added to the input file.

Equilibrium reactions can be entered in the `ReactionNetwork` block using an
`AqueousEquilibriumReactions` sub-block, while kinetic reactions are entered in
a `SolidKineticReactions` sub-block.

The input file syntax for equilibrium reactions has to following form:

\begin{equation}
\begin{aligned}
\nu_{11} \mathcal{A}_1 + \nu_{21} \mathcal{A}_2 + \ldots =& \mathcal{A}_{eq1} \log_{10}(K_{eq}),\\
\nu_{12} \mathcal{A}_1 + \nu_{22} \mathcal{A}_2 + \ldots =& \mathcal{A}_{eq2} \log_{10}(K_{eq})
\end{aligned}
\end{equation}

Individual equilibrium reactions are provided with the primary species on the left hand side, while
the equilibrium species follows the `=` sign, followed by the log of the equilibrium constant. A
comma is used to delimit reactions, so that multiple equilibrium reactions can be entered.

The syntax for solid kinetic reactions is similar, except that no equilibrium constant is entered in
the reactions block.

To demonstrate the use of the reaction network parser, consider the geochemical model used in
[!cite](guo2013), which features aqueous equilibrium reactions as well as kinetic mineral dissolution
and precipitation.

Equilibrium reactions:

\begin{equation}
\begin{aligned}
H^+ + HCO_3^- &\rightleftharpoons CO_2(aq)  & K_{eq} &= 10^{6.341} \\
HCO_3^- &\rightleftharpoons H^+ + CO_3^{2-} & K_{eq} &= 10^{-10.325} \\
Ca^{2+} + HCO_3^- &\rightleftharpoons H^+ + CaCO_3(aq) & K_{eq} &= 10^{-7.009} \\
Ca^{2+} + HCO_3^- &\rightleftharpoons CaHCO_3^+ & K_{eq} &= 10^{-0.653} \\
Ca^{2+} &\rightleftharpoons H^+ + CaOH^+ & K_{eq} &= 10^{-12.85} \\
- H^+ &\rightleftharpoons OH^- & K_{eq} &= 10^{-13.991}
\end{aligned}
\end{equation}

Kinetic reaction:

\begin{equation*}
Ca^{2+} + HCO_3^- \rightleftharpoons H^+ + CaCO_3(s)
\end{equation*}

with equilibrium constant $K_{eq} = 10^{1.8487}$, specific reactive surface area $a_m = 0.461$
m$^2$/L, kinetic rate constant $k_m = 6.456542 \times 10^{-2}$ mol/m$^2$ and activation energy $E_a =
15,000$ J/mol.

[ReactionNetwork]
[./AqueousEquilibriumReactions]
    primary_species = 'ca2+ hco3- h+'
    secondary_species = 'co2_aq co32- caco3_aq cahco3+ caoh+ oh-'
    pressure = pressure
    reactions = 'h+ + hco3- = co2_aq 6.341,
                 hco3- - h+ = co32- -10.325,
                 ca2+ + hco3- - h+ = caco3_aq -7.009,
                 ca2+ + hco3- = cahco3+ -0.653,
                 ca2+ - h+ = caoh+ -12.85,
                 - h+ = oh- -13.991'
  [../]
  [./SolidKineticReactions]
    primary_species = 'ca2+ hco3- h+'
    kin_reactions = 'ca2+ + hco3- - h+ = caco3_s'
    secondary_species = caco3_s
    log10_keq = 1.8487
    reference_temperature = 298.15
    system_temperature = 298.15
    gas_constant = 8.314
    specific_reactive_surface_area = 4.61e-4
    kinetic_rate_constant = 6.456542e-7
    activation_energy = 1.5e4
  [../]
[]

         caption=Example of AqueousEquilibriumReactions action.

The reactive transport system above can be provided in the input file without using the reaction
network parser. However, this adds more than 400 lines of input in this case, due to the large number
of kernels that have to be provided!

## Objects, Actions, and, Syntax



## actions

### AddCoupledEqSpeciesActions


This action only creates the [Kernels](Kernels/index.md) and [AuxKernels](AuxKernels/index.md).
The primary species are created as [nonlinear variables](Variables/index.md), by the [AddPrimarySpeciesAction.md].
The reactions are parsed from the syntax described on this [page](modules/chemical_reactions/index.md#parser).
Equilibrium species are output as [auxiliary variables](AuxVariables/index.md), by the [AddSecondarySpeciesAction.md].
This action is the aqueous equilibrium pendant of the solid kinetic [AddCoupledSolidKinSpeciesAction.md].




### AddCoupledSolidKinSpeciesActions


This action only creates the [Kernels](Kernels/index.md) and [AuxKernels](AuxKernels/index.md).
The primary species are created as [nonlinear variables](Variables/index.md), by the [AddPrimarySpeciesAction.md].
The reactions are parsed from the syntax described on this [page](modules/chemical_reactions/index.md#parser).
Equilibrium species are output as [auxiliary variables](AuxVariables/index.md), by the [AddSecondarySpeciesAction.md].
This action is the solid kinetic pendant of the aqueous equilibrium [AddCoupledEqSpeciesAction.md].




### AddPrimarySpeciesAction


All the variables are created with the same finite element family and order, and with the same nonlinear variable
scaling.


#### Inputs for aqueous equilibrium reactions


#### Inputs for solid kinetics reactions



### AddSecondarySpeciesAction


All the variables are created with the same finite element family and order, which are also
shared by the primary variables created within the same syntax by the [AddPrimarySpeciesAction.md].


#### Inputs for aqueous equilibrium reactions


#### Inputs for solid kinetics reactions



### ChemicalComposition Action

This action is designed for use with the thermochemistry library Thermochimica [!cite](piro2013). Check out the corresponding submodule by running `git submodule update --init --checkout modules/chemical_reactions/contrib/thermochimica`.

#### Description

The `ChemicalComposition` action is used to initiate the framework for thermochemical calculations using the thermodynamics solver [*Thermochimica*](https://github.com/ORNL-CEES/thermochimica). The action creates variables needed for the analysis, reads the thermodynamic model for material system, and sets the units for temperature, pressure, and elemental amounts. It can optionally initiate the amounts of elements used in the model.

The `ChemicalComposition` action is also used to specify lists of chemical phases and chemical species for which concentrations should be output at each timestep. The phase and species names must match those in the data file specified. The `ChemicalComposition` action creates all AuxVariables needed for output of phase concentration data, chemical potentials, vapor pressures, etc. The list of phases is specified in the `output_phases` variable, and the list of species is specified in `output_species`. The species must be specified in the convention `phase_name:species_name` so that the desired species in the desired phase is uniquely identified. Alternatively, users can specify `ALL` to output all species present in the specified thermodynamic database. Other desired outputs such as element potentials, vapor pressures of species in gas phase and moles of elements in specified phases can be specified using `output_element_potentials`, `output_vapor_pressures`, and `output_element_phases` respectively. The `ChemicalComposition` action creates a UserObject derived from [`ThermochimicaNodalData`](/userobjects/ThermochimicaNodalData.md) or [`ThermochimicaElementData`](/userobjects/ThermochimicaElementData.md) which runs Thermochimica at each node and stores the output in the created aux variables.

In this UserObject, the masses of elements included in the vector variable [!param](/UserObjects/ThermochimicaElementData/elements) are input
to the Fortran 90 module Thermochimica, along with the temperature and pressure. Optionally, the
user may disable Thermochimica calculation re-initialization by setting [!param](/UserObjects/ThermochimicaElementData/reinit_type) to `none`.
This may reduce memory use in the calculation, but will likely greatly increase the length of each
call to Thermochimica.

The `ALL` option circumvents the need for users to explicitly state each input element and the output variables. When used for specifying the input [!param](/ChemicalComposition/elements), all the chemical elements present in the thermodynamic database are parsed and used to create the required MOOSE variables. The users must however be careful to specify the proper values of these elements either directly in the input file (for example, as done using ICs in `MoRu.i`) or using CSV inputs (such as in `csv.i`). When the `ALL` option is used to specify outputs, all phases / species / element potentials / etc. that are present in the thermodynamic database and which can exist with the given combination of input elements will be outputted. The users must be aware that, depending on the size of the thermodynamic database, this can lead to a large number of such variables being written to the output files leading to slowdown of both the simulations as well as higher memory use.

#### Variables for Chemical Elements

Chemical element variables to be used and initiated in the model using in `ChemicalComposition` action are specified using the block `[GlobalParams]`, and vector `elements` as in [chemact:globpar]:

[GlobalParams]
  elements = 'Mo Ru'
[]

The vector [!param](/ChemicalComposition/elements) will be passed to the `ChemicalComposition` action and used to generate scalar variables, (e.g. `Mo`, and `Ru`) of the chemical elements contained in the vector.

The names of scalar variables listed in `elements` vector and created using `ChemicalComposition` action should not be used for other variables in the model, e.g. the model should not define variables `Mo`, or `Ru` in the `[Variables]` or `[AuxVariables]` blocks.

The element composition scalar variables can be initialized in `ChemicalComposition` action, or using `[Functions]` block combined with other MOOSE capabilities.

#### Variables for Chemical Phases, Species, and Element Chemical Potentials

Chemical phase and species variables, as well as chemical potentials of elements, to be used and initiated in the model using in `ChemicalComposition` action are specified using the block `[GlobalParams]`, and vector [!param](/ChemicalComposition/output_phases) as in [phaseact:globpar]:


The vectors [!param](/ChemicalComposition/output_phases), [!param](/ChemicalComposition/output_species), [!param](/ChemicalComposition/output_element_potentials), [!param](/ChemicalComposition/output_vapor_pressures), and [!param](/ChemicalComposition/output_element_phases) will be passed to the `ChemicalComposition` action and used to generate scalar variables, (e.g. `BCCN` and `BCCN:Mo`) for the chemical phases and species contained in the vectors. The action will set up either a [ThermochimicaNodalData](ThermochimicaNodalData.md) or a [ThermochimicaElementData](ThermochimicaElementData.md) userobject, depending on whether the  [!param](/ChemicalComposition/is_fv) parameter is set to `false` or `true` respectively.

The names of scalar variables listed in `phases` vector and created using `ChemicalComposition` action should not be used for other variables in the model, e.g. the model should not define variable `BCCN` in the `[Variables]` or `[AuxVariables]` blocks.

The format for entries in `output_species` must be `phase_name:species_name` or `ALL`, and both must match the specified thermodynamic database.

The format for entries in `output_element_potentials` must be `mu:element_name`  or `ALL`.

The format for entries in `output_vapor_pressures` must be `vp:gas_phase_name:species_name`  or `ALL`. The phase name must correspond to the gas phase in the thermodynamic database.

The format for entries in `output_element_phases` must be `ep:phase_name:element_name`  or `ALL`.

The variables created by this action will be used by the UserObject `ThermochimicaNodalData` (or, more likely, a derived class specific to the application) to generate arrays in which to store the indices of the requested phases in Thermochimica calculation results, and to store the corresponding concentration values.

The elemental composition is used in `Thermochimica` calculations, e.g `ThermochimicaNodalData` or `ThermochimicaElementData` UserObject, that expect an `elements` vector.

This `ChemicalComposition` action syntax is shown on the
[ChemicalComposition action](/ChemicalComposition/index.md) action
system page.


### CommonChemicalComposition Action

#### Description

This `CommonChemicalComposition` action adds the parameters supplied at the `[ChemicalComposition]` level as defaults for all the subblocks within the `[ChemicalComposition]` block. See the description, example use, and parameters on the [ChemicalComposition action](/ChemicalComposition/index.md) action system page.

## auxkernels

### AqueousEquilibriumRxnAux


Calculates the concentration of the $i^{\mathrm{th}}$ secondary species, $C_i$ in terms of
primary species concentration $C_j$ using the mass action equation

\begin{equation}
C_i = \frac{K_i}{\gamma_i} \prod_{j=1}^{N_c} \left(\gamma_j C_j\right)^{\nu_{ji}},
\end{equation}
where $K_i$ is equilibrium constant, $\gamma_i$ is the activity coefficient, and
$N_c$ is the number of primary species.




### EquilibriumConstantAux


#### Description

Calculates the equilibrium constant $K_{eq}$ given a series of temperature - $\log_{10}(K_eq)$
points, which is returned as $\log_{10}(K_eq)$.

If more than five points are provided, $\log_{10}(K_eq)$ is calculated using a Maier-Kelly
type fit

\begin{equation}
\log_{10}(K_{eq}) = c_1 \log(T) + c_2 + c_3 T + c_4/T + c_5/T^2,
\end{equation}
where $T$ is the temperature in Kelvin.

If between two and four data points are provided, a linear least-squares fit is used
to calculate $\log_{10}(K_eq)$.

If only one data point is provided, then $\log_{10}(K_eq)$ is set as a constant value.

#### Example Input File Syntax





### KineticDisPreConcAux


Calculates the concentration of mineral using the kinetic reaction rate $I_m$ (calculated using
[`KineticDisPreRateAux`](/KineticDisPreRateAux.md)),

\begin{equation}
\frac{d C_m}{d t} = I_m.
\end{equation}




### KineticDisPreRateAux


Calculates the kinetic reaction rate based on transition state theory

\begin{equation}
I_m = \pm k_m a_m \left|1 - \Omega_m^{\theta}\right|^{\eta},
\end{equation}
where $I_m$ is positive for dissolution and negative for precipitation, $k_m$ is the rate constant,
$a_m$ is the specific reactive surface area, $\Omega_m$ is termed the mineral saturation ratio,
expressed as

\begin{equation}
\Omega_m = \frac{1}{K_m} \prod_{j}(\gamma_j C_j)^{\nu_{jm}},
\end{equation}
where $K_m$ is the equilibrium constant for mineral $m$, $\gamma_j$ is the activity coefficient,
$C_j$ is the concentration of the $j^{\mathrm{th}}$ primary species and $\nu_{jm}$ is the
stoichiometric coefficient.

The rate constant $k_m$ is typically reported at a reference temperature (commonly
25$^{\circ}$C). Using an Arrhenius relation, the temperature dependence of $k_m$ is given as

\begin{equation}
k_m(T) = k_{m,0} \exp\left[\frac{E_a}{R} \left(\frac{1}{T_0} - \frac{1}{T}\right)\right],
\end{equation}
where $k_{m,0}$ is the rate constant at reference temperature $T_0$, $E_a$ is the activation
energy, $R$ is the gas constant.

The exponents $\theta$ and $\eta$ in the reaction rate equation are specific to each mineral
reaction, and should be measured experimentally. For simplicity, they are set to unity in this
module.




### PHAux


Calculates the pH of the solution, defined as

\begin{equation}
pH = - \log_{10} \left(a_H \right),
\end{equation}
where $a_H$ is the activity of H+ ions,

\begin{equation}
a_H = \gamma_H C_H,
\end{equation}
where $\gamma_H$ is the activity coefficient of the H+ ions, and
$C_H$ is the molar concentration of free H+ ions.




### TotalConcentrationAux


Calculates the total concentration of the $j^{\mathrm{th}}$ primary species
as the sum of its free concentration $C_j$ and its stoichiometric contribution
to all secondary equilibrium species in which it participates
\begin{equation}
C_{j, \mathrm{tot}} = C_j + \sum_i \nu_{ji} C_i,
\end{equation}
where $\nu_{ji}$ is the stoichiometric coefficient of the $j^{\mathrm{th}}$ primary
species in the $i^{\mathrm{th}}$ secondary equilibrium species.




## bcs

### ChemicalOutFlowBC


Integrated boundary condition to specify $\nabla u$ on the boundary, which arises
from integration by parts on the diffusion term
\begin{equation}
\nabla \cdot \left(\phi D \nabla C_j \right)
\end{equation}
where $\phi$ is porosity and $D$ is the diffusivity.




## kernels

### CoupledBEEquilibriumSub


Derivative of concentration of $j^{\mathrm{th}}$ primary species present in the
secondary equilibrium species wrt time. Implements the weak form of
\begin{equation}
\frac{\partial}{\partial t} \left(\phi \sum_i \nu_{ji} C_i\right),
\end{equation}
where $\phi$ is porosity, $\nu_{ji}$ are the stoichiometric coefficients, and
$C_i$ is the concentration of the $i^{\mathrm{th}}$ secondary equilibrium species.




### CoupledBEKinetic


Derivative of concentration of $j^{\mathrm{th}}$ primary species present in the
mineral species wrt time. Implements the weak form of
\begin{equation}
\frac{\partial}{\partial t} \left(\phi \sum_m C_m \right),
\end{equation}
where $\phi$ is porosity and $C_m$ is the concentration of the $m^{\mathrm{th}}$
mineral species.




### CoupledConvectionReactionSub


Convective flux of concentration of the $j^{\mathrm{th}}$ primary species present in the secondary
equilibrium species. Implements the weak form of

\begin{equation}
\mathbf{q} \cdot \left[ \nabla \left(\sum_i \nu_{ji} C_i\right) \right]
\end{equation}
where $\nu_{ji}$ are the stoichiometric coefficients, $C_i$ is the concentration of the
$i^{\mathrm{th}}$ secondary equilibrium species, and $\mathbf{q}$ is the Darcy velocity

\begin{equation}
\mathbf{q} = - \frac{K}{\mu} \left(\nabla P - \rho \mathbf{g}\right),
\end{equation}
where $K$ is the permeability tensor, $\mu$ is fluid viscosity, $P$ is pressure, $\rho$ is fluid
density, and $\mathbf{g}$ is gravity (by default, the gravity term is not included).

$K/\mu$ and $\rho$ are expected as material properties called conductivity and density, respectively.




### CoupledDiffusionReactionSub


Diffusive flux of the $j^{\mathrm{th}}$ primary species present in the secondary equilibrium
species. Implements the weak form of

\begin{equation}
\nabla \cdot \left[\phi D \nabla \left(\sum_i \nu_{ji} C_i\right) \right]
\end{equation}
where $\phi$ is porosity, $D$ is the diffusivity, $\nu_{ji}$ are the stoichiometric coefficients,
$C_i$ is the concentration of the $i^{\mathrm{th}}$ secondary equilibrium species.




### DarcyFluxPressure


The Darcy flux
\begin{equation}
\mathbf{q} = - \frac{K}{\mu} \left(\nabla P - \rho \mathbf{g}\right),
\end{equation}
where $K$ is permeability, $\mu$ is fluid viscosity, $P$ is pressure, $\rho$ is fluid density,
and $\mathbf{g}$ is gravity.

This kernel should be used for the pressure variable. If gravity or density are not provided
(the default behaviour), this kernel is identical to the Diffusion kernel.

$K/\mu$ and $\rho$ are expected as material properties called conductivity and density, respectively.




### DesorptionFromMatrix


The weak form for this term is:

(\dot{m}, \psi)

where $\dot{m}$ is the mass rate from the matrix to the porespace and $\psi$ the test function.
The mass rates used in the kernel are retrieved directly from material properties, with the property name
following the same convention as [LangmuirMaterial.md] and [MollifiedLangmuirMaterial.md], e.g. "mass_rate_from_matrix"
for the mass rate, and "dmass_rate_from_matrix_dC" / "dmass_rate_from_matrix_dp" for its derivatives with regards to the
nonlinear variables, concentration and pore pressure.




### DesorptionToPorespace


The weak form for this term is:

(-\dot{m}, \psi)

where $\dot{m}$ is the mass rate from the matrix to the porespace and $\psi$ the test function.
The mass rates used in the kernel are retrieved directly from material properties, with the property name
following the same convention as [LangmuirMaterial.md] and [MollifiedLangmuirMaterial.md], e.g. "mass_rate_from_matrix"
for the mass rate, and "dmass_rate_from_matrix_dC" / "dmass_rate_from_matrix_dp" for its derivatives with regards to the
nonlinear variables, concentration and pore pressure.




### PrimaryConvection


Convective flux of concentration of the $j^{\mathrm{th}}$ primary species.
Implements the weak form of
\begin{equation}
\mathbf{q} \cdot \left(\nabla C_j \right)
\end{equation}
where $\mathbf{q}$ is the Darcy velocity
\begin{equation}
\mathbf{q} = - \frac{K}{\mu} \left(\nabla P - \rho \mathbf{g}\right),
\end{equation}
where $K$ is the permeability tensor, $\mu$ is fluid viscosity, $P$ is pressure,
$\rho$ is fluid density, and $\mathbf{g}$ is gravity (by default, the gravity term
is not included).

$K/\mu$ and $\rho$ are expected as material properties called conductivity and density, respectively.




### PrimaryDiffusion


Diffusive flux of the $j^{\mathrm{th}}$ primary species. Implements the weak form of
\begin{equation}
\nabla \cdot \left(\phi D \nabla C_j \right)
\end{equation}
where $\phi$ is porosity and $D$ is the diffusivity.




### PrimaryTimeDerivative


Derivative of concentration of the $j^{\mathrm{th}}$ primary species wrt time.
Implements the weak form of
\begin{equation}
\phi \frac{\partial C_j}{\partial t},
\end{equation}
where $\phi$ is porosity.




## materials

### LangmuirMaterial


This material computes the mass rates from the matrix to the porespace, as well as the derivatives
of the mass rates with regards to the gas species and with regards to the pressure.

If the concentration is above the equilibrium concentration, desorption occurs and the mass rate is
equal to

\dot{m}_{m\rightarrow p} = \dfrac{C-C_{eq}}{K_d} 

else adsorption is happening and:

\dot{m}_{m\rightarrow p} = \dfrac{C-C_{eq}}{K_a} 

where $m_{m\rightarrow p}$ is the mass rate from the matrix to the porespace, $C$ the species concentration, $C_{eq}$ the
equilibrium concentration and $K_d$ / $K_a$ are the desorption and adsorption time constants (in seconds).




### MollifiedLangmuirMaterial


This material computes the mollified mass rates from the matrix to the porespace, as well as the derivatives
of the mollified mass rates with regards to the gas species and with regards to the pressure.

If the concentration is above the equilibrium concentration, desorption occurs and the mass rate is
equal to

\dot{m}_{m\rightarrow p} = A_{mol} * \dfrac{C-C_{eq}}{K_d} 

else adsorption is happening and:

\dot{m}_{m\rightarrow p} = A_{mol} * \dfrac{C-C_{eq}}{K_a} 

where $m_{m\rightarrow p}$ is the mass rate from the matrix to the porespace, $C$ the species concentration, $C_{eq}$ the
equilibrium concentration and $K_d$ / $K_a$ are the desorption and adsorption time constants (in seconds). The mollifier term
$A_{mol}$ is equal to

A_{mol} = tanh(\dfrac{C - C_{eq}}{ \text{mollifier} * \text{Langmuir density}})




## postprocessors

### TotalMineralVolumeFraction


Calculates the total volume fraction of the coupled mineral species
\begin{equation}
\phi_m = \frac{V_m}{V},
\end{equation}
where $V_m$ is the total volume of the mineral species, and
the reference volume $V$ is the volume of the mesh.




## userobjects

### ThermochimicaData

Contains the templated baseclass for [`ThermochimicaElementData`](ThermochimicaElementData.md) and [`ThermochimicaNodalData`](ThermochimicaNodalData.md).

### ThermochimicaElementData


This UserObject is designed for use with thermochemistry library Thermochimica.

#### Description

[`ThermochimicaElementData`](ThermochimicaElementData.md) performs Thermochimica calculations on elements.

This object can only be set up using the [ChemicalComposition](ChemicalCompositionAction.md) action

Thermochimica is called by this object at every execute (please see the Thermochimica user manual
for more details), and the data required to re-initialize Thermochimica calculations is
saved/loaded if re-initialization is enabled.

#### Example Input Syntax




### ThermochimicaNodalData


This UserObject is designed for use with thermochemistry library Thermochimica.

#### Description

[`ThermochimicaNodalData`](ThermochimicaNodalData.md) performs Thermochimica calculations at nodes.

This object can only be set up using the [ChemicalComposition](ChemicalCompositionAction.md) action

Thermochimica is called by this object at every execute (please see the Thermochimica user manual
for more details), and the data required to re-initialize Thermochimica calculations is
saved/loaded if re-initialization is enabled.

#### Example Input Syntax




# Combined Module

As its name implies, the Combined module combines the capabilities of all of the
other modules. This module does not provide capabilities on its own. Its main
purpose is to provide an executable that links together the capabilities of other
modules to allow them to be coupled together for testing and demonstration purposes.


# Contact Module

The interaction of moving bodies is a common occurrence in our world, and therefore modeling such problems is essential to accurately represent the mechanical behavior of the physical world. However, finite element methods do not have an inherent means of modeling contact. Therefore, specific contact algorithms are required. These algorithms enforce constraints between surfaces in the mesh, to prevent penetration and develop contact forces. The MOOSE contact module provides the necessary tools for modeling mechanical contact.

[](---)

## Theory

Mechanical contact between two deformable bodies is based on three requirements.

\begin{equation*}
g \le 0,
\end{equation*}
\begin{equation*}
t_N \ge 0,
\end{equation*}
\begin{equation*}
t_N g = 0.
\end{equation*}


That is, the penetration distance (typically referred to as the gap $g$ in the contact literature) of one of the body into another must not be positive; the contact force $t_N$ opposing penetration must be positive in the normal direction; and either the penetration distance or the contact force must be zero at all times.  In the MOOSE Contact Module, these contact constraints are enforced through the use of either node/face constraints or by using a mortar method.

[](---)

## Node/Face Mechanical Contact

Contact constraints can be enforced through the use of node/face constraints in a manner similar to that detailed by [!cite](heinstein_algorithm_1999)). In this approach, first, a geometric search determines which secondary nodes have penetrated primary faces. For those nodes, the internal force computed by the divergence of stress is moved to the appropriate primary face at the point of contact. Those forces are distributed to primary nodes by employing the finite element shape functions. Additionally, the secondary nodes are constrained to remain on the primary faces, preventing penetration. The module currently supports frictionless, frictional, and glued contact.

[](---)

## Mortar-Based Mechanical Contact

Models specific for mechanical contact enforcement have been developed based on the MOOSE
[mortar constraint system](Constraints/index.md), and provide an alternative
discretization technique for solving mechanical contact. Results of performance studies
using this approach are summarized in [MortarPerformance](modules/contact/MortarPerformance.md).

[](---)


### Tutorial and examples class=center style=font-weight:200;




### Implementation details and analysis class=center style=font-weight:200;

- [Mortar performance](contact/MortarPerformance.md)



## `Contact` Syntax Block

Setting up a model to use contact enforcement in MOOSE requires the creation of
multiple types of MOOSE objects. Using the top-level
[Contact](/Contact/index.md) syntax block, which streamlines the process of
setting up these objects, is highly recommended, and supports most available types of contact.
The following input file example shows the basic usage of the `Contact` block:

[Contact]
[./leftright]
    secondary = 3
    primary = 2
    model = frictionless
    penalty = 1e+6
    normal_smoothing_distance = 0.1
  [../]
[]


## Objects, Actions, and Syntax


## actions

### Contact Action


#### Description

ContactAction is a MOOSE action that constructs objects needed for mechanical contact enforcement. This
is invoked by including the [Contact](syntax/Contact/index.md) block at the top level in a MOOSE input file.
See the page documenting the syntax for that block for a description, example usage, and parameters.

For node-to-segment mechanical contact, the action offers the possibility to automatically set up
mechanical contact pairs given a maximum distance between contacting boundary centroids.
To use that option, the user must set `automatic_pairing_method = CENTROID`.
The user can leverage this capability by providing `automatic_pairing_distance` and
`automatic_pairing_boundaries`. This is particularly useful when many feasible contact
interactions can take place in a periodically repeating pattern.

Alternatively, also for
node-to-segment, the user can choose to select a computation of proximity based on nodal
locations. In essence, for all boundaries provided by the user in `automatic_pairing_boundaries`,
the action will search for all nodes whose distance is less than `automatic_pairing_distance`.
If so, each nodal pair distance from different boundaries less than the `automatic_pairing_distance`
distance will create a contact pair. Repeated contact pairs are automatically eliminated. In order to
activate this feature, in addition to `automatic_pairing_boundaries` and `automatic_pairing_distance`, the
user needs to set the input parameter `automatic_pairing_method = NODE`.

### ExplicitDynamicsContact Action


#### Description

ExplicitDynamicsContactAction is a MOOSE action that constructs objects needed for mechanical contact enforcement for explicit dynamics finite element simulations. This action sets up the method described in [ExplicitDynamicsContactConstraint](source/constraints/ExplicitDynamicsContactConstraint.md).

## auxkernels

### CohesiveZoneMortarUserObjectAux

#### Description

The `CohesiveZoneMortarUserObjectAux` outputs various cohesive zone quantities that
are helpful for analyzing or debugging cohesive zone or debonding simulation results.
This auxiliary kernel is to be used in conjunction with mortar cohesive zone user objects, namely
[BilinearMixedModeCohesiveZoneModel](/BilinearMixedModeCohesiveZoneModel.md).

Quantities that this object can output include: the cohesive zone model damage and the
opening mode mixity ratio.




### ContactPressureAux

#### Description

The `ContactPressureAux` outputs the normal pressure incurred due to two bodies coming into contact. It is computed via:
\begin{equation*}
  p_N = \frac{\boldsymbol{f}\cdot \boldsymbol{n}}{A},
\end{equation*}
where $p_N \in \mathbb{R}$ denotes the contact pressure, $\boldsymbol{f} \in \mathbb{R}^{d}$ represents the contact force in $d$ dimensions, and $A \in \mathbb{R}$ is the nodal area (see [Nodal Area](userobjects/NodalArea.md)).  This object is an [AuxKernel](AuxKernels/index.md), and is used only for the purpose of output. Note that the [Contact](Contact/index.md) action sets this object up automatically, so it is typically not necessary to include this in an input file.






### MortarArchardsLawAux

#### Description

The `MortarArchardsLawAux` outputs the nodal worn-out depth based on a well-known wear equation by Archard. This auxiliary kernel computes nodal quantities which may depend on mortar quantities, i.e. variables that are the result of numerical integration over corresponding mortar segments.
The wear velocity on the boundary may be defined as:

\begin{equation*}
  \dot{w} = \frac{k_{w}}{\mu} \dot{d} = E_{w} \dot{d},
\end{equation*}

where $\dot{d} = \mu p_{n} ||{\dot{\boldsymbol{\tilde{v}}}_{\tau, \text{rel}}}||$ is the frictional dissipation rate density, $E_{w}$ is the energy wear coefficient, $k_{w}$ is the local wear coefficient, $p_n$ is the normal contact pressure, $\mu$ is the coefficient of friction, and $\dot{\boldsymbol{\tilde{v}}}_{\tau, \text{rel}}$ is the tangential relative velocity computed in the mortar sense.
Potential applications of this mortar auxiliary kernel includes the modification of contacting surface shapes due to fretting wear.

#### Input example

Creation of auxiliary variables, i.e. nodal worn-out depth:


Creation of auxiliary kernel for computing worn-out depth:





### MortarFrictionalPressureVectorAux

#### Description

The `MortarFrictionalPressureVectorAux` outputs the frictional pressure vector components using information from the mortar contact solution and its
geometry. Nodal information is used to associate the two frictional Lagrange's multiplier vectors in three-dimensions with their corresponding
tangent vectors generated at the time the mortar segment mesh is generated. This auxiliary kernel is automatically included in the `ContactAction` when the user selects three-dimensional, frictional mortar contact.
The computation of the frictional pressure vector can be expressed as:

\begin{equation*}
  \boldsymbol{p}_{\mu} = \lambda_{fx} \cdot \boldsymbol{t}_{x} + \lambda_{fy} \cdot \boldsymbol{t}_{y},
\end{equation*}

where $\boldsymbol{p}_{\mu}$ denotes the frictional pressure vector, $\lambda_{fx}$ and $\lambda_{fx}$ are two frictional Lagrange's multipliers, and $\boldsymbol{t}_{x}$ and $\boldsymbol{t}_{y}$ are two mutually perpendicular tangent vectors. Note that the directions $x$ and $y$ need not be aligned with global axes. This object is an [AuxKernel](AuxKernels/index.md), and is used only for the purpose of output. Note that the [Contact](Contact/index.md) action sets this object up automatically, so it is typically not necessary to include this in an input file.

#### Input example

Creation of auxiliary variables, i.e. frictional pressure vector components:


Creation of component-wise auxiliary kernels:






### MortarFrictionalStateAux

#### Description

The `MortarFrictionalStateAux` outputs the frictional state of the contact interface nodes. This nodal auxiliary kernel requires the user to
provide the Lagrange multipliers that hold the values of normal contact pressure and frictional tangential pressures. Using a coefficient 
of friction inputted by the user as a reference, this kernel outputs: "1" if the node is not in contact, "2" if the node is in contact and sticking (i.e. frictional force is less than its frictional capacity), and "3" if the node experiences relative tangential velocity, i.e. it is sliding at its frictional capacity.

This kernel can be useful for analyzing complex contact mechanics output in a finite element mesh viewer.




### MortarPressureComponentAux

#### Overview

This object transforms the Lagrange multiplier (LM) variable from the Cartesian coordinate system to the local coordinate system and outputs each individual component along the normal or the tangential direction.

The definition of LM variable on node $j$ in the Cartesian coordinate system is
\begin{equation}
\boldsymbol{z}_j = (z_x)_j (\boldsymbol{v}_x)_j + (z_y)_j (\boldsymbol{v}_y)_j + (z_z)_j (\boldsymbol{v}_z)_j,
\end{equation}
where $z_x$, $z_y$, $z_z$ are the LM variable components along the $x$, $y$, $z$ directions, respectively. Here, $z_z$ vanishes for two-dimensional problems. The $\boldsymbol{v}_x$ $\boldsymbol{v}_y$, $\boldsymbol{v}_z$ are the normal vectors along the three directions.

In the local coordinate system, the definition of LM variable is
\begin{equation}
\boldsymbol{z}_j = (z_n)_j \boldsymbol{n}_j + (z_\tau^{1})_j \boldsymbol{\tau}^{1}_j + (z_\tau^{2})_j \boldsymbol{\tau}^{2}_j ,
\end{equation}
where $z_n$ is the component that is normal to the contact surface,  $\boldsymbol{n}$ is the local normal vector. For frictional problems in two dimensions, the $z_\tau^{1}$ is the tangential component that is aligned with the contact surface, $\boldsymbol{\tau}^{1}$ is the corresponding tangential vector. In three-dimensional frictional problems, an additional component, $z_\tau^{2}$ exist along the contact surface, which is associated with the second tangential vector $\boldsymbol{\tau}^{2}$.





### PenaltyMortarUserObjectAux

#### Description

The `PenaltyMortarUserObjectAux` outputs various contact quantities that
are helpful for analyzing or debugging contact results. This auxiliary kernel
is to be used in conjunction with mortar penalty contact user objects, namely
[PenaltyFrictionUserObject](/PenaltyFrictionUserObject.md) or
[PenaltyWeightedGapUserObject](/PenaltyWeightedGapUserObject.md).

Quantities that this object can output include: the normal and friction
pressure values, accumulated slip distances, tangential relative velocities,
and weighted gap values.




### WeightedGapVelAux


#### Overview

This object computes a discrete weighted gap velocity $\dot{\tilde{g}}_i$ in a mortar context according to

\begin{equation}
\dot{\tilde{g}}_i = \frac{\int_{\Gamma_c^{(1)}} \psi_i \dot{g}_h dA}{\int_{\Gamma_c^{(1)}} dA}
\end{equation}

where $\Gamma_c^{(1)}$ denotes the secondary contact interface, $\psi_i$ is the $i$th
shape function associated with the auxiliary variable this aux kernel is
computing the value for and $\dot{g}_h$ is the discretized version of the gap velocity
function, computed in this aux kernel as the difference in quadrature point spatial velocity
between primary and secondary faces times the normal vector.




## constraints

### CartesianMortarMechanicalContact


#### Overview

It applies mortar generalized forces from Lagrange multipliers defined in the global Cartesian frame of reference.
This can be used for both frictional and frictionless contact.

#### Example Input File Syntax

In this example, we solve a cylinder-on-plane plane strain frictional problem with Cartesian Lagrange multipliers.
Subdomain `10000` and `10001` are lower dimensional blocks (1D here) created from the `2` and `3` sidesets respectively,
which are on both sides of the contact axis.





### ComputeDynamicFrictionalForceLMMechanicalContact


When the mortar mechanical contact constraints are used in dynamic simulations, the normal contact constraints need to be stabilized by ensuring that normal gap derivatives are included in the definition. This is a way of guaranteeing the 'persistency' condition, i.e. not only do we enforce the constraints instantaneously, but also that it will remain in contact. This approximate contact constraint stabilization is performed in [ComputeDynamicWeightedGapLMMechanicalContact](/ComputeDynamicWeightedGapLMMechanicalContact.md), from which this object inherits. Therefore `ComputeDynamicFrictionalForceLMMechanicalContact` is used as the base frictional mortar contact class to implement friction models that in a dynamic setting.

The `capture_tolerance` is an optional contact parameter used in dynamic contact constraints to determine when to impose the persistency condition for normal contact. For relevant, general equations, see [!citep](tal2018dynamic).




### ComputeDynamicWeightedGapLMMechanicalContact


This object is virtually analogous to [ComputeWeightedGapLMMechanicalContact](/ComputeWeightedGapLMMechanicalContact.md), but it is used for dynamic simulations.

When the mortar mechanical contact constraints are used in dynamic simulations, the normal contact constraints need to be stabilized by ensuring that the normal gap time derivative is included to guarantee a dynamic contact. This is a means of guaranteeing the 'persistency' condition, i.e. not only do we enforce the constraints instantaneously, but also that the contact interface will remain in contact locally. This approximate contact constraint stabilization is performed in  `ComputeDynamicWeightedGapLMMechanicalContact`. Once nodal contact is established, the constraint enforcement is switched to the persistency equation:

\begin{equation}
\begin{aligned}
(\tilde{g}_n)_j \coloneqq  \dot{\tilde{g}}_{nj} \cdot \Delta t
\end{aligned}
\end{equation}

where $\,\dot{}\,$ denotes the first time derivative, $\Delta t$ is the time step increment, $j$ refers to an arbitrary node.

The `capture_tolerance` is an optional contact parameter used in dynamic contact constraints to determine when to impose the persistency condition for normal contact.

For relevant, general equations, see [!citep](tal2018dynamic). Also, for discussion on the relevance of normal contact constraint stabilization for energy conservation and contact force accuracy, in the context of mortar constraints, see [!citep](recuero2022practical).




### ComputeFrictionalForceCartesianLMMechanicalContact



This class represents a preliminary implementation of frictional mortar contact constraints intended to be used with Lagrange's multiplier interpolation with dual bases. The nonlinear complementarity constraints employed here are based on a primal-dual active set strategy (PDASS), see [!citep](gitterle2010finite). These constraints capture nodes in sticking and slipping states on different solution branches, and can be written as:

\begin{equation}
C_{tj}(\lambda_{j},\boldsymbol{u}, \boldsymbol{\dot{u}}) = \max({\mu({p} + c_{n}\tilde{g}_{nj}),  \mathrm{abs}({\lambda_{j} + c_t \tilde{u}_{tj}}))  \lambda_{j} - \mu \max({0,({p} + c_{n}\tilde{g}_{nj})}) (\lambda_{j} + c_t \tilde{u}_{tj})
}
\end{equation}

$p$ is the normal contact pressure, $\lambda_{j}$ is a Lagrange's multiplier that refers to the tangential contact pressure at node $j$, $\tilde{u}_{tj}$ is the weighted tangential velocity integrated forward in time, $\tilde{g}_n)_j$ is the weighted normal gap, $c_{n}$ is a numerical parameter ($c$ in [ComputeWeightedGapLMMechanicalContact](/ComputeWeightedGapLMMechanicalContact.md)) and $c_{t}$ is a numerical parameter that can determine convergence properties but has no effect on the results.

The nodal, weighted tangential velocity is computed as
\begin{equation}
\tilde{v}_{tj} = \int_{\gamma_c^{(1)}} \Phi_j v_{t,h} dA
\end{equation}

where $\gamma_c^{(1)}$ denotes the secondary contact interface, $\Phi_j$ is the
j'th lagrange multiplier test function, and $v_{t,h}$ is the discretized version
of the tangential velocity function. Note that this object assumes that the Lagrange multipliers are defined in a global Cartesian frame.
Local variables to solve the contact problem are projected using nodal geometry, i.e. normal and tangential vectors.

This object automatically enforces normal contact constraints by making calls to its parent class.

The preliminary recommendation is to select  `c` to be on the order of the moduli of elasticity of the bodies into contact, and `c_t` to be a few orders of magnitude less than `c`. This selection of these purely numerical parameters can represent an initial difficulty when running *new* models, but they can be held constant once good convergence behavior has been attained.

The `ComputeFrictionalForceCartesianLMMechanicalContact` object computes the weighted gap and
applies the frictional contact conditions using Lagrange multipliers defined in a global Cartesian reference frame.
As a consequence, the number of contact constraints at each node will be two, in two-dimensional problems,
and three, in three-dimensional problems. The normal contact pressure is obtained by projecting the Lagrange
multiplier vector along the normal vector computed from the mortar generation objects. The result is a normal
contact constraint, which, in general, will be a function of all (two or three) Cartesian Lagrange multipliers.
The other degree(s) of freedom are constrained by
enforcing that tangential tractions follow Coulomb constraints within a semi-smooth Newton approach. Usage of
Cartesian Lagrange multipliers is recommended when condensing Lagrange multipliers via the variable condensation preconditioner
(VCP) [VariableCondensationPreconditioner](/VariableCondensationPreconditioner.md).





### ComputeFrictionalForceLMMechanicalContact



This class represents a preliminary implementation of frictional mortar contact constraints intended to be used with Lagrange's multiplier interpolation with dual bases. The nonlinear complementarity constraints employed here are based on a primal-dual active set strategy (PDASS), see [!citep](gitterle2010finite). These constraints capture nodes in sticking and slipping states on different solution branches, and can be written as:

\begin{equation}
C_{tj}(\lambda_{j},\boldsymbol{u}, \boldsymbol{\dot{u}}) = \max({\mu({p} + c_{n}\tilde{g}_{nj}),  \mathrm{abs}({\lambda_{j} + c_t \tilde{u}_{tj}}))  \lambda_{j} - \mu \max({0,({p} + c_{n}\tilde{g}_{nj})}) (\lambda_{j} + c_t \tilde{u}_{tj})
}
\end{equation}

$p$ is the normal contact pressure, $\lambda_{j}$ is a Lagrange's multiplier that refers to the tangential contact pressure at node $j$, $\tilde{u}_{tj}$ is the weighted tangential velocity integrated forward in time, $\tilde{g}_n)_j$ is the weighted normal gap, $c_{n}$ is a numerical parameter ($c$ in [ComputeWeightedGapLMMechanicalContact](/ComputeWeightedGapLMMechanicalContact.md)) and $c_{t}$ is a numerical parameter that can determine convergence properties but has no effect on the results.

The nodal, weighted tangential velocity is computed as
\begin{equation}
\tilde{v}_{tj} = \int_{\gamma_c^{(1)}} \Phi_j v_{t,h} dA
\end{equation}

where $\gamma_c^{(1)}$ denotes the secondary contact interface, $\Phi_j$ is the
j'th lagrange multiplier test function, and $v_{t,h}$ is the discretized version
of the tangential velocity function.

This object automatically enforces normal contact constraints by making calls to its parent class `ComputeWeightedGapLMMechanicalContact`, see [ComputeWeightedGapLMMechanicalContact](/ComputeWeightedGapLMMechanicalContact.md) for input parameters and details.

The preliminary recommendation is to select  `c` to be on the order of the moduli of elasticity of the bodies into contact, and `c_t` to be a few orders of magnitude less than `c`. This selection of these purely numerical parameters can represent an initial difficulty when running *new* models, but they can be held constant once good convergence behavior has been attained.




### ComputeWeightedGapCartesianLMMechanicalContact

The Karush-Kuhn-Tucker conditions of mechanical contact are:

\begin{equation}
\begin{aligned}
g &\ge 0\\
\lambda &\ge 0\\
g\lambda &= 0
\end{aligned}
\end{equation}

where $g$ is the gap and $\lambda$ is the contact pressure, a Lagrange multiplier
variable living on the secondary face. Per [!citep](wohlmuth2011variationally)
and [!citep](popp2014dual), the variationally consistent, discretized version of
the KKT conditions are:

\begin{equation}
\begin{aligned}
(\tilde{g}_n)_j &\ge 0\\
(\lambda_n)_j &\ge 0\\
(\tilde{g}_n)_j (\lambda_n)_j &= 0
\end{aligned}
\end{equation}

where $n$ indicates the normal direction, $j$ denotes the j'th secondary contact
interface node, and $(\tilde{g}_n)_j$ is the discrete weighted gap, computed by:

\begin{equation}
(\tilde{g}_n)_j = \int_{\gamma_c^{(1)}} \Phi_j g_{n,h} dA
\end{equation}

where $\gamma_c^{(1)}$ denotes the secondary contact interface, $\Phi_j$ is the
j'th lagrange multiplier test function, and $g_{n,h}$ is the discretized version
of the gap function.

The KKT conditions are enforced using a nonlinear complementarity problem (NCP) function, in this case the most
simple such function, $min(c(\tilde{g}_n)_j, (\lambda_n)_j)$, where $c$ (implemented with the input
parameter `c`) is used to balance the size of the gap
and the normal contact pressure. If the contact pressure is of order 10000, and the
gap is of order .01, then `c` should be set to 1e6 in order to bring
components of the NCP function onto the same level and achieve optimal
convergence in the non-linear solve.

The `ComputeWeightedGapCartesianLMMechanicalContact` object computes the weighted gap and
applies the KKT conditions using Lagrange multipliers defined in a global Cartesian reference frame.
As a consequence, the number of contact constraints at each node will be two, in two-dimensional problems,
and three, in three-dimensional problems. The normal contact pressure is obtained by projecting the Lagrange
multiplier vector along the normal vector computed from the mortar generation objects. The result is a normal
contact constraint, which, in general, will be a function of all (two or three) Cartesian Lagrange multipliers.
This methodology only constrains one degree of freedom. The other degree(s) of freedom are constrained by
enforcing that tangential tractions are identically zero. Note that, if friction with Cartesian Lagrange multipliers
is chosen via [ComputeFrictionalForceCartesianLMMechanicalContact](/ComputeFrictionalForceCartesianLMMechanicalContact.md),
those remaining nodal degrees of freedom are constraint using Coulomb constraints within a semi-smooth Newton approach. Usage of
Cartesian Lagrange multipliers is recommended when condensing Lagrange multipliers via the variable condensation preconditioner
(VCP) [VariableCondensationPreconditioner](/VariableCondensationPreconditioner.md).

The user can also employ locally oriented Lagrange multipliers [ComputeWeightedGapLMMechanicalContact](/ComputeWeightedGapLMMechanicalContact.md),
which minimizes the number of contact constraints for frictionless problems.





### ComputeWeightedGapLMMechanicalContact

The Karush-Kuhn-Tucker conditions of mechanical contact are:

\begin{equation}
\begin{aligned}
g &\ge 0\\
\lambda &\ge 0\\
g\lambda &= 0
\end{aligned}
\end{equation}

where $g$ is the gap and $\lambda$ is the contact pressure, a Lagrange multiplier
variable living on the secondary face. Per [!citep](wohlmuth2011variationally)
and [!citep](popp2014dual), the variationally consistent, discretized version of
the KKT conditions are:

\begin{equation}
\begin{aligned}
(\tilde{g}_n)_j &\ge 0\\
(\lambda_n)_j &\ge 0\\
(\tilde{g}_n)_j (\lambda_n)_j &= 0
\end{aligned}
\end{equation}

where $n$ indicates the normal direction, $j$ denotes the j'th secondary contact
interface node, and $(\tilde{g}_n)_j$ is the discrete weighted gap, computed by:

\begin{equation}
(\tilde{g}_n)_j = \int_{\gamma_c^{(1)}} \Phi_j g_{n,h} dA
\end{equation}

where $\gamma_c^{(1)}$ denotes the secondary contact interface, $\Phi_j$ is the
j'th lagrange multiplier test function, and $g_{n,h}$ is the discretized version
of the gap function.

The `ComputeWeightedGapLMMechanicalContact` object computes the weighted gap and
applies the KKT conditions. The KKT conditions
are enforced using a nonlinear complementarity problem (NCP) function, in this case the most
simple such function, $min(c(\tilde{g}_n)_j, (\lambda_n)_j)$, where $c$ (implemented with the input
parameter `c`) is used to balance the size of the gap
and the normal contact pressure. If the contact pressure is of order 10000, and the
gap is of order .01, then `c` should be set to 1e6 in order to bring
components of the NCP function onto the same level and achieve optimal
convergence in the non-linear solve.





### ExplicitDynamicsContactConstraint


This object implements node-face constraints for the enforcement of normal
mechanical contact in explicit dynamics. Surrogate balance-momentum equations are
solved at each node on the secondary surface using density and wave speed
material properties and the velocities of the two surfaces in contact.

This method MUST be used with the [DirectCentralDifference](source/timeintegrators/DirectCentralDifference.md) time integrator found in the Solid Mechanics module.

Following the work of [!citep](heinstein2000contact), the contact is constrained as such,

\begin{equation}
    \begin{aligned}
        \mathbf{a_n} &= \mathbf{M}^{-1}(\mathbf{F}^\text{ext}-\mathbf{F}^{\text{int}}(\mathbf{u}_n)-\mathbf{G}^T_n\lambda_n)\\
    \end{aligned}
\end{equation}
where $\lambda_n$ is the contact force, and $\mathbf{G_n}$ is the Jacobian of the contact constraints. $\lambda_n$ is calculated with the following iteration,
\begin{equation}
    \begin{aligned}
        \mathbf{v}^{0}_{n+\frac{1}{2}} &= \mathbf{M}^{-1}(\mathbf{F}^\text{ext}-\mathbf{F}^{\text{int}}(\mathbf{u}_n)),\\
        \mathbf{v}^{j+1}_{n+\frac{1}{2}} &= \mathbf{v}^j_{n+\frac{1}{2}}-\Delta t \mathbf{M}^{-1}\mathbf{G_n}(\lambda^{j+1}_n-\lambda^{j}_n),\\
        j & \leftarrow j+1, \text{next } j,
    \end{aligned}
\end{equation}

where $\mathbf{v}^0_{n+\frac{1}{2}}$ is the initial guess for the midstep velocity.

$\lambda_n$ is calculated at each node as a function of the wave speed and density of the primary and secondary material, the gap rate $\mathbf{\dot g}$, and tributary area $\Delta A$,
\begin{equation}
    \begin{aligned}
        \lambda_{n_q} = \frac{\rho^{(1)}\rho^{(2)}c^{(1)}c^{(2)}}{\rho^{(1)}c^{(1)}+\rho^{(2)}c^{(2)}}\mathbf{\dot g}_{n+\frac{1}{2}}\mid_q \Delta A_q,
    \end{aligned}
\end{equation}

where the subscript $_q$ is a nodal index. With this formulation, the constraint force will be calculated within a few iterations.
<!-- For relevant equations, see [!citep](heinstein2000contact), in particular,
Equations (15), (21), (26) and (29). -->




### MechanicalContactConstraint


#### Description

The `MechanicalContactConstraint` class enforces mechanical contact of different types. Three contact models are available. These are `glued`, `frictionless`, and `coulomb`. Here we have
\begin{equation*}
\boldsymbol{t} = t_N\boldsymbol{n} + t_{T}\boldsymbol{\tau},
\end{equation*}
where $\boldsymbol{t}$ denote the total traction, $t_N$ is the normal traction, $t_{T}$ represents the tangential traction, $\boldsymbol{n}$ and $\boldsymbol{\tau}$ are the normal and tangential unit vectors, respectively. The normal contact constraint is the same for these three contact types and are detailed in [contact module description](/modules/contact/index.html). The differences among these contact types lie in the constraint equations for the tangential contact, which is described in the following section.

##### Contact Models

The `glued` contact does not allow slip between the nodes once they come into contact, i.e., $|\boldsymbol{v}_{T}| = 0$,
where $\boldsymbol{v}_{T}$ is the tangential relative velocity.
 Due to the no-slip condition, the `glued` contact is often used to model bonded connections between adjacent bodies that may have mismatching meshes in solid mechanics.

In contrast to the `glued` contact, the `frictionless` contact allows slip between the nodes that are in contact. No tangential traction is assumed, i.e., $|\boldsymbol{v}_{T}| > 0$ and ${t}_{T} = {0}$. The `frictionless` contact is often utilized when the contact surface is pretty smooth thus tangential fraction along the interface can be omitted.

Different from the above two contact models, the `coulomb` model accounts for the friction along the interface caused by the relative motion between nodes. This is modeled using the Coulomb law, which computes a tangential traction that is proportional to the normal traction via a slip condition:
\begin{equation*}
{t}_{T} = -\mu |t_N| \frac{\boldsymbol{v}_T}{||\boldsymbol{v}_T||}\cdot\tau \quad \text{if} \quad ||{t}_T||> \mu |t_N|,
\end{equation*}
where $\mu$ is the friction coefficient.

##### Contact Formulations

To enforce the contact constraints, three types of formulations are available. These are `kinematic`, `penalty`, and `mortar`.
The `kinematic` and `penalty` formulations have been developed for some time and turn out to be robust for many mechanical contact problems. Recent efforts have been put in developing a mortar-based contact formulation. In this documentation, however,  we focus on `kinematic` and `penalty` formulations. For readers who are interested in mortar-based mechanical contact, please go to [mortar constraint system](Constraints/index.md) for more information.

The overall workflow of imposing a mechanical constraint is as follows: 1) Determine whether penetration occurs. If so, constrain displacement; 2) In the normal direction, eliminate the penetration; 3) In the tangential direction, slip must satisfy friction model, no slip is allowed for the `glued` model, no constraint is applied for the `frictionless` model, Kuhn-Tucker conditions must be satisfied in the tangential direction for the `coulomb` model. The mechanical contact enforcement steps for the `glued` and `frictionless` models are summarized below:

For `penalty`:

|  Glued  | Frictionless |
| ---------- | ------------ |
|  $\boldsymbol{f}_c = k_p (\boldsymbol{x} - \boldsymbol{x}_{p_{t-1}})$     | $\boldsymbol{f}_c = \boldsymbol{n}\boldsymbol{n}^{T} k_p (\boldsymbol{x} - \boldsymbol{x}_p)$ |
|  $\boldsymbol{r}_s = \boldsymbol{r}_s + \boldsymbol{f}_c$    | $\boldsymbol{r}_s = \boldsymbol{r}_s + \boldsymbol{f}_c$ |
|  $\boldsymbol{r}_m = \boldsymbol{r}_m - \phi_i\boldsymbol{f}_c$     | $\boldsymbol{r}_m = \boldsymbol{r}_m - \phi_i \boldsymbol{f}_c$ |

For `kinematic`:

|  Glued  | Frictionless |
| ---------- | ------------ |
|  $\boldsymbol{f}_c = -\boldsymbol{r}_{s_{copy}}$     | $\boldsymbol{f}_c = -\boldsymbol{n}\boldsymbol{n}^{T} \boldsymbol{r}_{s_{copy}}$  |
|  $\boldsymbol{r}_s = \boldsymbol{r}_s+\boldsymbol{f}_c+k_p(\boldsymbol{x} - \boldsymbol{x}_{p_{t-1}})$     | $\boldsymbol{r}_s = \boldsymbol{r}_s + \boldsymbol{f}_c + \boldsymbol{n}\boldsymbol{n}^{T} k_p (\boldsymbol{x} - \boldsymbol{x}_{p_{t-1}})$ |
|  $\boldsymbol{r}_m = \boldsymbol{r}_m - \phi_i \boldsymbol{f}_c$     | $\boldsymbol{r}_m = \boldsymbol{r}_m - \phi_i \boldsymbol{f}_c$ |

Note that the `kinematic` method uses penalty parameter only to enforce the condition that the secondary node has the desired position on the primary face, so the errors are very small in the converged solution. Unlike in `penalty` formulations, penalty compliance is not introduced on the contact surface. Therefore, the converged solution has no error due to penalty compliance.

For the frictional contact (`coulomb` model), the `penalty` method calculates normal force and tangential predictor force using penalty stiffness and check for frictional capacity. While using the `kinematic` method, the deformation of surrounding material serves the role of the penalty parameter.

##### Contact gap offset

Gap offset can be provided to the current mechanical contact constraint. It can be either `secondary_gap_offset` (gap offset from secondary side) or `mapped_primary_gap_offset` (gap offset from primary side but mapped to secondary side). Use of these gap offset parameters treats the surfaces as if they were virtually extended (positive offset value) or narrowed (negative offset value) by the specified amount, so that the surfaces are treated as if they are closer or further away than they actually are. There is no deformation within the material in this gap offset region.




### MortarGenericTraction

The `MortarGenericTraction` class is used to apply global traction
vectors on domain boundaries using a mortar formulation. This object
queries an interface traction vector from a mortar user object and
applies it.





### NormalMortarMechanicalContact

The `NormalMortarMechanicalContact` class is used to apply normal contact forces
to the displacement residuals. The contact pressure variable (a Lagrange
multiplier) is specified using the `variable` parameter. The displacement variable
must be specified either using the `secondary_variable` or `primary_variable`
parameter. You must create as many `NormalMortarMechanicalContact` classes as
dimensions in your simulation, e.g. for a two dimensional simulation there must
be `NormalMortarMechanicalContact` instances for both x and y displacement components.





### RANFSNormalMechanicalContact

Enforces the zero penetration constraint using the Reduced Active Nonlinear
Function Set (RANFS) scheme. The algorithm is as follows: do a min comparison
between the penetration and the Lagrange Multiplier (LM) associated with the
zero penetration constraint. If the penetration (properly signed) is less than
the LM, then we replace the non-linear residual equation for the secondary node with
the zero-penetration constraint equation (represented simply by the gap). In
this way the gap is required to be zero.

Advantages of the RANFS scheme:

- No Lagrange Multipliers, e.g. no saddle-point and consequently we are free to use preconditioners like AMG
- No penalty term, so no introduction of ill conditioning into the matrix
- Exact satisfaction of the constraints

The `RANFSNormalMechanicalContact` object includes ping-ponging protection. It
detects when a secondary node has alternated back and forth between two different
element faces a sufficient number of times (currently
face1-face2-face1-face2-face1) and then fixes the issue by applying more RANFS
Explicitly, we apply a number of equality constraints equal to the mesh
dimension tying together the locations of the secondary node and the nearest primary
node (which we assert is a node that both primary faces involved in the ping-pong
share). This ping-ponging protection is necessary for solving step 19 of the
[`full-bouncing-block-ranfs`](bouncing-block-contact/bouncing-block-ranfs.i) test. Without the
protection the solve does not converge and the time-step gets cut.





### TangentialMortarMechanicalContact

The `TangentialMortarMechanicalContact` class is used to apply tangential stresses
to the displacement residuals. The tangential stress variable (a Lagrange
multiplier) is specified using the `variable` parameter. The displacement variable
must be specified either using the `secondary_variable` or `primary_variable`
parameter. You must create as many `TangentialMortarMechanicalContact` classes as
dimensions in your simulation, e.g. for a two dimensional simulation there must
be `TangentialMortarMechanicalContact` instances for both x and y displacement components.





## convergence

### AugmentedLagrangianContactConvergence

The augmented Lagrangian contact algorithm involves a nested solution strategy; see [AugmentedLagrangianContactProblem.md].

`AugmentedLagrangianContactFEProblemConvergence` and  `AugmentedLagrangianContactReferenceConvergence`
track the convergence of the nested solution procedure described above, allow interaction with the solver at each iteration until the tolerance criteria are met, and allow for updating the Lagrangian multipliers as prescribed by [AugmentedLagrangianContactProblem.md].

#### AugmentedLagrangianContactFEProblemConvergence





#### AugmentedLagrangianContactReferenceConvergence





## dampers

### ContactSlipDamper


#### Description

This damper minimizes the oscillations that are inherent in the solution of frictional contact problems by limiting the change in contact state from one nonlinear iteration to the next. This is designed specifically to work with node/face mechanical contact enforced using [MechanicalContactConstraint](/constraints/MechanicalContactConstraint.md).

This damper specifically addresses reversals in the slip direction from one nonlinear iteration to the next. If a node that is in contact slips farther than it should during a given nonlinear iteration, the resulting residual will cause that node to slip back in the opposite direction in the next nonlinear iteration. If that slip in the opposite direction in this next nonlinear iteration is large enough that it causes the node to slip past the original contact point, it can be extremely difficult to obtain a converged solution because the node keeps slipping back and forth past that original contact point during each nonlinear iteration.

This damper mitigates this problem by scaling back the nonlinear solution update to limit the amount of slip experienced by nodes that are slipping in a direction opposite to the slip direction in the previous nonlinear iteration. For each node in this situation, a scale factor that would bring the node back to its original position is computed, and the minimum value for all such nodes is taken as the overall scale factor. For a simulation with many nodes in contact, this can result initially in small damping factors, but over the course of iterations as the converged solution is approached, the damping factor will typically increase.

The following optional parameters can be used to adjust the behavior of this damper:

- `min_damping_factor` sets a minimum value for the damping. Setting this to a number larger than 0 can permit some amount of excess slip reversals to avoid having the solution getting stuck with extremely small damping factors.
- `max_iterative_slip` allows the damper to also limit the amount of slip that can occur during a nonlinear iteration, in addition to limiting slip reversals. This is prescribed in the length units of the model.
- `damping_threshold_factor` affects the slip reversal limiting behavior of this damper when the magnitude of the slip is small. If the amount of slip is small, the node is likely actually in a sticking state, and simply moving within the limits permitted by the penalty factor. This factor specifies the threshold slip, computed as a multiplier on the limit imposed by the penalty factor, at which the damper will start to limit slip reversals. Setting it to larger numbers will make this damper have less effect on nodes will small amounts of slip.

In addition to limiting the nonlinear solution step, this damper also prints out some useful diagnostic information to the output stream, including statistics on the numbers of nodes in various contact states.

Finally, it should be noted that although this damper is primarily intended to be used with frictional contact, it can be useful for frictionless contact because of its ability to limit the maximum amount of slip.

#### Example Input Syntax





## linesearches

### ContactLineSearch

This class (through a `PetscContactLineSearch` derivation) implements a custom
line search (based on the Petsc `LineSearchShell`) for use with mechanical
contact. The line search is not fancy. It takes two parameters, set in the MOOSE
Executioner block: `contact_line_search_ltol` and
`contact_line_search_allowed_lambda_cuts`. The
`contact_line_search_allowed_lambda_cuts` parameter specifies the number of
times the line search is allowed to cut lambda. If allowed to be cut, lambda
will be reduced by half, and a new residual will be evaluated. If the residual
is smaller with a smaller lambda, then cuts will continue until reaching
`contact_line_search_allowed_lambda_cuts`. If the residual is larger with a
smaller lambda, then the line search is curtailed and the smaller residual is
used. It's recommended that `contact_line_search_allowed_lambda_cuts` be <= 3,
with smaller values being used for smaller contact problems. This is to allow
necessary residual increases when the transient problem requires significant
changes in the contact state.

When the contact set is changing, the user may optionally use a looser linear tolerance set by
the `contact_line_search_ltol` parameter. Then when the contact set is changing during the
beginning of the Newton solve, unnecessary computational expense is avoided. Then when the
contact set is resolved late in the Newton solve, the linear tolerance will return to the finer
tolerance set through the traditional `l_tol` parameter.

This line search helps significantly with the phenomenon in the contact
literature known as jamming or zig-zagging [!citep](wriggers2006computational)
where a Newton solve bounces back and forth between
different contact sets. However, it is not a panacea. It will only partially
assuage problems associated with "bad" linear solves which can arise during
Jacobian-Free Newton-Krylov solves with noisy functions. Function noise can be
introduced through large penalty factors and/or poor scaling of variables.

If a developer wants to implement the line-search with a solver other than Petsc
they will have to create the class themself.


## postprocessors

### ContactDOFSetSize

The `ContactDOFSetSize` class outputs the number of degrees of freedom greater than
a certain tolerance (specified through the `tolerance` parameter; the default
value is 1e-6). The usual application of this, as indicated by the class name,
is to indicate how many nodes (if using first order Lagrange shape functions for
the contact pressure lagrange multiplier) or element faces (if using constant
monomials) are in contact. The `subdomain` parameter should be the name or id
representing the lower dimensional block that the Lagrange multiplier variable
lives on.

### Description and Syntax






### NumAugmentedLagrangeIterations


Defaults to 0 if the problem is not an [AugmentedLagrangianContactProblem.md].
The reader is referred to the [AugmentedLagrangianContactProblem.md] for more explanation
on the augmented Lagrangian iteration.




## problems

### AugmentedLagrangianContactProblem

The augmented Lagrangian contact algorithm involves a nested solution strategy. In the inner solve, the Lagrangian multipliers are kept fixed and the contact problem is solved. Once the problem is solved, the algorithm checks to see whether the constraints are satisfied and decides if convergence has been reached. If the model has not yet converged, the Lagrangian multipliers are updated, and the inner solve is repeated.

The AugmentedLagrangianContactProblem manages the nested solution procedure described above, repeating the solution until convergence has been achieved, which is controlled by [AugmentedLagrangianContactConvergence.md], and updating the Lagrangian multipliers.

### AugmentedLagrangianContactProblem





## splits

### ContactSplit

#### Description

The `ContactSplit` class is used to create a split-based preconditioner for contact problems. The idea is to separate the DOFs on the contact interface from the DOFs in the rest of the domain. This allows users to apply different preconditioners for each DOF type. As a common practice, a direct preconditioner (e.g., LU) is often utilized for the interface problem, where the problem size is relatively small while the condition number is large. An iterative preconditioner (e.g., boomeramg) is often employed for the interior problem, where the problem is often better conditioned while the problem size is usually large.


#### Example Input Syntax





## userobjects

### BilinearMixedModeCohesiveZoneModel

#### Description

The `BilinearMixedModeCohesiveZoneModel` object computes a global traction vector
from a local traction vector that is calculated from a bilinear mixed mode cohesive
zone model. Theoretical equations and their application to particle fuel is described
and discussed in [!cite](jiang2021efficient).

This object inherits from [PenaltySimpleCohesiveZoneModel](/PenaltySimpleCohesiveZoneModel.md)
and can include penalty mortar mechanical contact.

This object implements the bilinear mixed mode traction separation law using the nodal-based mortar quantities
that are employed in the MOOSE formulation. Such quantities are identified with a tilde
at a secondary surface node $j$. The definitions of mortar surfaces and mortar quantities are identical to
those presented in previous technical reports ([!cite](martin2022implement,recuero2022mortar)),
which are in turn based on existing discretization approaches ([!cite](wohlmuth2011variationally,
puso2008segment)).


##### Quadratic failure criterion

The softening of the interface in the bilinear mixed mode traction separation law is given by a quadratic failure criterion. The onset of softening of the interface takes place when the traction state reaches the following equality:
\begin{equation}
    {\left(\frac{<{\tilde{\sigma}_{N,j}}>}{N}\right)}^{2} + {\left(\frac{{\tilde{\tau}_{1,j}}}{T_{1}}\right)}^{2} + {\left(\frac{{\tilde{\tau}_{2,j}}}{T_{2}}\right)}^{2} = 1.0,
    \label{eq:tsl_softening}
\end{equation}
where $<{\tilde{\sigma}_{N,j}}>$, $\tilde{\tau}_{1,j}$, and $\tilde{\tau}_{2,j}$ are the (positive) normal traction, the shear traction along direction one, and the shear traction along direction two, respectively. These three traction components are computed at each node $j$ using interpolated, weighted quantities. $N$, $T_{1}$, and $T_{2}$ are the interlaminar tensile and shear strengths, which are model parameters.

##### Mode mixity

The displacement on the interface can be split into normal and tangential parts. Therefore, the mixed mode relative displacement can be expressed as:
\begin{equation}
  \tilde{\delta}_{m,j} = \sqrt{\tilde{\delta}_{t1,j}^{2} + \tilde{\delta}_{t2,j}^{2} + \langle{\tilde{\delta}_{N,j}\rangle}^{2}},
  \label{eq:mixed_disp}
\end{equation}
where subscripts $N$, and $t1$ and $t2$ denote the normal direction and the two tangential directions, respectively.

The formulation assumes that the interface traction generated by the displacements is proportional; in essence, a traction component is equal to a penalty factor times the displacement jump component ($\tau_{i} = K_{i}\delta_{i}$, where $K_{i}$ is the penalty factor). If $\tilde{\delta}_{N,j} \leq 0$, the mixity ratio is obtained as:
\begin{equation}
  \tilde{\beta} = \frac{\sqrt{\tilde{\delta}_{t1,j}^{2} + \tilde{\delta}_{t2,j}^{2}}}{\tilde{\delta}_{N,j}}.
  \label{eq:mixity_ratio}
\end{equation}

Assuming $T_1 = T_2$, the uni-mode relative displacements at the beginning of softening (denoted by superscript ``0'') are given by:
\begin{equation}
  \tilde{\delta}_{ti,j}^{0} = \frac{T_{i}}{K_{i}},\,  \tilde{\delta}_{N,j}^{0} = \frac{N}{K_{i}}.
  \label{eq:rel_disp}
\end{equation}

The mixed mode relative displacement corresponding to the initiation of softening, $\tilde{\delta}_{m,j}^{0}$, is defined by the following multi-part definition:
\begin{equation}
\tilde{\delta}_{m,j}^{0} =
\left\{
	\begin{array}{ll}
		\tilde{\delta}_{N,j}^{0} \tilde{\delta}_{t2,j}^{0} \sqrt{\frac{1 + \tilde{\beta}^{2}}{\tilde{(\delta}_{t2,j}^{0})^2 + (\tilde{\beta} \tilde{\delta}_{N,j}^{0})^2}}  &  {if } \tilde{\delta}_{N,j}^{0} \geq 0, \\
		\tilde{\delta}_{t2,j}^{0}  &  {if } \tilde{\delta}_{N,j}^{0}  < 0.
	\end{array}
\right.
    \label{eq:mix_mode_rel_disp}
\end{equation}

##### Mode mixity Delamination propagation prediction

The new CZM mortar implementation also accounts for two types of delamination propagation models. (1) A power law-based criterion and (2) The Benzeggagh-Kenane (BK) criterion (see, e.g.,[!cite](benzeggagh1996measurement,bui2011modified)).

###### Power law-based delamination criterion

The power law criterion may be described as:
\begin{equation}
\left(\frac{G_{I}}{G_{IC}}\right)^{\alpha} + \left(\frac{G_{II}}{G_{IIC}}\right)^{\alpha} = 1.0,
\label{eq:power_law_crit}
\end{equation}
where $G_{I}$ and $G_{II}$ are the critical energy release rates for mixed modes; whereas $G_{IC}$ and $G_{IIC}$ are the critical energy release rates for pure modes. The power exponent $\alpha$ is can be obtained experimentally.

During the delamination or debonding process, a relative interface displacement may be reached such that cohesive fores completely disappear, i.e. the cohesive model ceases to influence boundary tractions. Such a mixed-mode displacement value is defined as follows (note that we carry the node-wise definition, $j$):
\begin{equation}
\tilde{\delta}_{m,j}^{f} =
\left\{
	\begin{array}{ll}
		\frac{2(1+\tilde{\beta}^{2})}{K \tilde{\delta}_{m,j}^{0}} \left[\left( \frac{1}{G_{IC}}\right)^{\alpha} + \left( \frac{\tilde{\beta}^{2}}{G_{IIC}}\right)^{\alpha}\right]^{\frac{-1}{\alpha}}   &  {if } \tilde{\delta}_{N,j}^{0} \geq 0, \\
		\sqrt{\tilde{\delta}_{1,j}^{f} + \tilde{\delta}_{2,j}^{f}}  &  {if } \tilde{\delta}_{N,j}^{0} < 0.
	\end{array}
\right.
    \label{eq:mix_mode_decohesion}
\end{equation}

###### Benzeggagh-Kenane (BK) delamination criterion

The BK criterion can be written as ([!cite](benzeggagh1996measurement)):
\begin{equation}
G_{TC} = G_{IC} + (G_{IIC} - G_{IC}) (\frac{G_{II}}{G_{T}})^{\eta},
\label{eq:bk_criterion}
\end{equation}
where $G_{T} = G_{I} + G_{II}$, $G_{TC}$ is the total critical strain energy release rate, and $\eta$ is a model parameter.

The mixed-mode total decohesion displacements are, for the BK criterion:
\begin{equation}
\tilde{\delta}_{m,j}^{f} =
\left\{
	\begin{array}{ll}
		\frac{2}{K \tilde{\delta}_{m,j}^{0}} \left[ G_{IC} + \left(G_{IIC} - G_{IC}\left[\frac{\tilde{\beta}^{2}}{1 + \tilde{\beta}^{2}}\right]^{\eta}\right)\right]   &  {if } \tilde{\delta}_{N,j}^{0} \geq 0, \\
		\sqrt{\tilde{\delta}_{1,j}^{f} + \tilde{\delta}_{2,j}^{f}}  &  {if } \tilde{\delta}_{N,j}^{0} < 0.
	\end{array}
\right.
    \label{eq:bk_mix_mode_decohesion}
\end{equation}

##### Constitutive model

The CZM constitutive models relate the weighted interface jump components to the interface traction in the local frame of reference. The traction, in the local frame of reference, can be expressed as:
\begin{equation}
    \tau_{l} = D_{li} \tilde{\delta}_{i},
\label{eq:traction}
\end{equation}
where $\tau_{l}$ is the $l$ component of the local traction and $D_{li}$ is an effective stiffness. The constitutive components are computed as:
\begin{equation}
 \tau_{l} =
\left\{
	\begin{array}{ll}
		(1 - \omega) K \tilde{\delta}_{\text{active}}  &  {if } \tilde{\delta}_{N,j}^{0} \geq 0, \\
		K \tilde{\delta}_{\text{inactive}}  &  {if } \tilde{\delta}_{N,j}^{0} < 0,
	\end{array}
\right.
\label{eq:constitutive}
\end{equation}
where $\tilde{\delta}_{\text{active}}$ represents the CZM weighted interface jump with shear components, i.e. it applies shear stiffness, and normal stiffness only if a gap exists. $\tilde{\delta}_{\text{inactive}}$ applies a normal traction that prevents interpenetration. A few notes about the previous equation:

  - The action of $\delta_{\text{inactive}}$ can potentially be replaced with (mortar) mechanical contact enforcement. \\
  - The local traction $\tau_{l}$ is computed nodally with weighted quantities, but is interpolated and applied on the primary and secondary surfaces using Lagrange interpolation functions. \\
  - The constitutive model can be expanded as needed in the user object.

The damage, $\omega$, is computed as follows (we omit the nodal subscript):
\begin{equation}
\omega = \frac{\tilde{\delta}_{m}^{f} \left( \tilde{\delta}_{m}^{\text{max}} - \tilde{\delta}_{m}^{0}\right)}{\tilde{\delta}_{m}^{\text{max}} \left( \tilde{\delta}_{m}^{f} - \tilde{\delta}_{m}^{0}\right)}.
\end{equation}

##### Viscous regularization

Sudden degradation of stiffness may be give rise to the appearance of large displacements. To alleviate this problematic numerical behavior in quasti-static simulations, we include in the constitutive equations a viscous damage $\omega_{v}$ instead:
\begin{equation}
\dot{\omega}_{v} = \frac{1}{\mu} \left( \omega - \omega_v\right).
\end{equation}


Example of usage:





### LMWeightedGapUserObject

#### Description

The `LMWeightedGapUserObject` object provides the Lagrange multiplier and
interpolation function for the enforcement of mortar mechanical constraints.
In essence, the Lagrange multiplier is provided to [NormalMortarMechanicalContact](/NormalMortarMechanicalContact.md) to enforce the non-penetration constraint. This object is set up automatically
when using the contact action [ContactAction](/ContactAction.md)




### LMWeightedVelocitiesUserObject

#### Description

The `LMWeightedVelocitiesUserObject` object provides the Lagrange multiplier and
interpolation function for the enforcement of mortar mechanical constraints.
In essence, the Lagrange multiplier is provided to [TangentialMortarMechanicalContact](/TangentialMortarMechanicalContact.md) to enforce friction via a Coulomb model. This object is set up automatically
when using the contact action [ContactAction](/ContactAction.md)




### NodalArea

#### Description

<!-- The `NodalArea` computes the nodal area along the boundaries. This object is typically utilized in contact simulations while computing the contact pressure along the interface
(see [ContactPressureAux](auxkernels/ContactPressureAux.md)). -->

The `NodalArea` object computes the tributary area of each node on a contact surface, which is used in node/face contact calculations. This object computes the value of a AuxVariable, but is implemented as a UserObject because the calculations involve iterations on the element faces, rather than the nodes. Note that the [Contact](Contact/index.md) action sets this object up automatically, so it is typically not necessary to include this in an input file.





### NodalDensity

#### Description

The `NodalDensity` object computes a nodal value of the
density material property. It is used by explicit dynamics contact.





### NodalWaveSpeed

#### Description

The `NodalWaveSpeed` object computes a nodal value of the
wave speed material property.





### PenaltyFrictionUserObject

#### Description

The `PenaltyFrictionUserObject` object computes tangential pressures due
to Coulomb friction by looping over mortar segments. The accumulated tangential
slip is penalized by a `penalty_friction` factor. As the slip accumulates, the
frictional pressure(s) saturates at the Coulomb limit. Note that a high enough
value of the `penalty_friction` value is required to obtain realistic frictional
pressure; otherwise, the tangential model will underpredict frictional forces. That is,
higher values of the `penalty_friction` parameter will more accurately predict the stick
and slip Coulomb behavior at the expense of worsening the convergence behavior. The
`slip_tolerance` parameter can be chosen to limit the amount of relative slip
at nodes that are not slipping (at the Coulomb limit).

The tangential traction (or tractions for a three-dimensional problem) generated
by this object contains Jacobian information as a consequence of using automatic
differentiation objects. These tractions are directly applied on the contacting
surfaces by [TangentialMortarMechanicalContact](/TangentialMortarMechanicalContact.md).
That is, the tangential contact pressure values computed by this object serve a purpose
analogous to the Lagrange multipliers when exact enforcement is used
(see [ComputeFrictionalForceLMMechanicalContact](/ComputeFrictionalForceLMMechanicalContact.md)).
This object is set up automatically when using the [contact action](/ContactAction.md).

This object is built from within the contact action when the formulation `MORTAR_PENALTY` and
the model `COULOMB` is selected. The action sets the `use_physical_gap` parameter to true,
which allows the user to select a normal contact penalty parameter on the order of the
stiffness of the materials coming into contact. Also, to ensure solution stability, dual bases
(i.e. `use_dual = true`) are employed by default to interpolate the contact traction
when using the contact action.

An augmented Lagrange (AL) approach can be used to enforce the contact constraints to a user-prescribed
tolerance. That tolerance can be the normal gap distance (distance to exact enforcement if in contact) or
the relative slip tolerance for slipping nodes. The AL approach solves the original MOOSE problem,
in which contact is enforced using a pure penalty approach, taking the necessary nonlinear iterations
and updates "fixed" Lagrange multipliers in an outer loop. This
process repeats until the contact-related tolerances are met. The "fixed" Lagrange multipliers represent
accumulated normal and tangential tractions over the AL iterations (see [!citep](wriggers2006computational)).
Usage of AL with this mortar constraint allows for, simultaneously 1. Having a contact formulation that, upon AL convergence, will yield results equivalent to Lagrange multiplier-enforced dual mortar,
2. Enforcement of the contact constraint to a user-prescribed tolerance (analogous to Lagrange multiplier
enforcement, see [ComputeWeightedGapLMMechanicalContact](/ComputeWeightedGapLMMechanicalContact.md)), and 3. Keeps
the system's condition number as if mechanical contact is not present; as long as the initial penalty coefficients are
selected on the order of the material stiffnesses.

For the reasons stated above, it is recommended to use an AL approach with the mortar penalty objects.

Example of usage in the contact action:


which can be combined with an augmented Lagrange problem:


See below an example of solver options with iterative preconditioners (e.g. algebraic multigrid) in a mortar
mechanical contact problem. This solver selection can enable the simulation of very large contact mechanics problems with the more memory efficient iterative procedures:






### PenaltySimpleCohesiveZoneModel

#### Description

The `PenaltySimpleCohesiveZoneModel` is an intermediate object between
mortar mechanical contact and mortar cohesive zone models. It can apply
penalty mortar normal and tangential contact forces and is intended to be
used as a parent class for more advanced cohesive zone models, such as
[BilinearMixedModeCohesiveZoneModel](/BilinearMixedModeCohesiveZoneModel.md).





### PenaltyWeightedGapUserObject

#### Description

The `PenaltyWeightedGapUserObject` object computes a normal weighted gap by
looping over mortar segments and penalizes it by a penalty factor to create
a distributed generalized force that can be directly applied as an interface
action on both sides of the contact interface. The weighted gap that is acted
on by the penalty factor contains the scaling associated with the mortar segments.
A large enough value of the `penalty` parameter is required for the simulation to
yield acceptable interpenetration values. A value too small is likely to
underpredict the stress states of the bodies into contact.

The generalized force generated by this object contains Jacobian information as a
consequence of using automatic differentiation objects. The normal contact pressure
obtained this way is directly applied on the contacting surfaces by
[NormalMortarMechanicalContact](/NormalMortarMechanicalContact.md). That is, the
contact pressure computed by this object serves a purpose analogous to a Lagrange
multiplier when exact enforcement is used
 (see [ComputeWeightedGapLMMechanicalContact](/ComputeWeightedGapLMMechanicalContact.md)). This object is set up automatically
when using the [ContactAction](/ContactAction.md).

This object is built from within the contact action when the formulation `MORTAR_PENALTY` and
the model `FRICTIONLESS` is selected. The action sets the `use_physical_gap` parameter to true,
which allows the user to select a normal contact penalty parameter on the order of the
stiffness of the materials into contact. Also, to ensure solution stability, dual bases
(i.e. `use_dual = true`) are employed by default to interpolate the contact traction
when using the contact action.

An augmented Lagrange (AL) approach can be used to enforce the contact constraints to a user-prescribed
tolerance. That tolerance parameter is the normal gap distance (distance to exact enforcement if in contact)
for normal contact. The AL approach solves the original MOOSE problem, in which contact is enforced using a pure penalty approach,
taking the necessary nonlinear iterations and updates "fixed" Lagrange multipliers in an outer loop. This
process repeats until the contact-related tolerances are met. The "fixed" Lagrange multipliers represent
accumulated normal tractions over the AL iterations (see [!citep](wriggers2006computational)),
thereby gradually fulfilling the contact constraints.
Usage of AL with this mortar constraint allows for, simultaneously 1. Having a consistent contact formulation,
2. Enforcement of the contact constraint to a user-prescribed tolerance (analogous to Lagrange multiplier
enforcement, see [ComputeWeightedGapLMMechanicalContact](/ComputeWeightedGapLMMechanicalContact.md)), and 3. Keeps
the system's condition number as if mechanical contact is not present; as long as the initial penalty coefficients are
selected to be on the order of the material stiffnesses.

For the reasons stated above, it is recommended to use an AL approach with the mortar penalty objects.

Example of usage:


which can be combined with an augmented Lagrange problem:


See below an example of solver options with iterative preconditioners (e.g. algebraic multigrid) in a mortar
mechanical contact problem. This solver selection can enable the simulation of very large contact mechanics problems with the more memory efficient iterative procedures:






# Electromagnetics Module

The electromagnetics module provides components and models to simulate electromagnetic
wave problems within the MOOSE framework, and facilitates multiphysics coupling of
electromagnetic simulations to other physical domains. Features include:

- Transient and time-harmonic (i.e., single-frequency, steady-state) simulation
  in 1D and 2D (3D is currently in development)
- Component-wise (scalar variables) and vector field (vector variables) components
  for the Helmholtz wave form of Maxwell's Equations
- Complex field calculations
- First-order port boundary conditions (scalar and vector forms)
- Electrostatic contact interface conditions based on the work of [!citep](cincotti2007sps)
- Parallel and perpendicular field interface conditions for electric field based on Maxwell's Equations
- Current density and electric field calculation based on electrostatic potential
- Fundamental eigenvalue solutions for 2D waveguide profiles
- Reflection coefficient calculation for a 1D slab

       style=width:50%;margin:auto;
       id=dipole-results-movie
       caption=Electric field radiation pattern of half-wave dipole antenna driven by a 1GHz signal, simulated using the electromagnetics module. Note that field intensity is normalized to 1.0.

- [Systems](modules/electromagnetics/systems.md) - A complete summary of all electromagnetic module objects

## Benchmarks

- [1D Slab Reflection](benchmarks/OneDReflection.md) - Calculating the reflection
  coefficient of a 1D metal-backed dielectric slab
- [Waveguide Transmission](benchmarks/WaveguideTransmission.md) - Complex field
  pattern in a single-frequency waveguide
- [Evanescent Wave Decay](benchmarks/EvanescentWave.md) - Characteristic decay and
  reflection of an evanescent wave when an obstruction is encountered
- [Half-wave Dipole Antenna](benchmarks/DipoleAntenna.md) - Radiation pattern of a
  half-wave dipole antenna excited at 1GHz (time domain result shown in [dipole-results-movie])
- [Waveguide Fundamental Eigenvalue](benchmarks/WaveguideEigenvalue.md) - Fundamental
  wave number (eigenvalue) of a 2D waveguide profile solved using [SLEPc]

## Verification Problems

- [Electrostatic Contact, Two Blocks](verification/electrostatic_contact_two_block.md) - Verification
  of electrostatic contact between a driven/powered block and a grounded block
- [Electrostatic Contact, Three Blocks](verification/electrostatic_contact_three_block.md) - Verification
  of electrostatic contact with a floating block sandwiched between a driven/powered block and a grounded
  block

## Citing


This paper documents the initial development, function, verification, and validation
of the electromagnetics module.

```
@article{icenhour2024electromagnetics,
  author = {Casey T. Icenhour and Alexander D. Lindsay and Cody J. Permann and Richard C. Martineau and David L. Green and Steven C. Shannon},
  title = {The MOOSE electromagnetics module},
  journal = {SoftwareX},
  publisher = {Elsevier},
  volume = {25},
  pages = {101621},
  year = {2024},
  month = {February},
  issn = {2352-7110},
  doi = {https://doi.org/10.1016/j.softx.2023.101621},
  url = {https://www.sciencedirect.com/science/article/pii/S2352711023003175}
}
```


While the above paper is the main citation, the following PhD dissertation documents the initial
development and capabilities of the electromagnetics module in greater detail and could be used
alongside the paper above if module capabilities are used in the to-be-published work that are not
covered therein.

```
@phdthesis{icenhourPHDelectromagnetics,
  author = {Icenhour, Casey T.},
  title = {Development and Validation of Open Source Software for Electromagnetics Simulation and Multiphysics Coupling},
  school = {North Carolina State University},
  year = {2023},
  url = {https://www.lib.ncsu.edu/resolver/1840.20/40985}
}
```

## auxkernels

### CurrentDensity / ADCurrentDensity


#### Overview

`CurrentDensity` and `ADCurrentDensity` allow for the calculation of the electric
current density given by

\begin{equation}
  \vec{J} = \sigma \vec{E}
\end{equation}

where

- $\vec{J}$ is the current density (SI units of A/m$^2$),
- $\sigma$ is the electrical conductivity (SI units of S/m), and
- $\vec{E}$ is the electric field (SI units of V/m).

The electric field can be determined either directly via an electromagnetic field
calculation (in which case, the [!param](/AuxKernels/CurrentDensity/electrostatic) 
parameter should be set to `false`), or calculated via the electrostatic potential 
$V$, where

\begin{equation}
  \vec{E} = -\nabla V.
\end{equation}

Note that calculation via the electrostatic potential is the default behavior.
MOOSE errors will be thrown if the inappropriate coupled variable is provided,
given the setting for the [!param](/AuxKernels/CurrentDensity/electrostatic) 
boolean parameter.

Additionally, note that the electrical conductivity $\sigma$ must be provided
as a material property for the block(s) this kernel is being applied to. The
user can use, e.g., [GenericConstantMaterial.md], [GenericFunctionMaterial.md],
or one of their AD counterparts. The user must also set the
[!param](/Materials/GenericConstantMaterial/prop_names) parameter of the chosen
object to `electrical_conductivity`.

#### Example Input File Syntax





### PotentialToFieldAux


#### Overview

This AuxKernel object uses the following equation for electric field:

\begin{equation}
  \mathbf{E} = s \nabla V
\end{equation}

where

- $\mathbf{E}$ is the electric field in units of Volts per meter,
- $V$ is the electrostatic potential in units of Volts, and
- $s$ is a coefficient set via the [!param](/AuxKernels/PotentialToFieldAux/sign) 
  parameter, and defaults to $-1$.

The sign of the resulting calculation can be changed from the default, if needed,
by setting [!param](/AuxKernels/PotentialToFieldAux/sign) to `positive`. This option 
is the result of the desire to keep the object code as general as possible for use in 
other scenarios where the positive gradient of a solution variable is desired, while 
still retaining the traditional and expected electrostatic field result from various 
electrodynamics texts by default.

#### Example Input File Syntax





## bcs

### EMRobinBC


#### Overview

The EMRobinBC object is an implementation of the first-order Robin-style boundary
condition outlined in [!citep](jin-fem) Equation 9.60 and [!citep](jin-computation)
Equation 9.3.51 for scalar field variables.

###### General (vector field) form

The generic condition from [!citep](jin-fem) is, in turn, based on the Sommerfeld
radiation condition for scattered fields. Given that any scattered field can be made up of a
combination of the scattered field and the incident field
($\vec{E} = \vec{E}_{sc} + \vec{E}_{inc}$), then we have

\begin{equation}
  \hat{\mathbf{n}} \times \left( \frac{1}{\mu_r} \nabla \times \vec{E} \right) + \frac{j k_0}{\eta_r} \hat{\mathbf{n}} \times \left( \hat{\mathbf{n}} \times \vec{E} \right) = \hat{\mathbf{n}} \times (\nabla \times \vec{E}_{inc}) + \frac{j k_0}{\eta_r} \hat{\mathbf{n}} \times \left( \hat{\mathbf{n}} \times \vec{E}_{inc} \right)
\end{equation}

where

- $\vec{E}$ is the total (i.e., the solution) electric field vector,
- $\vec{E}_{inc}$ is the incoming electric field vector,
- $\mu_r$ is the relative magnetic permeability,
- $j = \sqrt{-1}$,
- $k_0$ is the wave number ($2 \pi / \lambda$ where $\lambda$ is the wavelength),
- $\eta_r$ is a radiation condition parameter ($\eta_r = 1$ if the condition is applied in free space), and
- $\hat{\mathbf{n}}$ is the boundary normal vector.

###### Scalar field form (for EMRobinBC)

In EMRobinBC, this condition is simplified for use with scalar field variables, such
as those solved for in plane-wave problems where only a component of the vector
field is being solved for. In such a problem, it is assumed that $E \sim e^{jkx}$.
The choice of $x$ as the spatial variable here is arbitrary; the directionality
of the plane wave determines the spatial variable of interest. The implemented
condition in this object is then

\begin{equation}
  \frac{\partial E_x}{\partial x} + jkE_x = j2kF(x)e^{jkx}
\end{equation}

where

- $E_x$ is the scalar field component value,
- $k$ is the wavenumber, and
- $F(x)$ is a function representing the amplitude profile of the incoming wave.

Note that in EMRobinBC, $k$ could be set via the [!param](/BCs/EMRobinBC/coeff_real) and [!param](/BCs/EMRobinBC/coeff_imag)
parameters for a constant wavenumber, or [!param](/BCs/EMRobinBC/func_real) and [!param](/BCs/EMRobinBC/func_imag) for a
property that varies in space or time. The incoming profile is set via
[!param](/BCs/EMRobinBC/profile_func_real) and [!param](/BCs/EMRobinBC/profile_func_imag).


###### Usage notes

It is important to note that when used as an absorber (strictly absorbing means that `mode = absorbing`
with zero incoming wave but a port also has an absorbing component for any reflections), care must be
taken in setting the shape of the truncation boundary as well as the distance
from the scattering object. Boundaries as close as $0.3 \lambda$ away from the
object was shown in [!citep](jin-fem), and several wavelengths were used in the
[DipoleAntenna.md] for [VectorEMRobinBC.md]. This boundary condition is also best
applied on spherical boundaries (as a result of its origin from the Sommerfeld
condition, which was derived for spherical boundaries). Of course, it is also
valid on any non-spherical smooth surface with a trade-off in accuracy.

#### Example Input File Syntax

##### As a Port


##### As an Absorber





### VectorEMRobinBC


#### Overview

The VectorEMRobinBC object is an implementation of the first-order Robin-style boundary
condition outlined in [!citep](jin-fem) Equation 9.60 and [!citep](jin-computation)
Equation 9.3.51 for vector field variables.

###### General (vector field) form

The generic Jin condition is, in turn, based on the Sommerfeld radiation condition
for scattered fields. Given that any scattered field can be made up of a
combination of the scattered field and the incident field
($\vec{E} = \vec{E}_{sc} + \vec{E}_{inc}$), then we have

\begin{equation}
  \hat{\mathbf{n}} \times \left( \frac{1}{\mu_r} \nabla \times \vec{E} \right) + \frac{j k_0}{\eta_r} \hat{\mathbf{n}} \times \left( \hat{\mathbf{n}} \times \vec{E} \right) = \hat{\mathbf{n}} \times (\nabla \times \vec{E}_{inc}) + \frac{j k_0}{\eta_r} \hat{\mathbf{n}} \times \left( \hat{\mathbf{n}} \times \vec{E}_{inc} \right)
\end{equation}

where

- $\vec{E}$ is the total (i.e., the solution) electric field vector,
- $\vec{E}_{inc}$ is the incoming electric field vector,
- $\mu_r$ is the relative magnetic permeability,
- $j = \sqrt{-1}$,
- $k_0$ is the wave number ($2 \pi / \lambda$ where $\lambda$ is the wavelength),
- $\eta_r$ is a radiation condition parameter ($\eta_r = 1$ if the condition is applied in free space), and
- $\hat{\mathbf{n}}$ is the boundary normal vector.

###### Implemented form

In VectorEMRobinBC, this condition is slightly generalized. The ratio of $k_0 / \eta_r$
is generalized to a coefficient function $\beta$, and so the implemented form is

\begin{equation}
  \hat{\mathbf{n}} \times \left( \frac{1}{\mu_r} \nabla \times \vec{E} \right) + j\beta(\mathbf{r}) \hat{\mathbf{n}} \times \left( \hat{\mathbf{n}} \times \vec{E} \right) = \hat{\mathbf{n}} \times (\nabla \times \vec{E}_{inc}) + j\beta(\mathbf{r}) \hat{\mathbf{n}} \times \left( \hat{\mathbf{n}} \times \vec{E}_{inc} \right)
\end{equation}

where

- $\beta(\mathbf{r})$ is a function containing the condition coefficients.

Note that $\beta$ generally is just the wavenumber $k$, since this condition is
generally applied in free space, but any function can be applied through the
[!param](/BCs/VectorEMRobinBC/beta) parameter.

###### Usage notes

It is important to note that when used as an absorber (strictly absorbing means
[!param](/BCs/VectorEMRobinBC/mode) is set to `absorbing` and zero incoming wave 
but a port also has an absorbing component), care must be taken in setting the 
shape of the truncation boundary as well as the distance from the scattering object. 
Boundaries as close as $0.3 \lambda$ away from the object was shown in [!citep](jin-fem), 
and several wavelengths were used in the [DipoleAntenna.md] for VectorEMRobinBC. Also, 
this boundary condition is best applied on spherical boundaries (as a result of its
origin from the Sommerfeld condition, which was derived for spherical boundaries).
Of course, it is also valid on any non-spherical smooth surface with a trade-off
in accuracy.

#### Example Input File Syntax

##### As a Port


##### As an Absorber





### VectorTransientAbsorbingBC


#### Overview

The VectorTransientAbsorbingBC implements the first-order absorbing boundary
condition mentioned in [!citep](jin-fem) Equation 12.83 for vector variables.
This condition is given by

\begin{equation}
  \hat{\mathbf{n}} \times \left[ \frac{1}{\mu_0} \nabla \times \vec{E}(\mathbf{r},t)\right] + Y_0 \: \hat{\mathbf{n}} \times \left[ \hat{\mathbf{n}} \times \frac{\partial \vec{E}(\mathbf{r}, t)}{\partial t}\right] = 0
\end{equation}

where

- $\vec{E}$ is the electric field vector with complex components,
- $\mu_0$ is the vacuum magnetic permeability,
- $Y_0$ is the intrinsic admittance of the infinite medium, and
- $\hat{\mathbf{n}}$ is the boundary normal vector.

The intrinsic admittance of the infinite medium is set to a default of free space, which is defined as

\begin{equation}
  Y_0 = \sqrt{\frac{\epsilon_0}{\mu_0}} = \frac{1}{\mu_0 c}
\end{equation}

where

- $\epsilon_0$ is the vacuum electric permittivity,
- $\mu_0$ is the vacuum magnetic permeability, and
- $c$ is the speed of light.

#### Example Input File Syntax





## interfacekernels

### ElectrostaticContactCondition


#### Description

This interface kernel models the conductivity of electric field across a specified
boundary between two dissimilar materials, as described by [!citep](cincotti2007sps).
It accounts for the influence of electrostatic potential differences across the
interface, with an appropriate electrical contact conductance coefficient
being provided either by the user as a constant scalar number or via a combination
of material properties and constants for calculation. The condition being applied is:

\begin{equation}
  \sigma_{el,1} \frac{\partial \phi}{\partial \mathbf{r}} \bigg\rvert_1 \cdot \mathbf{\hat{n}} = \sigma_{el,2} \frac{\partial \phi}{\partial \mathbf{r}} \bigg\rvert_2 \cdot \mathbf{\hat{n}}
\end{equation}

and

\begin{equation}
  \sigma_{el,1} \frac{\partial \phi}{\partial \mathbf{r}} \bigg\rvert_1 \cdot \mathbf{\hat{n}} = -C_E (\phi_1 - \phi_2)
\end{equation}

where

- $\sigma_{el, i}$ is the electrical conductivity of each material along the interface,
- $C_E$ is the electrical contact conductance, and
- $\phi_i$ is the electrostatic potential of the material at the interface.

The temperature- and mechanical-pressure-dependent electrical contact conductance, given by [!citep](babu2001contactresistance), is calculated using:

\begin{equation}
  C_E(T, P) = \alpha_E \sigma_{el,Harm} \bigg( \frac{P}{H_{Harm}} \bigg)^{\beta_E}
\end{equation}

where

- $\alpha_E$ is an experimentally-derived proportional fit parameter (set to be 64, from [!citep](cincotti2007sps)),
- $\sigma_{el,Harm}$ is the harmonic mean of the temperature-dependent electrical conductivities on either side of the boundary,
- $P$ ($=F/S$) is the uniform mechanical pressure applied at the contact surface area (S) between the two materials,
- $H_{Harm}$ is the harmonic mean of the hardness values of each material, and
- $\beta_E$ is an experimentally-derived power fit parameter (set to be 0.35, from [!citep](cincotti2007sps)).

For reference, the harmonic mean calculation for two values, $V_a$ and $V_b$, is given by

\begin{equation}
  V_{Harm} = \frac{2 V_a V_b}{V_a + V_b}
\end{equation}

Please note that `variable` *must always* refer to the variable of higher potential,
while the `neighbor_var` *must always* refer to the variable of lower potential in
your model. Knowledge of your boundary conditions (where potential is applied or
grounded) and electrical conductivities on either side of the boundary is vital
to making the right choice! Please refer to the electromagnetics module test
examples as well as [!citep](cincotti2007sps) for guidance and usage.

#### Example Input File Syntax






### ParallelElectricFieldInterface


#### Overview

ParallelElectricFieldInterface is a vector InterfaceKernel object that
implements the condition

\begin{equation}
  \vec{E}_{1}^{\parallel} - \vec{E}_{2}^{\parallel} =0
\end{equation}

where

- $\vec{E}_{1}^{\parallel}$ is the parallel component of the electric field vector on the primary side of the interface, and
- $\vec{E}_{2}^{\parallel}$ is the parallel component of the electric field vector on the secondary side of the interface.

#### Example Input File Syntax





### PerpendicularElectricFieldInterface


#### Overview

PerpendicularElectricFieldInterface is a vector InterfaceKernel object that
implements the condition

\begin{equation}
  \epsilon_1 \vec{E}_{1}^{\perp} - \epsilon_2 \vec{E}_{2}^{\perp} = \sigma_f
\end{equation}

where

- $\epsilon_1$ is the electric permittivity on the primary side of the interface,
- $\epsilon_2$ is the electric permittivity on the secondary side of the interface,
- $\vec{E}_{1}^{\perp}$ is the perpendicular component of the electric field vector on the primary side of the interface,
- $\vec{E}_{2}^{\perp}$ is the perpendicular component of the electric field vector on the secondary side of the interface, and
- $\sigma_f$ is the free electric charge on the interface.

#### Example Input File Syntax






## kernels

### CurlCurlField


#### Overview

The CurlCurlField object implements the following PDE term for vector variables:

\begin{equation}
  \nabla \times \left( a \; \nabla \times \vec{u} \right)
\end{equation}

where

- $a$ is a constant coefficient (default = 1.0), and
- $\vec{u}$ is the solution field vector variable.

#### Example Input File Syntax





### VectorCurrentSource


#### Overview

The VectorCurrentSource object implements the volumetric current source term in
the electric field Helmholtz wave equation. This term, in general, is

\begin{equation}
  j \; f(\mathbf{r}, t) \; \vec{J}
\end{equation}

where

- $j = \sqrt{-1}$,
- $f(\mathbf{r}, t)$ is a time- and spatially-varying coefficient function, and
- $\vec{J}$ is the complex source vector field.

Note that $\vec{J}$ is provided via vector-valued functions, using the
[!param](/Kernels/VectorCurrentSource/source_real) and [!param](/Kernels/VectorCurrentSource/source_imag)
parameters for the real and imaginary components respectively.

#### Example Input File Syntax





### VectorSecondTimeDerivative


#### Overview

The VectorSecondTimeDerivative object implements the weak form inner product term
associated with the second time derivative of a vector field variable with a function
coefficient. The term is

\begin{equation}
  \left(\vec{\psi}_i \; , \; a(\mathbf{r}, t) \frac{\partial^2 \vec{u}}{\partial t^2}\right)
\end{equation}

where

- $\vec{\psi}_i$ is a vector-valued test function,
- $\vec{u}$ is the solution vector field variable, and
- $a(\mathbf{r}, t)$ is a function coefficient (default = 1.0).

#### Example Input File Syntax





## materials

### WaveEquationCoefficient


#### Overview

This object provides a ready-to-use coefficient for the electric field Helmholtz
wave equation problem, specifically a coefficient material property of the form

\begin{equation}
  f(\mathbf{r}) = k^2 \mu_r \epsilon_r
\end{equation}

where

- $k$ is the complex wave number ($2 \pi / \lambda$ where $\lambda$ is the wavelength),
- $\epsilon_r$ is the complex relative electric permittivity, and
- $\mu_r$ is the complex relative magnetic permeability.

Note that all of these parameters (real and imaginary parts) can be provided by
the user as material properties.

#### Example Input File Syntax





## postprocessors

### ReflectionCoefficient


#### Overview

This object is used within the [OneDReflection.md] in order to calculate the
resulting reflection coefficient of the incoming wave. This assumes that the
complex-valued solution wave at the domain boundary has the form

\begin{equation}
  F_{boundary} = F_{incoming} + R F_{reflected}
\end{equation}

where $R$ is the reflection coefficient of the wave. As the wave is a
complex-valued plane wave in the benchmark case, the incoming and reflected plane
waves have the general forms

\begin{equation}
  F_{incoming} = C e^{jkL\cos(\theta \pi / 180^{\circ})} \\
  F_{reflected} = C e^{-jkL\cos(\theta \pi / 180^{\circ})}
\end{equation}

where

- $C$ is a constant coefficient representing the amplitude of the incoming wave,
- $j = \sqrt{-1}$,
- $k$ is the wave number ($2 \pi / \lambda$ where $\lambda$ is the wavelength),
- $L$ is the length of the slab domain, and
- $\theta$ is the incident angle of the incoming wave, in degrees.

To calculate the percentage of reflected power, as required in the benchmark,
the squared magnitude of $R$ above is taken as the object output

R_{power} = |R|^2

#### Example Input File Syntax





external_petsc_solver

## mesh

### PETScDMDAMesh

Generate a parallel (distributed) mesh from PETSc DMDA.  DMDA could be passed in from an application such as ExternalPetscSolverApp or created on the fly. Note that this mesh object does not have one layer of ghost elements. It is designed for holding the solution from an external PETSc application. And then the solution can be coupled to other MOOSE-based applications using the existing MultiApp transfers.

## problems

### ExternalPETScProblem

This is an interface to call a pure PETSc solver. We also sync the PETSc solution to moose variables, and then these variables can be coupled to other moose applications




## timesteppers

### External PETSc time stepper

This time stepper is used to query dt from PETSc TS to synchronize the time step size
between the wrapper app and the external PETSc solver.

The list of PETSc time steppers / integrators can be found on
[this summary](https://petsc.org/release/overview/integrator_table/#integrator-table).

# Fluid Properties Module

The Fluid Properties module provides the [FluidProperties System](syntax/FluidProperties/index.md]),
as well as various classes to support it.


## actions

### AddFluidPropertiesAction

This action adds fluid properties from the [`[FluidProperties]`](syntax/FluidProperties/index.md) block.
Fluid properties are user objects in the back end, but use a dedicated syntax block,
and have their own dedicated action task, which enables creating them at the desired time
in the simulation setup.




### AddFluidPropertiesDeprecatedAction

This action adds fluid properties from the `[Modules/FluidProperties]` block.

As the name suggests, this action is deprecated. Do not rely on it and convert your inputs to using the
non-nested `[FluidProperties]` block instead.




### AddFluidPropertiesInterrogatorAction


This action performs a number of tasks needed to use [FluidPropertiesInterrogator](/FluidPropertiesInterrogator.md)
in a minimal setting; it creates a dummy mesh, executioner, and problem, and it
creates a console output for the printing performed by the interrogator.



## auxkernels

### FluidDensityAux


### Description

Calculate the fluid density from the fluid properties object as a function of pressure
and temperature.




#### Example

Below is an example for computing the density using the `eos` fluid property object
based on nonlinear variables that represent pressure and temperature that are named
`pressure` and `temperature`, respectively.

  block=AuxKernels/density

### PressureAux


Calculates the pressure given specific volume and specific internal energy.





### SaturationTemperatureAux


This class computes saturation temperature for a 2-phase fluid mixture, given
a pressure variable at which to evaluate the saturation temperature and a
2-phase fluid properties user object.





### SpecificEnthalpyAux


The specific enthalpy is computed directly from the fluid properties object specified.
This, with additional postprocessing, can be used to evaluate the amount of thermal energy stored in
a fluid system.




### StagnationPressureAux


Stagnation pressure, or *total* pressure, is the pressure the fluid would obtain if brought to rest isentropically. It is
the sum of static and dynamic pressure. Stagnation pressure is best used to describe reservoirs, pools, and other stagnation
points.

Stagnation pressure is computed from the fluid properties using the static entropy and stagnation enthalpy.




### StagnationTemperatureAux


Stagnation temperature is the temperature is the temperature the fluid would obtain if brought to rest isentropically.
Stagnation points include reservoirs and pools with no flow velocity.

Stagnation temperature is computed from the fluid properties using the stagnation specific volume and the stagnation
specific internal energy.




### TemperatureAux


Calculates the temperature given specific volume and specific internal energy.





## fluidproperties

### BrineFluidProperties


A high-precision and consistent formulation for fluid properties for binary salt (NaCl) and water
mixtures at pressures and temperatures of interest.

Density, enthalpy, internal energy and specific heat capacity are
calculated using the formulations provided in [!cite](driesner2007a) and [!cite](driesner2007b).

Viscosity and thermal conductivity of brine are calculated using the formulation of [!cite](phillips1981).

Brine vapor pressure is calculated using the formulation presented in [!cite](haas1976).

Solubility of solid salt (halite) in water is given by [!cite](potter1977).

By default, the BrineFluidProperties UserObject uses the [Water97FluidProperties](/Water97FluidProperties.md)
and [NaClFluidProperties](/NaClFluidProperties.md) which are constructed internally, so do not have to be
supplied by the user.

The BrineFluidProperties UserObject takes an optional parameter `water_fp` which can be used to pass
a specific water formulation. This allows the user to use a tabulated version of the water properties
(using [TabulatedFluidProperties](/TabulatedFluidProperties.md)), which can significantly speed up the
calculation of brine properties. 

#### Range of validity

The BrineFluidProperties UserObject is valid for:

- 273.15 K $\le$ T $\le$ 1273.15 K,
- 0.1 MPa $\le$ p $\le$ 500 MPa,
- 0 $\le$ x$_{\mathrm{nacl}}$ $\le$ 1





### CaloricallyImperfectGas


This class implements fluid properties for a gas that behaves like an
ideal gas except that the specific heat capacities are a function of temperature
(as opposed to constants as for the ideal gas).

The relationship between pressure, density, and temperature is identical to an ideal
gas:

\begin{equation}
  pv = R_s T,
\end{equation}  

where $p$ is pressure, $v$ is specific volume, $R_s$ is the specific
gas constant, and $T$ is temperature.

The internal energy $e$ is a user-provided function of temperature:

\begin{equation}
  e = e(T).
\end{equation}  

The function $e(T)$ is provided via parameter [!param](/FluidProperties/CaloricallyImperfectGas/e). The time argument is interpreted
as temperature.

The enthalpy is computed by:

\begin{equation}
  h = e(T) + R_s T.
\end{equation}  

The specific heat capacities at constant volume and pressure $c_v$ and $c_p$
are computed by:

\begin{aligned}
c_v &= \frac{de}{dT} \\
c_p &= \frac{de}{dT} + R_s.
\end{aligned}

The specific heat capacities are computed from $e(T)$ using the `timeDerivative` method
of the `Function` class. The type of function that is used for $e(T)$ *must* implement
the `timeDerivative` method.

The inverse functions $T(e)$ and $T(h)$ are obtained as follows:

1. Ensure that within the acceptable temperature range (parameters `min_temperature` and `max_temperature`) $c_v > 0$.

2. Compute the minimum and maximum values of $e$ and $h$.

\begin{aligned}
e_{min} &= e(T_{min}) \\
e_{max} &= e(T_{max}) \\
h_{min} &= h(T_{min}) \\
h_{max} &= h(T_{max}) \\
\end{aligned}

3. Sample

   \begin{equation}
   e_j = e_{min} + j \frac{e_{max}-e_{min}}{N},\qquad j=0,..,N.
   \end{equation}

   and for each $e_j$ solve

   \begin{equation}
   e_j - e(T_j)= 0,
   \end{equation}

   for $T_j$. Create tabulation $\{e_j, T_j\}$. Create a similar tabulation for enthalpy.

4. Evaluating $T(e)$ uses linear interpolation in $\{e_j, T_j\}$.

#### Evaluating Entropy

From the first and second law of thermodynamics is follows that:

\begin{aligned}
dq &= de + pdv \\
ds &= dq/T,
\end{aligned}

where $dq$ is an infinitesimal amount of heat. Solving for $ds$ and using the ideal gas law leads to:

\begin{equation}
 ds = \frac{de}{T} + R_s \frac{dv}{v}.
\end{equation}

Integrating this equation leads to an expression for the entropy:

\begin{equation}
 s(e, v) - s(e_0, v_0) = \int\limits_{e_0}^e \frac{de'}{T'} + R_s \log \frac{v}{v_0},
\end{equation}

where the prime indicates that these variables are dummy variables of integration.
We are free to select a zero-point for entropy and we select $s(e_0, v_0) = 0$.
We also select $v_0 = 1$ and $e_0 = e(T_{min})$. Then we define:

\begin{equation}
 Z(T) = \int\limits_{e_0}^{e(T)} \frac{de'}{T'} = \int\limits_{T_{min}}^{T} \frac{c_v(T')}{T'} dT'.
\end{equation}

Entropy is computed from the expression:

\begin{equation}
 s(e, v) = Z(T(e)) + R_s \log v,
\end{equation}

where $Z(T)$ is computed using a trapezoidal rule and tabulated between $T_{min}$ and $T_{max}$.
It is linearly interpolated.

The derivatives of entropy with respect to $T$, $e$, $h$, $v$ are given by:

\begin{aligned}
\left(\frac{\partial s}{\partial e}\right)_v &= \frac{1}{T(e)} \\
\left(\frac{\partial s}{\partial v}\right)_e &= \frac{R_s}{v} \\
\left(\frac{\partial s}{\partial p}\right)_T &= -\frac{R_s}{p} \\
\left(\frac{\partial s}{\partial T}\right)_p &= \frac{c_p(T)}{T} \\
\left(\frac{\partial s}{\partial p}\right)_h &= -\frac{R_s}{p} \\
\left(\frac{\partial s}{\partial h}\right)_p &= \frac{1}{T}.
\end{aligned}

These derivatives are implemented in the 5 argument versions of the `s_from_x_y`
functions.





### CO2FluidProperties


Fluid properties for CO$_2$ are mainly calculated using the Span and Wagner equation of state
[!citep](spanwagner1996). This formulation uses density and temperature as the primary variables with
which to calculate properties such as density, enthalpy and internal energy. However, the Fluid
Properties module uses pressure and temperature in its interface, which is suitable for use in the
Porous Flow module. As a result, CO$_2$ properties are typically calculated by first calculating
density iteratively for a given pressure and temperature. This density is then used to calculate the
other properties, such as internal energy, directly.

Viscosity is calculated using the formulation presented in [!cite](fenghour1998), while
thermal conductivity is taken from [!cite](scalabrin2006).

Dissolution of CO$_2$ into water is calculated using Henry's law [!citep](iapws2004).

#### Properties of CO$_2$

| Property             | value |
| --- | --- |
| Molar mass           | 0.0440098 kg/mol |
| Critical temperature | 304.1282 K       |
| Critical pressure    | 7.3773 MPa        |
| Critical density     | 467.6 kg/m$^3$ |
| Triple point temperature | 216.592 K |
| Triple point pressure | 0.51795 MPa |

#### Range of validity

The CO2FluidProperties UserObject is valid for:

- 216.592 K $\le$ T $\le$ 1100 K for p $\le$ 800 MPa





### External Fluid Properties Submodules

Additional submodules are available as `git submodules`. They can be downloaded by performing:

```
cd ~/project/moose
git submodule update --init --checkout modules/fluid_properties/contrib/air modules/fluid_properties/contrib/carbon_dioxide modules/fluid_properties/contrib/helium modules/fluid_properties/contrib/nitrogen modules/fluid_properties/contrib/potassium modules/fluid_properties/contrib/sodium
cd modules fluid_properties
make -j6
```

This will download and build the optional submodules.
The optional submodules contain fluid properties for:

- [Air](AirSBTLFluidProperties.md optional=True)
- Carbon dioxide [liquid](CarbonDioxideLiquidFluidProperties.md optional=True), [vapor](CarbonDioxideVaporFluidProperties.md optional=True) and [two-phase](CarbonDioxideTwoPhaseFluidProperties.md optional=True) fluid properties, as well with [the homogeneous equilibrium model](CarbonDioxideHEMFluidProperties.md optional=True)
- [Helium](HeliumSBTLFluidProperties.md optional=True)
- [Nitrogen](NitrogenSBTLFluidProperties.md optional=True)
- Potassium [liquid](PotassiumLiquidFluidProperties.md optional=True), [vapor](PotassiumVaporFluidProperties.md optional=True) and [two-phase](PotassiumTwoPhaseFluidProperties.md optional=True)
- Sodium [liquid](SodiumLiquidFluidProperties.md optional=True), [vapor](SodiumVaporFluidProperties.md optional=True) and [two-phase](SodiumTwoPhaseFluidProperties.md optional=True)

### FlibeFluidProperties


#### Description

The `FlibeFluidProperties` class provides fluid properties for
a peritectic molar composition of 67% LiF and 33% BeF$_2$, commonly
referred to as 'flibe'.

Density is calculated from [!cite](richard), but with a pressure dependence
added to ensure finite derivatives with respect to pressure needed by some
applications. The partial derivative of density with respect to pressure is
assumed to be 1.7324e-7 kg/m$^3$/Pa [!cite](richard), but this may be set to
a user-defined value. Slightly increasing the partial derivative of density
with respect to pressure may improve convergence of compressible flow equations
without significantly affecting the physical accuracy of the density estimation
[!cite](scarlat). In the absence of the pressure dependence, the uncertainty
on density is $\pm$0.05% [!cite](richard).

Viscosity, isobaric specific heat, and thermal conductivity are calculated
with uncertainties of $\pm$20%, $\pm$2%, and $\pm$15%, respectively
[!cite](richard). The viscosity of LiF and BeF$_2$ vary by eight orders of
magnitude, so caution should be used if applying these fluid properties to
LiF-BeF$_2$ mixtures with slightly different ratios [!cite](romatoski).

Isochoric specific heat is calculated according to its definition as

\begin{equation}
C_v=\left(\frac{\partial e}{\partial T}\right)_v
\end{equation}

which becomes, after substituting the definition for $e$,

\begin{equation}
C_v=\left(\frac{\partial h}{\partial T}\right)_v-\left(\frac{\partial(Pv)}{\partial T}\right)_v
\end{equation}

Molar mass is calculated assuming 99.995% enrichment of lithium in the
Li-7 isotope.

#### Range of Validity

These fluid properties are only applicable to liquid flibe. At atmospheric
pressure, the melting and boiling points of flibe are approximately 458$\degree$C
and 1400$\degree$C, respectively [!cite](richard). These fluid properties should
not be used outside this range.




### FlinakFluidProperties


#### Description

The `FlinakFluidProperties` class provides fluid properties for
a molar eutectic composition of 46.5% LiF, 11.5% NaF, and 42% KF,
commonly referred to as 'flinak'.

Density is calculated from [!cite](richard), but with a pressure dependence
added to ensure finite derivatives with respect to pressure needed by some
applications. The partial derivative of density with respect to pressure is
assumed to be 1.7324e-7 kg/m$^3$/Pa [!cite](richard), but this may be set to
a user-defined value. Slightly increasing the partial derivative of density
with respect to pressure may improve convergence of compressible flow equations
without significantly affecting the physical accuracy of the density estimation
[!cite](scarlat). In the absence of the pressure dependence, the uncertainty
on density is $\pm$2% [!cite](richard).

Viscosity, isobaric specific heat, and thermal conductivity are calculated
with uncertainties of $\pm$20%, $\pm$20%, and $\pm$15%, respectively
[!cite](richard).

Isochoric specific heat is calculated according to its definition as

\begin{equation}
C_v=\left(\frac{\partial e}{\partial T}\right)_v
\end{equation}

which becomes, after substituting the definition for $e$,

\begin{equation}
C_v=\left(\frac{\partial h}{\partial T}\right)_v-\left(\frac{\partial(Pv)}{\partial T}\right)_v
\end{equation}

#### Range of Validity

These fluid properties are only applicable to liquid flinak. At atmospheric
pressure, the melting and boiling points of flibe are approximately 454$\degree$C
and 1570$\degree$C, respectively [!cite](richard). These fluid properties should
not be used outside this range.




### HeliumFluidProperties


#### Description

The `HeliumFluidProperties` class provides fluid properties for helium
[!cite](petersen).

The standard deviation $\sigma$ for density is approximately 0.03% at a pressure
of 0.1 MPa and 0.3% at 10 MPa, or

\begin{equation}
\sigma=0.03\sqrt{\frac{P}{10}}\ \%
\end{equation}

where $P$ is in MPa. The isobaric and isochoric specific heats are constant,
with an uncertainty at 273 K of 0.05% at 0.1 MPa
and 0.5% at 10 MPa. At higher temperature, the standard deviation is lower, and
approximately

\begin{equation}
\sigma=0.05\left(\frac{P}{10}\right)^{0.6-0.1T/T_o}\ \%
\end{equation}

where $T_o=273.16$K, $P$ is in MPa, and $T$ is in K.
The standard deviation of the dynamic viscosity is approximately 0.4% at
273 K and 2.7% at 1800 K, or approximately

\begin{equation}
\sigma = 0.0015T\ \%
\end{equation}

where $T$ is in K. The standard deviation of the thermal conductivity is
approximately 1% at 273 K and 6% at 1800K, or

\begin{equation}
\sigma=0.0035T\ \%
\end{equation}

where $T$ is in K. The speed of sound is calculated as [!cite](harlow)

\begin{equation}
c=\sqrt{\frac{-\left\lbrack\frac{P}{\rho^2}-\frac{C_v}{\left(\frac{\partial\rho}{\partial T}\right)_p}\right\rbrack}{C_v\left(\frac{\partial\rho}{\partial P}\right)_T\left(\frac{\partial T}{\partial \rho}\right)_P}}
\end{equation}

#### Range of Validity

The HeliumFluidProperties UserObject is valid for:

- 273.15 K $\le$ $T$ $\le$ 1800 K and
- 0.1 MPa $\le$ $p$ $\le$ 10 MPa.





### HydrogenFluidProperties


Fluid properties for hydrogen are mainly calculated using the Leachman et al. equation of state
[!citep](leachman2009). This formulation uses density and temperature as the primary variables with
which to calculate properties such as density, enthalpy and internal energy.

When used with the pressure and temperature interface, which is the case in the Porous Flow module, hydrogen properties are typically calculated by first calculating density iteratively for a given pressure and temperature. This density is then used to calculate the other properties, such as internal energy, directly.

Viscosity is calculated using the formulation presented in [!cite](muzny2013). Thermal conductivity is calculated using the relationship presented in [!cite](assael2011)

Dissolution of hydrogen into water is calculated using Henry's law [!citep](iapws2004).

#### Properties of hydrogen

| Property             | value |
| --- | --- |
| Molar mass           | 0.00201588e kg/mol |
| Critical temperature | 33.19 K       |
| Critical pressure    | 1.315 MPa        |
| Critical density     | 31.262kg/m$^3$ |
| Triple point temperature | 13.952 K |
| Triple point pressure | 7.7 kPa |

#### Range of validity

The HydrogenFluidProperties UserObject is valid for:

- 13.957 K $\le$ T $\le$ 1000 K for p $\le$ 2000 MPa





### IdealGasFluidProperties


A simple formulation that is suitable for ideal gases, where properties are derived from
the ideal gas law
\begin{equation}
  P = \rho R T.
\end{equation}

Temperature is calculated using the internal energy of an ideal gas
\begin{equation}
  u = c_v T.
\end{equation}




### IdealRealGasMixtureFluidProperties

This class computes fluid properties for gaseous mixtures with a condensable
(primary) component and one or more non-condensable (secondary) components.
This model (which corresponds to "Model A" in [!citep](hansel2018ncgs))
assumes that each gas in the mixture occupies the entire mixture
volume at a common temperature and each has a partial pressure and is considered
an ideal gas mixture approximation applied to real gases.

#### Formulation

Consider a mixture of $N$ gases. Let the $i$ subscript denote the component index
and the lack of a subscript denote a mixture quantity. The mass fraction $\xi_i$
is defined as the ratio of the component mass $m_i$ to the mixture mass $m$:

\xi_i = \frac{m_i}{m} = \frac{\rho_i}{\rho} = \frac{v}{v_i} \,,

where the densities $\rho_i$ and $\rho$ are with respect to the mixture volume. The molar fraction
$\psi_i$ is defined as the ratio of the component number of moles $n_i$ to the mixture
number of moles $n$:

\psi_i = \frac{n_i}{n} \,.

The mixture molar mass $M$ can be computed using the component molar fractions
and molar masses $M_i$:

M = \sum\limits_i^N \psi_i M_i \,.

The mass fraction and molar fraction are related as

\xi_i = \frac{\psi_i M_i}{M} \,.

Note the following relation for all mass-specific quantities, such as
specific volume and specific internal energy:

v = \sum\limits_i^N \xi_i v_i(p_i, T) \,,

e = \sum\limits_i^N \xi_i e_i(p_i, T) \,,

where $y_i(p_i, T)$ is the component equation of state call for $y$, evaluated
at the partial pressure and common temperature.

Note that the mixture density should be computed as

\rho = \frac{1}{v}

instead of a summation of component densities, since this would be
inconsistent if any component is not an ideal gas.

Transport properties, such as dynamic viscosity and thermal conductivity are
computed as

\mu = \sum\limits_i^N \psi_i \mu_i(p_i, T) \,,

k = \sum\limits_i^N \psi_i k_i(p_i, T) \,.

The gases share a temperature $T$, and each has a partial pressure $p_i$,
which is an assumption known as Dalton's law:

p = \sum\limits_i^N p_i(T, v_i) \,,

where by [!eqref](massfrac),

v_i = \frac{v}{\xi_i} \,.

Note

p_i = \psi_i p \,.

#### Sound Speed and Specific Heat Capacities

The mixture sound speed and heat capacities are computed directly from thermodynamic definitions
relative to mixture properties, rather than constituent properties:

c_p = \left(\frac{\partial h}{\partial T}\right)_p \,,

c_v = \left(\frac{\partial e}{\partial T}\right)_v \,,

c = v\sqrt{-\left(\frac{\partial p}{\partial v}\right)_s} \,.

Since the independent parameters are $p$ and $T$, the following relations can be used:

\left(\frac{\partial e}{\partial T}\right)_v = \left(\frac{\partial e}{\partial T}\right)_p
  - \left(\frac{\partial e}{\partial p}\right)_T
  \frac{\left(\frac{\partial v}{\partial T}\right)_p}
  {\left(\frac{\partial v}{\partial p}\right)_T} \,,

\left(\frac{\partial p}{\partial v}\right)_s = \left[\left(\frac{\partial v}{\partial p}\right)_T
  - \left(\frac{\partial v}{\partial T}\right)_p
  \frac{\left(\frac{\partial s}{\partial p}\right)_T}
  {\left(\frac{\partial s}{\partial T}\right)_p}\right]^{-1} \,.

#### Implementation

The available interfaces are summarized in the following table, where the rows
correspond to the computed quantity, and the columns correspond to the various
combinations of input arguments. Note that the notation
$x : y(x) = y$ denotes the nonlinear solve of the equation $y(x) = y$ for $x$:

| Quantity | $(v,e,\xi)$ | $(p,T,\xi)$ | $(T,v,\xi)$ | $(p,v,\xi)$ | $(p,\rho,\xi)$ |
| :- | - | - | - | - | - |
| $v$ |   | $v: p(T,v,\xi) = p$ |   |   |   |
| $\rho$ |   | $\frac{1}{v(p,T,\xi)}$ |   |   |   |
| $T$ | $T: e(T,v,\xi) = e$ |   |   | $T: p(T,v,\xi) = p$ |   |
| $e$ |   | $e(T,v(p,T,\xi),\xi)$ | $\sum\limits_i^N \xi_i e_i(T, v/\xi_i)$ |   | $e(T(p,\frac{1}{\rho},\xi), \frac{1}{\rho}, \xi)$ |
| $s$ |   |   | $\sum\limits_i^N \xi_i s_i(T, v/\xi_i)$ |   |   |
| $p$ | $p(T(v,e,\xi),v,\xi)$ |   | $\sum\limits_i^N p_i(T,v/\xi_i)$ |   |   |
| $c$ | [!eqref](soundspeed) | [!eqref](soundspeed) | [!eqref](soundspeed) |   |   |
| $c_p$ |   | [!eqref](cp) | [!eqref](cp) |   |   |
| $c_v$ |   | [!eqref](cv) | [!eqref](cv) |   |   |
| $\mu$ |   | $\sum\limits_i^N \psi_i \mu_i(v_i, e_i(T, v_i))$ | [!eqref](viscosity) |   |   |
| $k$ |   | $\sum\limits_i^N \psi_i k_i(v_i, e_i(T, v_i))$ | [!eqref](conductivity) |   |   |




### LeadBismuthFluidProperties


These properties are based on experiments reported in the Handbook on Lead-bismuth Eutectic Alloy and Lead
Properties, Materials Compatibility, Thermal-hydraulics and Technologies [!citep](Fazio).
Most properties only depend on temperature; the fluid is considered incompressible.
The fluid properties are summarized in [tab:leadbi], which reports the formulas used and their origin.

| Properties                     | Equations| Equation/Table # |
| :----------------------------- | :------------- | :------------- |
| Melting point, $T_{mo}$ (K)    | 398 | Equation 2.1  |
| Density, $\rho$ (kg/m^3)       | $11065 - 1.2793T$ | Equation 2.30  |
| Viscosity, $\mu$ (Pa-s)        | $4.94 \times 10^{-4} \times e^{\frac{754.1}{T}}$ | Equation 2.83  |
| Specific enthalpy, $h$ (J)     | $164.8(T - T_{mo}) - 1.97 \times 10^{-2}(T^2 - T_{mo}^2) + 4.167 \times 10^{-6}(T^3 - T_{mo}^3) + 4.56 \times 10^5(\frac{1}{T} -\frac{1}{T_{mo}})$ | Equation 2.55  |
| Thermal Conductivity, $k$ (W/m-K)        | $3.284 + 1.617 \times 10^{-2}T - 2.305 \times 10^{-6}T^2$ | Equation 2.91  |
| Isobaric Specific Heat, $cp$ (J/kg-K)    | $164.8 - 3.94 \times 10^{-2}T + 1.25 \times 10^{-5}T^2 - \frac{4.56 \times 10^5}{T^2}$ |  Table 2.19.3  |
| Isentropic Bulk Modulus, $B_S$ (N/m$^2$) | $(38.02 - 1.296 \times 10^{-2}T + 1.320 \times 10^{-6}T^2)10^9$ | Equation 2.44  |
| Speed of Sound, $c$ (m/s)                | $1855 - 0.212 T$ | Table 2.19.3 |

#### Range of validity

The properties defined in `LeadBismuthFluidProperties` from [!citep](Fazio) are valid for:

400 K $\le$ T $\le$ 1100 K

#### Uncertainties of Lead Bismuth Eutectic Fluid Properties

The reported uncertainties in [!citep](Fazio) for lead-bismuth eutectic fluid properties are:

| Properties     | Range/ Uncertainties|
| :------------- | :------------- |
| Density        | 0.8% |
| Viscosity      |  8% |
| Thermal Conductivity | 15% |
| Isobaric Specific Heat | 7% |





### LeadFluidProperties


These properties are based on experiments reported in the Handbook on Lead-bismuth Eutectic Alloy and Lead
Properties, Materials Compatibility, Thermal-hydraulics and Technologies [!citep](Fazio).
Most properties only depend on temperature; the fluid is considered incompressible.
The fluid properties are summarized in [tab:lead], which reports the formulas used and their origin.

| Properties                     | Equation       | Equation/Table # |
| :----------------------------- | :------------- | :------------- |
| Melting point, $T_{mo}$ (K)    | 600            | Equation 2.1  |
| Density, $\rho$ (kg/m^3)       | $11441 - 1.2795T$ | Equation 2.28  |
| Viscosity, $\mu$ (Pa-s)        | $4.55 \times 10^{-4} \times e^{\frac{1069}{T}}$ | Equation 2.81  |
| Specific enthalpy, $h$ (J)     | $176.2(T - T_{mo}) - 2.4615 \times 10^{-2}(T^2 - T_{mo}^2) + 5.147 \times 10^{-6}(T^3 - T_{mo}^3) + 1.524 \times 10^6(\frac{1}{T} -\frac{1}{T_{mo}})$ | Equation 2.53  |
| Thermal Conductivity, $k$ (W/m-K)        | $9.2 + 0.011T$ | Equation 2.89  |
| Isobaric Specific Heat, $cp$ (J/kg-K)    | $176.2 - 4.923\times 10^{-2} \times T + 1.544 \times 10^{-5} \times T^2 - \frac{1.524 \times 10^6}{T^2}$ |  Table 2.19.1  |
| Isentropic Bulk Modulus, $B_S$ (N/m$^2$) | $(43.50 - 1.552 \times 10^{-2}T + 1.622 \times 10^{-6}T^2)10^9$ | Equation 2.42  |
| Speed of Sound, $c$ (m/s)                | $1953 - 0.246 T$ | Table 2.19.1 |

#### Range of validity

The properties defined by `LeadFluidProperties` are valid for:

 - 600 K $\le$ T $\le$ 1800 K

#### Uncertainties of Lead Fluid Properties

The reported uncertainties in [!citep](Fazio) for lead fluid properties are:

| Properties | Uncertainties |
| :------------- | :------------- |
| Density | 1% |
| Viscosity | 5% |
| Thermal Conductivity | 15% |
| Isobaric Specific Heat | 5% |





### MethaneFluidProperties


Fluid properties for methane are mainly calculated using the Setzmann and Wagner equation of state
[!citep](setzmann1991). This formulation uses density and temperature as the primary variables with
which to calculate properties such as density, enthalpy and internal energy.

When used with the pressure and temperature interface, which is the case in the Porous Flow module, methane properties are typically calculated by first calculating density iteratively for a given pressure and temperature. This density is then used to calculate the other properties, such as internal energy, directly. The computational expense associated with the iterative calculation can be mitigated using [TabulatedFluidProperties](/TabulatedFluidProperties.md).

For low pressures (typically less than 10 MPa), the properties of methane can be approximated using an [ideal gas](/IdealGasFluidProperties.md), which are much faster to calculate. However, at higher pressures, this approximation can lead to large differences, see [methane_density].

       id=methane_density
       style=width:60%;margin-left:10px;
       caption=Methane density at 350K for various pressures.

Transport properties such as viscosity and thermal conductivity are calculated using the formulations provided in [!cite](irvine1984).

Dissolution of methane into water is calculated using Henry's law [!citep](iapws2004).

#### Properties of methane

| Property             | value |
| --- | --- |
| Molar mass           | 0.0160425 kg/mol |
| Critical temperature | 190.564 K       |
| Critical pressure    | 4.5992 MPa        |
| Critical density     | 162.66 kg/m$^3$ |
| Triple point temperature | 90.6941 K |
| Triple point pressure | 0.01169 MPa |

#### Range of validity

The MethaneFluidProperties UserObject is valid for:

- 90.69 K $\le$ T $\le$ 625 K

and pressures up to 100 MPa.





### NaClFluidProperties


NaCl fluid properties as a function of pressure (Pa) and temperature (K).

Only solid state (halite) properties are currently implemented to use in brine formulation

Properties for halite given by [!cite](Driesner2007b), apart from thermal conductivity, which is
calculated using the data of [!cite](urqhart2015). Critical values are taken from [!cite](Anderko1992).

#### Properties of NaCl

| Property             | value |
| --- | --- |
| Molar mass           | 0.058443 kg/mol |
| Critical temperature | 3841.15 K       |
| Critical pressure    | 18.2 MPa        |
| Critical density     | 108.43 kg/m$^3$ |
| Triple point temperature | 1073.85 K |
| Triple point pressure | 50 Pa |

#### Range of validity

The NaClFluidProperties UserObject is valid for the solid phase region only





### NaKFluidProperties


These properties are based on experiments reported in the Handbook on NaK [!citep](NaKHandbook).
Most properties only depend on temperature; the fluid is considered incompressible.
The fluid properties are summarized in [tab:NaK], which reports the formulas used and their origin.

| Properties                     | Equation       | Equation # |
| :----------------------------- | :------------- | :------------- |
| Density liquid Na, $\rho_{Na}$ (kg/m^3)       | $0.9453 - 2.2473e-4 * T_c$ ($T_c$ in C) | Equation 1.5 |
| Density liquid K, $\rho_K$ (kg/m^3)       | $0.8415 - 2.172e-4 * T_c - 2.7e-8 * T_c^2 + 4.77e-12 * T_c^3$ ($T_c$ in C) | Equation 1.8  |
| Density liquid NaK, $\rho$ (kg/m^3)       | $1 / (N_K / \rho_K + N_{Na} / \rho_{Na})$ | Equation 1.9 |
| Viscosity, $\mu$ (Pa-s)        | See handbook | Equation 1.18 - 1.19  |
| Thermal Conductivity, $k$ (W/m-K)        | $0.214 + 2.07e-4 * T_c - 2.2e-7 * T_c^2$ ($T_c$ in C) | Equation 1.53  |
| Isobaric Specific Heat, $cp$ (J/kg-K)    | $0.2320 - 8.82e-5 * T_c + 8.23-8 * T_c^2$ ($T_c$ in C) | Equation 1.59 |


#### Range of validity

The reported range of validity is specified for each property:

- Density liquid Na 210 C $\le$ T $\le$ 1100 C
- Density liquid K 63.2 C $\le$ T $\le$ 1250 C
- Viscosity NaK 100 C $\le$ T
- Thermal conductivity 150 C $\le$ T $\le$ 680 C
- Isobaric Specific Heat: unspecified. Measured from 0 to 800 C


#### Uncertainties of NaK Fluid Properties

The +reported+ uncertainties in [!citep](NaKHandbook) for NaK fluid properties are in [tab:uncertainty].

Many `NaK` properties are computed from a mix of `Na` and `K` properties and the uncertainty is only reported for these individual properties. We report it here, and the user will have to perform uncertainty propagation to obtain the uncertainties for the eutectic.

| Properties | Uncertainties |
| :------------- | :------------- |
| Density liquid Na | 0.14-0.18% |
| Density liquid K | 0.25% |
| Viscosity liquid Na | 3.5e-6 - 6.5e-6 Pa.s |
| Viscosity liquid K | 7e-6 - 1.7e-5 Pa.s |
| Thermal Conductivity | 0.8% |
| Isobaric Specific Heat Na | 0.4% |
| Isobaric Specific Heat K | 2-5% |





### NitrogenFluidProperties


Fluid properties for nitrogen are mainly calculated using the Span et al. equation of state
[!citep](span2000). This formulation uses density and temperature as the primary variables with
which to calculate properties such as density, enthalpy and internal energy.

When used with the pressure and temperature interface, which is the case in the Porous Flow module, nitrogen properties are typically calculated by first calculating density iteratively for a given pressure and temperature. This density is then used to calculate the other properties, such as internal energy, directly.

Viscosity and thermal conductivity are calculated using the formulation presented in [!cite](lemmon2004).

Dissolution of nitrogen into water is calculated using Henry's law [!citep](iapws2004).

#### Properties of nitrogen

| Property             | value |
| --- | --- |
| Molar mass           | 0.02801348 kg/mol |
| Critical temperature | 126.192 K       |
| Critical pressure    | 3.3958 MPa        |
| Critical density     | 313.3 kg/m$^3$ |
| Triple point temperature | 63.151 K |
| Triple point pressure | 12.523 kPa |

#### Range of validity

The NitrogenFluidProperties UserObject is valid for:

- 63.151 K $\le$ T $\le$ 1000 K for p $\le$ 2200 MPa





### SalineMoltenSaltFluidProperties


The mole fractions of the various elements / molecules present in the salt must sum to one.
The following properties can be computed:

- density
- isobaric specific heat
- enthalpy
- viscosity
- thermal diffusivity

Saline must be installed alongside MOOSE using the `contrib/saline` submodule in the Fluid Properties
module to be able to use this fluid property object. To initialize/download the Saline submodule:

```bash
cd <directory where moose is downloaded>
git submodule update --init --checkout modules/fluid_properties/contrib/saline
```


#### Example input syntax

In this example, the fluid properties for a `LiF-NaF-KF` salt mixture are computed by a
`SalineMoltenSaltFluidProperties`.


It leverages the salt property input data in the `saline_custom.prp` file below.
The data is sorted in columns. The first column is the name of the salt, then its id, then
a number of thermo-physical properties with additional metadata such as the range of validity,
the uncertainty and a short name for the reference publication providing the data.

More details on working with Saline can be found in this [reference](https://info.ornl.gov/sites/publications/Files/Pub167853.pdf).






### SimpleFluidProperties


This is a computationally simple fluid based on a constant bulk modulus density fluid,
with density given by
\begin{equation}
  \rho = \rho_{0}\exp(P/K_{f} - \alpha_{f} T),
\end{equation}
where $K_{f}$ (the bulk modulus) and $\alpha_{f}$ (the thermal expansion coefficient) are
constants.

In this formulation, viscosity and thermal conductivity are constant (with values specified
in the input file), while internal energy and enthalpy are given by
\begin{equation}
  e = c_v T
\end{equation}
and
\begin{equation}
  h = e + \gamma\frac{p}{\rho}
\end{equation}
respectively.  Here $\gamma$ is called the `porepressure_coefficient`: usually it should be set to $1$ but many analytical studies assume $\gamma=0$.




### SinglePhaseFluidProperties

`SinglePhaseFluidProperties` is a base class for all single-phase fluid properties
objects. Its main function is to provide interfaces for computing various properties
from different combinations of other properties.

#### Properties

The following properties are considered in this class, where the "Name" column
gives the identifier for the property used in the available interfaces:

| Name | Symbol | Description |
| :- | :- | :- |
| `beta` | $\beta$ | Volumetric expansion coefficient |
| `c` | $c$ | Speed of sound |
| `cp` | $c_p$ | Isobaric specific heat capacity |
| `cv` | $c_v$ | Isochoric specific heat capacity |
| `e` | $e$ | Specific internal energy |
| `g` | $g$ | Gibbs free energy |
| `gamma` | $\gamma$ | Ratio of specific heats, $\frac{c_p}{c_v}$ |
| `h` | $h$ | Specific enthalpy |
| `k` | $k$ | Thermal conductivity |
| `mu` | $\mu$ | Dynamic viscosity |
| `p` | $p$ | Pressure |
| `rho` | $\rho$ | Density |
| `s` | $s$ | Specific entropy |
| `T` | $T$ | Temperature |
| `v` | $v$ | Specific volume |

Because two independent, intensive thermodynamic properties define a
thermodynamic state of a pure fluid, interfaces in these objects are of the form $f(a,b)$
where $f$ is the desired thermodynamic property and $a$ and $b$ are independent,
intensive thermodynamic properties that define the thermodynamic state. The
corresponding function name is `fname_from_aname_bname`, where `fname`, `aname`,
and `bname` are the names in the table above, corresponding to $f$, $a$, and $b$,
respectively. The following table lists which
properties are available from various combinations of properties (e.g., "Yes"
in the column $(a,b)$ for the row $f$ denotes that the interface `fname_from_aname_bname`
is available):

| Name     | $(p,T)$ | $(v,e)$ | $(p,s)$ | $(p,h)$ | $(T,v)$ | $(v,h)$ | $(p,\rho)$ | $(\rho,T)$ | $(h,s)$ |
| :-       | -       | -       | -       | -       | -       | -       | -          |            |         |
| $\beta$  | Yes     |         |         |         |         |         |            |            |         |
| $c$      | Yes     | Yes     |         |         |         |         |            |            |         |
| $c_p$    | Yes     | Yes     |         |         |         |         |            |            |         |
| $c_v$    | Yes     | Yes     |         |         | Yes     |         |            |            |         |
| $e$      | Yes     |         |         |         | Yes     | Yes     | Yes        |            |         |
| $g$      |         | Yes     |         |         |         |         |            |            |         |
| $\gamma$ | Yes     | Yes     |         |         |         |         |            |            |         |
| $h$      | Yes     |         |         |         | Yes     |         |            |            |         |
| $k$      | Yes     | Yes     |         |         |         |         |            | Yes        |         |
| $\mu$    | Yes     | Yes     |         |         |         |         |            | Yes        |         |
| $p$      |         | Yes     |         |         | Yes     |         |            |            | Yes     |
| $\rho$   | Yes     |         | Yes     |         |         |         |            |            |         |
| $s$      | Yes     | Yes     |         | Yes     | Yes     |         |            |            |         |
| $T$      |         | Yes     |         | Yes     |         |         |            |            |         |
| $v$      | Yes     |         |         |         |         |         |            |            |         |

Interfaces are also provided for getting derivatives of fluid properties with respect
to the input arguments. These interfaces are named the same as their non-derivative
counterparts, but have no return value but 3 additional (output) arguments,
corresponding to the property value and then the derivatives of each of the two input
arguments. For example, $\rho(p,T)$ has the interface `rho_from_p_T(p, T, rho, drho_dp, drho_dT)`,
where `drho_dp` and `drho_dT` correspond to $(\partial\rho/\partial p)|_T$ and
$(\partial\rho/\partial T)|_p$, respectively.

Fluid properties objects have interfaces for taking advantage of MOOSE's
Automatic Differentiation capability. See the example in the next section.

Additionally, the following interfaces are available:

- `fluidName()`: The fluid name.
- `molarMass()`: The fluid's molar mass (kg/mol).

The full list of available methods can be found in either the source code or the
[Modules Doxygen](http://mooseframework.org/docs/doxygen/modules/classes.html) page for each
FluidProperties class.

#### Default Analytical Fluid Properties Relations

`SinglePhaseFluidProperties` provides a number of default implementations for some fluid properties where
analytical relations hold for all single phase fluid properties. Some of these fluid properties
are also implemented along with their derivatives with regards to the input variables, when
these derivatives can also be analytically described. Relevant automatic differentiation (AD)
implementations are also provided through a `macro` to avoid duplicated code.

The full list of available methods can be found in either the source code or the
[Doxygen](https://mooseframework.inl.gov/docs/doxygen/modules/classSinglePhaseFluidProperties.html) page.

#### Variable Set Conversions

Different fluid applications may require different variable sets, such as (pressure, temperature)
or (specific volume, specific internal energy), depending on the flow regimes of interest and relatedly
the numerical discretization. Fluid properties are not necessarily implemented or known for all variable sets,
so conversions from one variable set to another can be helpful.

For many fluids, analytical closures for these conversions are not known, so `SinglePhaseFluidProperties`
defines several routines for iteratively converting from one variable set
to another. This leverages the [numerical inversion methods utilities](utils/FluidPropertiesUtils.md).
Notably, the following routines are provided:




These routines may then be used to convert from one variable set to another before obtaining the desired
fluid property. For example, this routine converts (pressure, temperature) to (specific volume, specific energy)
to compute entropy.


### Sodium Fluid Properties


`SodiumProperties` inherits from the base class `FluidProperties` and provides the needed functionality for determining sodium
fluid properties that may be used for coolant channel simulations.

The following methods are provided in this class:

- Thermal Conductivity: `k(temperature)`
- Enthalpy: `h(temperature)`
- Heat capacity: `heatCapacity(temperature)`
- Temperature: `temperature(h)`
- Density: `rho(temperature)`
- Derivative of Density w.r.t temperature: `drho_dT(temperature)`
- Derivative of Density w.r.t enthalpy: `drho_dh(h)`

Properties of liquid sodium are obtained from [!cite](Fink:1995bf).






### SodiumSaturationFluidProperties


#### Description

The `SodiumSaturationFluidProperties` class provides fluid properties for _saturated_ liquid
sodium based on correlations used in the SAS4A/SASSYS-1 reactor dynamics
and safety analysis code developed at Argonne National Laboratory for
liquid metal reactors [!cite](sas). These property models are obtained as
fits to experimental data, with computational efficiency
motivating the use of a simpler functional fits than proposed in the original
references upon which the SAS4a/SASSYS-1 implementation is based,
namely [!cite](fink). Only for $C_p$ and $C_v$ are the original correlations/data
used, since the SAS4A/SASSYS-1 implementation does not differentiate between
$C_p$ and $C_v$ for the saturated liquid.

Density is calculated as an empirical fit to two saturated liquid
density correlations recommended by Fink and Leibowitz that
cover the range $371 < T (K) < 2509$:

$\rho=1.00423\times10^3-0.21390T-1.1046\times10^{-5}T^2$

This equation fits the Fink and Leibowitz models to within 9.5%.

The thermal conductivity is a fit to experimental data by Fink and Leibowitz
below 1500 K, and extrapolated values above 1500 K based on
a method described by Grosse [!cite](sas):

$k=1.1045\times10^2-6.5112\times10^{-2}T+1.5430\times10^{-5}T^2-2.4617\times10^{-9}T^3$

This equation fits the Fink and Leibowitz data to within 0.5%.

The dynamic viscosity is given as a fit to experimental data by Fink and
Leibowitz below 1200 K and extrapolated values about 1200 K based on
a method described by Grosse [!cite](sas):

$\mu=3.6522\times10^{-5}+\frac{0.16626}{T}-\frac{4.56877\times10^1}{T^2}+\frac{2.8733\times10^4}{T^3}$

This equation fits the Fink and Leibowitz data to within 0.5%.

The isobaric and isochoric specific heats are obtained as new fits to the
experimental data in Fink and Leibowitz over the range $400 < T (K) < 2200$,

$C_p=3.7782\times10^{-1}T^2-1.7191\times10^{-6}T^3+3.0921\times10^{-3}T^2-2.4560T+1.972\times10^3$

$C_v=1.0369\times10^{-8}T^3+3.7164\times10^{-4}T^2-1.0494T+1.5826\times10^3$

The $R^2$ values for both fits are 0.997, where the $C_p$ fit matches experimental
data to within 0.5%, while for $C_v$ matches experimental data to within 1.5%.

Enthalpy is computed based on the definition of $C_p$,

$C_p\equiv\left(\frac{\partial h}{\partial T}\right)_p$

Neglecting any variation in the saturation conditions with respect to pressure
(i.e. Poynting-type effects), $h$ can be computed by integrating the above
expression,

$h(T)-h(T_{ref})=\int_{T_{ref}}^TC_pdT'$

where $T_{ref}$ is a reference temperature and $h(T_{ref})$ is the enthalpy
at that reference temperature. This expression is used to evaluate enthalpy
based on the $C_p$ fit as

$h(T)=F(T)-401088.7$

where $F(T)$ is the integral of $C_p$ with respect to temperature evaluated
at $T$ and $401088.7$ J/kg/K is a constant representing $-F(T_{ref})+h(T_{ref})$
selected in order to match the Fink and Leibowitz correlation at 371 K.
This approach, rather than simply using the Fink and Leibowitz correlation outright,
is used to ensure exact compatibility with thermodynamic definitions and the particular
fit for $C_p$ selected in this class.
Computing $h$ based on an integral of $C_p$ matches the Fink
and Leibowitz correlations to within 0.2% over the entire range for which
the $C_p$ fit is valid.

#### Range of Validity

These fluid properties correspond to saturated conditions (that is, the sodium is at the
saturation pressure).




### StiffenedGasFluidProperties


A simple fluid class that implements a stiffened equation of state [!citep](metayer2004)
\begin{equation}
  p = (\gamma - 1) \rho (e - q) - \gamma p_{\infty},
\end{equation}
where $\gamma = c_p/c_v$ is the ratio of specific heat capacities, $q$ is a constant that defines the
zero reference state for internal energy, and $p_{\infty}$ is a constant representing the attraction
between fluid molecules that makes the fluid *stiff* in comparison to an ideal gas. This equation of
state is typically used to represent water that is under very high pressure.





### StiffenedGasTwoPhaseFluidProperties

This class corresponds to both liquid and vapor phases being approximated using
the stiffened gas equation of state (SGEOS).

The saturation curve $T_\text{sat}(p)$ is generated by reasoning that at
thermodynamic equilibrium, the Gibbs free enthalpy of the phases must be
equal at the interface (see Equation (38) of [!cite](berry2010)). A saturation
curve is stored at a number of points determined by user-defined parameters,
and then linear interpolation is used to get values.

Surface tension is computed using the following form that IAPWS uses for approximating
the surface tension of water [!cite](iapws_surface_tension):
\begin{equation}
  \sigma(T) = A \left(1 - \frac{T}{T_C}\right)^B \left[1 - C \left(1 - \frac{T}{T_C}\right)\right] \,,
\end{equation}
where

- $T$ is the temperature \[K\],
- $T_C$ is the critical temperature \[K\], and
- $A$ \[N/m\], $B$ \[-\], and $C$ \[-\] are a fluid-dependent constants.





### TabulatedBicubicFluidProperties


See [TabulatedFluidProperties.md] for more information on how to use this object.

Third order fluid property interpolations are not always monotonous. This is exacerbated by composition when using
alternative variable sets such as (specific volume, specific internal energy). If this arises
and is observed to remove the uniqueness of the numerical solution, lower order interpolation should be considered.




### TabulatedFluidProperties

Single phase fluid properties computed using bi-dimensional interpolation of tabulated values.

Property values are read from a CSV file containing property data. Monotonically increasing values
of pressure and temperature must be included in the data file, specifying the phase space where
tabulated fluid properties will be defined. An error is thrown if either temperature or pressure data
is not included or not monotonic, and an error is also thrown if this object is requested to
provide a fluid property outside this phase space.

This class is intended to be used when complicated formulations for fluid properties (such as
density or internal energy) are required, which can be computationally expensive.  This is particularly
the case when the fluid equation of state is based on a Helmholtz free energy that is a function of
density and temperature, like that used in [CO2FluidProperties](/CO2FluidProperties.md). In this example,
density must be solved iteratively using pressure and temperature, which increases the computational burden.

Using an interpolation of tabulated fluid properties can significantly reduce the computational time
for computing fluid properties defined using complex equations of state, which may reduce the overall
computational cost dramatically, especially if fluid properties are calculated a large number of times.

`TabulatedFluidProperties` is a base class and may not be used. A derived class, specifying an interpolation
method to use to interpolate between the tabulated data, must be used instead.
Currently only [bicubic tabular interpolation](TabulatedBicubicFluidProperties.md) is implemented.
Bilinear interpolation is a work in progress.

#### File format id=format

The expected file format for the tabulated fluid properties is now described.  The first line must be
the header containing the required column names *pressure* and *temperature*, and also any number of
the fluid properties that `TabulatedFluidProperties` understands. The exact names used are:

- *density*
- *enthalpy*
- *v* (specific_volume)
- *internal_energy*
- *viscosity*
- *k* (the thermal conductivity)
- *g* (gibbs free energy)
- *cp* (the isobaric specific heat capacity)
- *cv* (the isochoric specific heat capacity)
- *c* (speed of sound in fluid)
- *entropy*


The order is not important, although having pressure and temperature first makes the data easier for a human to read.

The data in the pressure and temperature columns *must* be monotonically increasing. This file format
does require duplication of the pressure and temperature data - each pressure value must be included
[!param](/FluidProperties/TabulatedFluidProperties/num_T) times, while each temperature value is repeated
[!param](/FluidProperties/TabulatedFluidProperties/num_p) times, where
[!param](/FluidProperties/TabulatedFluidProperties/num_T) and [!param](/FluidProperties/TabulatedFluidProperties/num_p) are the
number of temperature and pressure points, respectively. This class will check that the required
number of data points have been entered
([!param](/FluidProperties/TabulatedFluidProperties/num_T) * [!param](/FluidProperties/TabulatedFluidProperties/num_p)).

An example of a valid fluid properties file, with two pressure points and three temperature points, is provided below:

```text
pressure, temperature,   density, enthalpy, internal_energy
  200000,         275,   3.90056,   -21487,        -72761.7
  200000,         277,   3.86573, -19495.4,        -71232.0
  200000,         280,   3.83155, -17499.1,        -69697.3
  300000,         275,   6.07273, -22728.3,        -73626.5
  300000,         277,   6.01721, -20711.5,        -72079.3
  300000,         280,   5.96277, -18691.0,        -70527.7
```

#### Using TabulatedFluidProperties

##### Reading from an existing file

Consider the example where a `TabulatedFluidProperties` object is used to reduce the cost of calculating
CO$_2$ fluid properties. In this example, a file containing the tabulated fluid properties, named
`fluid_properties.csv` is provided. All properties listed in this file will be calculated using
either Bilinear or Bicubic interpolation (the interpolation type is to be specified in the input file),
while all remaining properties provided by the `FluidProperties` interface will be
calculated using a [CO2FluidProperties](/CO2FluidProperties.md) object.

The input file syntax necessary to achieve this with a (pressure, temperature) variable set is shown below.
A [TabulatedBicubicFluidProperties.md] is used.


With a (specific volume, specific energy) variable set, the syntax shown in the example file below may be used:



##### Writing data file

The `TabulatedFluidProperties`-derived classes can write a file containing the data for the properties specified in the
input file parameter *interpolated_properties*. It will use the pressure and temperature
ranges specified in the input file at the beginning of the simulation.

For example, if we wish to generate a file containing tabulated properties for CO$_2$ density, enthalpy
and viscosity for $300 \mathrm{K} \le T \le 400 \mathrm{K}$ and $1 \mathrm{MPa} \le p \le 10 \mathrm{MPa}$,
divided into 50 and 100 equal points, respectively, then the input file syntax necessary is

```text
[FluidProperties]
  [co2]
    type = CO2FluidProperties
  []
  [tabulated]
    type = TabulatedBicubicFluidProperties
    fp = co2
    fluid_property_output_file = fluid_properties.csv
    interpolated_properties = 'density enthalpy viscosity'

    # Bounds of interpolation
    temperature_min = 300
    temperature_max = 400
    pressure_min = 1e6
    pressure_max = 10e6

    # Grid discretization
    num_T = 50
    num_p = 100
  []
[]
```


This tabulated data will be written to file in the correct format, enabling suitable data files to be
created for future use. There is an upfront computational expense required for this initial data
generation, depending on the required number of pressure and temperature points. However, provided
that the number of data points required to generate the tabulated data is smaller than the number of
times the property members in the FluidProperties object are used, the initial time to generate
the data and the subsequent interpolation time can be much less than using the original
FluidProperties object.

Using the  [!param](/FluidProperties/TabulatedFluidProperties/construct_pT_from_ve) parameter and the
[!param](/FluidProperties/TabulatedFluidProperties/fluid_property_output_file) parameters, a tabulation
using the (specific volume, specific internal energy) variables can be generated. The output file name
for this additional tabulation will be suffixed with `_ve.csv`.

All fluid properties read from a file or specified in the input file (and their derivatives with
respect to pressure and temperature) will be calculated through interpolation, while all
remaining (or missing) fluid properties will be calculated using the provided `FluidProperties` object.

#### Using alternative variable sets

The (pressure, temperature) variable set is not adequate for all fluid flow applications, and alternative
variable sets may be used with `TabulatedFluidProperties` objects. (specific volume (v), specific internal energy (e)),
and (specific volume, specific enthalpy (h)) are supported.

##### Option 1: Creation of interpolations between variable sets

The first option is to use (pressure, temperature) variable for all fluid properties, and rely on tabulated conversions from (specific volume, specific internal energy / enthalpy) to (pressure, temperature) to compute properties.
This option is selected with the [!param](/FluidProperties/TabulatedFluidProperties/construct_pT_from_ve) and
[!param](/FluidProperties/TabulatedFluidProperties/construct_pT_from_vh) parameters.
The workflow is as follows:

- The data is read from a data file tabulated with pressure and temperature, and interpolations based on
  pressure and temperature are created for each tabulated property.

- The pressure and temperature data is converted to the alternative variable set (for example (v,e)) using [Newton's method](utils/FluidPropertiesUtils.md).
  The inversion uses the interpolations created from the tabulated data, or if available the `FluidProperties` object
  as this reduces the error.

- A grid of values for pressure and temperature is computed for the alternative variable set. This is used to create
  a tabulated interpolation from the alternative variable set to the (pressure, temperature) variable set. This process is
  described in the next section, see [TabulatedFluidProperties.md#pt_from_ve].

- When querying a fluid property using the alternative variable set, the interpolations are first used to convert
  to the (pressure, temperature) variable set (for example, computing $p(v,e)$ and $T(v,e)$). Then the fluid property
  desired is queried using this variable set (for example, $\rho(p, T)$) and returned. This can be summarized as
  $\rho(v,e) = \rho_{interpolated}(p_{interpolated}(v,e), T_{interpolated}(v,e))$


The additional variable sets supported are $(v,e)$ and $(v,h)$. A few properties may be computed using alternative
variable sets: $e(p,\rho), T(p,\rho), T(p,h)$ and $s(h,p)$ for example.

File data may only be read and written with the (pressure, temperature) variable set. The alternative variable set
must be either contained in the tabulation read or be computable from pressure and temperature in the
`FluidProperties` object.

##### Generating (v,e) to (p,T) conversion interpolations id=pt_from_ve

As fluid properties are much more often tabulated using pressure and temperature than alternative variable
sets, the alternative variables are systematically converted to pressure and temperature to perform the
fluid property evaluations. This involves the creation of an interpolation of pressure and temperature using the
alternative variable sets. This is done in several sets, described for the $(v,e)$ set:

- A grid of $(v,e)$ data is generated. If a fluid property user object is provided, the bounds are based on
  the specified bounds on pressure and temperature : $e_{min/max} = e(p_{min/max}, T_{min/max})$, else the bounds
  are chosen from the tabulated data. The number of points in the grid in both dimensions are user-selected parameters.
  The v grid may be created using base-10 log-spacing by setting [!param](/FluidProperties/TabulatedFluidProperties/use_log_grid_v).
  The e grid may be created using base-10 log-spacing by setting [!param](/FluidProperties/TabulatedFluidProperties/use_log_grid_e).

- These bounds may not be physically realizable simultaneously. It could be that the fluid may not have both $v=v_{min}$
  and $e=e_{min}$. Part of the grid may not be physical.

- The pressure and temperature are then calculated for every point in the $(v,e)$ grid by using the
  [Newton method utilities](utils/FluidPropertiesUtils.md). Note that sometimes pressure and temperature values
  can be outside the user-defined range during this variable set inversion. when this is the case, the $(p,T)$ values are
  replaced with their respective minimum and maximum values. This only means that the interpolations will be constant
  over part of the $(v,e)$ grid, which should be outside of the range of interest.

- An interpolation object, very similar to the ones created for the other fluid properties based on $(p,T)$ data,
  is created for both variables of the alternative set. This object can then compute: $p_{interpolated}(v,e)$ and
  $T_{interpolated}(v,e)$.


Warnings will be output when a pressure or temperature value is limited to its bound, and when an inversion from
the alternative variable set to pressure or temperature fails, often because the grid extends beyond physically
reachable values.

##### Option 2: Using interpolations in (v,e) of the fluid properties

To avoid the difficulties in converting from (v,e) to (pressure, temperature) and then evaluating the properties
with (pressure, temperature), the properties can also be interpolated in (v,e). These interpolations can be created
from either another `FluidProperties` object, with the [!param](/FluidProperties/TabulatedFluidProperties/fp), or from a
(specific volume, specific internal energy) tabulation, using the [!param](/FluidProperties/TabulatedFluidProperties/fluid_property_ve_file) parameter.

Similarly as for (pressure, temperature), the list of properties to interpolate should be provided using the [!param](/FluidProperties/TabulatedFluidProperties/interpolated_properties) parameter.

The format of the tabulation is similar to the one mentioned in [TabulatedFluidProperties.md#format], except that specific volume and specific internal
energy replace pressure and temperature for the tabulation variables. Pressure and temperature will likely
instead appear as the tabulated properties, so that `temperature(v,e)` and `pressure(v,e)` can be computed directly from interpolations.




### TemperaturePressureFunctionFluidProperties


The temperature and pressure will be passed as respectively the x and y spatial arguments of the
functions. The following relations hold true:

\begin{equation}
\begin{aligned}
  x = T \\
  y = P \\
  \rho = \rho^{u}(t=0, (x=T, y=P, z=0)) \\
  \mu = \mu^{u}(t=0, (x=T, y=P, z=0)) \\
  k = k^{u}(t=0, (x=T, y=P, z=0)) \\
\end{aligned}
\end{equation}

Both the time (`t`) and Z-axis dimension are not used here. A fluid property made to depend on time will
not be properly updated by this `FluidProperties` object.
There are two options for specific heat. Either the user sets a constant specific isochoric heat capacity

\begin{equation}
\begin{aligned}
  c_v = c_v^{u} \\
  e = e_{ref} + c_v * (T - T_{ref})
\end{aligned}
\end{equation}

Or, the user uses a function of temperature and pressure (same arguments as for density)

\begin{equation}
\begin{aligned}
  x = T \\
  y = P \\
  cp = cp^{u}(t=0, (x=T, y=P, z=0))
  cv = cp - \dfrac{\alpha^2 T}{\rho \beta_T}
\end{aligned}
\end{equation}

with $T$ the temperature, $P$ the pressure, $\rho$ the density, $\mu$ the dynamic viscosity, $k$ the thermal conductivity, $c_v$ the specific isochoric heat capacity, $e$ the specific internal energy, $T_{ref}$ a reference temperature at which the specific internal energy is equal to a reference energy $e_{ref}$, $\alpha$ the coefficient of thermal expansion, $\beta_T$ the isothermal
compressibility, and the $^u$ exponent indicating a user-passed parameter.

The derivatives of the fluid properties are obtained using the `Function`(s) gradient components
and the appropriate derivative chaining for derived properties.

The range of validity of the property is based off of the validity of the functions
that are input, and is not checked by this `FluidProperties` object.

Support for the conservative (specific volume, internal energy) variable set is only
partial. Notable missing implementations are routines for entropy, the speed of sound, and some
conversions between specific enthalpy and specific energy.

When using a function for the isobaric specific heat capacity, a numerical integration is performed to compute
$e(p,T)$ as $e_{ref} + \int_{T_{ref}}^T c_v(p,T) dT$. Note that this neglects the $dV$ term. This is exact
for incompressible fluids and ideal gases.

#### Example Input File Syntax

In this example, temperature and pressure dependent density, dynamic viscosity and thermal conductivity of a fluid are being set using
three `ParsedFunctions`. The functions are specified with the `x` and `y` coordinates, and are evaluated with respectively the temperature and
pressure variables.





### TwoPhaseFluidPropertiesIndependent


This 2-phase fluid properties class takes as its parameters the names of its
two 1-phase fluid properties objects, thus allowing an arbitrary combination of
1-phase fluid properties objects to be used. This class disallows calling any
of the 2-phase fluid properties interfaces (for example, saturation temperature),
since this class assumes that the 2 phases are independent and thus should
not have any 2-phase properties. This class is useful for using in test problems
that ideally should reduce to two 1-phase test problems acting independently.





### TwoPhaseNCGPartialPressureFluidProperties

This fluid properties class is used for two-phase fluids that have a single,
non-condensable gas (NCG) mixed with their vapor phase. The vapor mixture model
of [IdealRealGasMixtureFluidProperties.md] is used, which corresponds to a
partial pressure mixture model for real gases.

In addition to the interfaces of its parent class, this class provides an
interface for computing the mass fraction of the NCG $\xi_\text{NCG}$ assuming saturation
of the main fluid at the temperature $T$ and mixture pressure $p$.
The molar fraction of the NCG $\psi_\text{NCG}$ is computed by combining the two relations:

p = p_{v,\text{sat}}(T) + p_\text{NCG} \,,

p_\text{NCG} = \psi_\text{NCG} p \,,

which with the relation between molar fractions and mass fractions, yields

\psi_\text{NCG} = \frac{p - p_{v,\text{sat}}(T)}{p} \,,

\xi_\text{NCG} = \frac{M_\text{NCG}}{M} \,,

where $M_\text{NCG}$ is the NCG molar mass, and $M$ is the mixture molar mass,

M = (1 - \psi_\text{NCG}) M_v + \psi_\text{NCG} M_\text{NCG} \,,

with $M_v$ denoting the main fluid molar mass.





### Water97FluidProperties


The water implementation in Fluid Properties is the IAPWS Industrial Formulation 1997 for the
Thermodynamic Properties of Water and Steam. This formulation calculates properties of water and
steam using pressure and temperature as inputs. The IAPWS-IF97 formulation is split into five
different regions in the phase diagram.

All five regions are implemented in the Fluid Properties module. To avoid iteration in region 3 of
the IAPWS-IF97 formulation, the backwards equations from [!cite](iapws1997region3) are implemented.

Viscosity is calculated using the IAPWS 2008 formulation [!citep](iapws2008). Note that the critical
enhancement has not been implemented.

Thermal conductivity is calculated using the IAPS 1985 formulation [!citep](iaps1985). Although there
is a newer formulation available [!citep](iapws2011), it is significantly more complicated, so has not
been implemented yet.

Dissolution of a dilute gas into water is calculated using Henry's law [!citep](iapws2004).

#### Properties of water

| Property             | value |
| --- | --- |
| Molar mass           | 0.018015 kg/mol |
| Critical temperature | 647.096 K       |
| Critical pressure    | 22.064 MPa        |
| Critical density     | 322.0 kg/m$^3$ |
| Triple point temperature | 273.16 K |
| Triple point pressure | 611.657 Pa |

#### Range of validity

The Water97FluidProperties UserObject is valid for:

- 273.15 K $\le$ T $\le$ 1073.15 K for p $\le$ 100 MPa
- 1073.15 K $\le$ T $\le$ 2273.15 K for p $\le$ 50 MPa





## functions

### SaturationDensityFunction

This function computes saturation density of either the liquid phase or vapor phase from a given
temperature function $T(\mathbf{x}, t)$:
\begin{equation}
  \rho_\text{sat}(\mathbf{x},t) = \rho(p_\text{sat}(T(\mathbf{x}, t)),T(\mathbf{x}, t)) \,,
\end{equation}
where the $p_\text{sat}(T)$ function is provided via the `p_sat(T)` API of
objects deriving from `TwoPhaseFluidProperties` and the $\rho(p,T)$ function is provided via the
'rho_from_p_T(p,T)' API of the liquid or vapor 'SinglePhaseFluidProperties' object.




### SaturationPressureFunction

This function computes saturation pressure $p_\text{sat}$ from a given
temperature function $T(\mathbf{x}, t)$:
\begin{equation}
  p_\text{sat}(\mathbf{x}, t) = p_\text{sat}(T(\mathbf{x}, t)) \,,
\end{equation}
where the $p_\text{sat}(T)$ function is provided via the `p_sat(T)` API of
objects deriving from `TwoPhaseFluidProperties`.




### SaturationTemperatureFunction

This function computes saturation temperature $T_\text{sat}$ from a given
pressure function $p(\mathbf{x}, t)$:
\begin{equation}
  T_\text{sat}(\mathbf{x}, t) = T_\text{sat}(p(\mathbf{x}, t)) \,,
\end{equation}
where the $T_\text{sat}(p)$ function is provided via the `T_sat(p)` API of
objects deriving from `TwoPhaseFluidProperties`.




### TwoPhaseNCGPartialPressureFunction

This function can be used to call a selection of property lookup functions from a
[TwoPhaseNCGPartialPressureFluidProperties.md] object. For a particular property
function specified by [!param](/Functions/TwoPhaseNCGPartialPressureFunction/property_call),
there is a certain number of input arguments, which are specified in the
parameters [!param](/Functions/TwoPhaseNCGPartialPressureFunction/arg1) and
[!param](/Functions/TwoPhaseNCGPartialPressureFunction/arg2) in the order
corresponding to the property call. Not all properties require the maximum
number of inputs, so the excess inputs should not be provided.




## ics

### RhoFromPressureTemperatureIC

Initial condition to set density from given pressure and temperature using the
`SinglePhaseFluidProperties` interface.





### RhoVaporMixtureFromPressureTemperatureIC

Initial condition to set density of vapor mixture from given pressure and temperature using the
`SinglePhaseFluidProperties` and `VaporMixtureInterface` interface.




### SpecificEnthalpyFromPressureTemperatureIC

Initial condition to set specific enthalpy from given pressure and temperature using the
`SinglePhaseFluidProperties` interface.





## interfaces

### NaNInterface

For some objects it is desirable to continue running despite generation of
NaN(s). This class provides an interface for choosing whether to:

- throw an error
- emit a warning, visible on the console for every occurrence of the condition
- throw an exception which will cause the solve to fail for [Steady.md] solves, or a time step reduction
  for [Transient.md] solves
- do nothing at all, just using a quiet NaN which may affect the solution downstream

This interface is commonly used in fluid properties for handling the occurrence of NaN(s).
This interface is not a substitute for implementing domain of validity checks in each fluid property.
This interface can be complimented by the [SolutionInvalidInterface.md], which can let the solver
re-attempt solves when an invalid condition is detected.

## materials

### ADSaturationTemperatureMaterial

This material computes an AD saturation temperature material property from a
pressure AD material property and the `T_sat(p)` interface of a
`TwoPhaseFluidProperties` object.




### ADSurfaceTensionMaterial

This material computes an AD surface tension material property from a temperature
AD material property and the `sigma_from_T(T)` interface of a
`TwoPhaseFluidProperties` object.




### FluidPropertiesMaterialPT


`FluidPropertiesMaterialPT` samples the functions available in a fluid property user object
and provides them as material properties.

The following material properties created are:

- Density: `rho(temperature, pressure)`
- Dynamic viscosity: `mu(temperature, pressure)`
- Isobaric specific heat capacity: `cp(temperature, pressure)`
- Isochoric specific heat capacity: `cv(temperature, pressure)`
- Thermal conductivity: `k(temperature, pressure)`
- Specific enthalpy: `h(temperature, pressure)`
- Specific energy: `e(temperature, pressure)`
- Specific entropy: `s(temperature, pressure)`
- Velocity of sound in medium: `c(temperature, pressure)`




### FluidPropertiesMaterialVE


`FluidPropertiesMaterialVE` samples the functions available in a fluid property user object
and provides them as material properties.

The following material properties created are:

- Density: `rho(specific_volume, specific_energy)`
- Dynamic viscosity: `mu(specific_volume, specific_energy)`
- Isobaric specific heat capacity: `cp(specific_volume, specific_energy)`
- Isochoric specific heat capacity: `cv(specific_volume, specific_energy)`
- Thermal conductivity: `k(specific_volume, specific_energy)`
- Velocity of sound in medium: `c(specific_volume, specific_energy)`


The following variables are also computed through a variable set inversion:

- Pressure
- Temperature





### SaturationPressureMaterial

This material computes saturation pressure as a material property from a
temperature material property and the `p_sat(T)` interface of a
`TwoPhaseFluidProperties` object.




### Sodium Properties Material


`SodiumPropertiesMaterial` samples the functions available in [SodiumProperties](fluidproperties/SodiumProperties.md)
and provides them as material properties.

The following material properties created for liquid sodium are:

- Thermal Conductivity: `k(temperature)`
- Enthalpy: `h(temperature)`
- Heat capacity: `cp(temperature)`
- Temperature from enthalpy: `T_from_h(h)`
- Density: `rho(temperature)`
- Derivative of Density w.r.t temperature: `drho_dT(temperature)`
- Derivative of Density w.r.t enthalpy: `drho_dh(h)`

Properties of liquid sodium are obtained from [!cite](Fink:1995bf).






## userobjects

### FluidPropertiesInterrogator


#### Introduction

The `FluidPropertiesInterrogator` user object is used to query fluid properties
objects that derive from the following types:

- `SinglePhaseFluidProperties`
- `VaporMixtureFluidProperties`
- `TwoPhaseFluidProperties` (note that `TwoPhaseNCGFluidProperties` derives from this)

The user specifies a thermodynamic state at which to evaluate a number of fluid
properties. This can be useful for a number of different tasks, such as the
following:

- Determining values for initial conditions or problem setup
- Verifying out-of-bounds inputs to fluid properties interfaces
- Getting values to be used in tests

#### Usage

The interrogator is used with a syntax for
[AddFluidPropertiesInterrogatorAction](/AddFluidPropertiesInterrogatorAction.md).
In an input file, the user will only need a block for the `FluidPropertiesInterrogator`
and a block for creating the fluid properties object that will be interrogated.
For convenience, an input file to use the interrogator is provided in the module:


#### Valid Input Combinations

Notation is summarized in the following table:

| Symbol | Description |
| - | - |
| $p$        | Pressure |
| $p_{sat}$  | Saturation pressure |
| $p_{crit}$ | Critical pressure |
| $T$        | Temperature |
| $T_{sat}$  | Saturation temperature |
| $\rho$     | Density |
| $v$        | Specific volume |
| $e$        | Specific internal energy |
| $E$        | Specific total energy |
| $h$        | Specific enthalpy |
| $\Delta h_{\ell\rightarrow v}$ | Latent heat of vaporization |
| $s$        | Specific entropy |
| $c$        | Sound speed |
| $u$        | Fluid speed |
| $\mu$      | Dynamic viscosity |
| $c_p$      | Specific heat at constant pressure |
| $c_v$      | Specific heat at constant volume |
| $k$        | Thermal conductivity |
| $\beta$    | Volumetric expansion coefficient |
| $x_{NCG}$  | Mass fraction of non-condensable gas |

Let the set of single-phase fluid properties be defined as
\begin{equation}
  \mathcal{P} \equiv \{p, T, \rho, v, e, h, s, c, \mu, c_p, c_v, k, \beta\} \,.
\end{equation}
The set of the same quantities for the *stagnation* state, rather than the
static state, is denoted as $\mathcal{P}_0$.

Let the set of valid inputs for single-phase *static* fluid properties be
\begin{equation}
  \mathcal{A} \equiv \{ \{p, T\}, \{p, \rho\}, \{\rho, e\} \} \,,
\end{equation}
and the set of valid inputs for single-phase *stagnation* fluid properties be
\begin{equation}
  \mathcal{A}_0 \equiv \{ \{p, T, u\}, \{p, \rho, u\}, \{\rho, e, u\}, \{\rho, \rho u, \rho E\} \} \,.
\end{equation}
For single-phase vapor mixture fluid properties, the valid input sets are as follows:
\begin{equation}
  \mathcal{A}_{mix} \equiv \{ \{p, T, x_{NCG}\}, \{\rho, e, x_{NCG}\} \} \,,
\end{equation}
\begin{equation}
  \mathcal{A}_{0,mix} \equiv \{ \{p, T, x_{NCG}, u\}, \{\rho, e, x_{NCG}, u\},  \{\rho, \rho u, \rho E, x_{NCG}\} \} \,,
\end{equation}


The following table summarizes the valid input combinations for single-phase
fluid properties objects.
Note that
`TwoPhaseNCGFluidProperties` inherits from `TwoPhaseFluidProperties`, so the
column `TwoPhaseFluidProperties` is used to describe fluid properties classes
that derive from `TwoPhaseFluidProperties` but not `TwoPhaseNCGFluidProperties`.

| Base Class | Valid Input Combinations | Outputs |
| - | - | - |
| `SinglePhaseFluidProperties` | $\mathcal{I}\in\mathcal{A}$   | $\mathcal{P}$ |
|                              | $\mathcal{I}\in\mathcal{A}_0$ | $\mathcal{P}$, $\mathcal{P}_0$ |
| `VaporMixtureFluidProperties` | $\mathcal{I}\in\mathcal{A}_{mix}$   | $\mathcal{P}$ |
|                               | $\mathcal{I}\in\mathcal{A}_{0,mix}$ | $\mathcal{P}$, $\mathcal{P}_0$ |
| `TwoPhaseFluidProperties` | $\mathcal{I} = \{\}$     | $p_{crit}$ |
|                           | $\mathcal{I}\in\{p\}$       | $p_{crit}$, $T_{sat}$, $\Delta h_{\ell\rightarrow v}$ |
|                           | $\mathcal{I}\in\{T\}$       | $p_{crit}$, $p_{sat}$, $\Delta h_{\ell\rightarrow v}$ |
|                           | $\mathcal{I}\in\{p, T\}$    | $p_{crit}$, $\Delta h_{\ell\rightarrow v}$ |
|                           | $\mathcal{I}\in\mathcal{A}, \mathcal{I}\ne\{p, T\}$ | $p_{crit}$, $\mathcal{P}_\ell$, $\mathcal{P}_v$ |
|                           | $\mathcal{I}\in\mathcal{A}_0$ | $p_{crit}$, $\mathcal{P}_\ell$, $\mathcal{P}_v$, $\mathcal{P}_{0,\ell}$, $\mathcal{P}_{0,v}$ |
| `TwoPhaseNCGFluidProperties` | $\mathcal{I} = \{\}$     | $p_{crit}$ |
|                              | $\mathcal{I}\in\{p\}$       | $p_{crit}$, $T_{sat}$, $\Delta h_{\ell\rightarrow v}$ |
|                              | $\mathcal{I}\in\{T\}$       | $p_{crit}$, $p_{sat}$, $\Delta h_{\ell\rightarrow v}$ |
|                              | $\mathcal{I}\in\{p, T\}$    | $p_{crit}$, $\Delta h_{\ell\rightarrow v}$ |
|                              | $\mathcal{I}\in\mathcal{A}, \quad \mathcal{I}\ne\{p, T\}$ | $p_{crit}$, $\mathcal{P}_\ell$ |
|                              | $\mathcal{I}\in\mathcal{A}_0$ | $p_{crit}$, $\mathcal{P}_\ell$, $\mathcal{P}_{0,\ell}$ |
|                              | $\mathcal{I}\in\mathcal{A}_{mix}$   | $p_{crit}$, $\mathcal{P}_\ell$, $\mathcal{P}_v$ |
|                              | $\mathcal{I}\in\mathcal{A}_{0,mix}$ | $p_{crit}$, $\mathcal{P}_\ell$, $\mathcal{P}_v$, $\mathcal{P}_{0,\ell}$, $\mathcal{P}_{0,v}$ |




# Fluid-Structure Interaction Module

- [System Documentation List](fsi/systems.md)

The Fluid-Structure Interaction Module is a library of simulation tools that solve
fluid and structure problems, wherein, their behavior is inter-dependent. This module
provides a simple approach for implementing even advanced capabilities:

- Plug-n-play design enables users to incorporate the relevant physics for specific and varied simulations
- Straight-forward procedure for adding new physics

This module currently is capable of simulating fluid-structure interaction behavior
using an acoustic formulation for the fluid. More information about this physics is
 available [here](/fsi_acoustics.md) and in [!cite](dhulipala2022acousticfsi).
Efforts are underway to add more capabilities such as Arbitrary Lagrangian Eulerian to this module.

## Explore the Capabilities

The +Fluid-Structure Interaction Module+ can be used in a variety of simulations
where the fluid and structural components are inter-dependent on each other. That is,
 the fluid behavior is affected by the structural behavior and vice-versa.

## Developing New Fluid-Structure Interaction Code

Consider becoming a developer yourself. Follow the MOOSE standards for [contributing code and documentation](MooseDocs/generate.md optional=True).

## auxkernels

### WaveHeightAuxKernel


#### Description

This auxkernel calculates the wave heights from fluid pressures. This is done as
follows:

\begin{equation}
    \label{eqn:Wave1}
    d_w = \frac{p}{\rho g}
\end{equation}

where, $p$ is the fluid pressure, $g$ is the acceleration due to gravity, $\rho$ is
the fluid density, and $d_w$ is the wave height.




## bcs

### Free surface fluid boundary condition


#### Description

The free surface fluid BC applies a mixed Dirichlet-Neumann condition to simulate
gravity waves. This condition is as follows:

\begin{equation}
    \label{eqn:Free1}
    \frac{\partial p}{\partial z} = -\alpha~\frac{\partial^2p}{\partial t^2}
\end{equation}

where, $p$ is the fluid pressure and $g$ is the acceleration due to gravity. This BC is part of the fluid-structure interaction codes. Please refer to [fluid-structure interaction using acoustics](/fsi_acoustics.md) for the theoretical details.




## interfacekernels

### ADPenaltyVelocityContinuity


This object is meant for use in coupling the Navier-Stokes fluid equations with
solid mechanics equations at a fluid-structure interface. In that context this
object imposes both continuity of stress and continuity of material velocity via
a penalty condition. For more information on the error of penalty methods,
please see [CoupledPenaltyInterfaceDiffusion.md].




### CoupledPenaltyInterfaceDiffusion

#### Description

This class ensures the continuity of flux of `variable` and `neighbor_var`
across an interface. Additionally, via a penalty factor,
`CoupledPenaltyInterfaceDiffusion` enforces the continuity of the value of
`secondary_coupled_var` and `primary_coupled_var`. The latter two parameters are
optional input file parameters; if they are not specified, then they default to
`neighbor_var` and `variable` respectively. Note that the penalty method (for
sufficiently high penalty parameter) displays optimal convergence rates (p + 1)
while strong enforcement of value continuity results in degradation of the
convergence rate. For a discussion of this phenomena, see
[this moose forum discussion](https://groups.google.com/forum/#!searchin/moose-users/yaqi$20alex%7Csort:date/moose-users/fi68gQRZl9g/n4Q1OzMRBAAJ).




### Structure-acoustic interface


#### Description

This interface kernel enforces displacement and pressure/stress continuity across
the fluid and structural domains. This interface kernel is part of the fluid-structure interaction codes. Please refer to [fluid-structure interaction using acoustics](/fsi_acoustics.md) for the theoretical details.

In this interface kernel, element is always the fluid and neighbor is always
 the structure. Furthermore, the normal vector always points from the fluid to
 the structure. This means, when defining the sideset using the `SideSetsBetweenSubdomainsGenerator` option in MOOSE meshing, `primary_block` should
  be the fluid and `paired_block` should be the structure. If sideset is defined
  using Paraview, use the `with respect to` option.




## kernels

### Acoustic inertia


#### Description

This kernel computes the residual contribution from the double time derivative of
the pressure term:

\begin{equation}
    \label{eqn:sample}
    \frac{1}{c_o^2} \frac{\partial^2 p}{\partial t^2}
\end{equation}

This kernel is similar to the [InertialForce](/InertialForce.md) kernel. Also, this kernel is part of the fluid-structure interaction codes. Please refer to [fluid-structure interaction using acoustics](/fsi_acoustics.md) for the theoretical details.

In [eqn:sample], the inverse of square of the fluid speed of sound is taken.
For water, in standard SI units (i.e., m, s, kg, and N), this value is of the order
$4\times 10^{-7}$ which is very small. If the fluid-structure interaction problem
is run in standard SI units, the presence of $\frac{1}{c_o^2}$ results in bad scaling
of the Jacobian matrices and hence poor convergence. To avoid this convergence issue,
it is recommended that Giga Newtons be used instead of Newtons, Giga kg be used instead of kg.




### ConvectedMesh


`ConvectedMesh` implements the corresponding weak form for the components of
the term:

\begin{equation}
\label{convection}
-\rho \left(\frac{\partial\vec{d_m}}{\partial t} \cdot \nabla\right) \vec{u}
\end{equation}

where $\rho$ is the density, $\vec{d_m}$ is the fluid mesh displacements, and
$\vec{u}$ is the fluid velocity. This term is essential for obtaining the
correct convective derivative of the fluid in cases where the fluid mesh is
dynamic, e.g. in simulations of fluid-structure interaction.




### ConvectedMeshPSPG


This object adds the pressure-stabilized Petrov-Galerkin term to the pressure
equation corresponding to the [ConvectedMesh.md] object. It implements the
weak form

\begin{equation}
\label{pspg}
\int \nabla \psi \cdot \left(\tau\frac{\partial\vec{d_m}}{\partial t}\cdot\nabla\vec{u}\right) dV
\end{equation}

where $\nabla \psi$ is the gradient of the pressure test function, $\tau$ is a
stabilization parameter computed automatically by the `navier_stokes` base class
`INSBase`, $\vec{d_m}$ is the fluid mesh displacements, and
$\vec{u}$ is the fluid velocity. Note that when comparing [pspg] with
[!eqref](ConvectedMesh.md#convection) that the minus sign and density $\rho$ have
disappeared. This is because the form of PSPG stabilization is

\begin{equation}
\int \nabla \psi \cdot \left(-\frac{\tau}{\rho}\vec{R}\right)
\end{equation}

where $\vec{R}$ denotes the strong form of the momentum residuals.




# Functional Expansion Tools

A MOOSE module for continuous, mesh-agnostic, high-fidelity, reduced-data MultiApp coupling

## Description

Functional expansions (FXs) are a methodology that represent information as moments of a functional
series [!citep](Flusser2016). This is related to a Fourier series representation of cyclic
data. Moments are generated via numerical integration for each term in the functional series to
represent the field of interest. These moments can then be used to reconstruct the field in a
separate app [!citep](Wendt2018a,Wendt2017c,Kerby2017).

Currently there are two main flavors of FX coupling available: interface and volumetric.

In other contexts FXs have been identified using the initialism 'FE'. However, since MOOSE is a
finite-element (FE) code, the initialism 'FX' is used throughout this module to prevent confusion.

This module should only be used with non-displaced meshes.

### Interface Coupling

Interface-based coupling provides for the coupling between physically distinct solutions that share a
common interface. FXs can be used to extract value and/or flux conditions at a boundary in one app,
then be transferred as boundary conditions to the coupled app. These coupled boundaries represent the
common interface between the two solutions.

### Volumetric Coupling

Volumetric-based coupling provides for coupling between solutions that share the same space with
coupled yet separate physics. The field in one app can be collapsed into an FX, then the moment
values are transferred to the other app to be used in its solution.

## Using this module

Set either `FUNCTIONAL_EXPANSION_TOOLS := yes` (or `ALL_MODULES := yes`) in the application
makefile. The following objects will then be available for use:

### AuxKernels

| Name | Description |
| - | - |
| [`FunctionSeriesToAux`](/FunctionSeriesToAux.md) | Expands an FX into the named +AuxVariable+ before the initial nonlinear solve. |


### BCs

| Name | Description |
| - | - |
| [`FXFluxBC`](/FXFluxBC.md) | Provides a *strongly encouraged* FX-based Neumann boundary condition. |
| [`FXValueBC`](/FXValueBC.md) | Provides a *fixed* FX-based Dirichlet boundary condition. |
| [`FXValuePenaltyBC`](/FXValuePenaltyBC.md) | Provides a *strongly encouraged* FX-based Dirichlet boundary condition. |


### Functions

| Name | Description |
| - | - |
| [`FunctionSeries`](/FunctionSeries.md) | The workhorse of the FX tools module. This evaluates the terms of a function series, used both for capturing moments and expanding an FX. All other FX-based objects will depend on a `FunctionSeries` instance. |


### Kernels

Although there are no kernels directly provided by this module (yet), these three from the framework itself have varying degrees of usefulness:

| Name | Description |
| - | - |
| [`BodyForce`](/BodyForce.md) | May be used to couple a `FunctionSeries` object directly to a solution, instead of using `FunctionSeriesToAux` and `CoupledForce`. If the `BodyForce` approach is used it is highly recommended to set `enable_cache = true` for the associated `FunctionSeries` object. |
| [`CoupledForce`](/CoupledForce.md) | Couples an +AuxVariable+ or +Variable+ to the solution of another +Variable+. Useful in conjunction with `FunctionSeriesToAux`.
| [`NullKernel`](/NullKernel.md) | May be required for use in situation where no +Variables+ or +Kernels+ are needed. This may occur, for example, in an app that uses only the recommended `FunctionSeriesToAux`+`CoupledForce` approach. |


### Transfers

| Name | Description |
| - | - |
| [`MultiAppFXTransfer`](/MultiAppFXTransfer.md) | This transfers the FX coefficients, or moments, between named FX objects in the multi and sub apps. Supported objects that contain coefficients for transferring are instances of `FunctionSeries` and any `FX...UserObject`. |


### UserObjects

| Name | Description |
| - | - |
| [`FXBoundaryFluxUserObject`](/FXBoundaryFluxUserObject.md) | Captures the moments of an FX representing the flux at a boundary. |
| [`FXBoundaryValueUserObject`](/FXBoundaryValueUserObject.md) | Captures the moments of an FX representing the value at a boundary. |
| [`FXVolumeUserObject`](/FXVolumeUserObject.md) | Captures the moments of an FX representing the field value over a volume. |

## Examples

Please refer to the [examples](/examples.md) included with the module for how these objects can be used.


## Supported Functional Series

This module currently supports FXs based on the 1D Legendre and 2D Zernike polynomial series. From
these can be constructed 1D, 2D, or 3D Cartesian basis sets (Legendre only), or 3D cylindrical
(Legendre + Zernike) basis sets. Nonseparable series, i.e. with fully-convolved cross terms, are used
in this implementation. Examples for selecting FXs are shown in
[`FunctionSeries`](/FunctionSeries.md).

Additional functional series, polynomial or otherwise, can be added by inheriting from the
`SingleSeriesBasisInterface` class (found in the `utils/` folder). The composite series (currently
the `Cartesian` and `CylindricalDuo` classes) will then need updated to support the newly-available
series.

Additional composite series, such as may be suitable for spherical or shell data, can be implemented
by inheriting from the `CompositeSeriesBasisInterface`. The `FunctionSeries` class will need updated
to support the newly-available series.


## Caveats

1. FXs are not recommended for spanning spaces with discontinuities [!citep](Ellis2017b).
   - One example would be a space containing two distinct materials with significantly different properties
   - Instead, using multiple FXs, each over its own region of continuity, is the recommended approach
2. Increasing the order of an FX does not always result in an improved representation. Numerical integration of the FX moment can yield large errors if not enough quadrature points are included [!citep](Griesheimer2005a).


## TODO

- Investigate the implementation of using `NearestPointBase` approach to easily equip multiple FXs
- Implement a +Materials+-derived FX-based class that can provide continuous material properties
- Implement a +Kernel+-derived class, a la `BodyForce`, that automatically sets `enable_cache = true` for the associated `FunctionSeries` object
- Add an error check in `MultiAppFXTransfer` for multiple objects of the same name but different type, i.e. if there are both a +Function+ and +UserObject+ with the same name (or other object types as they are added)
- Implement support in `MutableCoefficientsInterface` for multiple sets of FX coefficients
- Implement support for various types of FX derivations
  - Separable series
  - Various orthonormalizations
- Add more functional series
  - Fourier
  - Annular Zernike (0 < r <= 1)
  - Shell (r = 1) for 3D cylindrical boundary conditions (Zernike-based?)
  - Spherical harmonics + spherical composite series
- Add check to ensure we are working in an undisplaced mesh context

## Objects, Actions, and Syntax


## auxkernels

### Function Series to Aux


#### Description

This `AuxKernel` expands an FX into the named `AuxVariable` before the initial nonlinear solve. It subclasses `FunctionAux` to perform the actual work. The only differences in `FunctionSeriesToAux` are:
1) it ensures that the provided `Function` is a subclass of `FunctionSeries`
2) it ensures that it is executed at `EXEC_TIMESTEP_BEGIN`

#### Example Input File Syntax





## bcs

### FXFluxBC


#### Description

This `BC` provides a *strongly encouraged* FE-based Neumann boundary condition. It subclasses
`FunctionNeumannBC` to perform the actual work. The only differences in `FXFluxBC` are:

1. it ensures that the provided `Function` is a subclass of `FunctionSeries`
2. it configures the provided `FunctionSeries` to use memoization (caching) for FX evaluations to
   improve performance

#### Example Input File Syntax





### FX Value BC


#### Description

This `BC` provides *fixed* FE-based Dirichlet boundary condition. It subclasses `FunctionDirichletBC` to perform the actual work. The only differences in `FXValueBC` are:
1) it ensures that the provided `Function` is a subclass of `FunctionSeries`
2) it configures the provided `FunctionSeries` to use memoization (caching) for FX evaluations to improve performance

#### Example Input File Syntax





### FX Value Penalty BC


#### Description

This `BC` provides *strongly encouraged* FE-based Dirichlet boundary condition. It subclasses `FunctionPenaltyDirichletBC` to perform the actual work. The only differences in `FXValuePenaltyBC` are:
1) it ensures that the provided `Function` is a subclass of `FunctionSeries`
2) it configures the provided `FunctionSeries` to use memoization (caching) for FX evaluations to improve performance




## functions

### Function Series


#### Description

This `Function` is the workhorse of the Functional Expansion Tools module. It
bridges the gap between the functional series and the associated
coefficients. For example, it provides access to the orthonormalized function
series that the `UserObject` classes need to evaluate a functional expansion. It
also provides the standard function series that are required to couple FXs to
the solvers (`AuxKernels`, `BCs`, etc...). As such, it is configured with
correlation parameters. These includes physical boundaries, series types, and
series' orders.

The coefficients are provided through implementing `MutableCoefficientsFunctionInterface`, and the function series are provided by composition (member variable) via `CompositeSeriesBasisInterface`.

There are `generation_type` and `expansion_type` parameters provided by `FunctionSeries`
that are passed on to the single series (`Zernike`, `Legendre`, ...). The
aforementioned parameters are `MooseEnum`s with (at the time of writing)
possible values of `orthonormal`, `standard`, and `sqrt_mu`. If the user does
not make any specification in the input file, then `generation_type` defaults to
`orthonormal` and `expansion_type` defaults to `standard`. Note that the
combination of generation and expansion must together apply the square of the
orthonormalization coefficient (see the work of David Griesheimer for more
detail).   `sqrt_mu` series generation/expansion
applies the orthonormalization constant. `orthonormal` series
generation/expansion applies the square of the
orthonormalization constant.  `standard` series generation/expansion
does not apply any factor. Consequently, valid combinations include: 1)
`orthonormal` for generation and `standard` for expansion (the default), 2)
`sqrt_mu` for both generation and expansion, and 3) `standard` for generation
and `orthonormal` for expansion. We suggest that users stick with the defaults
unless coupling with external codes that require different normalizations.


#### Example Input File Syntax








## transfers

### MultiApp FX Transfer


#### Description

This `Transfer` transfers the coefficients from an FX-generating object (such as the `FX...UserObject`s) to a FX-utilizing object (such as a `FunctionSeries`). It leverages `MutableCoefficientsInterface`, from which all of these objects must subclass, to perform the transfers.

It searches the associated `MultiApp` objects for the named objects to perform the transfers. It also ensures that each is a subclass of `MutableCoefficientsInterface`.

#### Example Input File Syntax





## userobjects

### FX Boundary Flux UserObject


#### Description

This `UserObject` captures the moments of an FX representing the flux at a boundary. It does this via subclassing the templated `FXIntegralBaseUserObject` with `SideIntegralVariableUserObject` as the policy parameter. It also requires a diffusivity parameter, which can either be a constant value or the name of a material property.

`FXIntegralBaseUserObject` also ensures that the provided `Function` is a subclass of `FunctionSeries`.

#### Example Input File Syntax





### FX Boundary Value UserObject


#### Description

This `UserObject` captures the moments of an FX representing the value at a boundary. It does this via subclassing the templated `FXIntegralBaseUserObject` with `SideIntegralVariableUserObject` as the policy parameter.

`FXIntegralBaseUserObject` also ensures that the provided `Function` is a subclass of `FunctionSeries`.

#### Example Input File Syntax





### FX Volume UserObject


#### Description

This `UserObject` captures the moments of an FX representing the field value over a volume. It does this via subclassing the templated `FXIntegralBaseUserObject` with `ElementIntegralVariableUserObject` as the policy parameter.

`FXIntegralBaseUserObject` also ensures that the provided `Function` is a subclass of `FunctionSeries`.

#### Example Input File Syntax





# The geochemistry module

## Overview

The geochemistry module is designed to solve geochemical models.  The capabilities include:

- equilibrium aqueous systems
- redox disequilibrium
- sorption and surface complexation
- kinetics
- all these combined with fluid and heat transport

The geochemistry module is designed to interface easily with the porous-flow module so that complicated reactive transport scenarios can be studied.


## Details

- [Theory, numerical solution technique and computational aspects](geochemistry/theory/index.md)
- [Examples](geochemistry/tests_and_examples/index.md)
- [Simulating biogeochemistry](theory/biogeochemistry.md)
- [Description of input-file objects](geochemistry/systems.md)
- [A to Z index of these webpages](geochemistry/contents.md)

## Installation and usage

After installing MOOSE using the "Getting Started" instructions (above), only the "framework" will have been compiled.  To compile any of the physics modules, including the geochemistry module, use the following instructions run from the command line:

```bash
cd ~/projects/moose/modules
make
cd ~/projects/moose/modules/geochemistry
make
cd ~/projects/moose/modules/geochemistry/unit
make
```

(If your computer has $N$ cores, the `make` process may be sped up by using the command `make -j`$N$ instead of simply `make`.)

Check that the geochemistry module is correctly compiled using the following instructions:

```bash
cd ~/projects/moose/modules/geochemistry/unit
./run_tests
cd ~/projects/moose/modules/geochemistry
./run_tests
```

Virtually all the tests should run and pass.  Some may be "skipped" due to a particular computer setup (for instance, not enough threads).  (If your computer has $N$ cores, the `run_tests` command may be sped up by using the command `./run_tests -j`$N$ instead of simply `./run_tests`.)

The geochemistry executable is called `geochemistry-opt` and is found at `~/projects/moose/modules/geochemistry`.  This may be used to run pure geochemistry simulations.  For example, to run the [cooling a solution in contact with feldspars example](tests_and_examples/cooling_feldspar.md):

```bash
cd ~/projects/moose/modules/geochemistry/test/tests/time_dependent_reactions
../../../geochemistry-opt -i cooling.i
```

For coupled reactive-transport simulations using the PorousFlow module, the `combined-opt` executable must be used.  For example, to run the [Weber-Tensleep GeoTES example](tests_and_examples/geotes_weber_tensleep.md) from the command line:

```bash
cd ~/projects/moose/modules/combined/examples/geochem-porous_flow/geotes_weber_tensleep
../../../combined-opt -i exchanger.i
```

## actions

### AddGeochemicalModelInterrogatorAction

This is an Action to add a [GeochemicalModelInterrogator](GeochemicalModelInterrogator.md) object

### AddSpatialReactionSolverAction

This is an Action to add a [GeochemistrySpatialReactor](GeochemistrySpatialReactor.md) userobject along with [GeochemistryQuantityAux](GeochemistryQuantityAux.md) aux kernels and a [GeochemistryConsoleOutput](GeochemistryConsoleOutput.md) output.

Please see the [SpatialReactionSolver page](SpatialReactionSolver/index.md) for examples.


### AddTimeDependentReactionSolverAction

This is an Action to add a [GeochemistryTimeDependentReactor](GeochemistryTimeDependentReactor.md) userobject along with [GeochemistryQuantityAux](GeochemistryQuantityAux.md) aux kernels and a [GeochemistryConsoleOutput](GeochemistryConsoleOutput.md) output.


### AddTimeIndependentReactionSolverAction

This is an Action to add a [GeochemistryTimeIndependentReactor](GeochemistryTimeIndependentReactor.md) userobject along with [GeochemistryQuantityAux](GeochemistryQuantityAux.md) aux kernels and a [GeochemistryConsoleOutput](GeochemistryConsoleOutput.md) output.


## auxkernels

### GeochemistryQuantityAux

This AuxKernel is used to extract information from the GeochemistryReactor that underlies `geochemistry` models.

A large number of AuxVariables and GeochemistryQuantityAux Kernels are often added automatically using the `geochemistry` actions, for instance [TimeDependentReactionSolver](TimeDependentReactionSolver/index.md).  However, if users wish to add their own manually, an example (that adds an AuxVariable to measure pH) is






### NodalVoidVolumeAux

This AuxKernel extracts the void volume, $V_{i}$, associated with each node $i$ from a [NodalVoidVolume](NodalVoidVolume.md) UserObject.  Its `variable` must therefore be a nodal variable (not a monomial, for instance).

$V_{i}$ is allows translation between moles of reactant at a node, $M_{i}$, and concentration (mol/volume-of-solute) at the node:
\begin{equation}
\mathrm{concentration}_{i} = \frac{M_{i}}{V_{i}} \ .
\end{equation}





## kernels

### GeochemistryDispersion

This Kernel implements the PDE fragment
\begin{equation}
\nabla(\phi D\nabla c) \ ,
\end{equation}
which is part of the [transport](theory/index.md) equations.  Here

- $\phi$ is the porosity, which may be a fixed real number or may be an `AuxVariable` that is spatially-dependent
- $D$ is the hydrodynamic dispersion tensor (called `tensor_coeff` in the input file)
- $c$ is the concentration (mol/m$^{3}$(aqueous solution)) of an aqueous species
- $\nabla$ denotes the vector of spatial derivatives





### GeochemistryTimeDerivative

This Kernel implements the PDE fragment
\begin{equation}
\phi \frac{\partial c}{\partial t} \ ,
\end{equation}
which is part of the [transport](theory/index.md) equations.  Here

- $\phi$ is the porosity, which may be a fixed real number or may be an `AuxVariable` that is spatially-dependent
- $c$ is the concentration (mol/m$^{3}$(aqueous solution)) of an aqueous species
- $t$ is time

Two notable features of this Kernel are:

- it should not be used for cases were porosity is time-dependent (in this case $\phi$ should be inside the time derivative);
- mass lumping to the nodes is used in order to reduce the possibility that concentration becomes negative.





## outputs

### GeochemicalModelInterrogator

Usually this Output is added using the [GeochemicalModelInterrogator action](GeochemicalModelInterrogator/index.md).  The purpose of this Output is to output [balanced reactions and equilibrium constants](reaction_balancing.md), [activity ratios](activity_ratios.md), [equilibrium temperature](eqm_temp_a.md), etc, depending on the `interrogation` option.  If a invalid swap is defined through the `swap_into_basis` and `swap_out_of_basis` options, the simulation will exit with an explanatory error message.

An example of outputting equilibrium reactions (`interrogation = reaction`) for different choices of basis components is


An example of outputting activity ratios/products (`interrogation = activity`) is


An example of computing temperature (`interrogation = eqm_temperature`) at equilibrium is


An example of outputting pH and pe (`interrogation = activity`) at equilibrium is






### GeochemistryConsoleOutput

This Output writes information to the console regarding the geochemical system (defined by the `geochemistry_reactor`) at a particular `point` that is defined by a [NearestNodeNumber UserObject](NearestNodeNumberUO.md).  It is quite verbose since it provides information about molalities, free masses, bulk compositions, surface characteristics and Nernst information for all relevant species, as well as descriptive characteristics such as temperature, pH, and ionic strength.  It should therefore be used with caution otherwise your std::out will rapidly fill up, but it is useful for understanding and debugging models.

Usually this Output is added using Actions such as the [TimeIndependentReactionSolver](TimeIndependentReactionSolver/index.md) and the [TimeDependentReactionSolver](TimeDependentReactionSolver/index.md).

Advanced users may wish to add these objects manually to their input files.  Here is an example:





## userobjects

### GeochemicalModelDefinition

Defines the geochemical system.  This extracts information from the geochemistry database and stores information pertinent to the model in computationally-efficient data structures, eliminating all extraneous information.

All `geochemistry` models must contain a `GeochemicalModelDefinition` userobject

This userobject extensively uses `utils/PertinentGeochemicalSystem`, and it is useful to fully discuss the input parameters of this class.

#### basis_species

This is a list of [basis components](basis.md) relevant to the [aqueous equilibrium problem](equilibrium.md).  The following requirements must be satisfied (otherwise a mooseError is produced and the simulation stops):

- "H2O" must appear first in this list;
- No member must appear more than once in this list;
- These components must be chosen from the "basis species" in the [database](geochemistry/database/index.md), the [sorbing sites](equilibrium.md) (if any) and the decoupled redox states that are in [disequilibrium](basis.md) (if any).

Any [redox pair](basis.md) that is not in this list or the [`kinetic_redox`](theory/index.md) list, will be assumed to be at equilibrium with the aqueous solution and will be considered a [secondary species](basis.md).

All these species, except H2O, may be later swapped out of this list, either by a manual user-prescribed [swap](swap.md) (and replaced by a mineral or a gas of fixed fugacity, for instance), or during the numerical solve.  For simple examples of this swap, see [GeochemicalModelInterrogator](GeochemicalModelInterrogator.md)

#### minerals

This list contains the minerals that are in equilibrium with the aqueous solution.  Conditions on the members of this list are:

- They must be "minerals" in the [database](geochemistry/database/index.md);
- No member can appear more than once in this list;
- Their [equilibrium reaction](equilibrium.md) must consist of only the `basis_species`, and [secondary species](basis.md) and non-kinetically-controlled [redox couples](basis.md) that can be expressed in terms of the basis_species;
- If they are also "sorbing minerals" in the database then their [sorption sites](equilibrium.md) must consist of the basis_species only.

During simulation, the user can compute the [saturation index](geochemistry_nomenclature.md) of these minerals.

These minerals can be [swapped](swap.md) into the basis if desired (or required during the numerical solve).  For simple examples of this swap, see [GeochemicalModelInterrogator](GeochemicalModelInterrogator.md).  If the user performs a manual "swap" then an initial condition must be provided for the mineral.

The user chooses whether these minerals are allowed to precipitate or not --- that is, they can be "suppressed".

This list, along with the kinetic_minerals list, comprises the entire list of minerals in the problem: all others are eliminated from consideration.

#### gases

This is a list of [gases](basis.md) that are in equilibrium with the aqueous solution and can have
their [fugacities](fugacity.md) fixed, at least at some time and spatial location.

- All members of this list must be a "gas" in the [database file](geochemistry/database/index.md).
- No gas must appear more than once in this list.
- The equilibrium reaction of each gas must involve only the basis_species, or secondary species or non-kinetically-controlled redox couples that can be expressed in terms of the basis_species.

This list comprises all the gases that are in the simulation: all others are eliminated.

#### kinetic_minerals

This is a list of minerals that whose dynamics are governed by a [rate law](theory/index.md).  These are not in equilibrium with the aqueous solution.

- The list can only include the "minerals" in the [database file](geochemistry/database/index.md).
- No member can appear more than once in this list.
- The [equilibrium reaction](equilibrium.md) of each mineral must involve only the basis_species, or secondary species or non-kinetically-controlled redox couples that can be expressed in terms of the basis_species.
- If a mineral is also a "sorbing mineral" in the [database](geochemistry/database/index.md) then their [sorption sites](equilibrium.md) must consist of the basis_speices only.
- No members of this list must be in the minerals list.

These minerals can never be [swapped](swap.md) into the basis, nor can they be "suppressed".


#### kinetic_redox

This is a list of [redox pairs](basis.md) that whose dynamics are governed by a [rate law](theory/index.md).  These are not in equilibrium with the aqueous solution.

- The list can only include the "redox couples" in the [database file](geochemistry/database/index.md).
- No member can appear more than once in this list.
- The [equilibrium reaction](equilibrium.md) of each member must involve only the basis_species, or secondary species or non-kinetically-controlled redox couples that can be expressed in terms of the basis_species.
- No members of this list must be in the basis_species list.

These species can never be [swapped](swap.md) into the basis.

#### kinetic_surface_species

This is a list of [surface sorbing species](basis.md) that whose dynamics are governed by a [rate law](theory/index.md).  These are not in equilibrium with the aqueous solution.

- The list can only include the "surface species" in the [database file](geochemistry/database/index.md).
- No member can appear more than once in this list.
- The [equilibrium reaction](equilibrium.md) of each member must involve only the basis_species, or secondary species or non-kinetically-controlled redox couples that can be expressed in terms of the basis_species.

These species can never be [swapped](swap.md) into the basis.

#### kinetic_rate_descriptions

A list of [GeochemistryKineticRate](GeochemistryKineticRate.md) user objects that define the kinetic rates for the kinetic species should be supplied.  If a kinetic species has no rate prescribed then its reaction rate will be zero.  Multiple [GeochemistryKineticRate](GeochemistryKineticRate.md) user objects can apply to a single kinetic species: in this case the sum of all the rates defines the overall reaction rate for the kinetic species.

#### Secondary species

The complete list of [secondary species](equilibrium.md) is automatically computed based on the above information using the following algorithm:

1. All "redox couples" in the [database](geochemistry/database/index.md) are queried one-by-one, and included if:

- they are not part of the `kinetic_redox` list; and
- they are not part of the `basis_species` list; and
- their reaction involves only basis_species or secondary species already encountered.  This means redox couples whose reactions involve already-encountered redox couples can be included in the secondary species' list.

2. All secondary species in the [database](geochemistry/database/index.md) are queried one-by-one, and included if:

- their reaction involves basis_species, or secondary species already encountered.

3. All surface species in the [database](geochemistry/database/index.md) are queried one-by-one, and included if:

- they are not in the kinetic_surface_species list; and
- their reaction involves only basis_species or secondary species encountered so far

The resulting list contains only species whose equilibrium reactions can ultimately be expressed in terms of basis species.  Once this list is created, the equilibrium reactions for the minerals, gases, kinetic_redox and kinetic_surface_species can also be checked that they can be ultimately expressed in terms of basis species as specified above in the conditions "the [equilibrium reaction](equilibrium.md) of each member must involve only the basis_species, or secondary species or non-kinetically-controlled redox couples that can be expressed in terms of the basis_species."

#### Creating the pertinent model

All the aforementioned species are included in the "pertinent model" created by this class, including their names, charges, molecular weights, ionic radii, molecular volumes, stoichiometric coefficients and equilibrium constants.

#### Executing

All computations in this Userobject are performed in its constructor during initial setup.  During simulation, this Userobject does nothing.

#### Example

An example that simply outputs equilibrium reactions involving the clinoptilolite mineral is:









### GeochemistryKineticRate

This `UserObject` defines a kinetic rate for a kinetic species.  Usually the reaction for a kinetic species $A_{\bar{k}}$ is written:
\begin{equation}
\label{gen_kin_react_eqn}
A_{\bar{k}} \rightleftharpoons \nu_{w\bar{k}}A_{w} + \sum_{i}\nu_{i\bar{k}}A_{i} + \sum_{k}\nu_{k\bar{k}}A_{k} + \sum_{m}\nu_{m\bar{k}}A_{m} + \nu_{p\bar{k}}A_{p} \ ,
\end{equation}
with equilibrium constant $K_{\bar{k}}$, and reaction rate $r$.  Further information can be found on the [theory](geochemistry/theory/index.md) page.

The general form of the rate is
\begin{equation}
r = kA[M] \frac{\tilde{m}^{\tilde{P}}}{(\tilde{m}^{\tilde{P}} + \tilde{K}^{\tilde{P}})^{\tilde{\beta}}}\left( \prod_{\alpha}\frac{m_{\alpha}^{P_{\alpha}}}{(m_{\alpha}^{P_{\alpha}} + K_{\alpha}^{P_{\alpha}})^{\beta_{\alpha}}} \right) \left|1 - \left(Q/K\right)^{\theta}\right|^{\eta} \exp\left( \frac{E_{a}}{R} \left(\frac{1}{T_{0}} - \frac{1}{T}\right)\right) D(Q/K) \ .
\end{equation}
This is a rather complicated equation, and simple examples are given below.  In this equation:

- $r$ (units: mol.s$^{-1}$) is the rate of the kinetic reaction.  If it is positive then the kinetic species' mass will be decreasing (eg, dissolution).  If it is negative then the kinetic species' mass will be increasing (eg, precipitation).
- $k$ is the intrinsic rate constant, which is positive (except in the `raw` and `death` cases mentioned below).  The product $kA[M]$ has units mol.s$^{-1}$ (assuming the simulation's time units are seconds).  Note that mole units are used, even if the initial amount of the kinetic species is given in mass or volume units.  Examples of $k$ are given below.
- $A$ is either the surface area (units: m$^{2}$) for the kinetic species, or the specific surface area (units: m$^{2}$.g$^{-1}$)
- $[M]$ (units: g) is the mass of the kinetic species.  It is optional (hence the square brackets).  Examples are given below.
- $\tilde{m}$ (units: mol.kg$^{-1}$) is the molality of the kinetic species.  Hence $\tilde{m}^{\tilde{P}}/(\tilde{m}^{\tilde{P}} + \tilde{K}^{\tilde{P}})^{\tilde{\beta}}$ is a monod form, where $\tilde{P}$ and $\tilde{\beta}$ are dimensionless parameters, and $\tilde{K}$ is a half saturation (units: mol.kg$^{-1}$).  This factor is optional, and may be omitted by ensuring $\tilde{P} = 0 = \tilde{\beta}$.
- $\alpha$ is a label denoting a promoting species
- $m_{\alpha}$ is either: mass of solvent water (in kg) if the promoting species is H$_{2}$O; fugacity of a gas if the promoting species is a gas; activity if the promoting species is either H$^{+}$ or OH$^{-}$; mobility, otherwise.
- $P_{\alpha}$ is a dimensionless power
- $\beta_{\alpha}$ is a dimensionless power.  The denominator of monod form, $(m_{\alpha}^{P_{\alpha}} + K^{P_{\alpha}})^{\beta_{\alpha}}$, may be omitted by simply setting $\beta_{\alpha} = 0$.
- $K_{\alpha}$ (units: mol.kg$^{-1}$) is a half-saturation constant.
- $Q$ is the [activity product](geochemistry_nomenclature.md) defined by the kinetic species' reaction in the database file
- $K$ is the reaction's equilibrium constant defined in the database file.  This may be modified if the `GeochemistryKineticRate` object is used to model biologically-catalysed reactions.  When a microbe catalyses one mole of the reaction, it captures $E_{c}$ Joules of energy (units: J).  This means $K = K_{\mathrm{database}}\exp( - E_{c}/(RT))$.
- $\theta$ and $\eta$ are dimensionless exponents.  If $\eta = 0$ then $\left|1 - \left(Q/K\right)^{\theta}\right|^{\eta} = 1$ irrespective of the value of $Q$, $K$ and $\theta$.
- $E_{a}$ (units: J.mol$^{-1}$) is the activation energy
- $R=8.314472\,$J.K$^{-1}$.mol$^{-1}$ is the gas constant
- $T_{0}$ (units: K) is a reference temperature
- $T$ (units: K) is the temperature
- $D(Q/K)$ is the "direction" of this reaction.  Recall that $r$ is a dissolution rate, so if $r>0$ then the kinetic mass will decrease with time.  The following choices for $D$ are available.

  - `both`: if $Q>K$ then $D=-1$ (so the kinetic species mass will increase with time), if $Q \leq K$ then $D=1$ (so the kinetic species mass will decrease with time).  This means both dissolution and precipitation are modelled, and which one occurs depends on the size of $Q$ relative to $K$.
  - `dissolution`: if $Q>K$ then $D=0$, while if $Q \leq K$ then $D=1$.  This means that precipitation is prevented, while only dissolution (with $r>0$) occurs
  - `precipitation`: if $Q>K$ then $D=-1$, while if $Q \leq K$ then $D=0$.  This means that precipitation (with $r<0$) occurs, but dissolution is prevented
  - `raw`: $D=1$ irrespective of $Q$ and $K$.  This means dissolution will occur if $k>0$, while precipitation will occur if $k<0$.
  - `death`: $D=1$ irrespective of $Q$ and $K$.  This means dissolution will occur if $k>0$, while precipitation will occur if $k<0$.  In addition, no reactants will be consumed or produced by the kinetic reaction: only the mass of the kinetic species will change.  This is used to model the death of microbes in biologically-catalysed scenarios.
  

In addition, there are auxiliary inputs that do not impact the rate directly, but impact the resulting products:

- `non_kinetic_biological_catalyst` is a primary or secondary species that may be created or destroyed in addition to the reactants and products in the kinetic reaction [gen_kin_react_eqn].  This is usually a biological species, hence the name "biological catalyst".  An example is the [sulfate reducer](bio_sulfate.md) model.
- `non_kinetic_biological_efficiency` is the number of moles of the `non_kinetic_biological_catalyst` that are created per mole of [gen_kin_react_eqn] reaction turnover
- `kinetic_biological_efficiency`: when one mole of the reaction [gen_kin_react_eqn] occurs then `kinetic_biological_efficiency` moles of $A_{\bar{k}}$ is *created*.  Obviously, this defaults to $-1$, but for [biogeochemical](theory/biogeochemistry.md) models, where $A_{\bar{k}}$ represents a microbe population that is catalysing a reaction, a positive value may be appropriate.  Examples are the [sulfate reducer](bio_sulfate.md), the [arsenate reducer](bio_arsenate.md) and the [aquifer zoning](bio_zoning.md) models.


Note that more than one `GeochemistryKineticRate` can be prescribed to a single kinetic species.  The sum of all the individual rates defines the overall rate for each species (see Example 6).  Simply supply your [GeochemicalModelDefinition](GeochemicalModelDefinition.md) with a list of all the rates.

#### Example 1

Suppose that the kinetic rate is just a constant:
\begin{equation}
r = k
\end{equation}
for both the forward and backward reactions (ie, for precipitation and dissolution).  Then set:

- $k$ to the constant value, with units mol.s$^{-1}$ (assuming the simulation time is measured in seconds)
- $A=1$ and `multiply_by_mass = false`
- do not use any `promoting_species_names` or `promoting_indices` or `promoting_monod_indices`
- ensure `kinetic_molal_index` and `kinetic_monod_index` are both zero
- set $\theta = 0$ and $\eta = 0$
- set $E_{a} = 0$ and $E_{c} = 0$
- set `direction = both`

#### Example 2

Suppose that the kinetic rate for a certain mineral is proportional the mineral's surface area
\begin{equation}
r = kA
\end{equation}
and that the surface area is known and fixed.  Then set:

- $k$ to the coefficient of proportionality, with units mol.m$^{-2}$.s$^{-1}$ (assuming the simulation time is measured in seconds)
- $A$ to the known mineral surface area, with units m$^{2}$
- `multiply_by_mass = false`
- do not use any `promoting_species_names` or `promoting_indices` or `promoting_monod_indices`
- ensure `kinetic_molal_index` and `kinetic_monod_index` are both zero
- set $\theta = 0$ and $\eta = 0$
- set $E_{a} = 0$ and $E_{c} = 0$
- set `direction = both`

#### Example 3

Suppose that the kinetic rate for a certain mineral is proportional the mineral's free mass
\begin{equation}
r = kM
\end{equation}
Then set

- $k$ to the coefficient of proportionality, with units mol.g$^{-1}$.s$^{-1}$ (assuming the simulation time is measured in seconds)
- $A = 1$
- `multiply_by_mass = true`.  MOOSE will automatically calculate the mineral's free mass depending on its molar mass and the number of free moles.
- do not use any `promoting_species_names` or `promoting_indices` or `promoting_monod_indices`
- ensure `kinetic_molal_index` and `kinetic_monod_index` are both zero
- set $\theta = 0$ and $\eta = 0$
- set $E_{a} = 0$ and $E_{c} = 0$
- set `direction = both`


#### Example 4

Suppose that the kinetic rate for a certain mineral is proportional the mineral surface area
\begin{equation}
r = kA \ ,
\end{equation}
but that the surface area itself isn't known.  Only the mineral's specific surface area (surface area per gram of free mineral m$^{2}$.g$^{-1}$) is known.  Then set

- $k$ to the coefficient of proportionality, with units mol.m$^{-2}$.s$^{-1}$ (assuming the simulation time is measured in seconds)
- $A$ to be the mineral specific surface area, with units m$^{2}$.g$^{-1}$.
- `multiply_by_mass = true`.  MOOSE will automatically calculate the mineral's free mass depending on its molar mass and the number of free moles.
- do not use any `promoting_species_names` or `promoting_indices` or `promoting_monod_indices`
- ensure `kinetic_molal_index` and `kinetic_monod_index` are both zero
- set $\theta = 0$ and $\eta = 0$
- set $E_{a} = 0$ and $E_{c} = 0$
- set `direction = both`

#### Example 5

Suppose that the kinetic rate for a certain redox couple is proportional the quantity of solvent water present:
\begin{equation}
r = kn_{w} \ ,
\end{equation}
Then set

- $k$ to the coefficient of proportionality, with units mol.kg$^{-1}$.s$^{-1}$ (assuming the simulation time is measured in seconds)
- $A = 1$ and `multiply_by_mass = false`.
- `promoting_species_names = H2O` and `promoting_indices = 1` and `promoting_monod_indices = 0`
- ensure `kinetic_molal_index` and `kinetic_monod_index` are both zero
- set $\theta = 0$ and $\eta = 0$
- set $E_{a} = 0$ and $E_{c} = 0$
- set `direction = both`


#### Example 6

Suppose that the kinetic rate for a certain redox couple depends on the pH:
\begin{equation}
r = k_{\mathrm{acid}} a_{H^{+}} + k_{\mathrm{base}} a_{OH^{-}}^{1.5}  \ .
\end{equation}
For this, two `GeochemistryKineticRate` UserObjects must be created.  Each has $A=1$, `multiply_by_mass = false`, $\theta = 0$, $\eta = 0$, $E_{a}=0$, $E_{c} = 0$, `direction = both` and zero `kinetic_molal_index` and zero `kinetic_monod_index`.

- The first has $k = k_{\mathrm{acid}}$, `promoting_species_names = H+` and `promoting_species_indices = 1` and `promoting_monod_indices = 0`.
- The second has $k = k_{\mathrm{base}}$, `promoting_species_names = OH-` and `promoting_species_indices = 1.5` and `promoting_monod_indices = 0`.

These are then supplied to the [GeochemicalModelDefinition](GeochemicalModelDefinition.md) using its `kinetic_rate_descriptions` input.


#### Example 7

Suppose that the kinetic rate for a certain redox couple depends on the pH, the molality of Ca$^{2+}$ via a monod expression, and the temperature:
\begin{equation}
r = k_{\mathrm{acid}} a_{H^{+}}^{1.5} \frac{m_{Ca++}^{0.3}}{(m_{Ca++}^{0.3} + K_{Ca++}^{0.3})^{2}}\exp(E_{a}/(RT)) \ .
\end{equation}
Then set

- $k = k_{\mathrm{acid}}$
- $A= 1$ and `multiply_by_mass = false`
- promoting_species_names = "H+ Ca++" and promoting_indices = "1.5 0.3" and promoting_monod_indices = "0 2"
- $K_{Ca++}$ appropriately
- $\theta = 0$ and $\eta = 0$
- $E_{a}$ appropriately
- `one_over_T0 = 0`
- $E_{c} = 0$
- `direction = both`

#### Example 8

Suppose that a microbe is subject to mortality only, and no reaction products are produced:
\begin{equation}
r = k \times \mathrm{mass} \mathrm{\ \ \ (with\ no\ reaction\ products)} \ .
\end{equation}
Then set

- `intrinsic_rate_constant = k`
- `multiply_by_mass = true`
- $\eta = 0$
- `direction = death`

An example where this is used is the [aquifer zoning](bio_zoning.md) model.

#### Example 9

Suppose that a microbe catalyses a reaction at rate
\begin{equation}
\label{eqn.microbe,monod}
r = kM \frac{m_{A}}{(m_{A} + K_{A})^{2}} \left(1 - \left(\frac{Q \exp(45000/RT)}{K} \right)^{1/5} \right) \ .
\end{equation}
Here $A$ is a basis or secondary equilibrium species.
Then set

- `intrinsic_rate_constant = k`
- `multiply_by_mass = true`
- `promoting_species_names = A`, `promoting_indices = 1`, `promoting_monod_indices = 2`, `promoting_half_saturation = KA`
- `theta = 0.2`
- `eta = 1`
- `energy_captured = 45000`

If, in addition, the 2 moles of microbe are created per 1 mole of reaction turnover, then

- `kinetic_biological_efficiency = 2`

This is similar to the [sulfate reducer](bio_sulfate.md) model.





### GeochemistrySpatialReactor

This UserObject is usually added via a [SpatialReactionSolver](SpatialReactionSolver/index.md) Action: please see that page for many examples.  This UserObject's purpose is to solve a time-and-space dependent geochemical system.

Advanced users may also add `GeochemistrySpatialReactor` objects manually to their input files





### GeochemistryTimeDependentReactor

This UserObject is usually added via a [TimeDependentReactionSolver](TimeDependentReactionSolver/index.md) Action: please see that page for many examples.  This UserObject's purpose is to solve a time-dependent geochemical system.

Advanced users may wish to add `GeochemistryTimeDependentReactor` objects manually to their input files.  Here is an example of that:






### GeochemistryTimeIndependentReactor

This UserObject is usually added via a [TimeIndependentReactionSolver](TimeIndependentReactionSolver/index.md) Action: please see that page for many examples.  This UserObject's purpose is to solve a time-independent geochemical system.

Advanced users may wish to add `GeochemistryTimeIndependentReactor` objects manually to their input files.  Here is an example of that:






### NodalVoidVolume

This UserObject computes the void volume associated with each node $i$, which is
\begin{equation}
V_{i} = \int_{V}\phi \ ,
\end{equation}
where:

- $\phi$ is the porosity
- $V$ is the volume surrounding a node

In finite-element language, this is
\begin{equation}
V_{i} = \int_{\mathrm{elements}} \psi_{i}\phi \ ,
\end{equation}
where $\psi_{i}$ is the shape function for node $i$, and the integral is over all elements attached to the node.

$V_{i}$ is allows translation between moles of reactant at a node, $M_{i}$, and concentration (mol/volume-of-solute) at the node:
\begin{equation}
\mathrm{concentration}_{i} = \frac{M_{i}}{V_{i}} \ .
\end{equation}

$V_{i}$ may be recorded into an AuxVariable using [NodalVoidVolumeAux](NodalVoidVolumeAux.md).





# Heat Transfer Module

Heat is transferred by three mechanisms: conduction, convection, and radiation.
The heat transfer module provides various implementations of the heat conduction
equation, as well as associated boundary/interface conditions, including radiation
between opaque, gray, diffuse surfaces and provisions to couple temperature fields to
fluid domains through boundary conditions.

## Tutorial Problems

A [tutorial](modules/heat_transfer/tutorials/introduction/index.md) for the Heat Transfer module is available to show the steps for setting up a basic model.

## Basic Theory of Heat Transfer

The heat conduction equation describes the diffusion of heat in a solid or stationary fluid:

\begin{equation}\label{eq:heat_equation}
  \rho(t, \vec{x}) c(t, \vec{x})\frac{\partial T}{\partial t} = \nabla k(t,\vec{x}) \nabla T + \dot{q} ~\text{for}~\vec{x} \in \Omega,
\end{equation}

where $T$ is temperature, $t$ is time, $\vec{x}$ is the vector of spatial coordinates, $\rho$ is the density, $c$ is the specific heat capacity, $k$ is the thermal conductivity, $\dot{q}$ is a heat source density, and $\Omega$ is the domain. It should be emphasized that for solids the isobaric and isochoric heat capacities, $c_p$ and $c_v$ respectively, are almost identical, while for stagnant fluids $c_p$ should be used.

Boundary conditions for the heat equation are defined on the boundary of the domain $\partial \Omega$. The boundary is divided into Dirichlet boundaries $\partial \Omega_D$ and Robin boundaries $\partial \Omega_R$ such that $\partial \Omega = \partial \Omega_D \cup \partial \Omega_R$:

\begin{equation}
\begin{array}{l l}
   T(t,\vec{x}) = T_D(t,\vec{x}) & \vec{x}\in \partial \Omega_D  \\
   -k \vec{n} \cdot \nabla T - G(t,\vec{x},T) = 0 & \vec{x}\in \partial \Omega_R,
\end{array}
\end{equation}

where $T_D$ and $G(t,\vec{x},T)$ are known functions and $\vec{n}$ is the outward normal at $\vec{x}$. The function $G(t,\vec{x},T)$ defines the type of Robin
boundary conditions. Common cases for $G$ are:

\begin{equation}
\begin{aligned}\label{eq:robin_bc_types}
   &\text{Neumann:     }~G(t,\vec{x},T) = 0 \\
   &\text{Convection:  }~G(t,\vec{x},T) = h (T - T_{\infty}) \\
   &\text{Radiation:   }~G(t,\vec{x},T) = \sum\limits_{j=1}^I F_{i,j} (J_i - J_j) ~\text{ on surface }i,
\end{aligned}
\end{equation}

where $j$ loops over all surfaces participating in the radiative exchange, $F_{i,j}$ is the view factor from the $i$-th to the $j$-th surface, and $J_j$ is the radiosity of the $j$-th defined by:

\begin{equation}
 J(t, \vec{x}) =  \epsilon(t,\vec{x}) \sigma T^4   + (1 - \epsilon(t,\vec{x})) H(t, \vec{x}),
\end{equation}

where $\epsilon(t,\vec{x})$ is the emissivity, $\sigma = 5.67 \times 10^{-8} \frac{W}{\text{m}^2 \text{K}^4}$ is the Stefan-Boltzmann constant, and $H(t,\vec{x})$ is the total irradiation. Often the surface of interest is in radiative transfer with just a single isothermal surface that completely encloses it. In this case $G(t,\vec{x},T)$ is given by:

\begin{equation}
 G(t,\vec{x},T) = \sigma S \left(T^4 - T^4_{\infty}\right),
\end{equation}

where $S$ depends on the geometry, e.g.,
\begin{equation}
  \begin{aligned}
     &\text{Infinite cylinder }~S = \frac{\epsilon ~\epsilon_C R_C}{\epsilon_C R_C + \epsilon R (1 - \epsilon_C)},
  \end{aligned}
\end{equation}

where $\epsilon_C$ is the emissivity of the enclosing cylinder, $R_C$ is the radius of the enclosing cylinder, and $R$ is the outer radius of the domain that is assumed to be cylindrical as well.

## Theory of Opaque, Gray, Diffuse Radiative Exchange id=gray_diffuse_radiative_exchange

This section discusses the pertinent equations of the net radiation method and relates them to the
more fundamental spectral intensity.
The development of the method is taken from [!cite](modest2013radiative).
The net radiation method computes the radiative exchange
between surfaces for the case of no attenuation in the medium between the surfaces. For a point on
any of the surfaces in radiative heat transfer, a heat balance is formulated at location $\vec{x}$:

\begin{equation}\label{eq:heat_balance}
  q(\vec{x}) = J(\vec{x}) - H(\vec{x}),
\end{equation}

where $J$ is the radiosity of the surface at point $\vec{x}$, and $H$ is the irradiation from other
surface to point $\vec{x}$. The units of all quantities in [eq:heat_balance] are $\text{W}/{\text{m}^2}$.
The radiosity is the sum of the emissive power and the reflected portion of the
irradiation:

\begin{equation}\label{eq:radiosity}
  J(\vec{x}) = \epsilon(\vec{x}) \sigma T^4 + \rho(\vec{x}) H(\vec{x}),
\end{equation}

where $\epsilon$ is the emissivity, and $\rho$ is the reflectivity.
For opaque, gray, diffuse surfaces, the reflectivity simply is $\rho = 1 - \epsilon$:

\begin{equation}\label{eq:radiosity_gray}
  J(\vec{x}) = \epsilon(\vec{x}) \sigma T^4 + (1 - \epsilon(\vec{x})) H(\vec{x}).
\end{equation}

At this point it is convenient to represent the radiosity, temperature, irradiation,
and emissivity on each distinct surface $i$ by a suitable average of the actual distribution.
We leave out the $\vec{x}$ argument and add an $i$ index by which we indicate that this
quantity has been averaged over the extent of surface $i$.

A second balance equation in addition to [eq:radiosity_gray] is obtained by relating
the irradiation onto surface $i$ to the radiosities of all other surfaces:

\begin{equation}\label{eq:second_balance}
  H_i = \sum\limits_{j=1}^n F_{i,j} J_j,
\end{equation}
where $n$ is the total number of surfaces, and $F_{i,j}$ is the view
factor from surface $i$ to surface $j$. Eliminating $H_i$ from [eq:second_balance] using
[eq:heat_balance] gives:

\begin{equation}\label{eq:fixed_q}
  \sum\limits_{j=1}^n \left( \delta_{i,j} - F_{i,j }\right) J_j = q_i.
\end{equation}

This result is used for computing $J_j$ on surfaces where $q_i$ is known. This is the case for
`ADIABATIC` surfaces, where $q_i = 0$.

A more convenient relationship is derived for surfaces where $T_i$ is either known (`FIXED_TEMPERATURE`) or
computed (`VARIABLE_TEMPERATURE`). We first assert that because [eq:heat_balance] and [eq:radiosity_gray] hold pointwise, they also hold for the averages over face $i$. This is denoted by switching from $J(\vec{x})$ to $J_i$ and similarly from $H(\vec{x})$ to $H_i$. Then, solving [eq:heat_balance] for $H_i$, eliminating $H_i$ in [eq:radiosity_gray], and solving for $q$ gives:

\begin{equation}
 q_i = \frac{\epsilon_i}{1 - \epsilon_i} \left( \sigma T_i^4 - J_i \right).
\end{equation}
Then we use this equation in [eq:fixed_q] to eliminate $q_i$:
\begin{equation}\label{eq:fixed_T}
 \sum\limits_{j=1}^n \left( \delta_{i,j} - (1 - \epsilon_i) F_{i,j }\right) J_j = \epsilon_i \sigma T_i^4.
\end{equation}

The net radiation method implements [eq:fixed_q] with $q=0$ on `ADIABATIC` boundaries, and [eq:fixed_T] on `FIXED_TEMPERATURE` and `VARIABLE_TEMPERATURE` boundaries. `FIXED_TEMPERATURE` boundaries allow the temperature to vary as a user-defined function, while `VARIABLE_TEMPERATURE` walls use a MOOSE variable to represent temperature. In both cases, $T$ is not constant over the extent of the surface. We average the right hand side of [eq:fixed_T] as follows:

\begin{equation}
  \sum\limits_{j=1}^n \left( \delta_{i,j} - (1 - \epsilon_i) F_{i,j }\right) J_j = \beta_i,
\end{equation}

where

\begin{equation}
  \beta_i =  \frac{ \epsilon_i  \sigma}{A_i} \int_{A_i} T_i^4 dA,
\end{equation}

where $A_i$ is the area of surface $i$.
The `GrayLambertSurfaceRadiationBase` object computes the average temperature $T_i$, heat flux $q_i$, and radiosity $J_i$.
These are all average quantities over the surface $i$.

## Relationship of Net Radiation Method with Radiative Transport

The radiative transport equation is formulated in terms of the spectral intensity $I(\vec{x}, t, \lambda, \hat{\Omega})$ with $\lambda$ being the photon's wavelength and $\hat{\Omega}$ being the direction
of propagation. The physical meaning of the spectral intensity is that the energy transported through
area $dA$ at $\vec{x}$, during time interval $dt$ at time $t$, along direction within a cone $d\hat{\Omega}$ about $\hat{\Omega}$ and with wavelengths within $d \lambda$ about $\lambda$ is:

\begin{equation}
  \text{Energy} = I(\vec{x}, t, \lambda, \hat{\Omega}) dt dA |\vec{n} \cdot \hat{\Omega}| d\hat{\Omega} d\lambda,
\end{equation}

where $\vec{n}$ is the normal on face $dA$.
The intensity is computed by a code that solves the radiative transfer equation, e.g., [Griffin](https://inlsoftware.inl.gov/product/griffin) within the MOOSE framework. The solution of the radiative transfer equation is coupled to heat conduction within solid domains
through the balance at the surface [eq:heat_balance], but now we evaluate the net heat flux from the spectral intensity:

\begin{equation}
  q(\vec{x}) = \int\limits_{4 \pi} d\hat{\Omega} \int\limits_{0}^{\infty} d\lambda (\vec{n} \cdot \hat{\Omega}) I(\vec{x}, t, \lambda, \hat{\Omega}).
\end{equation}

The boundary condition for the thermal radiation equation on a gray, diffuse surface is:
\begin{equation}\label{eq:rad_transfer_bc}
  I(\vec{x}, t, \lambda, \hat{\Omega}) = \frac{1}{\pi}\left[\frac{\epsilon(t,\vec{x},\lambda) n^2 2 \pi h c_0^2}{\lambda^5 \left[ \exp{\frac{h c_0}{k_B \lambda T}} - 1 \right]} + \left(1 - \epsilon(t,\vec{x},\lambda)\right) \int\limits_{\hat{\Omega}' \cdot \vec{n} > 0}  \hat{\Omega}' \cdot \vec{n} ~I(\vec{x}, t, \lambda, \hat{\Omega}') d \hat{\Omega}' \right]~\text{for}~\vec{n} \cdot \hat{\Omega} < 0,
\end{equation}

where $n$ is the refractive index of the medium that the surface radiates into, $\epsilon(t,\vec{x},\lambda)$ is the emissivity of the surface at wavelength $\lambda$, $h$ is Planck's constant, $k_B$ is Boltzmann's constant, and $c_0$ is the speed of light in vacuum.
First, it should be stressed that the refractive index is very close to unity in vacuum or a weakly absorbing gas, but may differ significantly from unity in semi-transparent media. As the net radiation method does not apply to semi-transparent materials, $n$ is assumed to be unity. Second, the normalization factor of $1/\pi$ in [eq:rad_transfer_bc] is for three-dimensional geometry; more accurately it is given by $\frac{1}{4} \int d \hat{\Omega}$, i.e. size of the unit sphere divided by four. Third, radiation effects in semi-transparent media can be modeled with the MOOSE based radiation transport code Rattlesnake.

## Including Adiabatic and Isothermal Boundaries

Boundaries can be declared adiabatic or isothermal boundaries. Adiabatic and isothermal boundaries do not participate in the heat conduction solution process, i.e. no temperature variable needs to be defined on them (if one is defined it is not used). Adiabatic and isothermal boundaries are convenient if the outer boundary of the heat conduction domain is in radiative transfer with a wall that is either insulated or kept at a constant temperature. For example, think of the outside of a reactor pressure vessel that is in radiative heat transfer with the reactor cavity cooling system. The reactor cavity cooling system may be modeled as isothermal wall, while the top and bottom of the cavity may be modeled as adiabatic walls.
The temperature equation is not solved on of these surfaces, but they are in radiative transfer with another surface on which temperature is defined as a variable.

## Implementation of Opaque, Gray, Diffuse Radiative Exchange

The implementation of the net radiation method in MOOSE relies on the following types of objects:

- Objects deriving from `GrayLambertSurfaceRadiationBase` are `SideUserObjects` that compute radiosities,
  heat fluxes, and average temperatures for a set of sidesets involved in radiative heat exchange.
  The net radiation method is implemented in `GrayLambertSurfaceRadiationBase`, which provides a public
  interface to the average heat flux, radiosities, and average temperatures computed for each sideset.
  These objects differ in how they are provided with view factors:

  - [ConstantViewFactorSurfaceRadiation.md], for providing view factors manually
  - [ViewFactorObjectSurfaceRadiation.md], for providing view factors via an object deriving from `ViewFactorBase`

  Note that a temperature variable must be available on sidesets that are not marked as isothermal or adiabatic.

- Objects inheriting from `ViewFactorBase`, such as the following:

  - [UnobstructedPlanarViewFactor.md]
  - [RayTracingViewFactor.md]

  compute view factors and provide them via the `getViewFactor` public interface. These objects are used by [ViewFactorObjectSurfaceRadiation.md], which inherits from  `GrayLambertSurfaceRadiationBase`.

- [GrayLambertNeumannBC.md] takes the average heat flux computed in `GrayLambertSurfaceRadiationBase`
  and applies it as boundary condition as described in [eq:robin_bc_types].

- [GrayLambertSurfaceRadiationPP.md] is a post-processor that retrieves the radiosity, heat flux, or temperature
  for a boundary used in a `GrayLambertSurfaceRadiationBase` object.

- [ViewFactorPP.md] is a post-processor that can retrieve a view factor from a `ViewFactorBase` for output purposes.

- [SurfaceRadiationVectorPostprocessor.md] is a vector post-processor that retrieves one or more of the following
  for all surfaces for a given `GrayLambertSurfaceRadiationBase` object: emissivity, radiosity, temperature, and heat flux.

- [ViewfactorVectorPostprocessor.md] is a vector post-processor that retrieves the view factors
  between all boundaries for a given `GrayLambertSurfaceRadiationBase` object.

- Future plans include the addition of an action to set up view-factor net radiation transfer using only a single syntax block.

## Gap Heat Transfer

There are multiple approaches in the Heat Transfer module for modeling heat
transfer across a gap:

- [ModularGapConductanceConstraint.md] uses the mortar finite element method and
  may be used when the gap is based on the distance between mesh faces.
- [SideSetHeatTransferKernel.md] is an [InterfaceKernel](InterfaceKernels/index.md)
  that models heat transfer across a side set, via conduction, convection, and
  radiation.
- [ThermalContact](syntax/ThermalContact/index.md) uses a "node-on-face" approach
  to model gap heat transfer and may be used when the gap is based on
  the distance between mesh faces.
- [CylindricalGapHeatFluxFunctorMaterial.md] is a [FunctorMaterial](FunctorMaterials/index.md)
  that computes heat fluxes across a cylindrical gap, where the gap thickness
  is provided via radii functors rather than taken from mesh information.

## Objects, Actions, and Syntax


## actions

### Mortar Gap Heat Transfer Action

#### Description

The `MortarGapHeatTransferAction` action sets up a set of models used to enforce heat transfer across two surfaces using a mortar approach. These models are separately implemented in user objects. See the description, example use, and parameters on the [MortarGapHeatTransfer](syntax/MortarGapHeatTransfer/index.md) system documentation page.

### Radiation Transfer Action

#### Description

The `RadiationTransferAction` action sets up radiative heat transfer problems
solved by the net radiation method. See the description,
example use, and parameters on the
[GrayDiffuseRadiation](/GrayDiffuseRadiation/index.md) system documentation page.

### ThermalContactAction

This action sets up the models for [ThermalContact](syntax/ThermalContact/index.md).

## auxkernels

### JouleHeatingHeatGeneratedAux


#### Description

The `JouleHeatingHeatGeneratedAux` AuxKernel is used to compute the heat generated by Joule heating. The heat (power per unit volume) is computed as $dP/dV= \bm{J} \cdot \bm{E} = E ^2 \sigma$, where $\bm{J} = \sigma \bm{E}$ is the current density, $\bm{E}$ is the electric field, and $\sigma$ is the electrical conductivity.




## bcs

### ADConvectiveHeatFluxBC


This boundary condition computes convective heat flux $q'' = H \cdot (T - T_{inf})$, where $H$ is convective heat transfer coefficient,
$T$ is the temperature, and $T_{inf}$ is far field temperature.  Both $H$ and $T_{inf}$ are coupled as material properties.





### ADFunctionRadiativeBC


This boundary condition computes the radiative heat flux from a boundary where the
emissivity function is provided through a Function.

\begin{equation}
 \sigma F_e (T_\infty^4-T_s^4)
\end{equation}
where $\sigma$ is the Stephan-Boltzmann constant, $F_e$ is the emissivity function,
$T_\infty$ is the temperature far from the surface, and $T_s$ is the temperature of
the surface.





### ADInfiniteCylinderRadiativeBC


This boundary condition computes the radiative heat flux from the boundary to
an infinite cylinder completely surrounding it. The boundary itself is assumed
to be a cylinder that is concentric to the enclosing cylinder. Geometry information
is provided by boundary_radius and cylinder_radius parameters. The mesh is not queried for
geometric information.






### ConvectiveFluxFunction


#### Description

The `ConvectiveFluxFunction` boundary condition is used to prescribe the following convective flux
$\dot{q}$ to a boundary of a thermal model:
\begin{equation}
   \dot{q} = h(T(x) - T_{\text{inf}})
\end{equation}
where $h$ is the heat transfer coefficient, $T(x)$ is the temperature at a location $x$, where $x$ is
the location of a given quadrature point on the surface where this boundary condition is applied, and
$T_{\text{inf}}$ is the far-field temperature of the fluid that the boundary is exposed to.

The far-field temperature is specified using the `T_infinity` parameter, which is a MOOSE Function. This can be provided as the name of a function, using a parsed function, or a constant value.  Likewise, the heat transfer coefficient is specified using the `coefficient` parameter, which is also a MOOSE Function, and the same options for how to prescribe `T_infinity` also apply for this parameter. By default, the heat transfer coefficient function is defined in terms of position and time (the standard usage of MOOSE Functions). If the optional `coefficient_function_type` parameter is set to `TEMPERATURE`, the coefficient is instead a function of the temperature. If a Function such as `PiecewiseLinear` were used to define this coefficient, the values on the x-axis of that function would be interpreted as temperature values. If a parsed function were used for this purpose, the `t` variable in a parsed equation would be used for the temperature, rather than for the time.




### ConvectiveHeatFluxBC


#### Description

The `ConvectiveHeatFluxBC` boundary condition imposes a heat flux equal to

\begin{equation}
\vec{q}\cdot\hat{n}=h\left(T-T_\infty\right)
\end{equation}

where $\vec{q}\cdot\hat{n}$ is the heat flux normal to the boundary, $h$ is
the convective heat transfer coefficient, and $T_\infty$ is the far-field temperature.
Both $h$ and $T_\infty$ are taken as material properties.
See [CoupledConvectiveHeatFluxBC](CoupledConvectiveHeatFluxBC.md) for a similar boundary condition coupled to variables.

#### Example Input File Syntax







### CoupledConvectiveHeatFluxBC


This boundary condition computes convective heat flux $q'' = scale \cdot Hw \cdot (T - T_{inf})$, where $Hw$ is convective heat transfer coefficient,
$T$ is the temperature solved for, and $T_{inf}$ is far field temperature.  Both $Hw$ and $T_{inf}$ are spatially varying variables.

A typical use case for this boundary condition are coupled multi-apps exchanging heat flux.

It is possible to use vector coupling to compute the heat flux for multi-phase fluids. In this case,
users need to supply `alpha` parameter, which represents the volume fraction for each phase. Similarly,
multiple components have to be supplied for `htc` and `T_infinity`. The number of components for `alpha`, `Hw` and `T_infinity` must match.
The heat flux is then computed as $q'' = scale \cdot \Sigma_k \alpha^k \cdot Hw^k \cdot (T - T_{inf}^k)$.

Parameter $scale$ can be used to scale the total heat flux. By default, it is $1.$ (i.e. no scaling).
Note that $scale$ is actually a field variable, so spatially dependent scaling is possible.
This can be used to locally turn the BC on or off.






### DirectionalFluxBC


The flux is only applied on the irradiation-facing side of the surface, i.e when the product of flux vector and (outward facing) normal is negative.

A [SelfShadowSideUserObject](SelfShadowSideUserObject.md) can be supplied to take self shadowing into account.





### FunctionRadiativeBC


This boundary condition is the finite element analog of
[FVFunctorRadiativeBC.md]. It computes the radiative heat flux from a boundary
where the emissivity function is provided through a Function.

\begin{equation}
 \sigma F_e (T_\infty^4-T_s^4)
\end{equation}
where $\sigma$ is the Stephan-Boltzmann constant, $F_e$ is the emissivity function,
$T_\infty$ is the temperature far from the surface, and $T_s$ is the temperature of
the surface.





### GapHeatTransfer


#### Description

GapHeatTransfer calculates the amount of heat transferred across unmeshed gaps between two different
blocks.

The `quadrature` option is generally recommended for most models. With this option, heat flux is
computed and applied as an integrated boundary condition at the quadrature points on both faces. Use
of the quadrature options generally gives smoother results, although there can be small differences
in the heat flux on the two surfaces.

It is also important to use the appropriate `gap_geometry_type` parameter (PLATE, CYLINDER, or
SPHERE) for the model geometry.

Two-dimensional Cartesian geometries are not restricted to be in or parallel to the X-Y coordinate plane.


#### Example Input syntax





### GapPerfectConductance


This object can be set up automatically by using the [ThermalContact](syntax/ThermalContact/index.md) action.

#### Description

This class enforces that temperatures match across the gap.  Specifically, the temperature on the secondary surface will match the temperature on the primary surface.  This is accomplished through a penalty constraint.  The residual is
\begin{equation}
  r = k (T_s - T_p)
\end{equation}
where $k$ is the penalty value, $T_s$ is the temperature on the secondary surface, and $T_p$ is the temperature on the primary surface.

#### Example Input Syntax





### GaussianEnergyFluxBC


This boundary condition is the finite element analog of
[FVGaussianEnergyFluxBC.md]. It computes an influx of energy from a beam
(e.g. laser) with a Gaussian spatial profile. The flux is given by

\begin{equation}
-\frac{2P_0}{\pi R^2}\exp{\frac{-2r_p^2}{R^2}}
\end{equation}

where $P_0$ is the total power of the beam, $R$ is the radius at which the
intensity falls to $1/\exp{2}$ of its axial value, and $r_p$ is the normed
distance from the point at which we're evaluating the flux to the centerpoint of
the beam. This functional form of the beam flux is taken from
[Wikipedia](https://en.wikipedia.org/wiki/Gaussian_beam). The negative sign on
the flux indicates that the flux is incoming. This class assumes that the beam
impinges perpendicular to the surface.




### GrayLambertNeumannBC


This boundary condition computes the heat flux density resulting from the
radiative heat transfer between surfaces adjacent to this boundary. These
surfaces must be diffuse, gray radiators (Lambert radiators). The heat flux
is computed by the net radiation method described in [!cite](modest2013radiative).
More information is available [here](userobjects/ConstantViewFactorSurfaceRadiation.md).

There are two modes available for operating this boundary condition. The mode can be switched
by the `reconstruct_emission` parameter. If set to `false`, the object queries the
net radiation object (`GrayLambertSurfaceRadiationBase` or derived class) object for the
net heat flux density on the surface. This heat flux density is applied as a constant for
each participating sideset. If the sidesets are large and the flat heat flux densities on two adjacent sidesets sufficiently different, then the temperature will be non-smooth.

A smoother temperature distribution on the surface is usually obtained by noting that a large
fraction of the spatial distribution of the heat flux stems from the temperature distribution
and hence from the emission. The approximation made is that the emission is allowed to spatially
vary, while the irradiation from other sidesets to the given sideset is assumed to be
spatially flat. The heat flux at location $\vec{x}$ on sideset $i$ is computed by:

\begin{equation}
   \dot{q}_i(\vec{x}) = \epsilon_i \left( \sigma T(\vec{x})^4 - H_i\right),
\end{equation}

where $\sigma$ is the Stefan-Boltzmann constant, $\epsilon_i$ the emissivity of sideset $i$, and
$H_i$ the average irradiation into sideset $i$.

block=BCs






### InfiniteCylinderRadiativeBC


This boundary condition computes the radiative heat flux from the boundary to
an infinite cylinder completely surrounding it. The boundary itself is assumed
to be a cylinder that is concentric to the enclosing cylinder. Geometry information
is provided by boundary_radius and cylinder_radius parameters. The mesh is not queried for
geometric information.






## constraints

### ADInterfaceJouleHeatingConstraint


#### Description

The `ADInterfaceJouleHeatingConstraint` class is intended to calculate and add the heat source due to Joule Heating which results from the electric potential drop across an interface.
The heat source is then added to the temperature field variable  in a coupled electro-thermal simulation.
This class is intended to be used in conjunction with [ModularGapConductanceConstraint](ModularGapConductanceConstraint.md) and [GapFluxModelPressureDependentConduction](GapFluxModelPressureDependentConduction.md), which enforce the closed gap interface requirement by checking for a positive normal pressure.
As such, the `ADInterfaceJouleHeatingConstraint` takes as a required argument the name of the Lagrange Multiplier variable used in the electrical contact.

Consistency in the selection of the primary boundary and secondary boundary among the electrical, thermal, and interface Joule Heating mortar contact input file components is recommended.

The heat source is calculated as a function of the electric potential change across the interface, as determined from the associated Lagrange multiplier $\lambda_{\phi}$,
\begin{equation}
  \label{eq:interfaceJH_fromLMvariable}
   q_{electric} = C_e \left( \Delta \phi \right)^2 = \frac{(\lambda_{\phi})^2}{C_e}
\end{equation}
where $C_e$ is the harmonic mean of the electrical conductivity of the primary and secondary blocks,
\begin{equation}
  \label{eq:electricCond_harmonicMean}
  C_e = \frac{2 \sigma_{primary} \sigma_{secondary}}{\sigma_{primary} + \sigma_{secondary}}
\end{equation}
following [!citep](cincotti2007modeling).
The Lagrange multiplier variable, passed from a separate mortar contact calculation, is calculated as
\begin{equation}
  \label{eq:electricalContact_LMvariable}
  \lambda_{\phi} = C_e \left[ \frac{S}{m} \right] \Delta \phi  \left[ \frac{V}{m} \right]
\end{equation}
where the harmonic mean of the electrical conductivity is the same as given in [eq:electricCond_harmonicMean].
In base SI units this Lagrange multiplier variable has the units $\left[ \frac{A}{m^2} \right]$ and is similar to the common approximation for the current density
\begin{equation}
  \label{eq:currentDensityApprox}
  J = \sigma E
\end{equation}
where $J$ is the current density, $\sigma$ is the electrical conductivity, and $E$ is the electric field.


The `ADInterfaceJouleHeatingConstraint` class should only be employed in simulations when the user is certain that the current-density-like electric potential contact Lagrange multiplier variable is nonzero only when the interface gap is closed. The `ADInterfaceJouleHeatingConstraint` class may also be used in simulations with an open gap at the interface, so long as the electric potential contact Lagrange multiplier variable across that gap is zero while the interface gap is open.

With the total interface Joule heating source determined, the fraction of the heat source applied to each block at the interface is determined as
\begin{equation}
  \label{eq:primary_interfaceJH}
  q_{primary} = -q_{electric} w_f
\end{equation}
and
\begin{equation}
  \label{eq:secondary_interfaceJH}
  q_{secondary} = -q_{electric} (1 - w_f)
\end{equation}
where $w_f$ is the user-defined weighting factor that governs how the heat source is divided between the two sides of the interface.
The use of the negative sign in [eq:primary_interfaceJH] and [eq:secondary_interfaceJH] indicates that the heat source is transferred into each block instead of away from the block.

##### Steady-State Analytical Verification

Under steady state analysis assumptions, the temperature at the interface in the primary boundary material block is given by Fourier's Law
\begin{equation}
  T_{interface} = \frac{l}{k_{primary}} q_{primary} + T_{edge}
\end{equation}
where $l$ is the length of the block, $k_{primary}$ is the thermal conductivity, and $T_{edge}$ is the prescribed temperature boundary condition at the edge of the material block.

Similarly, the interface temperature in the secondary block material is given as
\begin{equation}
  T_{interface} = \frac{l}{k_{secondary}} q_{secondary} + T_{edge}
\end{equation}

In cases where the heat source weighting factor, [eq:primary_interfaceJH] and [eq:secondary_interfaceJH], is set to 0.5, the temperature at the interface in each block will depend on the thermal conductivity value and size of each block.

#### Example Input File Syntax


`ADInterfaceJouleHeatingConstraint` should be used in conjunction with the modular gap conductance constraint, shown here,


and the pressure-dependent gap flux conduction user object, as shown below:






### Gap Conductance Constraint


The `GapConductanceConstraint` class is used to specify a heat flux across a gap
equivalent to $\frac{k}{l}\left(u_m - u_s\right)$ where $k$ is the gap
conductance, $l$ is the gap distance, $u_m$ is the temperature on the primary
side of the mortar interface, and $u_s$ is the temperature on the secondary
side. Constraint enforcement is done using lagrange multipliers.





### ModularGapConductanceConstraint


The `ModularGapConductanceConstraint` class is used specify a heat flux across a
gap.  The flux is computed by user objects derived from `GapFluxModelBase`. Such as

- [GapFluxModelSimple](GapFluxModelSimple.md)
- [GapFluxModelConduction](GapFluxModelConduction.md)
- [GapFluxModelRadiation](GapFluxModelRadiation.md)
- [GapFluxModelPressureDependentConduction](GapFluxModelPressureDependentConduction.md)

Multiple models can be specified with their contributions getting summed up.

#### Gap geometry types

Plate, cylindrical, and spherical gap geometries can be specified using the [!param](/Constraints/ModularGapConductanceConstraint/gap_geometry_type) parameter.

For cylindrical geometries, e.g. `gap_geometry_type = cylinder`, the axis of the cylinder can be specified using the [!param](/Constraints/ModularGapConductanceConstraint/cylinder_axis_point_1) and [!param](/Constraints/ModularGapConductanceConstraint/cylinder_axis_point_2) parameters. In 2D Cartesian coordinate systems (e.g. `Mesh/coord_type=XYZ`), these parameters can be omitted to automatically determine the cylinder axis. This is accomplished by averaging positions over the primary side set, which should yield the center of the cylinder, assuming the side set spans the entire 360 degree rotation around the theoretical axis. The axis is then extended in z-direction.

For spherical geometries the origin of the sphere can be specified using the [!param](/Constraints/ModularGapConductanceConstraint/sphere_origin) parameter. If the parameter is omitted, the sphere origin is deduced by averaging positions over the primary side set.

If the gap is sliced by a symmetry plane (e.g. only a quarter of a cylinder or an eighth of a sphere are modeled), the positional average over the primary side set will not yield the correct origin or axis and they will need to be supplied manually.





## dirackernels



## functormaterials

### (AD)ConvectionHeatFluxFunctorMaterial

This [functor material](/FunctorMaterials/index.md) computes a convection heat
flux $q$ between a solid surface and a fluid using [functors](/Functors/index.md):

q \equiv \mathbf{q}\cdot\mathbf{n}_\text{solid} = h (T_\text{solid} - T_\text{fluid}) \,,

where

- $h$ is the heat transfer coefficient, given by [!param](/FunctorMaterials/ConvectionHeatFluxFunctorMaterial/htc),
- $\mathbf{n}_\text{solid}$ is the outward normal unit vector from the solid surface,
- $T_\text{solid}$ is the solid temperature, given by [!param](/FunctorMaterials/ConvectionHeatFluxFunctorMaterial/T_solid), and
- $T_\text{fluid}$ is the fluid temperature, given by [!param](/FunctorMaterials/ConvectionHeatFluxFunctorMaterial/T_fluid).

The AD version of this class is used to retrieve all of the input functors with AD types.




### CylindricalGapHeatFluxFunctorMaterial

This [functor material](/FunctorMaterials/index.md) computes the heat flux
across a cylindrical gap due to conduction and/or radiation, assuming infinitely
long cylindrical surfaces.

This is an appropriate approach to use whenever the mesh may not actually represent
the gap distances between surfaces, and instead the radii of the cylindrical
surfaces are provided by [functors](/Functors/index.md).

The following functor materials are added for the conduction heat flux $q_\text{cond}$,
radiation heat flux $q_\text{rad}$, and total heat flux $q$, with names given by the user:

- [!param](/FunctorMaterials/CylindricalGapHeatFluxFunctorMaterial/conduction_heat_flux_name),
  $q_\text{cond}$, as computed in [utils/HeatTransferModels.md#cylindrical_gap_conduction_heat_flux].
- [!param](/FunctorMaterials/CylindricalGapHeatFluxFunctorMaterial/radiation_heat_flux_name),
  $q_\text{rad}$, as computed in [utils/HeatTransferModels.md#cylindrical_gap_radiation_heat_flux].
- [!param](/FunctorMaterials/CylindricalGapHeatFluxFunctorMaterial/total_heat_flux_name),
  $q = q_\text{cond} + q_\text{rad}$.




### FinEfficiencyFunctorMaterial

This [functor material](/FunctorMaterials/index.md) computes a fin efficiency,
which can be used with [FinEnhancementFactorFunctorMaterial.md], for example.

#### Formulation

Under the following assumptions:

- straight fin,
- uniform cross section, and
- adiabatic tip,

the fin efficiency $\eta_f$ is the following [!citep](incropera2002):

\eta_f = \frac{\text{tanh}(m L)}{m L} \,,

m = \sqrt{\frac{\mathcal{H} P}{k A_c}} \,,

where

- $\mathcal{H}$ is the heat transfer coefficient,
- $k$ is the thermal conductivity of the fin,
- $L$ is the fin height, i.e., the distance the fin extends above the surface,
- $P$ is the fin perimeter, and
- $A_c$ is the fin cross-sectional area.

Note that the fin perimeter and cross-sectional area are not needed separately; only the
ratio $P / A_c$ is needed. For example, for a rectangular fin with width $w$ and thickness $t$
and a cylindrical pin fin with diameter $D$:

| Fin type | $P$ | $A_c$ | $\frac{P}{A_c}$ |
| :- | - | - | - |
| Rectangular | $2 w + 2 t$ | $w t$ | $\frac{2 w + 2 t}{w t}$ |
| Cylindrical pin | $\pi D$ | $\frac{\pi D^2}{4}$ | $\frac{4}{D}$ |

#### Usage

This functor material creates a functor material property for the fin efficiency
$\eta_f$ with the name given by the parameter
[!param](/FunctorMaterials/FinEfficiencyFunctorMaterial/fin_efficiency_name).

The quantities $\mathcal{H}$, $k$, $L$, and $P / A_c$ are provided by the [functor](/Functors/index.md)
parameters
[!param](/FunctorMaterials/FinEfficiencyFunctorMaterial/heat_transfer_coefficient),
[!param](/FunctorMaterials/FinEfficiencyFunctorMaterial/thermal_conductivity),
[!param](/FunctorMaterials/FinEfficiencyFunctorMaterial/fin_height), and
[!param](/FunctorMaterials/FinEfficiencyFunctorMaterial/fin_perimeter_area_ratio), respectively.




### FinEnhancementFactorFunctorMaterial

This [functor material](/FunctorMaterials/index.md) computes the enhancement
factor $\zeta$ for a convective heat transfer condition due to extended surfaces such as fins.

#### Formulation

Consider the convective heat transfer rate $Q_0$ at a surface with area $A_0$
without the addition of any fins:

Q_0 = \mathcal{H} (T - T_\infty) A_0 \,,

where

- $\mathcal{H}$ is the heat transfer coefficient,
- $T$ is the surface temperature, and
- $T_\infty$ is the fluid temperature.

The addition of extended surfaces such as fins to the surface enhances this
heat transfer rate by a factor $\zeta$:

Q = \zeta Q_0 \,.

The fin efficiency $\eta_f$ characterizes the performance of a single fin and
is defined as the ratio of the heat transfer rate through the fin $Q_f$ to the
theoretical maximum heat transfer rate through the fin $Q_{f,\text{max}}$ [!citep](incropera2002):

\eta_f \equiv \frac{Q_f}{Q_{f,\text{max}}} \,,

Q_{f,\text{max}} \equiv \mathcal{H} (T - T_\infty) A_{f,\text{single}} \,,

where $A_{f,\text{single}}$ is the surface area of the fin.

The total surface efficiency $\eta_t$ characterizes the performance of an array
of fins on a surface, not just a single fin, as $\eta_f$ does, and is defined
as the ratio of the total heat transfer rate $Q$ of the entire surface to the
theoretical maximum heat transfer rate $Q_{\text{max}}$ [!citep](incropera2002):

\eta_t \equiv \frac{Q}{Q_{\text{max}}} \,,

Q_{\text{max}} \equiv \mathcal{H} (T - T_\infty) A_t \,,

Combining [!eqref](total_heat_rate), [!eqref](total_efficiency), and [!eqref](total_efficiency_max)
gives the definition of the enhancement factor:

\zeta = \eta_t \frac{A_t}{A_0} \,,

where $A_t$ is the total surface area, including fins.
The total efficiency is computed from the fin efficiency and the fin area
ratio $A_f / A_t$ [!citep](incropera2002):

\eta_t = 1 - (1 - \eta_f) \frac{A_f}{A_t} \,,

where $A_f$ is the surface area of all fins on the surface.

#### Usage

This functor material creates a functor material property for the enhancement
factor $\zeta$ with the name given by the parameter
[!param](/FunctorMaterials/FinEnhancementFactorFunctorMaterial/fin_enhancement_factor_name).

The quantities $\eta_f$, $A_f / A_t$, and $A_t / A_0$ are provided by the [functor](/Functors/index.md) parameters
[!param](/FunctorMaterials/FinEnhancementFactorFunctorMaterial/fin_efficiency),
[!param](/FunctorMaterials/FinEnhancementFactorFunctorMaterial/fin_area_fraction), and
[!param](/FunctorMaterials/FinEnhancementFactorFunctorMaterial/area_increase_factor), respectively.




### (AD)RadiativeP1DiffusionCoefficientMaterial

This [functor material](/FunctorMaterials/index.md) computes the effective
P1 radiative heat transfer coefficient as follows:

\begin{equation}
\Gamma = \frac{1}{3 \kappa + \sigma_{s, eff}}
\end{equation}

where

- $\kappa$ is the opacity (SI units $m^{-1}$)
- $\sigma_{s, eff}$ is the P1 effective scattering cross section (SI units $m^{-1}$), e.g., $3 \sigma_{tr}$ with $\sigma_{tr}$ being the transport cross section.

If scattering in the medium can be assumed isotropic,
then $\sigma_{s, eff} \approx 3 \sigma_{s}$ is a good approximation [!citep](incropera2002).




## fvbcs

### FunctorThermalResistanceBC


The FunctorThermalResistanceBC is simply the [FVThermalResistanceBC.md] using functor
material properties. See its documentation for more details.




### FVFunctorConvectiveHeatFluxBC


### Description

This boundary condition computes convective heat flux $q'' = h \cdot (T - T_{bulk})$, where $h$ is the convective heat transfer coefficient,
$T$ is the temperature, and $T_{bulk}$ is the far-field temperature. Both $h$ and $T_{bulk}$ are functors, which enables various spatial, variable and other dependences.
The domain of the variable can be specified as either a fluid or a solid using the `is_solid` parameter. For a solid domain, the equation above is applied.
For a fluid domain, the negative of the heat flux is applied. This allows for easier implementation of a double Robin
boundary condition.

Similar objects:
- [CoupledConvectiveHeatFluxBC](CoupledConvectiveHeatFluxBC.md) for a similar boundary condition coupled to variables, for finite elements
- [FunctorThermalResistanceBC](FunctorThermalResistanceBC.md) for a combined conduction, convection, and radiative boundary condition, with a constant outside ambient temperature

### Example syntax

In this example, the `FVFunctorConvectiveHeatFluxBC` boundary condition forms a convective boundary condition between
the fluid and the solid.





### FVFunctorRadiativeBC


This boundary condition is the finite volume analog of
[FunctionRadiativeBC.md]. It computes the radiative heat flux from a boundary
where the emissivity is provided through a [functor](Functors/index.md).

\begin{equation}
 \sigma F_e (T_\infty^4-T_s^4)
\end{equation}
where $\sigma$ is the Stephan-Boltzmann constant, $F_e$ is the emissivity function,
$T_\infty$ is the temperature far from the surface, and $T_s$ is the temperature of
the surface.




### FVGaussianEnergyFluxBC


This boundary condition is the finite volume analog of
[GaussianEnergyFluxBC.md]. It computes an influx of energy from a beam
(e.g. laser) with a Gaussian spatial profile. The flux is given by

\begin{equation}
-\frac{2P_0}{\pi R^2}\exp{\frac{-2r_p^2}{R^2}}
\end{equation}

where $P_0$ is the total power of the beam, $R$ is the radius at which the
intensity falls to $1/\exp{2}$ of its axial value, and $r_p$ is the normed
distance from the point at which we're evaluating the flux to the centerpoint of
the beam. This functional form of the beam flux is taken from
[Wikipedia](https://en.wikipedia.org/wiki/Gaussian_beam). The negative sign on
the flux indicates that the flux is incoming. This class assumes that the beam
impinges perpendicular to the surface.




### FVInfiniteCylinderRadiativeBC


#### Overview

This object implements a boundary flux of the form
\begin{equation}
F = \sigma c \left(T^4 - T_{\infty}^4\right)
\end{equation}

where $\sigma$ is the Stefan-Boltzmann constant, $T$ is the temperature,
$T_{\infty}$ is the temperature at infinity and the coefficient $c$ is given by

\begin{equation}
\frac{\epsilon_b \epsilon_c r_c}{\epsilon_c r_c + \epsilon_b r_b \left(1 -
\epsilon_c\right)}
\end{equation}

where $\epsilon_b$ is the emissivity of the boundary we are on (e.g. the
`boundary` parameter), $\epsilon_c$ is the emissivity of the theoretical
cylinder surrounding the theoretical cylinder bounded by our `boundary`, $r_c$
is the radius of the surrounding cylinder, and $r_b$ is the radius corresponding
to the location of our `boundary`.




### FVMarshakRadiativeBC

This boundary condition implements the Marshak boundary conditions for
the radiative heat flux.

#### Overview

The Marshak boundary condition implemented reads as follows [!citep](modest2021):
\begin{equation}
F_G = (G - 4 \sigma T_{b, rad}^4) \frac{\epsilon_b}{2 \Gamma (2 - \epsilon_b)}
\end{equation}

where:

- $F_G$ is the normal space derivative of the radiation heat flux at the boundaries defined by the `boundary` parameter
- $G$ is the ratiative heat flux (SI units (W/m$^2$))
- $\sigma$ is the Stefan-Boltzmann constant (SI units (W/m$^2$/K$^4$))
- $\sigma T_{b, rad}$ is the radiation temperature at the boundary (SI units (K))
- $\epsilon_b$ is the emissivity of the boundary (SI units (-))
- $\Gamma$ is the radiation diffusion coefficient (SI units (m))




### FVThermalResistanceBC


### Description

Heat flux boundary condition for the fluid or solid energy conservation equations. When used
with the fluid energy equation, this boundary condition specifies

\begin{equation}
-\int_\Gamma\kappa_f \nabla T_f\cdot\hat{n}d\Gamma\ ,
\end{equation}

where

\begin{equation}
-\kappa_f\nabla T_f\cdot\hat{n}=\tilde{q}\ ,
\end{equation}

where $\tilde{q}$ is the imposed heat flux, to be discussed shortly.
When used with the solid energy equation, this boundary condition specifies

\begin{equation}
-\int_\Gamma\kappa_s\cdot\nabla T_s\cdot\hat{n}d\Gamma\ ,
\end{equation}

where

\begin{equation}
-\kappa_s\cdot\nabla T_s\cdot\hat{n}=\tilde{q}\ .
\end{equation}

The heat flux $\tilde{q}$ is computed based on the thermal resistance concept, where heat
is assumed to conduct through multiple parallel slabs of constant-property solid in series,
followed by parallel convection and radiation to an ambient temperature. For $N$ conducting
layers, the conduction thermal resistance $R_c$ is computed for Cartesian slabs as

\begin{equation}
R_c=\sum_{i=1}^N\frac{\Delta x_i}{k_i}\ ,
\end{equation}

where $\Delta x_i$ is the thickness of each layer and $k_i$ is the thermal conductivity of
each layer. For cylindrical annuli, the conduction thermal resistance is computed as

\begin{equation}
R_c=\sum_{i=1}^N\frac{\ln{\left(\frac{\Delta x_i+r_i}{r_i}\right)}}{2 \pi k_i}\ ,
\end{equation}

where $r_i$ is the inner radius corresponding to each layer. The inner radius of the very
first cylindrical annulus is specified by the `inner_radius` parameter.

The inner radius of a cylindrical bed is also provided by the `inner_radius` parameter for
setting porosity functions and other near-wall behavior. To prevent errors associated with
mixing the two different interpretations of the `inner_radius` parameter, it's best to avoid
setting this parameter in the `GlobalParams` input file block.

The parallel convection and radiation resistance from the surface of the conduction
layers, or $R_p$, is then computed as

\begin{equation}
R_p=\frac{1}{R\left(h_r+h_c\right)}\ ,
\end{equation}

where $R$ is equal to the cylindrical annuli outer radius for cylindrical geometries and
unity for Cartesian geometries; $h_c$ is the surface convection coefficient; and $h_r$ is
the radiation heat transfer coefficient,

\begin{equation}
h_r=\varepsilon\sigma\left(T_s^2+T_\infty^2\right)\left(T_s+T_\infty\right)\ ,
\end{equation}

where $\varepsilon$ is the emissivity of the last conduction layer, $\sigma$ is the
Stefan-Boltzmann constant, $T_s$ is the surface temperature of the last conduction layer,
and $T_\infty$ is the far-field temperature.

The surface temperature is implicitly dependent on the heat flux, so an underrelaxed
fixed point iteration is used to solve for $T_s$ at each quadrature point.

The thermal resistance concept does not apply to conducting slabs with heat sources
or systems undergoing transients. This boundary condition should only be applied to steady-state
or pseudo-steady transients.

The `emissivity` parameter represents the emissivity of the _surface_, or last layer,
of the conducting slabs.

#### Example input syntax

In this example, we set thermal resistance boundary conditions on the `top` and `left` boundaries.
We specify emissivity, thermal conductivity and convective heat transfer coefficients to model those
three heat transfer mechanisms where present (they are set to 0 when absent).

The inner iteration parameters are exposed for the `left` boundary. This is only meant to be used
to fine-tune a simulation for performance, or if convergence difficulties are encountered for that
boundary.





## fvkernels

### FVHeatConductionTimeDerivative

#### Description

The `FVHeatConductionTimeDerivative` kernel implements the residual

\begin{equation}
\int_{\Omega_C} \rho c_p \frac{\partial u}{\partial t} dV
\end{equation}

where $\rho$ is the material density, $c_p$ is the specific heat capacity at
constant pressure and $u$ the temperature variable.




### FVThermalRadiationSourceSink

#### Description

The `FVThermalRadiationSourceSink` kernel implements the source and the sink
terms for radiation heat transfer.
The term added reads as follows:

\begin{equation}
- \int_{\Omega_C} \kappa (\sigma T_{rad}^4 - G) dV
\end{equation}

where:

-  $G$ is the radiation heat flux (SI units (W/m$^2$))
-  $\kappa$ is the oppacity (SI units (1/m))
-  $\sigma$ is the Stefan-Boltzmann constant (SI units (W/m$^2$/K$^4$))
-  $T_{rad}$ is the rqadiation temperature (SI units (K))




## interfacekernels

### ConjugateHeatTransfer


#### Description

This `InterfaceKernel` models conjugate heat transfer between a solid and a fluid.
At the interface the condition:

\begin{equation}
  -k \vec{n} \cdot \nabla T_s = h (T_s - T_f)
\end{equation}

is imposed. In this equation $k$ is the solid thermal conductivity, $T_s$ is the solid
temperature, $h$ is the heat transfer coefficient, and $T_f$ is the fluid temperature.

The condition is applied directly in the fluid equation where $h (T_f - T_s)$ appears as
a boundary contribution. In the solid equation, integration of the heat conduction term
results in a $-k \vec{n} \cdot \nabla T_s$ integrated over the boundary. The above equality
is used to substitute the right hand side.

Note, in general the fluid energy equation does not need to be solved for temperature.
Therefore, the parameter `variable` may be tied to internal energy. For these cases, the
parameter `T_fluid` must be provided.

This class adopts the convection that the primary side is the fluid side and the secondary side
is the solid side. Therefore, `variable` expects the primary variable of the fluid energy
equation and `neighbor_var` expects the solid temperature. It is assumed that the solid energy
equation is solved for the solid temperature.

#### Example Input File Syntax

 block=InterfaceKernels





### SideSetHeatTransferKernel


#### Description

This kernel models the heat transfer across a side set using all three heat transfer mechanisms. The purpose is to model the heat transfer across a small gap without modeling the gap itself. The heat transfer mechanisms for each side of the gap are described by the following equations:
\begin{equation}
  q''^{+}_{\mathrm{conduction}} = q''^{-}_{\mathrm{conduction}} = -C_{\mathrm{gap}} (T_{+}-T_{-}),
\end{equation}
\begin{equation}
  q''^{\pm}_{\mathrm{convection}} = \pm h_{\mathrm{gap}}^{\pm} (T_{\mathrm{bulk}} - T_{\pm}),
\end{equation}
\begin{equation}
  q''^+_{\mathrm{radiation}} = q''^-_{\mathrm{radiation}} = \epsilon^{-}_{\mathrm{eff}}T_{-}^4 -  \epsilon^{+}_{\mathrm{eff}}T_{+}^4,
\end{equation}
where the $+$ and $-$ indices indicate the primary and neighbor side of the boundary, respectively.

 - $C_{\mathrm{gap}}$ is the gap conductance typically defined as conductivity divided by gap width: `conductance`

 - $h_{\mathrm{gap}}^{\pm}$ is the convective heat transfer coefficient: `h_primary`/`h_neighbor`

 - $T_{\mathrm{bulk}}$ is the bulk temperature of the gap, either defined by a material property or variable: `Tbulk_mat` or `Tbulk_var`

 - $\epsilon^{\pm}_{\mathrm{eff}}$ is the effective emissivity: `emissivity_eff_primary`/`emissivity_eff_neighbor`

\begin{equation}
  \epsilon^{\pm}_{\mathrm{eff}} = \sigma\epsilon^{\pm}\frac{1-\rho^{\mp}}{1-\rho^{+}\rho^{-}}
\end{equation}

#### Example Input File Syntax

Using material properties generated from [SideSetHeatTransferMaterial](SideSetHeatTransferMaterial.md):


Using bulk gap temperature (for convection) as auxiliary variable:






### ThinLayerHeatTransfer


#### Description

This kernel models the heat transfer across a thin domain. The purpose is to model a thin domain with an interface. This will reduce number of mesh elements and avoid high aspect ratio elements within a thin domain. The flux for each side of the gap are defined by the following equations:

\begin{equation}
-n^+\cdot q^+ = \frac{dQ}{2}-\rho C_p(\frac{d}{2}\frac{\partial T^+}{\partial t}) - (-k\frac{T^- -T^+}{d})
\end{equation}
\begin{equation}
-n^-\cdot q^- = \frac{dQ}{2}-\rho C_p(\frac{d}{2}\frac{\partial T^-}{\partial t}) - (-k\frac{T^+ -T^-}{d})
\end{equation}
where the $+$ and $-$ indices indicate the primary and neighbor side of the boundary, respectively, $d$ is the layer thickness, $Q$ is a heat source in the layer and $k$, $C_p$ and $\rho$ are thermal conductivity, specific heat and density of the layer.

An example below is used to verify the thin layer heat transfer model. With the interface approach, heat transfer in the thin layer is solved at the interface. Its solution is compared against the case where a thin domain is explicitly represented in the finite element domain.

       style=width:650px;margin-left:70px;float:center;
       id=fig:two_bl_mesh
       caption=Finite element mesh used for thin layer heat transfer using interfacekernel.

       style=width:650px;margin-left:70px;float:center;
       id=fig:two_bl_temp
       caption=Temperature field for thin layer heat transfer using interfacekernel.

       style=width:650px;margin-left:70px;float:center;
       id=fig:three_bl_mesh
       caption=Finite element mesh used for thin layer heat transfer using a thin domain.

       style=width:650px;margin-left:70px;float:center;
       id=fig:three_bl_temp
       caption=Temperature field for thin layer heat transfer using a thin domain.

#### Example Input File Syntax

 block=InterfaceKernels





## kernels

### ADHeatConduction

#### Description

`ADHeatConduction` is the implementation of [HeatConduction](/HeatConduction.md) within the framework of [!ac](AD). Please see the [HeatConduction](/HeatConduction.md) documentation for more information.

#### Example Input File Syntax

The case demonstrates the use of `ADHeatConduction` where the
diffusion coefficient (thermal conductivity) is defined by an [ADGenericConstantMaterial](GenericConstantMaterial.md).

  start=Kernels
  end=Preconditioning
  remove=BCs






### ADHeatConductionTimeDerivative

#### Description

`ADHeatConductionTimeDerivative` is the implementation of [HeatConductionTimeDerivative](/HeatConductionTimeDerivative.md) within the framework of [!ac](AD). Please see the [HeatConductionTimeDerivative](/HeatConductionTimeDerivative.md) documentation for more information.

#### Example Input File Syntax

The case demonstrates the use of `ADHeatConductionTimeDerivative` where the
properties are defined by an [ADGenericConstantMaterial](GenericConstantMaterial.md)

  start=Kernels
  end=Materials
  remove=BCs




### ADJouleHeatingSource


#### Overview

`ADJouleHeatingSource` is the implementation of a heat source corresponding to
electric Joule heating, as in [JouleHeatingSource](JouleHeatingSource.md), within
the framework of automatic differentiation.

The strong form for `ADJouleHeatingSource` is defined as

\begin{equation}
q = \mathbf{J} \cdot \mathbf{E} = (\sigma_{elec} \nabla \phi) \cdot \nabla \phi
\end{equation}

where $\phi$ is the electrostatic potential and $\sigma_{elec}$ is the
electrical conductivity of the material. $\sigma_{elec}$ is defined as an
`ADMaterialProperty`. Within the heat transfer module, this property could
currently be provided by [ADElectricalConductivity](ADElectricalConductivity.md).

This class inherits from the [ADKernelValue](Kernel.md) class.

#### Example Input File Syntax

An example of how to use `ADJouleHeatingSource` can be found in the
heat transfer module test `transient_ad_jouleheating.i`.





### ADMatHeatSource

#### Description

`ADMatHeatSource` implements a force term in thermal transport to represent a
heat source. The strong form, given a domain $\Omega$ is defined as

\begin{equation}
\underbrace{-f}_{\textrm{BodyForce}} + \sum_{i=1}^n \beta_i = 0 \in \Omega
\end{equation}
where $f$ is the source term (negative if a sink) and the second term on the
left hand side represents the strong forms of other kernels. The `BodyForce`
weak form, in inner-product notation, is defined as

\begin{equation}
R_i(u_h) = (\psi_i, -f) \quad \forall \psi_i,
\end{equation}
where the $\psi_i$ are the test functions, and $u_h$ are the trial solutions in
the finite dimensional space $\mathcal{S}^h$ for the unknown ($u$).

Here, $f$ is given as a material property with an optional constant scalar. The
Jacobian is calculated automatically via automatic differentiation.





### AnisoHeatConduction

#### Description

`AnisoHeatConduction` implements the diffusion kernel in the thermal energy conservation equation, with an anisotropic material property for the thermal conductivity.
The strong form is

\begin{equation}
\underbrace{-\nabla\cdot(\mathbf{k}\nabla T)}_{\textrm{AnisoHeatConduction}} + \text{other kernels} = 0 \in \Omega
\end{equation}

where $\mathbf{k}$ is a tensor thermal conductivity (nine components) and $T$ is
temperature. The corresponding weak form,
in inner-product notation, is

\begin{equation}
R_i(u_h)=(\nabla\psi_i, \mathbf{k}\nabla u_h)\quad\forall \psi_i,
\end{equation}

where $u_h$ is the approximate solution and $\psi_i$ is a finite element test function.

The thermal conductivity is specified with a material property, [!param](/Kernels/AnisoHeatConduction/thermal_conductivity).

#### Example Input File Syntax

The case below demonstrates the use of `AnisoHeatConduction` where the diffusion
coefficient (thermal conductivity) is defined by an [AnisoHeatConductionMaterial](AnisoHeatConductionMaterial.md).

  start=Kernels
  end=Executioner
  remove=BCs




### AnisoHomogenizedHeatConduction


Einstein summation convention is used in this documentation page.

#### Description

This `Kernel` computes the right hand side of the equation

\int_Y \frac{\partial v}{\partial y_i}\lambda_{ij} \frac{\partial \chi^k}{\partial y_j} = -\int_Y \frac{\partial v}{\partial y_i}\lambda_{ik} \text{d}y

where $\lambda_{ik}$ is the thermal conductivity tensor, $y_i$ is the coordinate in the unit cell, and $\chi^k$ is the $k$-th characteristic function used for homogenizing the thermal conductivity.  It is used in conjunction with the [Anisotropic Heat Conduction](AnisoHeatConduction.md) `Kernel` and the [Homogenized Thermal Conductivity](HomogenizedThermalConductivity.md) `Postprocessor` to compute homogenized thermal conductivity values.

This homogenization is executed for a unit cell with periodic boundary conditions. For
any vector $\vec{y}_b$ on the boundary, the unit cell geometry must satisfy the condition:

\vec{n}(\vec{y}_b + \vec{p}) = -\vec{n}(\vec{y}_b),

where $\vec{n}$ is the outward normal vector, and $\vec{p}$ is the periodicity of the boundary where $\vec{y}_b$ is located.

This kernel is the anisotropic version of [HomogenizedHeatConduction](HomogenizedHeatConduction.md).
See [!cite](hales15homogenization) and [!cite](SONG2006710) for more details.

#### Example Input File Syntax






### HeatCapacityConductionTimeDerivative


This kernel uses the [DerivativeMaterialInterface](/DerivativeMaterialInterface.md) and accesses
derivatives of the heat capacity to build the Jacobian.

See also [/SpecificHeatConductionTimeDerivative.md]




### HeatConduction

#### Description

`HeatConduction` implements the diffusion kernel in the thermal energy conservation equation, with a material property for the diffusion coefficient. The strong form is

\begin{equation}
\underbrace{-\nabla\cdot(k\nabla T)}_{\textrm{HeatConduction}} + \text{other kernels} = 0 \in \Omega
\end{equation}

where $k$ is the diffusion coefficient (thermal conductivity) and $T$ is
the variable (temperature). The corresponding weak form,
in inner-product notation, is

\begin{equation}
R_i(u_h)=(\nabla\psi_i, k\nabla u_h)\quad\forall \psi_i,
\end{equation}

where $u_h$ is the approximate solution and $\psi_i$ is a finite element test function.

The diffusion coefficient is specified with a material property; the
[!param](/Kernels/HeatConduction/diffusion_coefficient)
parameter is used to define the material property name
which contains the diffusion coefficient.
The Jacobian will account for partial derivatives of the diffusion coefficient
with respect to the unknown variable if the [!param](/Kernels/HeatConduction/diffusion_coefficient_dT) property
name is provided. These particular defaults for these parameters
are the names used by [HeatConductionMaterial](HeatConductionMaterial.md),
though you can also define these materials using other [Material](Materials/index.md) objects.

#### Example Input File Syntax

The case below demonstrates the use of `HeatConduction` where the diffusion
coefficient (thermal conductivity) is defined by a `HeatConductionMaterial`.

  start=Kernels
  end=BCs

The case below instead demonstrates the use of `HeatConduction` where the
diffusion coefficient (thermal conductivity) is defined by a [ParsedMaterial](ParsedMaterial.md)

  start=Kernels
  end=Executioner
  remove=BCs




### HeatConductionTimeDerivative

#### Description

`HeatConductionTimeDerivative` implements the time derivative term in the
thermal energy conservation equation. The strong form is

\begin{equation}
\label{eq:hctd}
\underbrace{\rho C_p\frac{\partial T}{\partial t}}_{\textrm{HeatConductionTimeDerivative}} + \text{other kernels} = 0 \in \Omega
\end{equation}

where $\rho$ is density, $C_p$ is the volumetric isobaric specific heat, and $T$ is
temperature.

This strong form does *not* assume that $\rho$ or $C_p$ are constant. Eq. [eq:hctd] is the rigorously-derived form which can be used for $\rho$ and $C_p$ which are not constant.

The corresponding weak form using inner-product notation is

\begin{equation}
R_i(u_h) = (\psi_i, \rho c_p\frac{\partial u_h}{\partial t}) \quad \forall \psi_i,
\end{equation}

where $u_h$ is the approximate solution and $\psi_i$ is a finite element test function.

The density and specific heat are specified with material properties,
and the [!param](/Kernels/HeatConductionTimeDerivative/density_name) and
[!param](/Kernels/HeatConductionTimeDerivative/specific_heat) parameters are used to define the material property
name providing those properties.
The Jacobian will account for partial derivatives of $\rho$ and $C_p$
with respect to the unknown variable if the [!param](/Kernels/HeatConductionTimeDerivative/density_name_dT) and [!param](/Kernels/HeatConductionTimeDerivative/specific_heat_dT) property
names are also provided.

See also [/HeatCapacityConductionTimeDerivative.md] and [/SpecificHeatConductionTimeDerivative.md].

#### Example Input File Syntax

The case below demonstrates the use of `HeatConductionTimeDerivative` where the
density and specific heat are defined by a [HeatConductionMaterial](/HeatConductionMaterial.md) (for specific heat) and a [ParsedMaterial](ParsedMaterial.md) for density.

  start=Kernels
  end=Executioner
  remove=BCs




### HeatSource

#### Description

The `HeatSource` kernel implements a volumetric heat source/sink forcing term. The strong form is

\begin{equation}
\underbrace{-\dot{q}}_{\textrm{HeatSource}} + \text{other kernels} = 0 \in \Omega
\end{equation}

where $\dot{q}$ is the volumetric heat source. The corresponding weak form,
in inner-product notation, is

\begin{equation}
R_i(u_h)=(\psi_i, -\dot{q})\quad\forall \psi_i,
\end{equation}

where $u_h$ is the approximate solution and $\psi_i$ is a finite element test function.

A slightly more general version of this same kernel can be found in [BodyForce](BodyForce.md), which you can equivalently use instead of `HeatSource`.

#### Example Input File Syntax

  block=Kernels




### HomogenizedHeatConduction


Einstein summation convention is used in this documentation page.

#### Description

This `Kernel` computes the right hand side of the equation of the equation

\int_Y \frac{\partial v}{\partial y_i}\lambda_{ij} \frac{\partial \chi^k}{\partial y_j} = -\int_Y \frac{\partial v}{\partial y_i}\lambda_{ik} \text{d}y

where $\lambda_{ik}$ is the thermal conductivity tensor, $y_i$ is the coordinate in the unit cell, and $\chi^k$ is the $k$-th characteristic function used for homogenizing the thermal conductivity.  
In this case, the thermal conductivity is isotropic, i.e. $\lambda_{ik} = \lambda \delta_{ij}$ with $k$ being the thermal conductivity and $\delta_{ij}$ being the Kronecker delta.
The equation simplifies to:

\int_Y \frac{\partial v}{\partial y_i}\lambda \frac{\partial \chi^k}{\partial y_j} = -\int_Y \frac{\partial v}{\partial y_k}\lambda \text{d}y

This kernel is used in conjunction with the [Heat Conduction](HeatConduction.md) `Kernel` and the [Homogenized Thermal Conductivity](HomogenizedThermalConductivity.md) `Postprocessor` to compute homogenized thermal conductivity values.

This homogenization is executed for a unit cell with periodic boundary conditions. For
any vector $\vec{y}_b$ on the boundary, the unit cell geometry must satisfy the condition:

\vec{n}(\vec{y}_b + \vec{p}) = -\vec{n}(\vec{y}_b),

where $\vec{n}$ is the outward normal vector, and $\vec{p}$ is the periodicity of the boundary where $\vec{y}_b$ is located.

See [!cite](hales15homogenization) and [!cite](SONG2006710) for more details.

#### Example Input File Syntax






### JouleHeatingSource


#### Overview

The strong form for `JouleHeatingSource` is defined as

\begin{equation}
q = \mathbf{J} \cdot \mathbf{E} = (\sigma_{elec} \nabla \phi) \cdot \nabla \phi
\end{equation}

where $\phi$ is the electrostatic potential and $\sigma_{elec}$ is the
electrical conductivity of the material. $\sigma_{elec}$ can either be an
`ADMaterial` or a traditional `Material`. Within the heat transfer module,
this default could currently be provided by
[ElectricalConductivity](ElectricalConductivity.md) for general problems or
[SemiconductorLinearConductivity](SemiconductorLinearConductivity.md) for more
specific problems related to semiconductors.

This class inherits from the [HeatSource](HeatSource.md) class via
[DerivativeMaterialInterface](DerivativeMaterialInterface.md) and
[JvarMapInterface](JvarMapInterface.md).

#### Example Input File Syntax

An example of how to use `JouleHeatingSource` can be found in the
heat transfer module test `transient_jouleheating.i`.





### SpecificHeatConductionTimeDerivative


This kernel uses the [DerivativeMaterialInterface](/DerivativeMaterialInterface.md) and accesses
derivatives of the specific heat and density to build the Jacobian.

See also [/HeatCapacityConductionTimeDerivative.md].




### TrussHeatConduction


This kernel provides the conduction term in the heat equation for truss elements, where the cross-sectional area of the truss should be taken into account. It is similar to the standard [HeatConduction](HeatConduction.md) kernel, but multiplies the contribution by a cross-sectional area, which is provided using a coupled variable:

\begin{equation}
\nabla \cdot (k A \nabla T)
\end{equation}
where A is cross-sectional area of the truss element, $k$ is thermal conduction of material.

This kernel should only be used for 1D line elements, which can be used to model heat conduction through networks of trusses in 1D, 2D, or 3D space. It is important to note that this should not be used for 1D models in 1D space if the intent is to model heat conduction through an infinite medium (in 1D Cartesian coordinates) or through an axisymmetric volume. The standard HeatConduction kernel should be used in those situations.




### TrussHeatConductionTimeDerivative


This kernel provides the time derivative term in the heat equation for truss elements, where the cross-sectional area of the truss should be taken into account. It is similar to the standard [HeatConductionTimeDerivative](HeatConductionTimeDerivative.md) kernel, but multiplies the contribution by a cross-sectional area, which is provided using a coupled variable:

\begin{equation}
\rho c_p A \frac{\partial T}{\partial t}
\end{equation}
where A is cross-sectional area of the truss element, $\rho$ is density of material, and $c_p$ is heat capacity of the material.

This kernel should only be used for 1D line elements, which can be used to model heat conduction through networks of trusses in 1D, 2D, or 3D space. It is important to note that this should not be used for 1D models in 1D space if the intent is to model heat conduction through an infinite medium (in 1D Cartesian coordinates) or through an axisymmetric volume. The standard HeatConductionTimeDerivative kernel should be used in those situations.




## materials

### ADElectricalConductivity


#### Overview

`ADElectricalConductivity` is the implementation of an electric conductivity
material property as in [ElectricalConductivity](ElectricalConductivity.md) within
the framework of automatic differentiation.

It is assumed here that resistivity varies linearly with temperature. This is
acceptable for small variations in temperature, but may break down if there are
larger temperature variations.

Resistivity ($\rho_{elec}$) with respect to temperature $T$ is defined as

\begin{equation}
  \rho_{elec}(T) = \rho_{ref} [1 + \alpha(T - T_{ref})]
\end{equation}

where $\rho_{ref}$ is the reference resistivity of the material, $\alpha$ is the
temperature coefficient of the material, and $T_{ref}$ is the reference
temperature.

Electrical conductivity can then be calculated via

\begin{equation}
  \sigma_{elec} = \frac{1}{\rho_{elec}}
\end{equation}

The defaults used for the parameters in this object are taken from published
values for Copper.

#### Example Input File Syntax

An example of how to use `ADElectricalConductivity` can be found in the
heat transfer module test `transient_ad_jouleheating.i`.





### AnisoHeatConductionMaterial


#### Description

The material model AnisoHeatConductionMaterial is used to model a material with anisotropic thermal properties. The thermal conductivity $k$ is represented as a rank two tensor:
\begin{equation}
  \begin{bmatrix}
  k_{11} & k_{12} & k_{13}\\
  k_{21} & k_{22} & k_{23}\\
  k_{31} & k_{32} & k_{33}\\
  \end{bmatrix}
  \label{eq:aeqn}
\end{equation}

It is mandatory for the user to supply the parameter `thermal_conductivity` as a vector with nine element '$k_{11}$ $k_{21}$ $k_{31}$ $k_{12}$ $k_{22}$ $k_{32}$ $k_{13}$ $k_{23}$ $k_{33}$'. The thermal conductivity can be set as a function of temperature ($T$) by providing the parameters `thermal_conductivity_temperature_coefficient_function` ($\alpha$) and the `reference_temperature` ($T_{ref}$). The thermal conductivity as a function of temperature $k(T)$ is expressed as:

\begin{equation}
 k(T) = k_{o} (1 + \alpha (T - T_{ref}) )
\end{equation}

where $k_{o}$ is the thermal conductivity based on the user supplied vector. The specific heat capacity $C_p$ can be supplied either as a constant value or as a function using the parameter `specific_heat`.

It should be noted that in some analyses the thermal conductivity could potentially depend on other variables (e.g. solute concentration). The user should provide off diagonal Jacobian contributions in these analyses.

#### Example Input Syntax






### ElectricalConductivity


#### Overview

It is assumed here that resistivity varies linearly with temperature. This is
acceptable for small variations in temperature, but may break down if there are
larger temperature variations.

Resistivity ($\rho_{elec}$) with respect to temperature $T$ is defined as

\begin{equation}
  \rho_{elec}(T) = \rho_{ref} [1 + \alpha(T - T_{ref})]
\end{equation}

where $\rho_{ref}$ is the reference resistivity of the material, $\alpha$ is the
temperature coefficient of the material, and $T_{ref}$ is the reference
temperature.

Electrical conductivity can then be calculated via

\begin{equation}
  \sigma_{elec} = \frac{1}{\rho_{elec}}
\end{equation}

The defaults used for the parameters in this object are taken from published
values for Copper.

#### Example Input File Syntax

An example of how to use `ElectricalConductivity` can be found in the
heat transfer module test `transient_jouleheating.i`.





### FunctionPathEllipsoidHeatSource


#### Description

This is a material for generating a moving heat source with an ellipsoidal shape that follows a user-defined path, with the volumetric heat source $Q$ being defined as follows:

\begin{equation}
  Q(x,y,z, t) = 6\sqrt{\frac{3}{\pi^3}}\frac{\alpha \eta P}{r_x r_y r_z}
                        \exp\left\{  -3\left[ \left(\frac{x-f_x(t)}{r_x} \right)^2 +
                        \left(\frac{y-f_y(t)}{r_y} \right)^2 +
                        \left(\frac{z-f_z(t)}{r_z} \right)^2  \right]\right\},
\end{equation}
where:\\
-  $P$ is the power\\
-  $\eta$ is the efficiency\\
-  $\alpha$ is the scaling factor\\
-  $r_x$, $r_y$, and $r_z$ are the effective heating spot radii in three directions\\
-  $f_x$, $f_y$, $f_z$ are the heating spot travel path in three directions

This material property is designed to model the heat generated by a laser beam during an additive manufacturing process, which should be applicable to heat sources that have similar characteristics.  Note, this is used together with the [ADMatHeatSource](ADMatHeatSource.md).

#### Example Input File Syntax

Following is an example input of the moving ellipsoid heat source:


The functions that specify the heat source moving path:








### GapConductanceConstant

#### Description

The `GapConductanceConstant` material provides a user-specified, constant
gap conductance that is used in thermal contact enforcement. This material
model is typically not directly specified by the user, but is created using
the `ThermalContactAction`, the details of which are documented in the
[ThermalContact](syntax/ThermalContact/index.md) system documentation page.






### HeatConductionMaterial


#### Description

`HeatConductionMaterial` is a general-purpose material model for heat conduction.  It sets
the thermal conductivity and specific heat at integration points.




### SemiconductorLinearConductivity


The [Steinhart-Hart equation](https://en.wikipedia.org/wiki/Steinhart%E2%80%93Hart_equation) is an empirical model for temperature dependent electrical resistance for semiconductors.  It is used in thermistor industry since it provides better expression of the temperature-resistance relationship.
\begin{equation}
\frac{1}{T}=A+B\ln(R)+C(\ln(R))^3
\end{equation}
where R is the resistance and T is the temperature in Kelvins.  $\sigma$, the electrical
conductivity, equals to 1/R.  A, B, and C are the Steinhart-Hart coefficients.  For some intrinsic
semiconductor materials, the log conductivity is a linear function of 1/T that the coefficient C = 0
(ref: "Introduction to Ceramics" by Kingery).  This model is for those materials only.

For conductivity data in $\log \sigma$ vs $\frac{1000}{T}$
\begin{equation}
\frac{1}{T} = A - B \ln 10 \cdot \log \sigma = A - B' \log \sigma
\end{equation}
where $B = B'/\ln 10$.

For the derivatives with respect to T:
\begin{equation}
\ln \sigma = \frac{1}{B}(A-\frac{1}{T})
\end{equation}

\begin{equation}
\sigma = \exp (\frac{1}{B}(A-\frac{1}{T})
\end{equation}

\begin{equation}
\frac{d \sigma}{dT} = \frac{1}{BT^2} \exp(\frac{1}{B}(A-\frac{1}{T}))
\end{equation}




### SideSetHeatTransferMaterial


#### Description

This is an interface material (boundary restricted material) specifically for application to [SideSetHeatTransferKernel](SideSetHeatTransferKernel.md). Material properties generated:

  - `gap_conductance`: $C_{\mathrm{gap}} = k_{\mathrm{gap}} / \delta$

  - `gap_Tbulk` : $T_{\mathrm{bulk}}$

  - `gap_h_primary` : $h^{+}_{\mathrm{gap}}$

  - `gap_h_neighbor` : $h^{-}_{\mathrm{gap}}$

  - `gap_emissivity_eff_primary` :

\begin{equation}
  \epsilon^{+}_{\mathrm{eff}} = \sigma\epsilon^{+}\frac{1-\rho^{-}}{1-\rho^{+}\rho^{-}}
\end{equation}

  - `gap_emissivity_eff_neighbor` :

\begin{equation}
  \epsilon^{-}_{\mathrm{eff}} = \sigma\epsilon^{-}\frac{1-\rho^{+}}{1-\rho^{+}\rho^{-}}
\end{equation}

$\sigma$ is the Stefan-Boltzmann constant defined as $5.670374419\times 10^{-8} \ W/m^2/K^4$.
The input variables that define these materials with their default values:

  - `conductivity`: $k(\vec{r},t)$ default: 0

  - `conductivity_temperature_function`: $k_{\mathrm{gap}}(\vec{r},T)$

  - `gap_temperature` : $T$ for $k_{\mathrm{gap}}(\vec{r},T)$

  - `gap_length` : $\delta$ default: 1

  - `Tbulk` : $T_{\mathrm{bulk}}$ default: 300 K

  - `h_primary` : $h^{+}_{\mathrm{gap}}$ default: 0

  - `h_neighbor` : $h^{-}_{\mathrm{gap}}$ default: 0

  - `emissivity_primary` : $\epsilon^{+}$ default: 0

  - `emissivity_neighbor` : $\epsilon^{-}$ default: 0

  - `reflectivity_primary` : $\rho^{+}$ default: $1-\epsilon^{+}$

  - `reflectivity_neighbor` : $\rho^{-}$ default: $1-\epsilon^{-}$


#### Example Input File Syntax

Defining conductivity as a space-time dependent function:


Defining conductivity as a temperature dependent function:






### ThermalCompliance


#### Overview

This material creates a thermal compliance, $K$, material based on temperature gradients and
thermal conductivities using the equation:

E=\frac{1}{2}\nabla T \dot K \dot \nabla T

The resulting material can be used for analysis purposes and for
setting up topology optimization Solid Isotropic Material Penalization-type of problems.

#### Example Input File Syntax





### ThermalSensitivity


#### Overview

TThis material takes a [`DerivativeParsedMaterial`](/DerivativeParsedMaterial.md) and uses its
derivative with respect to the [!param](/Materials/ThermalSensitivity/design_density) variable.
The 'design_density' can be a pseudo-density which is
employed to solve a solid isotropic material penalization (SIMP) topology optimization
problem. This sensitivity is intended to optimize a thermal compliance objective function.

#### Example Input File Syntax

This material can be used to optimize a multimaterial topology problem or in combination with
other physics, such as a small deformation elastic problem





## meshgenerators

### PatchSidesetGenerator

#### Description

This mesh generator splits a given sideset (`sideset` parameter) into `n` pieces (`n_patches`).
The pieces are referred to as patches. Patches are used for net radiation transfer method via
view factors. The sideset is divided into `n` patches using partitioner that are available from
libMesh. The new sidesets are named `<old_side_name>_<id>`, where `<id>` is a number running from
`0` to `n - 1`.

In addition to libMesh partitioners, this mesh generator also supports a grid partitioner. The
grid partitioner superimposes a 3-dimensional (where $d$ is the dimensionality of the problem) uniform, orthogonal grid
over the sideset and partitions the elements according to where the centroids of the
sideset faces fall on the orthogonal grid. The superimposed grid is congruent to the bounding box of the sideset to ensure
that the sideset is completely encompassed within the superimposed grid.

The superimposed orthogonal grid is _always_ 3-dimensional because the sideset (surface in 3D and line in 2D problems)
does not need to be orthogonal to any of the coordinate axes. The superimposed 3-dimensional mesh is aligned with the coordinate
axis and will have a single element in 1 (2) directions for 3 (2)-dimensional problems. These are discussed in turn:

- for 2-dimensional problems, sidesets are a collection of line segments so sidesets are 1-dimensional. The bounding box of the sideset
  is computed and the largest distance along any of the three axes is computed (i.e. $\max (x_{\text{max}}-x_{\text{min}}, y_{\text{max}}-z_{\text{min}},x_{\text{max}}-z_{\text{min}})$). The superimposed mesh has `n_patches` subdivisions along the longest axis and a single
  subdivision along the two shorter axes.
- for 3-dimensional problems, sidesets are a collection of faces so sidesets are 2-dimensional. The bounding box of the sideset
  is computed and the two largest distance along any of the three axes is computed (i.e. two largest from set $\{x_{\text{max}}-x_{\text{min}}, y_{\text{max}}-z_{\text{min}},x_{\text{max}}-z_{\text{min}}\}$). The superimposed mesh has a single subdivision along the axes with the smallest extent.
  The number of elements along the two larger dimensions are determined as follows:

  \begin{equation}
  \begin{aligned}
    n_1 &= \lfloor \sqrt{\frac{\Delta_1}{\Delta_2} n_p} \rfloor \\
    n_2 &= \lfloor \sqrt{\frac{\Delta_2}{\Delta_1} n_p} \rfloor,
  \end{aligned}  
  \end{equation}

  where $n_1$ and $n_2$ are the subdivisions along the longest and second longest axes and $n_p$ is equal to `n_patches`. Due to the rounding,
  the $n_1 \cdot n_2$ does not need to be equal to `n_patches` so the number of patches might be adjusted. A warning is printed if that happens.

#### Example Input Syntax





## physics

### HeatConductionCG

This [Physics](syntax/Physics/index.md) object implements the heat conduction equation over a
volumetric domain using a continuous Galerkin finite element discretization.

It creates the kernels for each term of the equation:

- the conduction term using [ADHeatConduction.md]
- the time derivative of the energy term using [ADHeatConductionTimeDerivative.md] if in a transient solve
- the heat source term using [ADCoupledForce](CoupledForce.md) if specified

The boundary conditions are created with:

- a [FunctorNeumannBC.md] for heat flux boundary conditions
- a [FunctorDirichletBC.md] for fixed temperature boundary conditions

A boundary condition object is created for each boundary, except if the same arguments
can be used across all boundaries in which case a single object is created and restricted to
the union of boundaries.




### HeatConductionFV

This [Physics](syntax/Physics/index.md) object implements the heat conduction equation over a
volumetric domain using a cell-centered finite volume discretization.

It creates the kernels for each term of the equation:

- the conduction term using [FVDiffusion.md]
- the time derivative of the energy term using [FVHeatConductionTimeDerivative.md] if in a transient solve
- the heat source term using [FVCoupledForce](CoupledForce.md) if specified

The boundary conditions are created with:

- a [FunctorNeumannBC.md] for heat flux boundary conditions
- a [FunctorDirichletBC.md] for fixed temperature boundary conditions

A boundary condition object is created for each boundary, except if the same arguments
can be used across all boundaries in which case a single object is created and restricted to
the union of boundaries.




### HeatConductionPhysicsBase

This class serves as a base class for `Physics` discretizing the heat conduction equations.
It notably:

- defines shared parameters
- sets up the initial condition for the temperature
- defines a default preconditioning using HYPRE's boomeramg

## postprocessors

### ConvectiveHeatTransferSideIntegral


#### Description

This postprocessor computes the total heat flux $Q$ by integrating
the product of the temperature difference and the heat transfer coefficient
over a set of boundaries.

\begin{equation}
 Q = \int\limits_{S} h (T_s - T_f)  dS,
\end{equation}

where $S$ is the set of boundaries, $T_s$ is the solid temperature, $T_f$ is the fluid temperature, and $h$ is the heat transfer coefficient.

This postprocessor is useful for ensuring conservative transfers when Robin boundary conditions are used.


#### Example Input File Syntax

block=Postprocessors






### ExposedSideAverageValue


This is used to compute the average of a variable over only the portion of a specified surface that is exposed, using the [SelfShadowSideUserObject](SelfShadowSideUserObject.md) to determine which portions of the surface are exposed and which are shadowed. This computation is identical to that performed in [SideAverageValue](SideAverageValue.md), except that only portions of the surface that are exposed (i.e., not shadowed) are included in the calculation.




### GrayLambertSurfaceRadiationPP


#### Description

This postprocessor extracts radiosity, heat flux density, or temperature from
the GrayLambertSurfaceRadiation userobject. The boundary from which this information
is extracted needs to be specified.

#### Example Input File Syntax

block=Postprocessors






### HomogenizedThermalConductivity


Einstein summation convention is used in this documentation page.

#### Description

This `PostProcessor` computes

\lambda^\text{H}_{ij}=\frac{1}{\left|\text{Y}\right|}\int_\text{Y}\left(\lambda_{ij} + \lambda_{ik} \frac{\partial \chi^j}{\partial y_k}\right)\;\text{d}\bm{y},

where $\lambda^\text{H}_{ij}$ is the $i,j$-th element of the homogenized thermal conductivity tensor, $\lambda_{ij}$ is the $i,j$-th element of the thermal conductivity tensor in the heterogeneous problem, $\chi^j$ is the j-th characteristic function defined as:

\int_Y \frac{\partial v}{\partial y_i}\lambda_{ij} \frac{\partial \chi^k}{\partial y_j} = -\int_Y \frac{\partial v}{\partial y_i}\lambda_{ik} \text{d}y


This `PostProcessor` is used in conjunction with the [Heat Conduction](HeatConduction.md) `Kernel` and the [Homogenized Heat Conduction](HomogenizedHeatConduction.md) `Kernel`.
An application can be found in [!cite](hales15homogenization).

First, compared to standard notation for homogenization theory applied to thermal conductivity (e.g. [!cite](SONG2006710)),
MOOSE computes $-\chi^j$. This is achieved by inverting the sign of the right hand side of [eq:1]. This leads to an inversion of the sign in the parenthesis in [eq:0].
Second, [eq:1] is the weak form of the equation typically provided in literature and integration by parts
on the right hand side leads to another sign flip.
Third, in contrast to [!cite](hales15homogenization) some notational inconsistencies are resolved in this document.

#### Example Input File Syntax









### ViewFactorPP


#### Description

This postprocessor extracts view factors between `from_boundary` to `to_boundary` from the view factor
userobject provided by `view_factor_object_name`.

#### Example Input File Syntax

block=Postprocessors






## raybcs

### ViewFactorRayBC


For more information, see [ViewFactorRayStudy.md] and [RayTracingViewFactor.md].




## userobjects

### ConstantViewFactorSurfaceRadiation

#### Description

`ConstantViewFactorSurfaceRadiation` implements the exchange of heat by radiation between
sidesets by the net radiation method.
The net radiation method is valid if the surfaces are gray, diffuse radiators.
The purpose of the `ConstantViewFactorSurfaceRadiation` is to provide the means
to model radiative exchange for coarse-grained model. `ConstantViewFactorSurfaceRadiation`
does not compute radiative exchange between element surfaces, but it computes radiative
transfer only in an average sense between sidesets.

The `ConstantViewFactorSurfaceRadiation` allows coupling radiative heat transfer to regions
where the heat equation is solved. The net heat transfer caused by radiative heat transfer is
coupled to the temperature field by `GrayLambertNeumannBC`. `ConstantViewFactorSurfaceRadiation` also supports the
definition of adiabatic and fixed temperature sidesets. The temperature variable, i.e. the
variable of the heat conduction equation, does not need to be defined on adiabatic and fixed
temperature boundaries. This is particularly useful in cavities, where temperature is only
defined on sidesets immediately adjacent to the heat conduction domain and not on the
adiabatic and isothermal walls enclosing the cavity. There are three different types of boundary
conditions in `ConstantViewFactorSurfaceRadiation`:

- `VARIABLE_TEMPERATURE` are sidesets where temperature is provided by the `temperature` variable.
  The heat equation is coupled to the `ConstantViewFactorSurfaceRadiation` through these boundaries.

- `FIXED_TEMPERATURE` are sidesets with temperature given as a function. The difference to `VARIABLE_TEMPERATURE`
  is that we do not need to solve for temperature on `FIXED_TEMPERATURE`. `FIXED_TEMPERATURE` sidesets
  can for example be the outside of a cavity that is in radiative heat transfer with the domain
  but is kept at constant temperature by being in contact with an effective coolant.

- `ADIABATIC` sidesets have a zero net heat-flux. This implies that the inflow of radiation has
  to equal the outflow of radiation. The surface temperature assumes the value at which this condition
  is true. `ADIABATIC` sidesets do not require the temperature variable to be defined.

#### Explanation of the input parameters

This paragraph describes the input structure of the `ConstantViewFactorSurfaceRadiation` object.
The following parameters are defined in detail:

- `temperature`: the user must provide the name of the temperature variable as the `temperature` parameter.
  `temperature` is the variable that the heat conduction equation solves for.

- `boundary` contains the names of _all_ sidesets that participate in the radiative heat exchange.

- `fixed_temperature_boundary` should list all sidesets that are fixed temperature boundaries.
  `fixed_temperature_boundary` must be a subset of the `boundary` array.

- `fixed_boundary_temperatures` contains function names specifying the temperatures on the fixed
  temperature boundaries. `fixed_boundary_temperatures` must be the same length as `fixed_temperature_boundary`.

- `adiabatic_boundary` should list all sidesets that are adiabatic boundaries.
  `adiabatic_boundary` must be a subset of the `boundary` array.

- `view_factors` lists the view factors $F_{i,j}$ from sideset $i$ to sideset $j$. The ordering of the
  `view_factors` follows the ordering in `boundary`. View factors must be added as square arrays. This may
  appear redundant because missing view factors can be computed using reciprocity, but this makes it impossible
  to check that each row of the view factor matrix sums to 1. This is absolutely necessary for conserving
  energy and ensuring stability of a coupled radiative transfer, heat conduction calculation. Row sums that
  are less than 5 percent off, are corrected to sum to 1. If the row sum is off by more than this threshold,
  an error is thrown. This is an example of the format of `view_factors` for three surfaces:

  \begin{equation}
      '~~F_{1,1} F_{1,2} F_{1,3} ;
       F_{2,1} F_{2,2} F_{2,3} ;
       F_{3,1} F_{3,2} F_{3,3} ~~'
  \end{equation}

#### Example Input syntax

block=UserObjects




### FunctorGapFluxModelConduction


#### Description

`FunctorGapFluxModelConduction` implements the same equations as
[GapFluxModelConduction.md], however, it uses the functor system to evaluate
needed quantities on-the-fly. The functor system is leveraged heavily by MOOSE's
finite volume discretizations. To use pre-initialized data, which is the
tradition for finite element discretizations, the [GapFluxModelConduction.md]
object may be the more appropriate object to use.

#### Example Input File Syntax


`FunctorGapFluxModelConduction` must be used in conjunction with the modular gap conductance
constraint as shown below:






### FunctorGapFluxModelRadiation


#### Description

`FunctorGapFluxModelRadiation` implements the same equations as
[GapFluxModelRadiation.md], however, it uses the functor system to evaluate
needed quantities on-the-fly. The functor system is leveraged heavily by MOOSE's
finite volume discretizations. To use pre-initialized data, which is the
tradition for finite element discretizations, the [GapFluxModelRadiation.md]
object may be the more appropriate object to use.

#### Example Input File Syntax


`FunctorGapFluxModelRadiation` must be used in conjunction with the modular gap conductance
constraint as shown below:






### GapFluxModelConduction


#### Description

`GapFluxModelConduction` computes a conductive heat flux across a gap following the existing implementation of radiation physics. It is used by
[ModularGapConductanceConstraint.md](ModularGapConductanceConstraint.md).

The user is required to select the appropriate `gap_geometry_type` parameter (PLATE, CYLINDER, or SPHERE) for the model geometry in [ModularGapConductanceConstraint.md](ModularGapConductanceConstraint.md). Two-dimensional Cartesian geometries are not restricted to be in or parallel to the X-Y coordinate plane.






### GapFluxModelPressureDependentConduction


#### Description

`GapFluxModelPressureDependentConduction` computes a conductive heat flux across
a closed gap between two solid bodies as a function of the normal mechanical pressure
at the interface. The normal contact pressure is included in this calculation as
a Lagrange multiplier associated with a lower-dimensional domain. This class
requires the use of [ModularGapConductanceConstraint](ModularGapConductanceConstraint.md).

The thermal conductance of the interface is calculated as
\begin{equation}
  \label{eq:pressureDepConductivity}
  C_T = \alpha k_{harm} \frac{P}{H_{harm}}
\end{equation}
where $\alpha$ is a scaling or fitting parameter, k$_{harm}$ is the harmonic mean
of the thermal conductivities, P is the contact pressure, and H$_{harm}$ is the
harmonic mean of the material hardness, following [!citep](cincotti2007modeling).
The harmonic mean of the thermal conductivities is given as
\begin{equation}
  \label{eq:harmonicMean}
  k_{harm} = \frac{2 k_1 k_2}{k_1 + k_2}
\end{equation}
where k$_1$ and k$_2$ are the thermal conductivities of the two materials on either
side of the closed gap interface. The harmonic mean of the hardness values is
calculated in a similar fashion.

##### Analytical Solution

Using this heat flux object alone, the temperature of the hotter material at the
interface, T$^h_{int}$, is given by the analytical expression
\begin{equation}
T^h_{int} = \frac{T^c_{BC}C_T k_c + T^h_{BC} k_h \left(k_c +C_T \right)}{k_h (k_c + C_T) + k_c C_T}
\end{equation}
and the temperature of the cooler material at the interface, T$^c_{int}$, is
\begin{equation}
T^c_{int} = \frac{T^h_{int} C_T + T^c_{BC} k_c}{k_c + C_T}
\end{equation}
where T$^h_{BC}$ and T$^c_{BC}$ are the prescribed hot and cool temperature boundary
conditions, respectively, k$_h$ and k$_c$ are the thermal conductivities of the
materials associated with the hot and cool temperatures, and C$_T$ is the thermal
conduction at the interface as given by [eq:pressureDepConductivity].
Note that these expressions were derived assuming no deformation and unit thickness
of both materials in the direction of the temperature gradient.

#### Example Input File Syntax


`GapFluxModelPressureDependentConduction` must be used in conjunction with the modular gap conductance
constraint as shown below:






### GapFluxModelRadiation


#### Description

`GapFluxModelRadiation` computes a radiative heat flux across a gap following the
diffusion approximation of radiation physics. This user object must be used in
combination with [ModularGapConductanceConstraint](ModularGapConductanceConstraint.md).

The heat flux across the gap is given by the classical expression
\begin{equation}
  \label{eqn:radiationHeatFlux}
  q_r = \sigma F_e \left( T_s^4 - T_f^4 \right) \sim h_r \left(T_s - T_f \right)
\end{equation}
where $\sigma$ is the Stephan-Boltzmann constant, $F_e$ is an emissivity function,
$T_s$ is the surface temperature, $T_f$ is the farfield temperature, and $h_r$
is the radiant gap conductance. This expression can be rearranged to solve for $h_r$:
\begin{equation}
  h_r = \sigma F_e \frac{\left( T_s^4 - T_f^4 \right)}{\left( T_s - T_f \right)}
\end{equation}
which reduces to
\begin{equation}
  \label{eqn:radiantGapConductance}
  h_r = \sigma F_e \left( T_s^2 + T_f^2 \right) \left( T_s + T_f \right).
\end{equation}

If the coordinate system type is Cartesian, the emissivity is computed using an
infinite parallel plate approximation given by
\begin{equation}
  \label{eqn:emissivityFunction}
  F_e = \frac{1}{\left( 1/e_s + 1/e_f -1 \right)}
\end{equation}
where $e_s$ and $e_f$ are the near surface and farfield emissivity values,
respectively. The primary and secondary surface emissivity values can be assigned
arbitrarily to $e_s$ and $e_f$. For an axisymmetric coordinate system, the
emissivity is computed using the same formula as that given in
[FVInfiniteCylinderRadiativeBC.md]:

\begin{equation}
\frac{e_s e_f r_f}{e_f r_f + e_s r_s \left(1 - e_f\right)}
\end{equation}

Here the $s$ subscript should correspond to whichever surface (secondary or
primary) has the smaller radius, and the $f$ subscript should correspond to
whichever surface has the larger radius.

#### Example Input File Syntax


`GapFluxModelRadiation` must be used in conjunction with the modular gap conductance
constraint as shown below:






### GapFluxModelRadiative


#### Description

This particular class, `GapFluxModelRadiative` represents an early implementation
of the modular gap flux constraint system and has limited functionality. The more
robust radiative heat flux class, [GapFluxModelRadiation](GapFluxModelRadiation.md)
is recommended for use instead.

`GapFluxModelRadiative` computes a radiative heat flux across a gap. It is used by
[ModularGapConductanceConstraint](ModularGapConductanceConstraint.md).





### GapFluxModelSimple


#### Description

`GapFluxModelSimple` computes a radiative heat flux across a gap. It is used by
[ModularGapConductanceConstraint](ModularGapConductanceConstraint.md).





### RayTracingViewFactor


#### Description

`RayTracingViewFactor` uses the ray tracing module to compute view factors for general cavities.
`RayTracingViewFactor` does not require the faces of the cavity to be planar and it allows obstruction.
Obstruction refers to the situation of boundary `a`'s line of sight to boundary `b` being obstructed
by boundary `c`, where `a`, `b`, and `c` are boundaries participating in the radiative heat exchange.
`RayTracingViewFactor` follows the general concept of radiative heat transfer geometries in MOOSE.
A set of boundaries is in radiative heat transfer through a cavity filled with a transparent medium;
the boundaries completely enclose the cavity so energy cannot leave the cavity by radiation.

For MOOSE's raytracing to work, the cavity +must+ be meshed. The view factors are computed by essentially
computing the integrals in [UnobstructedPlanarViewFactor.md]. The difference
from [UnobstructedPlanarViewFactor.md] is that the raytracer follows the
ray drawn from starting to ending quadrature points and determines if the ray collides with any of the boundaries
participating in the radiative heat transfer before it reaches the ending quadrature point. The view factor integrals
are only incremented by the contribution associated with the starting/ending quadrature point if no collision with any boundary
occurred.

The `RayTracingViewFactor` requires a [ViewFactorRayStudy.md] for computing the view factors. The user should
read the corresponding documentation.

#### Important Convention on Boundaries and Normals

Boundaries (or synonymously sidesets) are a collection of element faces. An element face in MOOSE is identified
by the element id and a *local* face id. As a consequence, a face belongs to a particular element because it's
simply one of the element's faces. For element faces on the domain boundary it is clear which element they belong to
because there is no other element across the face. However, for internal faces the question which of the two neighboring
elements an element face belongs to is important. An example helps to clarify. Let's assume that element `e1` and `e2`
are neighbors and that they are adjacent across an element face that have the local indices `s1` and `s2` in elements
`e1` and `e2`, respectively. Element face `(e1, s1)` belongs to element `e1`, while element face `(e2, s2)` belongs to
element `e2`. This is important when applying boundary conditions on boundaries that are not domain boundaries. Let's say
element `e1` belongs to block `b1` and element `e2` belongs to block `b2` and we want to apply boundary conditions for the
heat equation solved on block `b1`. In this case, the boundary that we apply boundary conditions for the heat equation
must be composed of element faces belonging to `b1`. Going back to our two neighboring example elements, the face `(e1,s1)`
must be added to the boundary because it belongs to element `e1` which belongs to block `b1` which defines the temperature.
If the user tries to impose the boundary condition on element face `(e2,s1)` MOOSE will segfault. This distinction between
internal and external boundaries is important to understand how to define boundaries around radiation cavities.  

Boundaries enclosing a cavity are either external or internal boundaries. External boundaries
do not have a neighbor on the other side of the face, while internal boundaries have valid elements on
both sides of it. For external boundaries, the sideset must belong to one of the cavity blocks simply because there
are no elements on the other side of the sideset.

However, for internal sidesets the cavity boundary +must+ belong to the element right outside of the cavity.
If element face `(e1, s1)` is just outside of the cavity and `(e2, s2)` is immediately on the other side inside of the cavity,
then `(e1, s1)` should be used to construct the sideset. The reason is that internal sidesets will usually solve coupled
heat conduction problems on the block just outside the cavity and boundary conditions for the temperature defined on this
block must be imposed on the heat conduction/cavity interface.

The [SideSetsBetweenSubdomainsGenerator.md] mesh generator can be used for setting up
cavity boundaries. In this mesh generator, the sidesets will belong to the "primary" side. Returning to the example,
if [!param](/Mesh/SideSetsBetweenSubdomainsGenerator/primary_block) is `b1` and [!param](/Mesh/SideSetsBetweenSubdomainsGenerator/paired_block) is `b2`, then `(e1,s1)` will be the element faces used in the new sideset.
Specifically, the [!param](/Mesh/SideSetsBetweenSubdomainsGenerator/primary_block) are the blocks around the cavity, while [!param](/Mesh/SideSetsBetweenSubdomainsGenerator/paired_block) are the blocks inside the cavity.

#### Example Input syntax

block=UserObjects




### SelfShadowSideUserObject


#### Description

`SelfShadowSideUserObject` determines the illumination state (illuminated or in the shadow) of every quadrature point in a given sideset (or combination of sidesets). It is used by
[DirectionalFluxBC](DirectionalFluxBC.md).


#### Design

The side user object is executed on every side of the sideset. A list of processor local quadrature points for each element/side combination is compiled, and each side is decomposes in either line segments (in 2D) or triangles (in 3D). The lists of line segments or triangles are broadcast to all processors.

The coordinates in both lists are rotated so that the illumination direction is aligned with the x-axis (2D) or z-axis (3D), which simplifies the shadowing calculation. Each processor then loops over the list of processor local quadrature points and checks each if they are in the shadow of any line segment or triangle.





### UnobstructedPlanarViewFactor

#### Description

`UnobstructedPlanarViewFactor` computes the view factors between `n` planar sides in radiative heat exchange.
These sides need to be such that they do not obstruct each other. This is in particular true if the sides fully enclose
a convex volume. This is the intended purpose of this UserObject.

View factors $F_{i,j}$ from side $i$ to side $j$ are computed via a double loop over side elements and the quadrature points
defined on them. View factors are computed by numerically evaluating:

\begin{equation}
  F_{1,2} = \frac{1}{A_1 \pi} \int_{A_1} \int_{A_2}  \frac{\cos \beta_1 \cos \beta_2}{r^2}  dA_1 dA_2,
\end{equation}

where $r$ is the distance between two points on the surfaces $A_1$ and $A_2$ and $\beta_1$ and $\beta_2$ are the angles that the line connecting these two points make with the normals at surface one and two, respectively.

In two-dimensional geometries, a different formula is evaluated. It is derived from the original
formula by considering a geometry that is extruded from $-\infty$ to $\infty$ along the $z$-axis.
We denote by $r_0$ the distance between two points on surface one and two projected onto the plane orthogonal to the $z$-axis. The line projected on this plane makes angles $\beta_{1,0}$ and $\beta_{2,0}$ with the normals at surfaces one and two, respectively. Note that the normals have no component into the $z$-direction. The following relationships hold:

\begin{equation}
  \begin{aligned}
    r^2 &= r_0^2 + (z_1 - z_2)^2 \\
    \cos \beta_{1,0} &= \cos \beta_{1}  \frac{r_0}{\sqrt{r_0^2 + (z_1 - z_2)^2}}\\
    \cos \beta_{2,0} &= \cos \beta_{2}  \frac{r_0}{\sqrt{r_0^2 + (z_1 - z_2)^2}}\\
    A_1 &= \Delta z L_1 \\
    dA_1&= dz_1 dl_1 \\
    dA_2&= dz_2 dl_2.
  \end{aligned}
\end{equation}

The view factor is then given by:

\begin{equation}
  F_{1,2} = \lim\limits_{\Delta z \rightarrow \infty} \frac{1}{L_1 \Delta z \pi} \int_{L1} dl_1
  \int_{L2} dl_2
  \frac{\cos \beta_{1,0} \cos \beta_{2,0} r_0^2}{\pi}
  \left [ \int_{- \Delta z / 2}^{\Delta z / 2} dz_1
  \int_{- \Delta z / 2}^{\Delta z / 2} dz_2 \frac{1}{\left( r_0^2 + (z_1 - z_2)^2 \right)^2} \right]
\end{equation}

The integral in brackets evaluates to:

\begin{equation}
\int_{- \Delta z / 2}^{\Delta z / 2} dz_1
\int_{- \Delta z / 2}^{\Delta z / 2} dz_2 \frac{1}{\left( r_0^2 + (z_1 - z_2)^2 \right)^2}
 = \frac{\Delta z \pi}{2 r_0^3}.
\end{equation}

The view factors in two-dimensional geometry are consequently given by:

\begin{equation}
  F_{1,2} = \frac{1}{2 L_1} \int_{L1}  \int_{L2}
  \frac{\cos \beta_{1,0} \cos \beta_{2,0}}{r_0} dl_1 dl_2
\end{equation}

View factors should satisfy:

\begin{equation}
  \sum\limits_{j=1}^n F_{i,j} = 1,~i=1,..,n.
\end{equation}
This can be checked by setting the parameter `view_factor_tol` and it can be enforced via normalization by setting the
parameter `normalize_view_factor`.

It is stressed that this UserObject may give wrong results if obstruction is present

#### Example Input syntax

block=UserObjects




### ViewFactorObjectSurfaceRadiation

#### Description

`ViewFactorObjectSurfaceRadiation` inherits from `GrayLambertSurfaceRadiationBase` and allows automatic computation of view factors.
View factors for `ViewFactorObjectSurfaceRadiation` are provided by a `ViewFactorBase` object, e.g. [UnobstructedPlanarViewFactor](UnobstructedPlanarViewFactor.md).

#### Example Input syntax

block=UserObjects




### ViewFactorRayStudy


#### Description

`ViewFactorRayStudy` computes view factors in a cavity enclosed by sidesets.
The view factors are computed by sending out rays from a sidesets along directions
determined by an angular quadrature. Rays are followed and traced through the cavity until
they hit any sideset that is not declared a "symmetry sideset". The view factor between
the sending and receiving sidesets is computed from the number of rays starting from one
and ending on the other side.

`ViewFactorRayStudy` uses ray tracing for computing view factors in two-dimensional and three-dimensional cavities. It does not impose
any restrictions on the geometry of the cavity; in particular it allows non-planar surfaces in radiative exchange, non-convex cavities, and obstruction
of view between two surfaces by a third surface.

#### Theory

The central idea for computing view factors using ray tracing is to transform the integral over the target area into an integral over
angular direction (i.e., an integral over the field of view of any infinitesimal element on the starting surface). An angular quadrature
is used to numerically approximate the angular integral. To this end, the ray tracing module is used to follow rays along the directions
of the angular quadrature and determine which surface they intersect first. The ray is terminated on that surface and the contribution
to the view factor between the surface of origin and this surface is incremented.

The view factor, $F_{i,j}$, is defined as a double integral over patches $i$ and $j$. In 3D geometries, the view factor, $F_{i,j}$, is computed by:
\begin{equation}\label{eq:view_factor}
  F_{i,j} = \frac{1}{A_i \pi} \int_{A_i} \int_{A_j}  \frac{\cos \alpha_i \cos \alpha_j}{r_{i,j}^2}  dA_i dA_j
\end{equation}
where the integral is taken over points $\vec{r}_i$ on $A_i$ and $\vec{r}_j$ on $A_j$ on patches $i$ and $j$. For each combination of points $\vec{r}_i$ and $\vec{r}_j$, we define:

\begin{equation}
\begin{aligned}
    r_{i,j} &= \|\vec{r}_j - \vec{r}_i \|  \\
    \cos \alpha_i &=  \frac{\vec{n}_i \cdot \left( \vec{r}_j - \vec{r}_i \right) }{r} \\
    \cos \alpha_j &=  \frac{\vec{n}_j \cdot \left( \vec{r}_i - \vec{r}_j \right) }{r}
\end{aligned}
\end{equation}

where $\vec{n}_i$ is the normal vector on patch $i$ pointing into the cavity and $\vec{n}_j$ is the corresponding counterpart on patch $j$.

To facilitate the computation of view factors, we change the integration variable from $\vec{r}_j$ to angular direction $d \hat{\Omega}$.
The infinitesimal element $dA_j$ becomes:
\begin{equation}
    dA_j = \frac{r_{i,j}^2}{\cos \alpha_j} d \hat{\Omega}
\end{equation}
where $d \hat{\Omega} = \sin \alpha_i d\alpha_i d\omega$ and $\omega$ is the azimuthal angle of $\hat{\Omega}$ measured in a plane orthogonal to $\vec{n}_1$ with respect to an arbitrarily chosen vector in that plane.
The view factor is then computed by:
\begin{equation}
    F_{i,j} = \frac{1}{A_i \pi} \int_{A_i} \int_{\hat{\Omega} \in A_j}  \cos \alpha_1  ~dA_i d \hat{\Omega} = \frac{1}{A_i \pi} \int_{A_i} \int_{\hat{\Omega} \in A_j}  \hat{\Omega} \cdot \vec{n}_i~ dA_i d \hat{\Omega}
\end{equation}
where $\hat{\Omega} \in A_j$ are all angular directions (starting from $\vec{r}_i$) that intersect $A_j$ before intersecting any other radiation patch. We define $\mu_i = \cos \alpha_i$ and finally obtain:
\begin{equation}\label{eq:trafo_view_factor}
       F_{i,j} = \frac{1}{A_i \pi} \int_{A_i} \int_{\hat{\Omega} \in A_j} \mu_i~ dA_i d \hat{\Omega}
\end{equation}

Before discretizing [eq:trafo_view_factor], we rewrite it slightly by introducing the function $H_j\left(\vec{r},\hat{\Omega}\right)$ which is $1$ if
a ray starting from location $\vec{r}$ into direction $\hat{\Omega}$ makes its first intersection with surface $j$. Then [eq:trafo_view_factor] becomes

\begin{equation}\label{eq:trafo_view_factor_2}
 F_{i,j} = \frac{1}{A_i \pi} \int_{A_i} \int_{2 \pi^+} \mu_i H_j\left(\vec{r},\hat{\Omega}\right) ~dA_i d\hat{\Omega},
\end{equation}

The integral in [eq:trafo_view_factor_2] is discretized using a spatial quadrature over the area $i$ and an angular quadrature over $2 \pi^+$:

\begin{equation}\label{eq:trafo_trafo}
 F_{i,j} = \frac{1}{A_i \pi} \sum\limits_{l=1}^L  \sum\limits_{k=1}^K w_l \omega_k  \left(\hat{\Omega}_k\cdot \vec{n}_l\right) H_j\left(\vec{r}_l,\hat{\Omega}_k\right) ,
\end{equation}

where $l$ enumerates the spatial quadrature points, $k$ enumerates the angular directions, $\vec{r}_l$ is the location of spatial quadrature point $l$, $\vec{n}_l$ is the
normal at spatial quadrature point $l$, and $\hat{\Omega}_k$ is the k-th angular direction. The role of ray tracing in [eq:trafo_trafo] is to evaluate $H_j\left(\vec{r}_l,\hat{\Omega}_k\right)$.

`ViewFactorRayStudy` uses Gaussian product quadratures for integrals in space, and a half-range Gauss-Chebyshev quadrature in angle.
The selected angular quadrature is a half-range Gauss-Legendre-Chebyshev quadrature adopted from [!citep](WaltersLCQ) by first restricting the polar range to $0 < \mu_i < 1$ and rotating the angular directions so that the polar angle is measured with respect to $\vec{n}_i$ instead of $(0, 0, 1)$.

Symmetry surfaces require special treatment. The difference between surfaces that participate in the radiative transfer and symmetry surfaces is that
view factors are not computed for symmetry surfaces (i.e. if either surface $i$ or $j$ in $F_{i,j}$ is a symmetry surface, the view factor is not computed).
Rays neither start nor end on symmetry surfaces. Instead, rays are specularly reflected off of symmetry surfaces. This is facilitated by the ray tracing
module by using the [ReflectRayBC.md].

#### Example Input syntax

block=UserObjects





## utils

### Heat Transfer Models

The `HeatTransferModels` namespace provides various model functions relevant to heat transfer.

#### Cylindrical Thermal Conductance id=cylindrical_thermal_conductance

The function `cylindricalThermalConductance` computes the thermal conductance
across a cylindrical medium using a steady thermal resistance analysis [!citep](incropera2002):

\mathcal{H} = \frac{k}{\bar{r} \ln(r_o / r_i)} \,,

where

- $r_i$ is the inner surface radius,
- $r_o$ is the outer surface radius,
- $\bar{r}$ is the arithmetic mean radius, and
- $k$ is the medium thermal conductivity.

#### Cylindrical Gap Conduction Heat Flux id=cylindrical_gap_conduction_heat_flux

The function `cylindricalGapConductionHeatFlux` computes the heat flux $q$ at a point
across a cylindrical gap due to conduction, using the thermal conductance given
in [#cylindrical_thermal_conductance]:

q = \mathcal{H} (T_i - T_o) \,,

where

- $T_i$ is the inner surface temperature,
- $T_o$ is the outer surface temperature, and
- $\mathcal{H}$ is computed from [!eqref](eq:cylindrical_thermal_conductance).

Note that the convention here is that a positive heat flux corresponds to heat
moving from the inner surface to the outer surface.

#### Cylindrical Gap Radiation Heat Flux id=cylindrical_gap_radiation_heat_flux

The function `cylindricalGapRadiationHeatFlux` computes heat flux $q$ at a point
across a cylindrical gap due to radiation, assuming opaque, gray, diffuse surfaces
with infinitely long, concentric cylinders [!citep](incropera2002):

q = \frac{\sigma (T_i^4 - T_o^4)}{\mathcal{R}} \,,

\mathcal{R} = \frac{1}{\epsilon_i} + \frac{r_i}{r_o}
\left( \frac{1 - \epsilon_o}{\epsilon_o} \right) \,,

where $\sigma$ is the Stefan-Boltzmann constant.

Note that the convention here is that a positive heat flux corresponds to heat
moving from the inner surface to the outer surface.

## vectorpostprocessors

### SurfaceRadiationVectorPostprocessor


#### Description

SurfaceRadiationVectorPostprocessor outputs
a selection of temperature, heat_flux_density, radiosity, and emissivity
from a gray, diffuse view factor calculation for all participating boundaries.
The information is obtained from a `GrayLambertSurfaceRadiationBase` or derived
object.







### ViewfactorVectorPostprocessor


#### Description

ViewfactorVectorPostprocessor outputs the view factors between all
boundaries involved in a gray, diffuse view factor calculation.







# Level Set Module

The level set module provides basic functionality to solve the level set equation, the following
links provided detailed information on the theory and use of the level set module:

- [Theory Manual](level_set/theory.md)

## Examples


For reference the following tables list the objects contained within the level set module and a brief
description of their purpose; each object may be selected to navigate to a detailed page.

## Level Set Module Tasks

The following additional tasks should be completed to make the level
set module more useful and robust for real-world applications:

- Develop automated techniques for setting the various re-initialization tuning parameters ($\Delta
  \tau$, $\epsilon$, etc.), see the [Theory](level_set/theory.md) page for more details.
- Implement a signed-distance-preserving re-initialization scheme based on established methods,
  e.g. [!cite](min2010reinitializing).
- Implement additional stabilization techniques such as the Galerkin Least Squares
  [!cite](hughes1989VIII) method and "shock/discontinuity capturing" schemes
  [!cite](hughes1986beyond,shakib1991compressible).
- Create module-specific input file syntax for level set problems to simplify input file generation
  and usage.
- Solve additional benchmark problems with various stabilization and re-initialization schemes, and
    investigate different mesh refinement and adaptivity strategies for said problems.

## Objects, Actions, and, Syntax



## base

### LevelSetProblem

This object specialize the MOOSE problem object to add a custom call to the execution of the transfers between
MultiApps allowing for mesh adaptivity from the parent application to be applied to the sub-application. This is used
within the level set module to allow the parent application to govern the adaptivity of the mesh for a sub-application
that is performing level set reinitialization steps.

#### Example Syntax

The [LevelSetProblem](#) is invoked by setting the "type" parameter within the [Problem](Problem/index.md) of the
input file.





### LevelSetReinitializationProblem

This object specialize the MOOSE problem object to add a custom call to reset the simulation to an
initial state so that the level set reinitialization step can be repeated. The
[LevelSetReinitializationMultiApp](/LevelSetReinitializationMultiApp.md) object requires that the
sub-application has a Problem type of [LevelSetReinitializationProblem](#)

#### Example Syntax

The [LevelSetReinitializationProblem](#) is invoked by setting the "type" parameter within the [Problem](Problem/index.md) of the
input file.





## functions

### LevelSetOlssonBubble

[!cite](olsson2005conservative) define a level set function ($\Phi$) that differs from the traditional
signed distance function. They define a level set function ranging from 0 to 1 with a defined
thickness ($\epsilon$), which is a commonly referred to as a smeared Heaviside function
($H_{sm}(\Phi)$):

\begin{equation}
H_{sm}(\Phi) =
\begin{cases}
0, & \Phi < -\epsilon, \\
\frac{1}{2} + \frac{\Phi}{2\epsilon} + \frac{1}{2\pi}\sin(\frac{\pi\Phi}{\epsilon}), & -\epsilon \le \Phi \le \epsilon, \\
1, & \Phi > \epsilon.
\end{cases}
\end{equation}

Typically, the interface of the level set function is defined by the 0.5 contour and the interface or
boundary layer is defined between 0 and 1.

For example, the following code creates a "bubble" in the lower left corner in a domain ranging from
0 to 1 in the x- and y-direction, as shown in the figure.






### LevelSetOlssonPlane

[!cite](olsson2005conservative) define a level set function ($\Phi$) that differs from the traditional
signed distance function. They define a level set function ranging from 0 to 1 with a defined
thickness ($\epsilon$), which is a commonly referred to as a smeared Heaviside function
($H_{sm}(\Phi)$):

\begin{equation}
H_{sm}(\Phi) =
\begin{cases}
0, & \Phi < -\epsilon, \\
\frac{1}{2} + \frac{\Phi}{2\epsilon} + \frac{1}{2\pi}\sin(\frac{\pi\Phi}{\epsilon}), & -\epsilon \le \Phi \le \epsilon, \\
1, & \Phi > \epsilon.
\end{cases}
\end{equation}

Typically, the interface of the level set function is defined by the 0.5 contour and the interface or
boundary layer is defined between 0 and 1.

`LevelSetOlssonPlane` creates a plane that is defined by a point and a normal vector to the plane. The value is greater than 0.5 if the point is on the same side of the plane as the normal vector and less than 0.5 if it is on the opposite side.






### LevelSetOlssonVortex


One of the most often utilized benchmark problems for the level set equation involve a vortex
velocity field in two-dimensions that result in a full reversal of the advected variable after some
time. The LevelSetOlssonVortex provides the velocity in the x and y direction ($v_x$ and $v_y$)
defined by [!cite](olsson2005conservative) as:

\begin{equation}
\begin{aligned}
v_x &= \sin^2(\pi x)\sin(2\pi y) \\
v_y &= -\sin^2(\pi y) \sin(2\pi x)
\end{aligned}
\end{equation}

There are two methods defined for reversing the velocity direction ("instantaneous" and "cosine"). The
former simply switches the sine of the velocity at mid-point of the provided reversal time. The later
applies a cosine multiplier so that the reversal is smooth.

#### Example Input Syntax







## kernels

### LevelSetAdvection

The level set equation is typically defined as below. As shown in this equation, the
`LevelSetAdvection` kernel implements the advection portion of the equation.

\begin{equation}
\frac{\partial u}{\partial t} + \underbrace{\vec{v} \cdot \nabla u}_{\textrm{LevelSetAdvection}} = 0,
\end{equation}
where $u$ is the level set variable, $t$ is time, and $\vec{v}$ is a known velocity field that
advects the level set variable.

The weak form of this portion of the equation is defined as: find $u_h$ such that:

\begin{equation}
(\Psi_i, \vec{v}\cdot\nabla u_h) = 0.
\end{equation}

#### Example Syntax

This kernel is utilized from within the [`Kernels`](syntax/Kernels/index.md) block in conjunction
with a time derivative kernel ([TimeDerivative](/TimeDerivative.md)).





### LevelSetAdvectionSUPG

This kernel adds the Streamline Upwind/Petrov-Galerkin (SUPG) stabilization
term [!citep](brooks1982streamline, donea2003finite) to the advection term of the level set equation.

\begin{equation}
\label{eq:LevelSetAdvectionSUPG:weak}
\left(-\tau \vec{v} \psi_i,\, \vec{v}\cdot\nabla u_h\right) = 0,
\end{equation}
where $\vec{v}$ is the level set velocity, $f$ is the forcing term, and $\tau$ as defined below.

\begin{equation}
\label{eq:LevelSetAdvectionSUPG:tau}
\tau = \frac{h}{2\|\vec{v}\|},
\end{equation}
where $h$ is the element length.

#### Example Syntax

The LevelSetAdvectionSUPG [Kernel](syntax/Kernels/index.md) should be used in conjunction with a complete level set equation.
For example, the following provides the necessary objects for the complete level set equation
with SUPG stabilization.









### LevelSetForcingFunctionSUPG

This kernel adds the Streamline Upwind/Petrov-Galerkin (SUPG) stabilization
term [!citep](brooks1982streamline, donea2003finite)  to a forcing or source term of a partial differential equation:

\begin{equation}
\label{eq:LevelSetForcingFunctionSUPG:weak}
\left(-\tau \vec{v} \psi_i,\, f\right) = 0,
\end{equation}
where $\vec{v}$ is the level set velocity, $f$ is the forcing term, and $\tau$ as defined below.

\begin{equation}
\label{eq:LevelSetForcingFunctionSUPG:tau}
\tau = \frac{h}{2\|\vec{v}\|},
\end{equation}
where $h$ is the element length.

#### Example Syntax

The LevelSetForcingFunctionSUPG [Kernel](syntax/Kernels/index.md) should be used in conjunction with a forcing term. For
example, if a [BodyForce](/BodyForce.md) is defined as follows in the `[Kernels]` block.


Given the forcing term, it is then possible to add the SUPG term to the same forcing function in the `[Kernels]` block
as follows.









### LevelSetOlssonReinitialization

This kernel implements the non-time portion of the conservative "re-initialization" algorithm
of [!cite](olsson2007conservative) that transforms $u_h$ into a smooth function in the range $[0, 1]$
rather than a signed distance, which is useful for certain types of problems such as phase
identification. The weak form of the original re-initialization equation is: find $U_h$ such that

\begin{equation}
  \left(\frac{\partial U_h}{\partial \tau}, \psi_i\right) + \underbrace{\left(\nabla\psi_i, -f\hat{n}_{\ast} + \epsilon\nabla U_h\right)}_{\textrm{LevelSetOlssonReinitialization}} = 0
\end{equation}
where $\tau$ is the pseudo time
during the re-initialization, $\hat{n}_{\ast}$ is the normal vector
computed from the level set variable $u_h$ at pseudo time $\tau=0$,
$\epsilon$ is the interface thickness, $f\equiv U_h(1-U_h)$, and
$U_h(\tau=0) = u_h$.

To avoid any tangential diffusion, a modified re-initialization formulation is proposed by restricting compressive flux to normal direction. The weak form of the modified re-initialization equation is: find $U_h$ such that

\begin{equation}
  \left(\frac{\partial U_h}{\partial \tau}, \psi_i\right) + \underbrace{\left(\nabla\psi_i, -f\hat{n}_{\ast} + \epsilon\nabla U_h\cdot\hat{n}_{\ast}\hat{n}_{\ast}\right)}_{\textrm{LevelSetOlssonReinitialization}} = 0,
\end{equation}
where $\tau$ is the pseudo time
during the re-initialization, $\hat{n}_{\ast}$ is the normal vector
computed from the level set variable $u_h$ at pseudo time $\tau=0$,
$\epsilon$ is the interface thickness, $f\equiv U_h(1-U_h)$, and
$U_h(\tau=0) = u_h$.

When steady-state for $U_h$ is detected when (see [/LevelSetOlssonTerminator.md] the entire process
is repeated at time $t+\Delta t$.

Our preliminary numerical tests indicate that the original re-initialization formulation works better to maintain the smoothness of an interface, so the original re-initialization formulation is set to be default. The modified re-initialization formulation can be used by setting `use_modified_reinitilization_step = true` although additional work needs to be done to investigate its numerical instability issue.

#### Example Syntax

The LevelSetOlssonReinitialization kernel is typically employed in a reinitialization sub-app (see
the MOOSE [MultiApp](/MultiApps/index.md) system), within this context this Kernel is invoked with
the `[Kernels]` as follows.








### LevelSetTimeDerivativeSUPG

This kernel adds the Streamline Upwind/Petrov-Galerkin (SUPG) stabilization
term [!citep](brooks1982streamline, donea2003finite)  to the time term of the level set equation.

\begin{equation}
\label{eq:LevelSetTimeDerivativeSUPG:weak}
\left(-\tau \vec{v} \psi_i,\, \frac{\partial u_h}{\partial t}\right) = 0,
\end{equation}
where $\vec{v}$ is the level set velocity, $f$ is the forcing term, and $\tau$ as defined below.

\begin{equation}
\label{eq:LevelSetTimeDerivativeSUPGtUPG:tau}
\tau = \frac{h}{2\|\vec{v}\|},
\end{equation}
where $h$ is the element length.

#### Example Syntax

The LevelSetTimeDerivativeSUPG [Kernel](syntax/Kernels/index.md) should be used in conjunction with a complete level set equation.
For example, the following provides the necessary objects for the complete level set equation
with SUPG stabilization.








## multiapps

### LevelSetReinitializationMultiApp

The LevelSetReinitializationMultiApp, as the name suggests, is for executing the reinitialization
equation for the level set solution. This [MultiApp](/MultiApps/index.md) object requires that the
sub-application be using the [LevelSetReinitializationProblem](/LevelSetReinitializationProblem.md),
which allows for the proper resetting of the pseudo reinitialization time.

#### Example Syntax





## postprocessors

### LevelSetCFLCondition

Computes the minimum timestep based on the Courant-Friedrichs-Lewy (CFL) condition. The CFL condition, is defined as

\begin{equation}
C = \Delta t \sum_{i=1}^{n}\frac{u_{x_i}}{\Delta x_i} \leq C_{max},
\end{equation}
where $C$ is the Courant number, $C_{max}$ is the maximum allowed Courant number, $u$ is the magnitude of the velocity, $\Delta t$ is the time step, and $\Delta x$ is
the interval distance, and $i$, in three dimensions, represents the index for the $x$, $y$, and $z$ components.

The `LevelSetCFLCondition` postprocessor estimates $C$ by using the magnitude of the maximum velocity across
quadrature points of an element ($u_{max}$) and computing the minimum element length for all elements in the
finite element mesh ($h_min$):

\begin{equation}
C = \frac{u_{max}\Delta t}{h_{min}} \leq C_{max}.
\end{equation}

Finally, assuming that $C_{max} = 1$ the maximum allowable Courant number, the maximum allowable timestep is computed
as:

\begin{equation}
\Delta t \leq \frac{h_{min}}{u_{max}}.
\end{equation}

#### Example Syntax

The [LevelSetCFLCondition](#) is added to the input file in the [`Postprocessors`](/Postprocessors/index.md) block
as follows.


and it is designed to work to set the timestep within the [TimeStepper](/TimeStepper/index.md) block. Also, notice
that at this point is possible to apply a "scaling" factor to the computed timestep to allow the simulation to operate
at some level below the timestep limitation.





### LevelSetVolume

A [Postprocessor](/Postprocessors/index.md) object utilized for computing the area or volume of the inside or
outside of a level set contour. The value computed from this postprocessor is an estimate computed using a
weighted average of the level set variables values at each quadrature point of an element.

#### Example Syntax





## transfers

### LevelSetMeshRefinementTransfer

When solving the level set equation performing reinitialization of the level set variable is often required
to maintain its conservative or signed distance characteristics. Within MOOSE the reinitialization step of the solve
is handled using the [MultiApp](/MultiApps/index.md) system.

To allow for the sub-application that is performing the reinitialization to use the adapted mesh of the parent
application the mesh adaptivity information must be transferred from the parent application to the sub-application,
this transfer is performed by the [LevelSetMeshRefinementTransfer](#).

#### Example Syntax





## userobjects

### LevelSetOlssonTerminator

This object is utilized to terminate a level set reinitialization solve, when steady-state for $U_h$
(see [/LevelSetOlssonReinitialization.md]) is detected:

\begin{equation}
  \label{eqn:steady_state}
  \frac{\|U_h^{m+1} - U_h^{m}\|}{\Delta\tau} < \delta,
\end{equation}
where $\delta$ is a problem-dependent tolerance, and $U_h^m \equiv U_h(\tau=m\Delta \tau)$.  When
steady-state is achieved, $u_h$ is set equal to the re-initialized solution $U_h$, and the entire
process is repeated at time $t+\Delta t$.

#### Example Syntax





# Misc Module

Documentation for the misc module needs some work...

## Objects, Actions, and Syntax


## auxkernels

### CoupledDirectionalMeshHeightInterpolation


#### Description

This object scales a user-provided coupled variable (either a solution variable or an auxiliary variable) by its position relative to the maximum and minimum coordinate of the undeformed mesh in a user-specified direction. When the coordinate is equal to the minimum coordinate, the scaling factor is 0, while when it is at the maximum coordinate, the scaling factor is 1. For locations between these mesh bounds, the scaling factor is linearly interpolated between those values.

#### Example Input File Syntax




## kernels

### ADThermoDiffusion

#### Description

`ADThermoDiffusion` implements thermodiffusion (also called thermophoresis, thermomigration, or the Soret effect)
or the movement of species due a temperature gradient. The mass flux $J$
is given as
\begin{equation}
\mathbf{J}=-S\nabla T
\end{equation}
where $S$ is Soret diffusion coefficient which is typically a combination of the
species concentration, temperature, and other material parameters. $S$ is kept
agnostic in this formulation and ultimately needs to be formulated in a separate
material property definition.





### CoefDiffusion

#### Description

`CoefDiffusion` implements a diffusion term using a simple floating point coefficient as the diffusivity.
It is equivalent to using [FunctionDiffusion.md] or [MatDiffusion.md] with a constant coefficient.





### ThermoDiffusion

#### Description

`ThermoDiffusion` implements thermodiffusion (also called thermophoresis, thermomigration, or the Soret effect),
or the movement of species due a temperature gradient. The mass flux $J$
is given as

\begin{equation}
\mathbf{J}=-S\nabla T
\end{equation}

where $S$ is Soret diffusion coefficient, which is typically a combination of the
species concentration, temperature, and other material parameters. $S$ is kept
agnostic in this formulation and ultimately needs to be formulated in a separate
material property definition.





## materials

### ArrheniusMaterialProperty


#### Description

`ArrheniusMaterialProperty` is used to declare an arbitrary material property $D$. For example, mass
diffusion coefficients are typically defined using an Arrhenius form [!citep](rpt:miller:2009)
\begin{equation}
D(T) = \sum_i D_{0,i}\exp{ \left( \frac{-Q_{i}}{RT} \right)}
\end{equation}
where $D_{0,i}$ is a pre-exponential factor, $Q_i$ is the activation energy, $R$ is the
universal gas constant, and $T$ is temperature. Also included is the derivative of $D$ with respect
to temperature.

#### Example Input Syntax






### Density / ADDensity


#### Description

The `Density` model creates a material property named density.  If coupled to displacement
variables, the model adjusts density based on deformation.




## postprocessors

### GeneralSensorPostprocessor


#### Description

`GeneralSensorPostprocessor` object implements a general sensor that takes in the calculated input signal from moose and outputs a realistic and sensor-mediated output that accounts for efficiency, drift, delay and noise of the sensor in question. This acts as a base class for [ThermocoupleSensorPostprocessor.md] class. The user can also employ the base class to realistically model any general sensor different from a thermocouple or a neutron counter. 

Drift, delay, efficiency, signal to noise factor, uncertainty, standard deviation of noise and standard deviation of uncertainty can be either a constant or time-dependent functions. The noise and the uncertainty terms are determined by sampling from a Gaussian with a mean of zero and a user-supplied standard deviation. $K_{p}$ and $K_i$ are multipliers for the proportional and the integral terms, respectively. The following equation shows the equation used to implement the `GeneralSensorPostprocessor`. The nomenclature for the table is given in the Table.

\begin{equation}
 \tilde{u}(t) =  u(t) + f_{SN}(t)n(\sigma(t)) 
\end{equation}

\begin{equation}
v(t) = \mu(t) + \eta(t) \left\{ K_p \tilde{u}(t-\tau(t)) + K_i \int_{0}^{t} \tilde{u}(t') R(t, t') dt' \right\} + \epsilon(\sigma(t))
\end{equation}



| Symbol           | Meaning                                       |
|------------------|-----------------------------------------------|
| $t$              | Time                                          |
| $v(t)$           | The output signal of the sensor               |
| $u(t)$           | MOOSE-calculated unknown                      |
| $\tau(t)$        | Delay interval (may be time-dependent)        |
| $\mu(t)$         | Bias or drift term (may be time-dependent)    |
| $\eta(t)$        | Efficiency of sensor (may be time-dependent)  |
| $n(\sigma(t))$   | Probability density function for the noise    |
| $\sigma(t)$      | Standard deviation (may be time-dependent)    |
| $f_{SN}(t)$      | Signal-to-noise factor                         |
| $K_p$            | Multiplier for the proportional term           |
| $K_i$            | Multiplier for the integration term            |
| $\epsilon(\sigma(t))$ | Uncertainty                               |
| $R(t, t')$ | Function used to capture convolution over time for delay term |






### InternalVolume


#### Description

`InternalVolume` computes the volume of an enclosed space. The complete boundary of the enclosed
 space must be represented by the user specified side set. The volume of the domain is calculated as
 the integral over the surface of the domain, where the domain surface is specified by the boundary.

If the given side set points outward, `InternalVolume` will report a negative volume.

As an example, consider
\begin{equation}
\int_V div(F) dV = \int_{dS} F \cdot \hat{n} dS
\end{equation}
where $F$ is a field, $\hat{n}$ is the normal of the surface, $V$ is the volume of the domain, and $S$ is
the surface of the domain.

For simplicity in this example, we choose
\begin{equation}
F = \left[ x, 0, 0 \right]^T \quad \text{then} \quad div(F) = 1
\end{equation}

such that the integral becomes

\begin{equation}
\int_V dV = \int_{dS} x \cdot n[0] dS
\end{equation}

The volume of the domain is the integral over the surface of the domain of the x position of the
surface times the x-component of the normal of the surface.

#### Example Input Syntax





### ThermocoupleSensorPostprocessor


#### Description

`ThermocoupleSensorPostprocessor` object implements a thermocouple sensor that takes in the calculated input signal from moose and outputs a realistic and sensor-mediated output that accounts for efficiency, drift, delay and noise of the sensor in question. Different types of thermocouples are included. This is a child class of `GeneralSensorPostprocessor`.

From the `GeneralSensorPostprocessor`,
\begin{equation}
 \tilde{u}(t) =  u(t) + f_{SN}(t)n(\sigma(t)) 
\end{equation}

\begin{equation}
v(t) = \mu(t) + \eta(t) \left\{ K_p \tilde{u}(t-\tau(t)) + K_i \int_{0}^{t} \tilde{u}(t') R(t, t') dt' \right\} + \epsilon(\sigma(t))
\end{equation}

For a thermocouple,
\begin{equation}
R(t, t') = \frac{e^{-(t-t')/\tau}}{\tau} ,
\end{equation}

\begin{equation}
K_p=0, K_i=1,
\end{equation}

\begin{equation}
v(t) =  \mu(t) + \eta(t)~\int_{0}^{t} \tilde{u}(t') e^{(t-t')/\tau}  dt'  + \epsilon(\sigma(t))
\end{equation}






module_loader

# Navier-Stokes Module

The MOOSE Navier-Stokes module is a library for the implementation of simulation tools that solve the
Navier-Stokes equations using either the continuous Galerkin finite element
(CGFE) or finite volume (FV) methods. The Navier-Stokes
equations are usually solved using either the pressure-based, incompressible formulation (assuming a
constant fluid density), or a density-based, compressible formulation, although
there are plans to add a finite volume weakly-compressible pressured-based implementation in
the not-too-distant future.

For documentation specific to finite element or finite volume implementations,
please refer to the below pages:

- [Incompressible Finite Volume](insfv.md)
- [Weakly Compressible Finite Volume](wcnsfv.md)
- [Porous media Incompressible Finite Volume](pinsfv.md)
- [Continuous Galerkin Finite Element](navier_stokes/cgfe.md)
- [Hybridized Discontinous Galerkin (HDG) Finite Element](NavierStokesHDGKernel.md)
- [Hybrid Continuous/Discontinuous Galerkin Finite Element](navier_stokes/hcgdgfe.md)
- [Compressible Finite Volume HLLC](CNSFVHLLCBase.md)
- [Porous media Compressible Finite Volume Kurganov-Tadmor](PCNSFVKT.md)
- [Porous media Compressible Finite Volume HLLC](PCNSFVHLLC.md)
- [Turbulence Modeling Theory](navier_stokes/rans_theory.md)

Here we give a brief tabular summary of the Navier-Stokes implementations:

| prefix     | Jacobian   | compressibility               | turbulence support          | friction support  | method | advection strategy                |
| ------     | --------   | ----------------------------- | --------------------------- | ----------------  | ------ | --------------------------------- |
| INS        | Hand-coded | incompressible                | None                        | Not porous        | CGFE   | SUPG                              |
| INSAD      | AD         | incompressible                | Smagorinsky                 | Not porous        | CGFE   | SUPG                              |
| INSFE      | Hand-coded | incompressible                | mixing length               | Not porous        | CGFE   | SUPG                              |
| PINSFE     | Hand-coded | incompressible                | mixing length               | porous            | CGFE   | SUPG                              |
| NS         | Hand-coded | compressible                  | None                        | Not porous        | CGFE   | SUPG                              |
| INSChorin  | Hand-coded | incompressible                | None                        | Not porous        | CGFE   | Chorin predictor-corrector        |
| INSFV      | AD         | incompressible                | mixing length; $k-\epsilon$ | Not porous        | FV     | RC, CD velocity; limited advected |
| WCNSFV     | AD         | weakly compressible           | mixing length               | Not porous        | FV     | RC, CD velocity; limited advected |
| WCNSFV2P   | AD         | weakly compressible; 2-phase  | mixing length               | Not porous        | FV     | RC, CD velocity; limited advected |
| PINSFV     | AD         | incompressible                | mixing length               | Darcy, Forcheimer | FV     | RC, CD velocity; limited advected |
| CNSFVHLLC  | AD         | compressible                  | None                        | Not porous        | FV     | HLLC, piecewise constant data     |
| PCNSFVHLLC | AD         | compressible                  | None                        | Darcy, Forcheimer | FV     | HLLC, piecewise constant data     |
| PCNSFVKT   | AD         | compressible                  | None                        | Darcy, Forcheimer | FV     | Kurganov-Tadmor, limited data     |

Table definitions:

- INS: incompressible Navier-Stokes
- AD: automatic differentiation
- WCNS: weakly-compressible Navier-Stokes
- WCNS2P: weakly-compressible Navier-Stokes 2-phase
- CNS: compressible Navier-Stokes
- PINS or PCNS: porous incompressible Navier-Stokes or porous compressible Navier-Stokes
- SUPG: Streamline-Upwind Petrov-Galerkin
- RC: Rhie-Chow interpolation
- CD: central differencing interpolation; equivalent to average interpolation
- HLLC: Harten Lax van Leer Contact
- data: includes both the advector, velocity, and the advected quantities
- limited: different limiters can be applied when interpolating cell-centered
  data to faces. A summary of limiter options can be found in
  [Limiters/index.md]

Note that the INS and INSFE kernel sets are redundant in terms of targeted
functionality. Historically, the INS kernel set was developed in this module and
the INSFE kernel set was developed in the SAM application (where there it was
prefixed with "MD") [!citep](hu2021sam). With
the Nuclear Energy Advanced Modeling and Simulation (NEAMS) program dedicated
to consolidating fluid dynamics modeling, SAM capabilities are being migrated
upstream as appropriate into the common module layer. In the not-too-distant
future these kernel sets will be consolidated into a single set.

For an introductory slideshow on the use of the Navier Stokes Finite Volume solvers in MOOSE, we refer the visitor to the [Navier Stokes Workshop Slides](slides/index.md optional=True).

As Navier-Stokes Finite Volume solvers continue to evolve in MOOSE, many new solvers have been added to the Navier-Stokes module. The following table provides a summary of the readiness of different solvers and the capabilities they support. Since many of these solvers are still under active development, feel free to reach out to the MOOSE team for updates on the latest progress or follow our monthly newsletter updates.

| Capability         | model                     | FE Newton  | FV Newton                                                    | FV Nonlinear SIMPLE                                          | FV Linear SIMPLE       |
| ------------------ | ------------------------- | ---------- | -----------------------------------------------------------  | ------------------------------------------------------------ | ---------------------- |
| Transient          |       --                  | Yes        | Yes                                                          | Yes                                                           | Yes                                                          |
| Turbulence         | Mixing length             | Yes        | Yes                                                          | Yes                                                          |                        |
|                    | $k-\epsilon$              |            | Yes                                                          | Yes                                                          | under development      |
|                    | $k-\omega$ SST            |            |                                                              | in [PR #28151](https://github.com/idaholab/moose/pull/28151) |                        |
| Two-phase          | Mixture model             | Yes        | Yes                                                          | Yes                                                          | in [PR #29614](https://github.com/idaholab/moose/pull/29614) |
|                    | Eulerian-Eulerian         |            |                                                              | Yes                                                          |                        |
| Porous Flow        |       --                  | Yes        | Yes                                                          | Yes                                                          |                        |
| Compressibility    | Incompressible            | Yes        | Yes                                                          | Yes                                                          | Yes                    |
|                    | Weakly compressible       |            | Yes                                                          | Yes                                                          | Yes                    |
|                    | Compressible              |            | Yes                                                          |                                                              |                        |
| Coupling           | Domain overlapping (SAM)  |            | Yes                                                          | Yes                                                          |                        |
|                    | Direct to THM             |            | in [PR #28528](https://github.com/idaholab/moose/pull/28528) |                                                              |                        |
|                    | MultiApp w/ Subchannel    |            | Yes                                                          |                                                              |                        |
| Scalar Transport   |       --                  |            | Yes                                                          | Yes                                                          | Yes                    |
| Physics Syntax     | Flow                      |            | Yes                                                          |                                                              | Yes                    |
|                    | Fluid heat transfer       |            | Yes                                                          |                                                              | Yes                    |
|                    | Solid phase heat transfer |            | Yes                                                          |                                                              |                        |
|                    | Two phase                 |            | Yes                                                          |                                                              | in [PR #29614](https://github.com/idaholab/moose/pull/29614) |
|                    | Turbulence                |            | Yes                                                          |                                                              |                        |
|                    | Scalar transport          |            | Yes                                                          |                                                              | Yes                    |



## actions

### CNSAction


#### Overview

This action is used for setting up Navier-Stokes equation over a subdomain.
Boundary conditions must cover the entire boundaries that enclose the subdomain.
This action is triggered with *Modules/CompressibleNavierStokes* input syntax.

#### Example Input File Syntax



### INSAction


#### Overview

This action is used for setting up incompressible Navier-Stokes equation over a subdomain.
Boundary conditions must cover the entire boundaries that enclose the subdomain.
This action is triggered with *Modules/IncompressibleNavierStokes* input syntax.

#### Example Input File Syntax


### NavierStokesFV Action

This class allows us to set up Navier-Stokes equations for porous medium or clean fluid flows using incompressible or weakly compressible approximations with a finite volume discretization.

This action is deprecated and is replaced by the `WCNSFVPhysics` classes. The deprecated
syntax can currently still be used. Please refer to the [section on how to transition to the new Physics syntax](NavierStokesFV/index.md#transition) for guidance on how to use the current syntax.

#### Overview

This action is used for setting up the Navier-Stokes equations over a subdomain
using a finite volume discretization. Furthermore, the action is able to handle
regular (clean fluid flow) or porous medium (flow within homogenized structures)
formulations using incompressible and weakly-compressible approximations.
This action is triggered with */Modules/NavierStokesFV* input syntax.
For more information, visit [NavierStokesFV](/Modules/NavierStokesFV/index.md). For more information
regarding the friction implemenation, visit [Friction Kernel](PINSFVMomentumFriction.md)

#### Example Input File Syntax

In this example, the equations, the wall/inlet/outlet boundary conditions and their parameters are all set automatically by the `NavierStokesFV` action.



### NSFVActionDeprecation

This action has been added to facilitate the deprecation of the [NavierStokesFVAction](NSFVAction.md).
It is used to detect the use of the `[Modules/NavierStokesFV]` syntax.
It will be removed once this action is removed past the deprecation period.

## auxkernels

### Courant


#### Overview

The `Courant` object computes the Courant number given coupled variables
representing velocity components (`u`, `v`, and `w`) and using the current
timestep size and element size. The Courant number formula is:

\begin{equation}
C = \frac{u\Delta t}{h}
\end{equation}

where $u$ is the norm of the velocity, $\Delta t$ is the timestep size, and $h$
is the local element size (units of length). Knowledge of the Courant number can
be very useful when determining timestep sizes when using explicit time
integrators as it is related to the
[Courant-Friedrichs-Lewy condition](https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition).




### EnthalpyAux


\begin{equation}
h = \dfrac{\rho e + P}{\rho}
\end{equation}

with $h$ the specific enthalpy, $\rho$ the density, $\rho e$ the total energy and
P$ the pressure.




### HasPorosityJumpFace


#### Overview

The `HasPorosityJumpFace` object returns values of 1 or 0. The object returns 1
if any face attached to an element has a jump in porosity value between the -
and + sides of the face. This object only takes elemental variables for its
`variable` parameter.




### INSCourant





### INSFVMixingLengthTurbulentViscosityAux


Computes the mixing length eddy viscosity used in the zero-equation turbulence
model:

\begin{equation}
  \nu_t = l_{m}^2 |2S_{ij}S_{ij}|
\end{equation}




### INSQCriterionAux

This calculates a scalar variable calculated as a function of the shear rate
properties of a fluid flow called $Q$ which is useful for visualizing complicated
flow patterns which tend to occur when running turbulent fluid flow simulations.
The quantity is calculated as:

\begin{equation}
Q = \frac{1}{2} (|| \bar{\bar{\Omega}} || - ||\bar{\bar{S}}||)
\end{equation}

With $\bar{\bar{\Omega}}$ and $\bar{\bar{S}}$ respectively being the antisymmetric
and symmetric strain rate tensors.
By taking the contour of $Q$ in a piece of visualization software where $Q=0$,
boundaries of vortices in the flow should be revealed. For more information,
see the paper [!cite](jeong1995).





### INSStressComponentAux

`INSStressComponentAux` calculates the stress (component) for an incompressible
Navier-Stokes simulation. Specify the `comp` param (allowed values 0, 1, 2) to
obtain the desired stress component. Note that the `velocity` parameter expects
a non-vector variable, e.g. this `AuxKernel` only currently makes sense with the
hand-coded set of INS objects.





### InternalEnergyAux





### kEpsilonViscosityAux

This is the auxiliary kernel used to compute the dynamic turbulent viscosity

\begin{equation}
\mu_t = \rho C_{\mu} k T_e \,,
\end{equation}

where:

- $\rho$ is the density,
- $C_{\mu} = 0.09$ is a closure parameter,
- $k$ is the turbulent kinetic energy,
- $\epsilon$ is the turbulent kinetic energy dissipation rate.
- $T_e = max( \frac{k}{\epsilon} , \sqrt(\frac{\nu}{\epsilon}) )$.

By setting parameter [!param](/AuxKernels/kEpsilonViscosityAux/bulk_wall_treatment) to `true`, the
kernel allows us to set the value of the cells on the boundaries specified in
[!param](/AuxKernels/kEpsilonViscosityAux/walls) to the dynamic turbulent viscosity predicted
from the law of the wall or non-equilibrium wall functions.
See [INSFVTurbulentViscosityWallFunction](INSFVTurbulentViscosityWallFunction.md) for more
details about the near-wall implementation.

If the boundary conditions for the dynamic turbulent viscosity are already set via [INSFVTurbulentViscosityWallFunction](INSFVTurbulentViscosityWallFunction.md),
there is no need to add bulk wall treatment, i.e., we should set
[!param](/AuxKernels/kEpsilonViscosityAux/bulk_wall_treatment) to `false`.
This type of bulk wall treatment is mainly designed for porous media formulations
with large computational cells.




### NSInternalEnergyAux





### NSLiquidFractionAux


The liquid fraction is defined as follows:

\begin{equation}
f_l =
\begin{cases}
f_l = 0, \text{ if } T < T_{solidus}, \\
f_l = \frac{T - T_{solidus}}{T_{liquidus} - T_{solidus},}, \text{ if } T \in (T_{solidus}, T_{liquidus}), \\
f_l = 1, \text{ if } T > T_{liquidus}, \\
\end{cases}
\end{equation}

where $T_{liquidus}$ and $T_{solidus}$ are the liquidus and solidus temperatures respectively;
note that $T_{solidus}$ must be less than $T_{liquidus}$.

The liquidus and solidus temperature must be defined by the user.
The larger the difference between these two temperatures, the more stable the numerical behavior of the code but the more diffusive the solutions obtained.

There is no need to define the solid fraction ($f_s$); it is defined internally in the solidification objects as $1 - f_l$.

The capping of the liquid fraction is done via a smooth function in `MOOSE` to avoid issues with the Jacobian at discontinuities.




### NSMachAux





### NSPressureAux





### NSSpecificTotalEnthalpyAux





### NSTemperatureAux





### NSVelocityAux





### PecletNumberFunctorAux


#### Overview

The `PecletNumberFunctorAux` object computes the element/cell Peclet number
given by

\begin{equation}
Pe = \frac{h u}{\alpha}
\end{equation}

where $u$ is the norm of the velocity, e.g. the speed, $h$ the largest dimension
of the element (computed using `_current_elem->hmax()`), and $\alpha$ is the
thermal diffusivity (or mass diffusivity if this object is being used to gauge
mass transfer). The Peclet number is a ratio of the importance of advective
transport to conductive/diffusive transport. If greater than ~1, then typically
advection discretizations should favor upstream over downstream values in order
to appropriately model the physics and produce a stable solution algorithm. For
both finite volume and finite element methods, this means leaning towards upwind
methods.




### RANSYPlusAux

Computes the dimensionless wall distance $y^+$. 

Four different formulations are supported for computing $y^+$ as defined by the [!param](/AuxKernels/RANSYPlusAux/wall_treatment) parameter.
Details on each of the four formulations can be found in 
[INSFVTurbulentViscosityWallFunction](source/fvbcs/INSFVTurbulentViscosityWallFunction.md).




### ReynoldsNumberFunctorAux


#### Overview

The `ReynoldsNumberFunctorAux` object computes the element/cell Reynolds number
given by

\begin{equation}
Re = \frac{\rho h u}{\mu}
\end{equation}

where $u$ is the norm of the velocity, e.g. the speed, $h$ the largest dimension
of the element (computed using `_current_elem->hmax()`), $\rho$ is the density,
and $\mu$ is the dynamic viscosity. The Reynolds number is a critical piece of a
fluid flow simulation as it is associated with transitions from laminar to
turbulent flows and also determines whether stabilization is needed. The
Reynolds number is a ratio of inertial forces to viscous forces. Large values of
the Reynolds number (e.g. >> 1) indicate advection or inertially dominated flows
(with the limit being an inviscid flow)
that require stabilization (typically upwinding) in order to reach a stable
solution. Low Reynolds numbers (e.g. << 1) are associated with viscous flows
(with the limit being Stokes flow) and are typically stable and do not require
stabilization.




### SpecificInternalEnergyAux


\begin{equation}
u = e - \dfrac{||\rho \vec{u}||_{L^2}}{2 \rho}
\end{equation}

with $u$ the specific internal energy, $e$ the specific total energy, and $\rho \vec{u}$ the
fluid momentum.




### SpecificVolumeAux


\begin{equation}
v = \dfrac{\alpha * A}{\rho}
\end{equation}

with $v$ the specific volume, $\alpha$ the volume fraction, $A$ the area and $\rho$ the density.




### TurbulentConductivityAux


#### Overview

This is the auxiliary kernel used to compute the thermal effective turbulent conductivity

\begin{equation}
k_t = \frac{c_p \mu_t}{Pr_t} \,,
\end{equation}

where:

- $c_p$ is the specific heat at constant pressure,
- $\mu_t$ is the dynamic turbulent viscosity,
- $Pr_t$ is the turbulent Prandtl number, which usually ranges between 0.3 and 0.9.




### WallDistanceMixingLengthAux

This auxkernel computes the turbulent mixing length by assuming that it is
proportional to the distance from the nearest wall. If a $\delta$ parameter is
set by the user, the mixing length takes on Escudier's modification to cap the
mixing length at a distance from the wall proportional to $\delta$. For more
details please refer to https://mooseframework.inl.gov/modules/navier_stokes/rans_theory.html.




### WallFunctionWallShearStressAux

This function computes the wall shear stress obtained using the standard
wall function in [INSFVWallFunctionBC](source/fvbcs/INSFVWallFunctionBC.md).
It assumes that the first cell centroid is located in the log layer.




### WallFunctionYPlusAux

Computes the dimensionless wall distance $y^+$ using the wall shear stress
calculation from the standard wall function [INSFVWallFunctionBC](source/fvbcs/INSFVWallFunctionBC.md).





## bcs

### AdvectionBC


This boundary condition accounts for advection of a scalar quantity $\phi$
by velocity $\vec{v}$.

It is usually applied on outflow boundary conditions and originates
from integration by parts of $\nabla \cdot (\vec{v} \phi)$. Multiplying by
test function $\psi$ and using Green's identity gives:
\begin{equation}
  \int_{\Omega}  \psi \nabla \cdot (\vec{v} \phi) d \Omega = - \int_{\Omega}  \nabla \psi  \cdot (\vec{v} \phi) d \Omega
  +  \int_{\partial \Omega}  \psi  \phi \vec{n} \cdot \vec{v}  d S.
\end{equation}
The boundary $\partial \Omega$ can be divided into two parts, inflow and outflow satisfying:
\begin{equation}
\begin{aligned}
\partial \Omega^-:&\vec{n} \cdot \vec{v} < 0 \\
\partial \Omega^+:&\vec{n} \cdot \vec{v} > 0
\end{aligned}
\end{equation}
Boundary conditions are applied on the inflow boundaries, e.g. the value of
$\phi$ may be known and is set by a Dirichlet boundary conditions. However, term:
\begin{equation}
  \int_{\partial \Omega^+}  \psi  \phi \vec{n} \cdot \vec{v} d S.
\end{equation}
still needs to be applied in the PDE. This is covered by AdvectionBC.




### EnergyFreeBC





### ImplicitNeumannBC





### INSADDisplaceBoundaryBC


This boundary condition displaces a boundary in proportion to a coupled
velocity. It is a strongly enforced boundary condition on every displacement
node with a residual of the form

\begin{equation}
u - (u_{old} + \Delta t \vec{v}_i)
\end{equation}

where $u$ denotes a given displacement vector component, $u_{old}$ is the
previous timestep's value of the displacement, $\Delta t$ is the timestep, and
$\vec{v}_i$ is a component of the coupled velocity vector, where $i$ denotes the
component.

Note that the formula above is appropriate for an [ImplicitEuler.md]
discretization of time derivatives. Consequently this class will error if the
time integrator used is not `ImplicitEuler`.

Using a Laplacian, e.g. something like [Diffusion.md], for the displacement
fields will smooth the interior mesh as the mesh is deformed through this
boundary condition. However, it is still possible to run into poor aspect ratio
elements, or if you have more tangential displacement at one boundary node than
another then you can get inverted elements.




### INSADDummyDisplaceBoundaryIntegratedBC


This object adds the sparsity dependence of the surface displacement degrees of
freedom on surface velocity degrees of freedom introduced by the nodal boundary
condition [INSADDisplaceBoundaryBC.md]. This sparsity must be added before
nodal boundary conditions are executed because the Jacobian matrix is assembled
prior to nodal boundary condition execution. At that time, if there is unused
sparsity in the matrix it is removed by PETSc. Hence the use of this object to
prevent new nonzero allocations during execution of `INSADDisplaceBoundaryBC`.




### INSADMomentumNoBCBC

The `INSADMomentumNoBCBC` class is used to implement the "No Boundary Condition"
developed by
[Griffiths](https://onlinelibrary.wiley.com/doi/abs/10.1002/(SICI)1097-0363(19970228)24:4%3C393::AID-FLD505%3E3.0.CO;2-O). According
to Griffiths, the "No Boundary Condition" is equivalent to imposing the
condition on the original analytical problem that the (p+1)st derivative of a finite element variable of order p
should vanish at a point close to the outflow. This is claimed to reduce error
relative to a natural boundary condition.





### INSADSurfaceTensionBC

This boundary condition implements effects of surface tension on a free
surface using the following expression:

\begin{equation}
\vec{n}\cdot \sigma_{liq} = -2 \mathcal{H} \sigma \vec{n} - \nabla_s \sigma \,,
\end{equation}

where $\mathcal{H}$ is the mean curvature of the surface, while
$\sigma$ describes the suface tension. In this context, $\nabla_s = (I-\vec{n}\vec{n})\cdot \nabla$
is the surface gradient operator. Parameter [!param](/BCs/INSADSurfaceTensionBC/include_gradient_terms)
can be used to enable or disable the second term in the expression.
Disabling the second term would disable the Marangoni effect and would decrease the
surface deformations. This decreases the fidelity of the model, with an increased robustness.
The model is based on the one discussed in [!cite](cairncross2000finite).




### INSADVaporRecoilPressureMomentumFluxBC


This object is the finite element analog of
[INSFVVaporRecoilPressureMomentumFluxBC.md]. It adds a flux to the Navier-Stokes
momentum equation of the form

\begin{equation}
\hat{n} p_r
\end{equation}

where $\hat{n}$ is the surface unit normal and $p_r$ is the recoil pressure that
represents the pressure impulse due to evaporation of material from the liquid
material we're a boundary condition for.




### INSFEFluidEnergyBC


This boundary condition can be used for porous media flow using the [!param](/BCs/INSFEFluidEnergyBC/porosity) parameter
to define the porosity.

#### Overview

This boundary condition can be used for porous media flow using the [!param](/BCs/INSFEFluidEnergyBC/porosity_elem) parameter
to define the porosity.

If the [!param](/BCs/INSFEFluidEnergyBC/v_fn) parameter is specified, it is used to compute the boundary fluid
velocity. If not, the domain velocity variables are used.
This kind of setup makes this boundary condition flexible to handle both specified velocity and specified pressure (thus velocity is part of the solutions) situations.
This boundary condition is reversible. If the velocity is outgoing from the boundary,
then the temperature considered for the heat flux is computed using the [!param](/BCs/INSFEFluidEnergyBC/temperature)
parameter variable.
If the velocity is such that the fluid enters the boundary, the fluid temperature is computed using the
[!param](/BCs/INSFEFluidEnergyBC/T_fn) parameter function, or the [!param](/BCs/INSFEFluidEnergyBC/T_branch)
parameter scalar variable, depending on which is specified.
The use of scalar variables is intended for coupling with thermal hydraulics components (in SAM).




### INSFEFluidEnergyDirichletBC


#### Overview

If the [!param](/BCs/INSFEFluidEnergyBC/v_fn) parameter is specified, it is used to compute the boundary fluid
velocity. If not, the domain velocity variables are used. The velocity is used to determine whether the boundary is
an inlet.

This boundary condition provides a `conditional' Dirichlet temperature boundary condition for the energy equation, given that no integration by parts is applied to the energy advection term.
Without applying integration by parts to the advection term, the energy equation needs a Dirichlet temperature boundary condition for an inlet condition.
This object additionally introduces a natural boundary condition at outlets.
This conditional Dirichlet boundary condition relies on its `shouldApply()' function to determine if it should be applied.
The fluid temperature is computed using the
[!param](/BCs/INSFEFluidEnergyDirichletBC/T_fn) parameter function, or the [!param](/BCs/INSFEFluidEnergyDirichletBC/T_scalar)
parameter scalar variable, depending on which is specified. The use of scalar variables is intended for coupling with thermal hydraulics components (in SAM).




### INSFEFluidMassBC


This boundary condition can be used for porous media flow using the [!param](/BCs/INSFEFluidEnergyBC/porosity) parameter
to define the porosity.
This boundary condition can describe both an inlet and an outlet.

#### Overview

If either the [!param](/BCs/INSFEFluidMassBC/v_fn) or [!param](/BCs/INSFEFluidMassBC/v_pps) parameters are specified, they are used to compute the boundary fluid velocity. If not, the domain velocity variables are used.
The mass flux is computed as

\rho v_{bc}

where $\rho$ is the local fluid density and $v_{bc}$ is the boundary fluid velocity. The mass flux times the test
function is the contribution of this boundary condition to the residual.




### INSFEFluidMomentumBC


This boundary condition can be used for porous media flow using the [!param](/BCs/INSFEFluidEnergyBC/porosity) parameter
to define the porosity.
This boundary condition can describe both an inlet and an outlet.
This boundary condition must be specified for each component of the momentum.

#### Overview

Either the boundary pressure or the boundary velocity should be specified. The boundary pressure can be specified
to be a scalar variable using the [!param](/BCs/INSFEFluidMomentumBC/p_branch) parameter. This is intended for coupling
with thermal hydraulics components (in SAM).


The momentum flux is computed as the sum of a viscous term (only for near-unity porosity)

-(\mu + \mu_t) \nabla_u \cdot \vec{n}

where $\mu$ is the dynamic viscosity, $\mu_t$ is the turbulent viscosity, $\nabla_u$ is the gradient of
velocity and $\vec{n}$ is the local boundary normal.

a pressure term (only if integrating pressure by parts)

\epsilon p (e_u \cdot \vec{n})

where $\epsilon$ is the local porosity, $p$ the boundary pressure, and $e_u \cdot \vec{n}$ the component of the local
boundary normal.
and a convection term (only if using the conservative form)

\rho u v_{bc} / \epsilon

where $\rho$ is the local fluid density, $u$ the velocity component and $v_{bc}$ is the boundary fluid velocity times the local normal.

The [!param](/BCs/INSFEFluidMomentumBC/p_int_by_parts) and [!param](/BCs/INSFEFluidMomentumBC/conservative_form)
parameter must be consistent with the formulation of the equations in the kernels.




### INSFEFluidWallMomentumBC


This boundary condition can be used for porous media flow using the [!param](/BCs/INSFEFluidEnergyBC/porosity) parameter
to define the porosity.
This boundary condition must be specified for each component of the momentum.

#### Overview

The momentum flux is computed as the sum of a viscous term, the wall shear stress, (only for near-unity porosity)

-(\mu + \mu_t) \nabla_u(comp) \vec{n}(comp)

where $\mu$ is the dynamic viscosity, $\mu_t$ is the turbulent viscosity, $\nabla_u$ is the gradient of
velocity and $\vec{n}$ is the local boundary normal, for which only the $comp$ component is used.

This boundary condition can only be used if the momentum equation pressure term is integrated by parts.




### INSFEMomentumFreeSlipBC


A free slip boundary condition imposes both no-normal flow and no normal shear stress at the wall.

This boundary condition is based entirely on the [MomentumFreeSlipBC.md], but replacing the momentum variables
with velocity variables, which is appropriate for incompressible flow.




### INSMomentumNoBCBCLaplaceForm





### INSMomentumNoBCBCTractionForm





### INSTemperatureNoBCBC





### MassFreeBC





### MomentumFreeBC





### MomentumFreeSlipBC





### NSEnergyInviscidSpecifiedBC





### NSEnergyInviscidSpecifiedDensityAndVelocityBC





### NSEnergyInviscidSpecifiedNormalFlowBC





### NSEnergyInviscidSpecifiedPressureBC





### NSEnergyInviscidUnspecifiedBC





### NSEnergyViscousBC





### NSEnergyWeakStagnationBC





### NSImposedVelocityBC





### NSImposedVelocityDirectionBC





### NSInflowThermalBC





### NSMassSpecifiedNormalFlowBC





### NSMassUnspecifiedNormalFlowBC





### NSMassWeakStagnationBC





### NSMomentumConvectiveWeakStagnationBC





### NSMomentumInviscidNoPressureImplicitFlowBC





### NSMomentumInviscidSpecifiedNormalFlowBC





### NSMomentumInviscidSpecifiedPressureBC





### NSMomentumPressureWeakStagnationBC





### NSMomentumViscousBC





### NSPenalizedNormalFlowBC





### NSPressureNeumannBC





### NSStagnationPressureBC





### NSStagnationTemperatureBC





### NSThermalBC





## correctors

### NSPressurePin


#### Overview

The `NSPressurePin` can pin the pressure in two modes:

- by offsetting the pressure variable to make it have an average equal to the [!param](/Correctors/NSPressurePin/phi0) parameter value
- by offsetting the pressure variable to make its value equal to the [!param](/Correctors/NSPressurePin/phi0) parameter value in the element
  containing the point specified by the [!param](/Correctors/NSPressurePin/point) parameter.


In the [NSFVAction.md], a `NSPressurePin` can be used by setting the [!param](/Modules/NavierStokesFV/pinned_pressure_type) parameter
to `average-uo` or `point-value-uo` respectively.




## executioners

### PIMPLE


#### Overview

This transient executioner is based on the algorithm discussed in [!cite](greenshieldsweller2022).
It is a combination of [SIMPLE.md] and the PISO (Pressure-Implicit with Splitting of Operators)
algorithm introduced by [!cite](issa1986solution).

In PISO, the user iterates between the source term in the pressure equation and the corrected pressure
and velocity fields without assembling the momentum system again. With the notation
already used in [SIMPLE.md], the PISO iteration is the following:

1. Take a velocity guess and compute $H(u^n)$ which is the offdiagonals of the momentum system matrix multiplied by
   the current guess minus the right hand side of the momentum matrix. Note that the face flux is computed using
   a different quess so this operation is just a matrix-vector multiplication and a vector-vector addition.
2. Use $H(u^n)$ and the diagonal of the momentum matrix $A$ to solve the pressure equation:

   \nabla \cdot \left(A^{-1}H(\vec{u}^{n})\right) = -\nabla \cdot \left(A^{-1}\nabla p^n\right).

   The pressure solution might have to be relaxed in this iteration:

   p^{n,*} = p^n + \lambda_p (p^{n}-p^{n-1}).

3. Once the pressure solution is obtained, update the velocity to the next guess:

   \vec{u}^{n+1} = - A^{-1}H(\vec{u}^{n}) -A^{-1}\nabla p^{n,*},

   and return to (1) until the maximum number of iterations is reached which can be set
   using the [!param](/Executioner/PIMPLE/num_piso_iterations) parameter.

#### Example Input Syntax

The problem setup is exactly the same as discussed for [SIMPLE.md], only the executioner
block is different:





### SIMPLE


#### Overview

This executioner is based on the algorithm proposed by [!cite](patankar1983calculation). The algorithm
is based on the splitting of operators and successive correction for the momentum and pressure fields.
The formulation implemented in MOOSE has been presented in [!cite](jasak1996error) and [!cite](juretic2005error).
See also the examples and derivations in [!cite](moukalled2016finite).
The concept relies on deriving a pressure equation using the discretized form of the momentum
equations together with the continuity constraint. Let's take the steady-state incompressible Navier-Stokes equations
in the following form:

\nabla \cdot \left(\rho \vec{u} \otimes \vec{u}\right) - \nabla \cdot \left(\mu_\text{eff} \left(\nabla\vec{u} +\nabla \vec{u}^T \right)\right) = -\nabla p + \vec{G}.

\nabla \cdot \left(\rho \vec{u}\right) = 0.

Where $\vec{u}$ denotes the velocity, $p$ the pressure, $\rho$ the density, and $\mu_\text{eff}$ the effective dynamic viscosity
which potentially includes the contributions of eddy viscosity derived from turbulence models.
Term $\vec{G}$ expresses a volumetric source term which can be potentially velocity-dependent.
As a first step, we assume that we have a guess for the pressure field, therefore the gradient is known. Furthermore, we assume that
the advecting velocity field is known from the previous iteration. By explicitly showing the iteration index,
[!eqref](momentum-eq) and [!eqref](continuity-eq) become:

\nabla \cdot \left(\rho \vec{u}^{n-1} \otimes \vec{u}^n\right) - \nabla \cdot \left(\mu_\text{eff} \left(\nabla\vec{u}^n +\nabla \vec{u}^{n,T}\right)\right) = -\nabla p^{n-1} + \vec{G}(\vec{u}^{n-1},\vec{u}^{n}).

\nabla \cdot \left(\rho \vec{u}^n\right) = 0.

At this point, we should note that the finite volume discretization in MOOSE uses a collocated formulation which has an advantage
of being flexible for unstructured meshes. However, in certain scenarios it can exhibit numerical pressure checker-boarding
due to the discretization of the pressure gradient and continuity terms. A common approach for tackling this issue is the
utilization of the Rhie-Chow interpolation method (See [!cite](rhie1983numerical) and [!cite](moukalled2016finite) for a detailed
explanation). This means that the face velocities (or face fluxes) are determined using pressure corrections. As we will see
later, due to this behavior, the iteration between pressure and velocity will in fact be an iteration between
pressure and face velocity. Nevertheless, to keep this in mind we add a subscript to the advecting velocity in our formulation:

\nabla \cdot \left(\rho \vec{u}^{n-1}_{RC} \otimes \vec{u}^n\right) - \nabla \cdot \left(\mu_\text{eff} \left(\nabla\vec{u}^n +\nabla \vec{u}^{n,T}\right)\right) = -\nabla p^{n-1} + \vec{G}(\vec{u}^{n-1},\vec{u}^{n}).

\nabla \cdot \left(\rho \vec{u}^n_{RC}\right) = 0.

Next, we split the operator acting on $\vec{u}$ in the momentum equation into two components: a component that incorporates effects
that result in contributions to the diagonal of a soon-to-be-generated system matrix and another component that contains
everything else. With this in mind, we can rewrite the equation the following, semi-discretized way:

A(\vec{u}^{n-1})\vec{u}^n + H(\vec{u}^{n}) = -\nabla p^{n-1},

where $A(\vec{u}^{n-1})$ is the diagonal contribution, and $H(\vec{u}^{n-1})$ includes the off-diagonal contributions
multiplied by the solution together with any additional volumetric source and sink terms (i.e. the discretized forms of $\vec{G}$).
One can solve this equation to obtain a new guess for the velocity field. This guess, however, will not respect the
continuity equation, therefore we need to correct it. For this, a pressure equation is derived from the following formulation:

A\vec{u}^n + H(\vec{u}^{n}) = -\nabla p^n.

By applying the inverse of the diagonal operator (a very cheap process computationally), we arrive to the following expression:

\vec{u}^n + A^{-1}H(\vec{u}^{n}) = -A^{-1}\nabla p^n,

By applying the continuity equation onto $\vec{u}^n$ (which is a constraint) and assuming that the Rhie-Chow
interpolation is used for the velocity, we arrive to a Poisson equation for pressure:

\nabla \cdot \left(A^{-1}H(\vec{u}^{n})\right) = -\nabla \cdot \left(A^{-1}\nabla p^n\right).

This equation is solved for a pressure which can be used to correct the face velocities in a sense that they
respect the continuity equation. This correction already involves a Rhie-Chow interpolation, considering that
the $A^{-1}H$ and $A^{-1}$ fields are interpolated to the faces in a discretized form:

\vec{u}^{n+1}_{RC,f} = - \left(A^{-1}H(\vec{u}^{n})\right)_f - (A^{-1})_f \nabla p^n_f.

This correction applies the continuity constraint in an iterative manner, while ensuring the lack of
numerical pressure checker-boarding phenomena.

The next guess for the velocity, however, does not necessarily respect the momentum equation. Therefore,
the momentum prediction and pressure correction steps need to be repeated until both the momentum and
continuity equations are satisfied.


The iterative process above is not stable if the full update is applied every time. This means that the
variables need to be relaxed. Specifically, it is a common practice to relax the pressure when plugging it
back to the gradient term in the momentum predictor:

p^{n+1,*} = p^n + \lambda_p (p^{n+1}-p^n),

where $p^{n+1,*}$ is the relaxed field and $\lambda_p \in (0,1]$ is the corresponding relaxation parameter.



To help the solution process of the linear solver, we add options to ensure diagonal dominance through
the relaxation of equations. This is done using the method mentioned in [!cite](juretic2005error), meaning that
a numerical correction is added to the diagonal of the system matrix and the right hand side. This is
especially useful for advection-dominated systems.



Currently, this solver only respects the following `execute_on` flags: `INITAL`, `TIMESTEP_BEGIN`, and `FINAL`, other flags are ignored. `MultiApps` and the corresponding `MultiappTransfers` are executed at `FINAL` only.


#### Example Input Syntax

The setup of a problem with the segregated solver in MOOSE is slightly different compared to
conventional monolithic solvers. In this section, we highlight the main differences.
For setting up a 2D simulation with the SIMPLE algorithm, we need three linear systems in MOOSE:
one for each momentum component and another for the pressure. The different systems
can be created within the `Problem` block:


It is visible that we requested that MOOSE keeps previous solution iterates as well. This is necessary to
facilitate the relaxation processes mentioned in the overview. Next, we create linear FV variables and assign them to the
given systems.


The kernels are then created within the `LinearFVKernels` block. The fundamental terms that contribute to the
face fluxes in the momentum equation (stress and advection terms) are lumped into one kernel. Furthermore,
instead of adding contribution from the continuity equation, we build an anisotropic diffusion (Poisson) equation for
pressure:


By default, the coupling fields corresponding to $A^{-1}H$ and $A^{-1}$ are handled by functor
called `HbyA` and `Ainv`, respectively. These fields are generated by [RhieChowMassFlux.md] under the hood.
This means that we need to add the user object responsible for generating these fields:


As a last step, we add the SIMPLE executioner:


#### Passive scalar advection

The `SIMPLE` executioner can be used to solve coupled problems involving both flow and passive scalar advection.
Advected passive scalars do not affect the flow distribution, and therefore can be solved after the velocity and
pressure fields have been computed using the `SIMPLE` algorithm.
Several systems may be used, for each passive scalar.




### SIMPLENonlinearAssembly


#### Overview

For the overview of the SIMPLE algorithm, please visit [SIMPLE.md].

This executioner implements the same iteration but it uses MOOSE's native
residual and Jacobian computing routines to build system matrices and
right hand sides. Even though this introduces an overhead in terms of computational
speed, it allows the utilization of the same variables, kernels and boundary conditions
that are used in the monolithic solvers.

#### Example Input Syntax

The setup of a problem with the segregated solver in MOOSE is slightly different compared to
conventional monolithic solvers. In this section, we highlight the main differences.
For setting up a 2D simulation with the SIMPLE algorithm, we add three systems in MOOSE:
one for each momentum component and another for the pressure. The different systems
can be created within the `Problem` block:


It is visible that we requested that MOOSE keeps previous solution iterates as well. This is necessary to
facilitate the relaxation processes mentioned in [SIMPLE.md].


The kernels are then created similarly to the monolithic system, with the exception that now the kernels acting on pressure are slightly different:


By default, the coupling fields corresponding to $A^{-1}H$ and $A^{-1}$ are called `HbyA`
and `Ainv`, respectively. These fields are generated by
[INSFVRhieChowInterpolatorSegregated.md] under the hood. This means that we need to
add the user object responsible for generating these fields:


Next, we add the `SIMPLENonlinearAssembly` executioner:


We see that it has a parameter called [!param](/Executioner/SIMPLENonlinearAssembly/pressure_gradient_tag). This tag needs to be added to the
pressure gradient kernels to enable the separation of terms needed in $A^{-1}H$. This can be easily done as follows in the `FVKernels`:






## functormaterials

### ExponentialFrictionFunctorMaterial


This material is used to simulate friction factor correlations in the form of

\begin{equation}
f(Re) = C_1 \mathrm{Re}^{C_2}~,
\end{equation}

where $C_1$ and $C_2$ are (potentially space-dependent) constants supplied by the user.




### FunctorErgunDragCoefficients


This class implements the Darcy and Forchheimer coefficients for the Ergun drag
force model which is discussed in detail in
[PINSFVMomentumFriction.md#friction_example]. We also give details on the
definition of Darcy and Forchheimer coefficients there.

To summarize, this class implements the Darcy coefficient as

\begin{equation}
\frac{150}{D_h^2}
\end{equation}

where $D_h$ is the hydraulic diameter defined as $\frac{\epsilon d_p}{1 - \epsilon}$
where $d_p$ is the diameter of the pebbles in the bed. The Forchheimer
coefficient is given as

\begin{equation}
\frac{2 \cdot 1.75}{D_h}
\end{equation}

where we have made the $2(1.75)$ multiplication explicit, instead of writing
$3.5$, to make the 1.75 factor from the
[Ergun wikipedia page](https://en.wikipedia.org/wiki/Ergun_equation) more
recognizable.




### FunctorKappaFluid


#### Description

Most macroscale models neglect thermal dispersion [!cite](suikkanen,y_li), in which case $\kappa_f$ is given as

\begin{equation}
\label{eq-KappaFluid}
\kappa_f=\epsilon k_f\ .
\end{equation}

Neglecting thermal dispersion is expected to be a reasonable approximation for high Reynolds numbers [!cite](gunn1987_htc,littman),
but for low Reynolds numbers more sophisticated models should be used [!cite](becker).
Because thermal dispersion acts to increase the diffusive effects, neglecting thermal dispersion is
(thermally) conservative in the sense that peak temperatures are usually higher [!cite](becker).




### GeneralFunctorFluidProps


#### Overview

This object uses a `SinglePhaseFluidProperties` derived-object to compute the following properties:

- specific heat at constant volume, $c_v$
- specific heat at constant pressure, $c_p$
- dynamic viscosity, $\mu$
- thermal conductivity, $k$
- Prandtl number, $\text{Pr}$
- pore/particle Reynolds number $\text{Re}$
- hydraulic Reynolds number $\text{Re}_h$
- interstitial Reynolds number $\text{Re}_i$


the time derivatives of the:

- specific heat at constant pressure, $c_p$
- density $\rho$


and the pressure and temperature derivatives of the:

- specific heat at constant pressure, $c_p$
- density $\rho$
- dynamic viscosity, $\mu$
- thermal conductivity, $k$
- Prandtl number, $\text{Pr}$
- pore Reynolds number $\text{Re}$

In order to use this with some fluid properties that do not compute the AD version of the density
derivatives, such as the Spline Base Table Lookup fluid properties, you can use the
[!param](/FunctorMaterials/GeneralFunctorFluidProps/neglect_derivatives_of_density_time_derivative)
to neglect the derivatives with regards to the nonlinear variables (usually pressure, temperature)
of the time derivative of the density.




### INSFVEnthalpyFunctorMaterial

This is the material class used to compute enthalpy $\rho c_p T$ where $\rho$ is the density, $c_p$
is the specific heat capacity, and $T$ is the temperature, for the incompressible/weakly-compressible
finite-volume implementation of the Navier-Stokes equations.

It defines the following functor material properties, for a variety of use cases and postprocessing needs:

- enthalpy density $\rho h$ or $\rho c_p T$
- specific enthalpy $h$ or $c_p T$
- time derivative of the specific enthalpy $\dfrac{dh}{dt} = c_p \dfrac{dT}{dt}$




### INSFVkEpsilonViscosityFunctorMaterial

This is the material class used to compute the dynamic turbulent viscosity

\begin{equation}
  \mu_t = \rho C_{\mu} \frac{k^2}{\epsilon} \,,
\end{equation}

where:

- $\rho$ is the density,
- $C_{\mu} = 0.09$ is a closure parameter,
- $k$ is the turbulent kinetic energy,
- $\epsilon$ is the turbulent kinetic energy dissipation rate.




### INSFVMushyPorousFrictionFunctorMaterial


This material computes the `Darcy_coefficient` and the `Forchheimer_coefficient` for a solidification problem.
The model uses a mushy-zone approach to compute the friction coefficients.

The coefficients are defined as follows:

\begin{equation}
D = \frac{\mu}{K} \,,
\end{equation}

where the permeability $K$ is defined as follows:

\begin{equation}
K = \frac{f_l^3}{f_s^2 F_k c_s} \,,
\end{equation}

where $f_l$ and $f_s$ are the liquid and solid fraction,
the switching function is defined as $F_k = 0.5 * \operatorname{atan}(s (f_s - f_{s,crit}) / \pi)$ with $s=100$ and $f_{s,crit}=0.27$
and $c_s = c / (\lambda)^2$ with $c = 180$ and the dendrite spacing is $\lambda$.
By default, we set $\lambda = 10^{-4}$. However, this coefficient may be tuned by the user if experimental data is available.

The Forchheimer coefficient is defined as follows:

\begin{equation}
F = C_F \frac{\rho_l}{\sqrt{K}} \,,
\end{equation}

where the Ergun coefficient is $C_F = 0.55$ and $\rho_l$ is the density of the liquid phase.

This material is compatible with [PINSFVMomentumFriction.md] for the non standard (simplified) formulation
which multiplies the incoming Forchheimer coefficient by the velocity magnitude times velocity component;
it is *incompatible* with the standard Forchheimer formulation which also multiplies with density over two. Thus the user should
set the parameter "standard_friction_formulation = false"




### LinearFrictionFactorFunctorMaterial

This class allows to compute the friction coefficient $W$ that is used
as:

-\epsilon \nabla p = W \rho \vec{v}_I

in the porous flow equations where all symbols have their common meaning (see [porous media equations](navier_stokes/pinsfv.md)) and we do not write all the other momentum equation terms. The
friction factor is a diagonal tensor computed by:

\vec{W} = \vec{A} f(\vec{r}, t) + \vec{B} g(\vec{r}, t) \| \vec{v}_I\|,

where $\vec{A}$ and $\vec{B}$ are constant vectors provided by the user,
$f$ and $g$ are scalar functors. 




### LinearFVEnthalpyFunctorMaterial

This [FunctorMaterial](syntax/FunctorMaterials/index.md) class is needed when the user wants to solve for the enthalpy conservation for the linear finite-volume implementation of the incompressible/weakly-compressible Navier-Stokes equations.

This material class defines the functors to convert from specific enthalpy and pressure to temperature ('T_from_p_h') and to convert from temperature and pressure to specific enthalpy ('h_from_p_T').

When solving the enthalpy conservation equation and obtaining the specific enthalpy ($h$) as the solution, two functors are required.
The 'T_from_p_h' functor computes the temperature field, which is then used to evaluate temperature-dependent thermophysical properties. The 'h_from_p_T' functor is primarily utilized for setting boundary conditions where the temperature is specified.

The specific enthalpy is defined as:

\begin{equation}
  h(T) = \int_{T_{ref}}^{T} c_p(p, T')dT' + h_{ref},
\end{equation}

where

- $c_p(p, T)$ is the pressure and temperature-dependent specific heat
- $T_{ref}$ is a reference temperature where the reference enthalpy $h_{ref}$ is defined

#### Example input syntax 1: Fluid Properties

In this input, a `LinearFVEnthalpyFunctorMaterial` is defined to solve for a 1D heated channel using lead fluid properties with a fixed mass flux.

The `FluidProperties` object for lead is defined in


Then, the `LinearFVEnthalpyFunctorMaterial` is defined taking the `FluidProperties` object as an input, which already contains the 'h_from_p_T' and 'T_from_p_h' functors defined.


#### Example input syntax 2: User-Defined Properties

In this input, a `LinearFVEnthalpyFunctorMaterial` is defined to solve for a 1D heated channel using FLiNaK properties with a fixed mass flux, defined by the user.


This functor material takes the user-defined 'h_from_p_T' and 'T_from_p_h' functors as inputs. The functors are defined in



for the linear specific heat:


If using user-defined properties, it is the responsibility of the user to update these properties often enough. For example auxiliary variable properties would only be updated at the end of every time step by default, which would introduce a lag. 




### MixingLengthTurbulentViscosityFunctorMaterial

This material calculates the 'total_viscosity' which is essentially the sum
of the material kinematic viscosity and the turbulent kinematic viscosity
computed using the mixing length model.





### NSFVDispersePhaseDragFunctorMaterial

This material computes the linear drag coefficient for a dispersed
phase based on the particle Reynolds number $Re_d$.
The particle Reynolds number is defined as follows:

\begin{equation}
  Re_d = \frac{\rho_d d_d \bm{u}_m}{\mu_m}
\end{equation}

where:

- $\rho_d$ is the density of the dispersed phase particles,
- $d_d$ is the characteristic diameter of the dispersed phase particles,
- $\bm{u}_m$ is the mixture velocity,
- $\mu_m$ is the mixture viscosity.

Based on this Reynolds number, the linear drag coefficient for the
dispersed phase is computed as follows [!cite](schiller1933drag):

\begin{equation}
  f_{drag} =
  \begin{cases}
      \begin{aligned}
          &1 + 0.15 Re^{0.678} & \quad &\text{if } Re \leq 1000, \\
          &0.0183 Re & \quad &\text{if } Re > 1000.
      \end{aligned}
  \end{cases}
\end{equation}




### NSFVFrictionFlowDiodeFunctorMaterial


This material is meant to be used to implement a simplistic volumetric flow diode. The
parameter [!param](/FunctorMaterials/NSFVFrictionFlowDiodeFunctorMaterial/additional_linear_resistance)
and [!param](/FunctorMaterials/NSFVFrictionFlowDiodeFunctorMaterial/additional_quadratic_resistance) should be chosen such that
the flow is sufficiently vanished in the direction opposite the diode.

The operation of the diode is controlled with the [!param](/FunctorMaterials/NSFVFrictionFlowDiodeFunctorMaterial/turn_on_diode)
parameter. If this parameter is false, the 'diode' does *NOT* create any flow restriction.

#### Example input file syntax

##### Simple always-on friction term

In this example the friction flow diode is added to a porous media simulation.
The `combined_linear/quadratic` friction coefficients contain both the diode
friction coefficients and the base porous media friction.

The friction coefficients are then combined using a [PiecewiseByBlockVectorFunctorMaterial.md] to have a uniform name over the whole domain for friction coefficients.


##### Dynamic operation of a diode

In this example, we show three [Control](syntax/Controls/index.md) strategies for the diode.
The idea of these controls is to detect a condition in which the flow should be blocked, because it's going
in the way opposite the direction of the diode, or because it meets a criterion that is outlined in the postprocessors
and functions involved to describe it.

The first strategy is simply to block the flow at a given time.


The second strategy is to look at the pressure drop across the diode, and block (add friction to) the flow if it exceeds a certain value.
If it exceeds a certain value, then in all likelihood means that the flow is flowing through the diode in the direction of decreasing pressure.


The final strategy is to compute the mass flow rate through the diode, and block (add friction to) the flow if it exceeds a certain value.


All these strategies are workarounds for the fact that looking at the local velocity (in multi-dimensional space)
to apply a friction term based on this local velocity, rather than an average quantity, seems to be numerically unstable.




### NSFVMixtureFunctorMaterial


This material is mainly used in multiphase modeling.
Given a phase fraction functor [!param](/FunctorMaterials/NSFVMixtureFunctorMaterial/phase_1_fraction) ($\lambda_1$)
and two vectors of (functor) properties [!param](/FunctorMaterials/NSFVMixtureFunctorMaterial/phase_1_names) and
[!param](/FunctorMaterials/NSFVMixtureFunctorMaterial/phase_2_names), named generically $p_{i,1}$ and $p_{i,2}$, respectively,
the material computes the phase-weighted average of the property as follows:

\begin{equation}
p_i = \lambda_1 p_{i,1} + (1 - \lambda_1) p_{i,2} \,,
\end{equation}

where we assume that $\lambda_2 = 1 - \lambda_1$.
The name of the output properties can be defined using the [!param](/FunctorMaterials/NSFVMixtureFunctorMaterial/prop_names) parameter.




### NSFVPumpFunctorMaterial


This is a functor material to set up the effective volume force of a pump. For a forward operating pump, the volume force model reads as follows:

\begin{equation}
  f_V = \frac{\rho |\vec{g}| h(Q) A_r}{V_r} ,
\end{equation}

where:

- $\rho$ is the fluid density
- $|\vec{g}|$ is the norm of the gravity vector
- $A_r$ is the rated area of the pump (typically taken as the area of the upstream volume leading to the pump)
- $V_r$ is the rated volume of the pump (we recommend taking this one as the area of the block leading to the pump)
- $h(Q)$ is the pressure head of the pump in units of {\it length} as a function of the flow rate with units of {\it volume / time}

The scaling of the pressure head of the pump is performed via the non-dimensional rotation speed of the pump defined as follows:

\begin{equation}
  \omega_s = \frac{\omega Q^{\frac{1}{2}}}{\left( g h \right)^{\frac{3}{4}}} ,
\end{equation}

For scaling purposes, the user can provide the following parameters:

- Rated and actual flow rate at the pump. The actual flow rate at the pump must be provided via a post-processor
- Rated and actual rotation speed of the pump. The actual rotation speed of the pump is a controllable parameter

To allow the pump to operate in reverse flow conditions, the user must set `enable_negative_rotation = true`.
The scaling of the model in the negative rotation condition is the same as the positive one.
However, for negative rotation, the user can provide the homologous pressure head curve via the `pressure_head_function_negative_rotation` function.
If the pressure head function for the positive direction should be used for negative rotation, the user should set `symmetric_negative_pressure_head = true`.




### PINSFVSpeedFunctorMaterial


This class defines the interstitial speed and interstitial velocity functors
that are often used in pressure drop and heat transfer correlations.




### ReynoldsNumberFunctorMaterial


This material is used to compute the Reynolds number defined as:

$\mathrm{Re} = \frac{D|u| \rho}{\mu}$

where $D$ is a characteristic length, $|u|$ is the velocity magnitude, while
$\rho$ and $\mu$ are the density and dynamic viscosity of the fluid.




### RhoFromPTFunctorMaterial


#### Overview

This object takes a fluid properties object and coupled pressure and temperature
variables and provides a functor material property `rho` that is evaluated with
the local pressure and temperature as `rho_from_p_T(_pressure(x), _temperature(x))` where `x`
represents a physical location, e.g. on an element or a face.




### ThermalDiffusivityFunctorMaterial


#### Overview

The `ThermalDiffusivityFunctorMaterial` object computes the thermal diffusivity

\begin{equation}
\alpha = \frac{k}{\rho c_p}
\end{equation}

where $k$ is the thermal conductivity, $\rho$ is the density, and $c_p$ is the
constant-pressure specific heat capacity. Thermal diffusivity has units of
length squared over time and is the heat transport analog of the kinematic
viscosity in momentum transport and the diffusion coefficient in species/mass
transport. This object takes $k$, $\rho$, and $c_p$ as input functors and
produces $\alpha$ as an output functor which will be evaluated on-demand.




### WCNSFV2PSlipVelocityFunctorMaterial

This material computes the slip velocity between a dispersed phase and
a mixture phase.
The slip velocity is modeled as follows:

\begin{equation}
  \bm{v}_{slip,d} = \frac{\tau_d}{f_{drag}} \frac{\rho_d - \rho_m}{\rho_d} \bm{a} \,,
\end{equation}

where:

- $\tau_d$ is the particle relaxation time,
- $f_{drag}$ is the linear drag coefficient function,
- $\rho_d$ is the density of the dispersed phase,
- $\rho_m$ is the density of the mixture,
- $\bm{a}$ is the acceleration vector.

The particle relaxation time is modeled as follows [!cite](bilicki1990dragmodel):

\begin{equation}
  \tau_d = \frac{\rho_d d_d^2}{18 \mu_m} \,,
\end{equation}

where:

- $d_d$ is the particle diameter,
- $\mu_m$ is the mixture dynamic viscosity.

The acceleration vector is the particle acceleration vector:

\begin{equation}
  \bm{a} = \bm{g} + \frac{\bm{f}}{\rho_m} - \bm{u}_m \cdot \nabla \bm{u}_m - \frac{\partial \bm{u}_m}{dt} \,,
\end{equation}

where:

- $\bm{g}$ is the acceleration of gravity,
- $\bm{f}$ is the volumetric force,
- $\bm{u}_m$ is the mixture velocity.




## fvbcs

### CNSFVHLLCFluidEnergyBC

The `CNSFVHLLCFluidEnergyBC` template class implements the fluid energy flux boundary condition for
Harten-Lax-Van Leer-Contact (HLLC) given either specified boundary fluid energy and
temperature functions or a
boundary pressure function. Note that these are functions corresponding to
static boundary quantities as opposed to stagnation quantities. More details
about the different template instantiations are given below.

#### CNSFVHLLCSpecifiedMassFluxAndTemperatureFluidEnergyBC




#### CNSFVHLLCSpecifiedPressureFluidEnergyBC




### CNSFVHLLCFluidEnergyImplicitBC


#### Overview

This object implements an implicit boundary condition for the fluid energy
equation when using a Harten-Lax-Van Leer-Contact (HLLC) formulation. Implicit
means that the boundary condition uses no external/explicit boundary condition
information, e.g. no external input in the boundary condition block like
Dirichlet or Neumann values; instead the boundary condition forms its boundary
flux based off information from the domain interior, e.g. information from
neighboring interior cell centroids such as cell center values and
gradients. For a description of HLLC flux computation please see [CNSFVHLLCBase.md].




### CNSFVHLLCFluidEnergyStagnationInletBC


#### Overview

This object implements the fluid energy portion of a stagnation boundary
condition based on stagnation pressure and stagnation temperature. Please see
[CNSFVHLLCStagnationInletBC.md] for the equations and theory behind computing
boundary conditions based on stagnation temperature and pressure.




### CNSFVHLLCMassBC

The `CNSFVHLLCMassBC` template class implements the mass flux boundary condition for
Harten-Lax-Van Leer-Contact (HLLC) given either specified boundary momentum and
temperature functions or a
boundary pressure function. Note that these are function corresponding to
static boundary quantities as opposed to stagnation quantities. More details
about the different template instantiations are given below.

#### CNSFVHLLCSpecifiedMassFluxAndTemperatureMassBC




#### CNSFVHLLCSpecifiedPressureMassBC




### CNSFVHLLCMassImplicitBC


#### Overview

This object implements an implicit boundary condition for mass in the context of
an HLLC formulation. Implicit here means that the boundary flux is formed
entirely from internal domain information.




### CNSFVHLLCMassStagnationInletBC


#### Overview

This object implements the conservation of mass portion of a stagnation boundary
condition based on stagnation pressure and stagnation temperature. Please see
[CNSFVHLLCStagnationInletBC.md] for the equations and theory behind computing
boundary conditions based on stagnation temperature and pressure.




### CNSFVHLLCMomentumBC

The `CNSFVHLLCMomentumBC` template class implements the momentum flux boundary condition for
Harten-Lax-Van Leer-Contact (HLLC) given either specified boundary momentum and
temperature functions or a
boundary pressure function. Note that these are functions corresponding to
static boundary quantities as opposed to stagnation quantities. More details
about the different template instantiations are given below.

#### CNSFVHLLCSpecifiedMassFluxAndTemperatureMomentumBC




#### CNSFVHLLCSpecifiedPressureMomentumBC




### CNSFVHLLCMomentumImplicitBC


#### Overview

This object implements an implicit boundary condition for momentum in the context of
an HLLC formulation. Implicit here means that the boundary flux is formed
entirely from internal domain information.




### CNSFVHLLCMomentumSpecifiedPressureBC


#### Overview

This object inherits from [CNSFVHLLCMomentumImplicitBC.md] and adds the
`specified_pressure_function` parameter. Evaluation of this provided function is
substituted for the implicit pressure value (e.g. the interior pressure value)
in boundary flux evaluation.




### CNSFVHLLCMomentumStagnationInletBC


#### Overview

This object implements the conservation of momentum portion of a stagnation boundary
condition based on stagnation pressure and stagnation temperature. Please see
[CNSFVHLLCStagnationInletBC.md] for the equations and theory behind computing
boundary conditions based on stagnation temperature and pressure.




### CNSFVHLLCStagnationInletBC

This is the base object for applying a stagnation boundary condition to the
mass, momentum, and energy equations. `stagnation_temperature` and
`stagnation_pressure` are required parameters of any objects derived from this
class. `CNSFVHLLCStagnationInletBC` computes several boundary quantities from
the supplied stagnation temperature and pressure. Boundary temperature is
computed with the assumptions laid out
[here](https://en.wikipedia.org/wiki/Stagnation_temperature) via the relation:

\begin{equation}
T_b = T_0 - \frac{V^2}{2c_p}
\end{equation}

where $T_b$ is the boundary temperature, $T_0$ is the stagnation temperature,
$V$ is the velocity and $c_p$ is the specific heat capacity. In
`CNSFVHLLCStagnationInletBC` $V$ is drawn from the cell centroid bordering the
boundary, e.g. it is implicit. With $T_b$ computed, the static pressure at the
boundary is computed using the isentropic relation:

\begin{equation}
p_b = p_0 \left(\frac{T_0}{T_b}\right)^{\frac{-\gamma}{\gamma - 1}}
\end{equation}

where $p_0$ is the stagnation pressure and $\gamma$ is the ratio of the specific
heats, e.g. $c_p/c_v$.

Armed with the boundary pressure and temperature, `CNSFVHLLCStagnationInletBC`
also computes the boundary values for the specific internal energy $e$, density
$\rho$, and specific total enthalpy $h_t$ for use the flux expressions of
the derived [mass](CNSFVHLLCMassStagnationInletBC.md),
[momentum](CNSFVHLLCMomentumStagnationInletBC.md), and
[energy](CNSFVHLLCFluidEnergyStagnationInletBC.md) classes.

### CNSFVMomImplicitPressureBC


#### Overview

This object adds a boundary pressure flux based on cell interior (implicit)
information. This is the free-flow analog of
[PCNSFVImplicitMomentumPressureBC.md] although this object can also be used with
porosity by setting `include_porosity = true` in the input file. This object
will then look for a material property named `porosity`.




### INSFVAveragePressureValueBC

This object wraps [FVBoundaryIntegralValueConstraint.md], meaning that this
object can be used to impose an average pressure value on a boundary. The
`variable` parameter should correspond to the pressure variable.




### INSFVInletIntensityTKEBC

This object wraps [`FVFunctionDirichletBC`](FVFunctionDirichletBC.md),
to impose a precomputed value for the turbulent kinetic energy.

The value set for the turbulent kinetic energy is:

\begin{equation}
k = \frac{3}{2} (I |\vec{u} \cdot \vec{n}|)^2 \,,
\end{equation}

where:

- $I$ is the turbulent intensity, which can be set by the user or computed via correlations, e.g., $I = 0.16 Re^{-\frac{1}{8}}$
- $\vec{u}$ is the velocity vector at a boundary face,
- $\vec{n}$ is the normal vector for a boundary face.




### INSFVInletVelocityBC

This object simply wraps [`FVFunctionDirichletBC`](FVFunctionDirichletBC.md), so a
required parameter is [!param](/FVBCs/INSFVInletVelocityBC/functor) describing the velocity along an inlet
boundary. The [!param](/FVBCs/INSFVInletVelocityBC/variable) parameter should correspond to a velocity component
variables. If applying `INSFVInletVelocity` for any velocity component on a given
[!param](/FVBCs/INSFVInletVelocityBC/boundary), then an `INSFVInletVelocity` should be specified for every velocity
component on that `boundary`. A `FVBC` for pressure should not be applied on the
same `boundary`. Instead a value for the pressure at the inlet will be extrapolated
from the interior.




### INSFVMassAdvectionOutflowBC

This object computes the residual and Jacobian contribution of the
incompressible version of the mass continuity equation, e.g. $\nabla\cdot\vec
u = 0$ along the domain boundary. This boundary condition should be used when it is
desired that the pressure value be extrapolated at the boundary face. If the
user wishes to have a certain value for pressure at the outflow boundary, then
they should use [INSFVOutletPressureBC](/INSFVOutletPressureBC.md).




### INSFVMixingLengthTKEDBC

This object wraps [`FVFunctionDirichletBC`](FVFunctionDirichletBC.md),
to impose a precomputed value for the turbulent kinetic energy dissipation rate.

The value set for the turbulent kinetic energy is:

\begin{equation}
\epsilon = C_{\mu}^{0.75} \frac{k^{\frac{3}{2}}}{0.07 L} \,,
\end{equation}

where:

- $C_{\mu} = 0.09$ is a closure parameter,
- $k$ is the turbulent kinetic energy,
- $L$ is a characteristic length, e.g., the diameter of a pipe, diameter of an inlet jet, or the side length of the lid-driven cavity.




### INSFVMomentumAdvectionOutflowBC

This object implements the $\rho\left(\vec u \cdot\nabla\right)\vec u$ component
term of the
incompressible Navier Stokes momentum equation along a domain boundary. It
simultaneously requires that the normal gradient of each velocity component at
the boundary be zero.




### INSFVNaturalFreeSlipBC

This object implements a free slip boundary condition. It should be applied to
each velocity component. This BC operates very simply by setting the total
momentum boundary flux, e.g. the sum of advective and viscous fluxes, to zero.




### INSFVNoSlipWallBC

This object simply wraps [`FVFunctionDirichletBC`](FVFunctionDirichletBC.md). So
the required parameter is `function` describing the boundary wall velocity for
the velocity component specified with `variable`. If applying
`INSFVNoSlipWallBC` for any velocity component on a given `boundary`, then an
`INSFVNoSlipWallBC` should be specified for every velocity component on that
`boundary`.




### INSFVOutletPressureBC

This object simply wraps [`FVFunctionDirichletBC`](FVFunctionDirichletBC.md), so
a required parameter is `function` describing the pressure along an outlet
boundary. The `variable` parameter should correspond to the pressure
variable. `INSFVOutletPressureBC` also inherits from `INSFVFullyDevelopedBC`
which allows modifications to the coefficients used to compute the Rhie-Chow
interpolation in [`INSFVMomentumAdvection`](INSFVMomentumAdvection.md). When
applying a `INSFVOutletPressureBC` for the pressure, no `FVBCs` should be given
for the velocity on the same `boundary`. In this way a zero viscous flux is
implicitly applied for the velocity on the `boundary`.




### INSFVSwitchableOutletPressureBC


The file is similar to [INSFVOutletPressureBC.md] but it allows the boundary conditions to be switched on/off.

The `switch_bc` parameter is a boolean that is used to turn the boundary condition on/off.
The parameter is controllable during runtime and can be controlled via a `BoolFunctionControl`.

The switch works as follows:

- If `switch_bc = true`: the boundary condition is applied as described in [INSFVOutletPressureBC.md].

- If `switch_bc = false`: the boundary condition is not applied and a single sided extrapolation to the boundary
  is applied from internal extrapolation.

In both cases, the interpolated value at the face is controlled by `face_limiter`.
By default, `face_limiter = 1.0`.
`face_limiter` value is controllable during runtime.




### INSFVSymmetryPressureBC

Though applied to the pressure, this object ensures that the velocity
perpendicular to a symmetry boundary is zero by setting the mass flow rate
across the symmetry boundary to zero. In addition to the
`INSFVSymmetryPressureBC`, a [`INSFVSymmetryVelocityBC`](INSFVSymmetryVelocityBC.md)
should be applied for every velocity component on a symmetry boundary.




### INSFVSymmetryScalarBC

This object ensures that the scalar quantity flux
perpendicular to a symmetry boundary is zero. This is generally
already achieved by the velocity and mass symmetry boundary conditions, which
set the fluid normal velocity to zero, but may required in their absence.

If solving the fluid flow equations simultaneously, in addition to the
`INSFVSymmetryScalarBC`, an [INSFVSymmetryVelocityBC.md]
should be applied for every velocity component
and an [INSFVSymmetryPressureBC.md] should be applied on the pressure, on a symmetry boundary.




### INSFVSymmetryVelocityBC

This object implements a symmetry boundary condition for the velocity. It
applies boundary forces such that the gradient of the velocity parallel to the
boundary is zero in the boundary normal direction. A `INSFVSymmetryVelocityBC`
should be applied for every velocity component on a symmetry boundary. Similarly
an [`INSFVSymmetryPressureBC`](INSFVSymmetryPressureBC.md) should be applied for
the pressure on the symmetry boundary.




### INSFVTKEDWallFunctionBC

This boundary condition should only be used if no wall treatment is added.
Implements wall boundary conditions for the turbulent kinetic energy dissipation rate.
A separate treatment is used for the laminar and logarithmic layers.
A linear blending functions is used to interpolate between both layers.




### INSFVTurbulentTemperatureWallFunction

The function sets up the equivalent heat flux of the near-wall
boundary layer when the wall temperature is set by the `T_w` parameter.

The boundary conditions are different depending on whether the centroid
of the cell near the identified boundary lies in the wall function profile.
Taking the non-dimensional wall distance as $y^+$, the three regions of the
boundary layer are identified as follows:

- Sub-laminar region: $y^+ \le 5$
- Buffer region: $y^+ \in (5, 30)$
- Logarithmic region: $y^+ \ge 30$

For the procedure of determining the non-dimensional wall distance as $y^+$
and the friction velocity $u_{\tau}$ please see
[INSFVTurbulentViscosityWallFunction](INSFVTurbulentViscosityWallFunction.md).

For the sub-laminar and logarithmic layer, the thermal diffusivity is defined
as follows:

\begin{equation}
    \alpha =
    \begin{cases}
        \alpha_l = \frac{k}{\rho c_p} & \text{if } y^+ \le 5 \\
        \alpha_t = \frac{u_{\tau} y_p}{Pr_t w_s} & \text{if } y^+ \ge 30
    \end{cases}
\end{equation}

where:

- $k$ is the thermal conductivity
- $\rho$ is the density
- $c_p$ is the specific heat at constant pressure
- $u_{\tau}$ is the friction velocity defined by law of the wall
- $y_p$ is the distance from the boundary to the centroid of the near-wall cell
- $Pr_t$ is the turbulent Prandtl number, which typically ranges between 0.3 and 0.9
- $w_s$ is a near-wall scaling factor that is defined as follows:

\begin{equation}
  w_s = \frac{1}{\kappa} \operatorname{ln}(E y^+) + J_k \,,
\end{equation}

where:

- $\kappa = 0.4187$ is the von Kármán constant
- $E = 9.793$ is a closure parameter
- $J_k$ is the Jayatilleke wall functions defined as follows:

\begin{equation}
  J_k = 9.24 \left[ \left( \frac{Pr}{Pr_t} \right)^{0.75} - 1 \right] \left( 1 + 0.28 e^{-0.007 \frac{Pr}{Pr_t}} \right) \,,
\end{equation}

where:

- $Pr$ is the Prandtl number

For the buffer layer, i.e., in $y^+ \in (5, 30)$, the thermal diffusivity
is defined via a linear blending function as follows:

\begin{equation}
  \alpha_b = \alpha_t \frac{(y^+ - 5)}{25} + \alpha_l \left[ 1 - \frac{(y^+ - 5)}{25} \right]
\end{equation}

Finally, using the thermal diffusivity, the heat flux at the wall is defined
as follows:

\begin{equation}
  q''_w = - \rho c_p \alpha \frac{T_w - T_p}{y_p} \,,
\end{equation}

where:

- $T_p$ is the temperature at the centroid of the near-wall cell
- $y_p$ is the distance from the wall to the centroid of the near-wall cell

The thermal wall functions are only valid for regions in which the equilibrium
momentum wall functions are valid, i.e., no flow detachment, recirculation, etc.
For resolving non-equilibrium phenomena, we recommend refining the mesh.




### INSFVTurbulentViscosityWallFunction

Implements wall function boundary condition for the turbulent
dynamic viscosity $\mu_t$.

The boundary conditions are different depending on where the centroid
of the cell near the identified boundary lies in the wall function profile.
Taking the non-dimensional wall distance as $y^+$, the three regions of the
boundary layer are identified as follows:

- Sub-laminar region: $y^+ \le 5$
- Buffer region: $y^+ \in (5, 30)$
- Logarithmic region: $y^+ \ge 30$

The wall function goal is to set the total viscosity at the wall $\mu_w$, decomposed as
$\mu_w = \mu + \mu_t$, such that the wall shear stress $\tau_w$ is accurately captured 
without the need of fully resolving the gradients at the near wall region. 

\begin{equation}
    \tau_w = \frac{ \mu_w u_p}{y_p} \,,
\end{equation}

where:

- $\mu_w = \mu + \mu_t$  is the total viscosity evaluated at the wall face
- $\mu_t$ is the turbulent viscosity, evaluated at the wall for the purpose of this boundary condition
- $\mu$ is the dynamic viscosity, evaluated at the wall for the purpose of this boundary condition
- $\tau_w$ is the wall-shear stress
- $u_p$ is the wall-parallel velocity at the centroid
- $y_p$ is the wall normal distance to the centroid

To impose a correct boundary condition for $\mu_t$, as seen in the Equation above, we need to compute $\tau_w$ using analytical 
relationships between the wall shear stress and the dimensionless wall distance $y^+$. For this purpose, four different
formulations are supported as defined by the [!param](/FVBCs/INSFVTurbulentViscosityWallFunction/wall_treatment) parameter.

To set the grid spacing for the first cell near the wall in your mesh, we recommend using the [RANSYPlusAux.md] auxiliary kernel. 
to estimate the dimensionless wall distance $y^+$.

#### Equilibrium wall functions using a Newton solve

This treatment can be enabled by setting the parameter
[!param](/FVBCs/INSFVTurbulentViscosityWallFunction/wall_treatment) to `eq_newton`.
The treatment uses equilibrium wall functions where the following formulation is used
for the turbulent viscosity.

\begin{equation}
    \mu_t =
    \begin{cases}
        0 & \text{if } y^+ \le 5 \\
        \frac{\rho u_{\tau}^2 y_p}{u_p} - \mu & \text{if } y^+ \ge 30 \,,
    \end{cases}
\end{equation}

where:

- $\rho$ is the density
- $\mu$ is the dynamic viscosity
- $u_{\tau} = \sqrt{\frac{\tau_w}{\rho}}$ is the friction velocity and $\tau_w$ is the wall friction
- $y_p$ is the distance from the boundary to the center of the near-wall cell
- $u_p$ is the parallel velocity to the boundary computed at the center of the near-wall cell

For the buffer layer, a linear blending method is used that defines the turbulent viscosity as follows:

\begin{equation}
    \mu_t = \mu_t(y^+=30) \frac{(y^+ - 5)}{25}
\end{equation}

Note that for $y^+ = 5$ and $y^+ = 30$ we recover the sub-laminar and logarithmic profiles, respectively.

Here the standard or equilibrium law of the wall defines $y^+$ and $u_{\tau}$ as follows:

\begin{equation}
  \frac{u_p}{u_{\tau}} = \frac{1}{\kappa} \operatorname{ln}(E y^+) \,,
\end{equation}

\begin{equation}
  y^+ = \frac{\rho u_{\tau} y_p}{\mu} \,,
\end{equation}

where:

- $\mu$ is the molecular dynamic viscosity
- $E = 9.793$ is a closure parameter
- $\kappa = 0.4187$ is the von Kármán constant

In this method, we iterate on the wall function and $y^+$ to find
$u_{\tau}$ via a Newton solve. Once $u_{\tau}$ is defined, $y^+$ is
computed followed by the determination of the boundary turbulent viscosity.

`eq_newton` solve will converge the fastest for simple flow geometries but it
may diverge for more complicated flows. Also, the code will run if the center
of the near wall cells are in the buffer layer. However, using a mesh that
contains nodes in the buffer layer is not recommended.


#### Equilibrium wall functions using a fixed-point solve

This treatment is enabled by setting parameter
[!param](/FVBCs/INSFVTurbulentViscosityWallFunction/wall_treatment) to `eq_incremental`.
The method uses the same equilibrium wall treatment than the Newton solve.
However, the main difference is that, instead of computing $u_{\tau}$ for the
near wall cells, a fixed point iteration is performed in the wall functions
to find $y^+$.

`eq_incremental` has a larger convergence radius than the Newton solve and
internal controls are added to avoid issues converging the wall function
at the buffer layer. However, it will take more iterations than the Newton
solve to converge. Using a mesh that contains nodes in the buffer layer is
not recommended.


#### Equilibrium wall functions using linearized wall function

This treatment is enabled by setting parameter
[!param](/FVBCs/INSFVTurbulentViscosityWallFunction/wall_treatment) to `eq_linearized`.
The treatment uses a linearized version of the wall function, in which
a linear Taylor approximation is used for the natural logarithm.
This approximation results in a quadratic equation that is solved directly for $u_{\tau}$.
Then, $y^+$ is computed from $u_{\tau}$.

`eq_linearized` will work fast as there is no nonlinear solve at
the near-wall region. However, the method may introduce significant
near-wall errors. The method is designed to be used in conjunction
with porous media treatment and not necessarily for free flow.

#### Non-equilibrium wall functions

This treatment is enabled by setting parameter
[!param](/FVBCs/INSFVTurbulentViscosityWallFunction/wall_treatment) to `neq`.
In this case, the non-dimensional wall distance is computed from the
turbulent kinetic energy near the wall as follows:

\begin{equation}
  y^+ = \frac{\rho y_p C_{\mu}^{0.25} \sqrt{k_p}}{\mu} \,,
\end{equation}

where:

- $C_{\mu} = 0.09$ is a fitting parameter
- $k_p$ is the turbulent kinetic energy at the centroid of the near-wall cell

Then, the turbulent viscosity is defined as follows:

\begin{equation}
    \mu_t =
    \begin{cases}
        0 & \text{if } y^+ \le 5 \\
        \mu \left[ \frac{\kappa y^+}{\operatorname{ln}(E y^+)} - 1.0 \right] & \text{if } y^+ \ge 30
    \end{cases}
\end{equation}

For the buffer layer, a linear blending method is used that defines the turbulent viscosity as follows:

\begin{equation}
    \mu_t = \mu_t(y^+=30) \frac{(y^+ - 5)}{25}
\end{equation}

`neq` should mainly be used for detached flow or other cases for which equilibrium wall
functions are not valid. One should try to use equilibrium wall functions when possible.




### INSFVVaporRecoilPressureMomentumFluxBC


This object is the finite volume analog of
[INSADVaporRecoilPressureMomentumFluxBC.md]. It adds a flux to the Navier-Stokes
momentum equation of the form

\begin{equation}
\hat{n} p_r
\end{equation}

where $\hat{n}$ is the surface unit normal and $p_r$ is the recoil pressure that
represents the pressure impulse due to evaporation of material from the liquid
material we're a boundary condition for.




### INSFVWallFunctionBC

This object imposes a wall shear stress to the momentum equation according to
the standard wall functions. Besides imposing the corresponding shear stress,
it ensures zero advective flux at the wall (non-penetrability).




### NSFVFunctorHeatFluxBC


`NSFVFunctorHeatFluxBC` is a version of [NSFVHeatFluxBC.md] using functor material properties.
Please see the documentation for this other boundary condition.




### NSFVHeatFluxBC


### Description

Boundary condition splitting a constant heat flux among a two-phase fluid and solid domain
based on a number of different models. There is no general consensus on the best boundary
condition for all flows, and virtually all models for splitting a constant heat flux
among multiple phases are quite crude [!citep](alazmi).

By setting `phase = fluid`, this boundary condition specifies the heat flux in the
fluid energy conservation equation as

\begin{equation}
-\int_\Gamma\kappa_f\cdot\nabla T_f\cdot\hat{n}d\Gamma\ ,
\end{equation}

where

\begin{equation}
-\kappa_f\cdot\nabla T_f\cdot\hat{n}=\frac{\zeta_f}{\zeta_s+\zeta_f}\tilde{q}\ ,
\end{equation}

where $\tilde{q}$ is the total heat flux specified by the `value` parameter,
$\zeta_f$ is the fluid-phase value of $\zeta$ and $\zeta_s$ is the solid-phase value
of $\zeta$. $\zeta$ is a placeholder to be discussed shortly.

By setting `phase = solid`, this boundary condition specifies the heat flux in the
solid energy conservation equation as

\begin{equation}
-\int_\Gamma\kappa_s\cdot\nabla T_s\cdot\hat{n}d\Gamma\ ,
\end{equation}

where

\begin{equation}
-\kappa_s\cdot\nabla T_s\cdot\hat{n}=\frac{\zeta_s}{\zeta_s+\zeta_f}\tilde{q}\ .
\end{equation}

The `splitting` parameter determines the form of $\zeta$; the heat flux split can
be assigned based on

- porosity, in which case $\zeta_f=\epsilon$ and $\zeta_s=1-\epsilon$
- effective thermal conductivity, in which case $\zeta_f=\kappa_f$ and $\zeta_s=\kappa_s$
- thermal conductivity, in which case $\zeta_f=k_f$ and $\zeta_s=k_s$

$\zeta$ may also be calculated either from the local value at the wall by setting
`locality = local` or from a domain-averaging postprocessor by setting
`locality = global`. For instance, it is well known that the porosity at the wall is unity
due to point contacts between pebbles and the wall; if splitting the heat flux based on the
porosity, the unity porosity would result in the entire heat flux depositing in the
fluid phase, when in reality the combined conduction, convection, and radiation processes
always result in heat deposition into both phases. The `locality` parameter attempts to
capture some of this phasic behavior independent of the closures precisely at the wall.

This boundary condition does not specify the
interpretation of what constitutes the domain, so you may choose for the global values to
represent averages over the entire geometry, or possibly a finite-width region near the wall.

For the following combinations of splitting method and locality, the following parameters
must be provided:
- `splitting = porosity`, `locality = local`: `porosity` coupled variable
- `splitting = porosity`, `locality = global`: `average_porosity` postprocessor
- `splitting = thermal_conductivity`, `locality = local`: nothing, material property grabs don't require user input
- `splitting = thermal_conductivity`, `locality = global`: `average_k_fluid` and `average_k_solid` postprocessors
- `splitting = effective_thermal_conductivity`, `locality = local`: `porosity` coupled variable due to internal
   representation of $\kappa_f$ as $\epsilon\tilde{\kappa}_f$, where $\tilde{\kappa_f}\equiv\frac{\kappa_f}{\epsilon}$.
- `splitting = effective_thermal_conductivity`, `locality = global`: `average_kappa` and `average_kappa_solid` postprocessors,
   as well as `average_eps` postprocessor due to internal representation of $\kappa_f$ as $\epsilon\tilde{\kappa}_f$.

To protect against cases where at the first time step
the thermal conductivity or effective thermal conductivity might not have yet
been initialized, or cases where the coupled postprocessors have not yet been
evaluated, we use an equal flux splitting.





### NSFVOutflowTemperatureBC

This boundary condition allows the user to specify the backflow temperature in problems that have flow inversion at a boundary.
In case the flow is going outside of the domain, i.e., $\vec{u} \cdot \vec{n} > 0$, the enthalpy flux is defined as follows:

\begin{equation}
h_{out} = \rho c_p T,
\end{equation}

where $T$ is the extrapolated temperature from the domain to the boundary.


In case the flow is coming into the domain, i.e., $\vec{u} \cdot \vec{n} < 0$, the enthalpy flux is defined as follows:

\begin{equation}
h_{in} = \rho c_p T_{backflow},
\end{equation}
where $T_{backflow}$ is a user-specified backflow temperature.




### PCNSFVHLLCFluidEnergyBC

The `PCNSFVHLLCFluidEnergyBC` template class implements the momentum flux boundary condition for
porous Harten-Lax-Van Leer-Contact (HLLC) given either specified boundary momentum and
temperature functions or a
boundary pressure function. Note that these are functions corresponding to
static boundary quantities as opposed to stagnation quantities. More details
about the different template instantiations are given below.

#### PCNSFVHLLCSpecifiedMassFluxAndTemperatureFluidEnergyBC




#### PCNSFVHLLCSpecifiedPressureFluidEnergyBC




### PCNSFVHLLCMassBC

The `PCNSFVHLLCMassBC` template class implements the mass flux boundary condition for
porous Harten-Lax-Van Leer-Contact (HLLC) given either specified boundary momentum and
temperature functions or a
boundary pressure function. Note that these are functions corresponding to
static boundary quantities as opposed to stagnation quantities. More details
about the different template instantiations are given below.

#### PCNSFVHLLCSpecifiedMassFluxAndTemperatureMassBC




#### PCNSFVHLLCSpecifiedPressureMassBC




### PCNSFVHLLCMomentumBC

The `PCNSFVHLLCMomentumBC` template class implements the momentum flux boundary condition for
porous Harten-Lax-Van Leer-Contact (HLLC) given either specified boundary momentum and
temperature functions or a
boundary pressure function. Note that these are functions corresponding to
static boundary quantities as opposed to stagnation quantities. More details
about the different template instantiations are given below.

#### PCNSFVHLLCSpecifiedMassFluxAndTemperatureMomentumBC




#### PCNSFVHLLCSpecifiedPressureMomentumBC




### PCNSFVImplicitMomentumPressureBC


#### Overview

This object adds a boundary pressure flux based on cell interior (implicit)
information. This is the porous analog of
[CNSFVMomImplicitPressureBC.md].




### PCNSFVStrongBC


#### Overview

This object accepts functions describing boundary values for pressure, fluid
temperature, and superficial velocity. The superficial velocity functions can
also be used to supply superficial momentum information instead by setting
`velocity_function_includes_rho = true`. If no function is provided for a
quantity, the boundary value of that quantity will be determined by
extrapolating from the neighboring boundary cell centroid using cell centroid
value and gradient information. From this mix of user-provided functions and
extrapolated boundary values for pressure, fluid temperature, and superficial
velocity/momentum, the fluxes for mass, momentum, energy, and even passive
scalars can be computed.




### PINSFVMomentumAdvectionOutflowBC


#### Overview

This object implements the $\rho \dfrac{1}{\epsilon} \left(\vec u_d \cdot\nabla\right)\vec u_d$ component
term of the incompressible porous media Navier Stokes momentum equation along a domain boundary,
with $u_d$ the superficial or Darcy velocity.
It simultaneously requires that the normal gradient of each superficial velocity component at
the boundary be zero.




### PINSFVSymmetryVelocityBC

#### Overview

This object implements a symmetry boundary condition for the superficial velocity. It
applies boundary forces such that the gradient of the velocity parallel to the
boundary is zero in the boundary normal direction. A `PINSFVSymmetryVelocityBC`
should be applied for every superficial velocity component on a symmetry boundary. Similarly
an [`INSFVSymmetryPressureBC`](INSFVSymmetryPressureBC.md) should be applied for
the pressure on the symmetry boundary.





### PWCNSFVMomentumFluxBC


This object is the porous medium version of [WCNSFVMomentumFluxBC.md].

The momentum flux is:

\phi = \dfrac{\rho v_d^2}{\epsilon} = \dfrac{\dot{m}^2}{\rho \epsilon A^2}

with $\phi$ the momentum flux, $\rho$ the density, $v_d$ the fluid superficial
velocity (assumed normal to the surface here), $\epsilon$ the porosity of the medium,
$\dot{m}$ the mass flow rate, and $A$ the inlet area.

There are two options for specifying the momentum flux:

- specifying a mass flow rate postprocessor, which is then divided by the area of the inlet,
  which may also be a postprocessor.

- specifying an inlet superficial velocity postprocessor and a density functor. The functor is
  usually a functor material property, defined by a [GeneralFunctorFluidProps.md].

The scaling factor may be used if the inlet is not aligned with the X or Y direction,
in which case a projection is necessary and this boundary condition should be used for
both components of the momentum equation.

This boundary condition works with postprocessors, which may be replaced by constant
values in the input. The intended use case for this boundary condition is to be receiving its value from
a coupled application, using a [Receiver.md] postprocessor.




### WCNSFVEnergyFluxBC


The energy flux is:

\phi = v \rho c_p T = \dfrac{\dot{e}}{A} = \dfrac{\dot{m} c_p T}{A}

with $\phi$ the energy flux, $\rho$ the density, $c_p$ the specific heat capacity, $\v$ the fluid velocity (assumed normal to the surface),
$T$ the fluid temperature, $\dot{e}$ the energy flow rate, $\dot{m}$ the mass flow rate and $A$ the inlet area.

There are three options for specifying the energy flux:

- specifying an energy flow rate postprocessor, which is then divided by the area of the inlet,
  which may also be a postprocessor.

- specifying an inlet velocity and an inlet temperature postprocessors, a specific heat capacity and a density functor.

- specifying an inlet mass flow rate, a specific heat capacity and a n inlet temperature postprocessor.


The functors needed are usually functor material properties, defined by a [GeneralFunctorFluidProps.md].

This boundary condition works with postprocessors, which may be replaced by constant
values in the input. The intended use case for this boundary condition is to be receiving its value from
a coupled application, using a [Receiver.md] postprocessor.

#### Determining Flow Direction

The `isInflow()` method is used to determine if the boundary is an inflow boundary.
The user must at least set one of the following parameters [!param](/FVBCs/WCNSFVEnergyFluxBC/energy_pp), [!param](/FVBCs/WCNSFVEnergyFluxBC/mdot_pp), or [!param](/FVBCs/WCNSFVEnergyFluxBC/velocity_pp). The code checks the parameters in the following order:


  -  if [!param](/FVBCs/WCNSFVEnergyFluxBC/mdot_pp) is provided, [!param](/FVBCs/WCNSFVEnergyFluxBC/mdot_pp) $>0$ indicates inflow,

  -  else if [!param](/FVBCs/WCNSFVEnergyFluxBC/velocity_pp) is provided, [!param](/FVBCs/WCNSFVEnergyFluxBC/velocity_pp) $>0$ indicates inflow,

  -  else if [!param](/FVBCs/WCNSFVEnergyFluxBC/energy_pp) is provided, [!param](/FVBCs/WCNSFVEnergyFluxBC/energy_pp) $>0$ indicates inflow.


#### Example input syntax

In this example input, the inlet boundary condition to the energy conservation equation is
specified using a `WCNSFVEnergyFluxBC`. The energy flux is specified using the mass flow rate, the inlet area,
the specific heat capacity and the temperature.





### WCNSFVInletTemperatureBC


There are three options for specifying the inlet temperature of the system:

- specifying a temperature postprocessor

- specifying an energy flow rate postprocessor, a mass flow rate postprocessor and a specific heat
  capacity functor. The functors are usually a functor material property, defined by a [GeneralFunctorFluidProps.md].
  The scaling factor can be used to account for projections if the inlet flow and
  the surface are not aligned.

- specifying an energy flow rate postprocessor, a mass flow rate postprocessor, a specific heat capacity
  and a density functor. The functors are usually a functor material property, defined by a [GeneralFunctorFluidProps.md].
  The scaling factor can be used to account for projections if the inlet flow and
  the surface are not aligned.


This boundary condition works with postprocessors, which may be replaced by constant
values in the input. The intended use case for this boundary condition is to be receiving its value from
a coupled application, using a [Receiver.md] postprocessor.

Specifying the inlet temperature using a `WCNSFVInletTemperatureBC` will not preserve
energy flow at the boundary in most cases, in part because of the discretization error.
Specifying an incoming energy flux using a [WCNSFVEnergyFluxBC.md] is currently the only conservative
approach.

#### Example input syntax

In this example input, the inlet boundary condition to the energy conservation equation
is specified using two `WCNSFVInletTemperatureBC`.
The inlet temperature is specified using an energy and a mass flow rate postprocessors.





### WCNSFVInletVelocityBC


There are two options for specifying a component of the inlet velocity:

- specifying a velocity postprocessor

- specifying a mass flow rate postprocessor and a density functor. The functor is
  usually a functor material property, defined by a [GeneralFunctorFluidProps.md].
  The scaling factor can be used to account for projections if the inlet flow and
  the surface are not aligned.


This boundary condition works with postprocessors, which may be replaced by constant
values in the input. The intended use case for this boundary condition is to be receiving its value from
a coupled application, using a [Receiver.md] postprocessor.

Specifying the inlet velocity using a `WCNSFVInletVelocityBC` will not preserve
mass or momentum flow at the boundary in most cases, in part because of the discretization error.
Specifying incoming mass and momentum fluxes using a [WCNSFVMassFluxBC.md] and a
[WCNSFVMomentumFluxBC.md] is currently the only conservative approach.

#### Example input syntax

In this example input, the boundary conditions to the mass conservation equation and the
momentum equations are specified using two `WCNSFVInletVelocityBC`, one for each component of the velocity.
The inlet velocity is specified using a mass flow rate postprocessor.





### WCNSFVMassFluxBC


The mass flux is:

\phi = \rho v = \dfrac{\dot{m}}{A}

with $\phi$ the mass flux, $\rho$ the density, $\v$ the fluid velocity,
$\dot{m}$ the mass flow rate and $A$ the inlet area.

There are two options for specifying the mass flux:

- specifying a mass flow rate postprocessor, which is then divided by the area of the inlet,
  which may also be a postprocessor.

- specifying an inlet velocity postprocessor and a density functor. The functor is
  usually a functor material property, defined by a [GeneralFunctorFluidProps.md].


This boundary condition works with postprocessors, which may be replaced by constant
values in the input. The intended use case for this boundary condition is to be receiving its value from
a coupled application, using a [Receiver.md] postprocessor.

#### Example input syntax

In this example input, the inlet boundary condition to the mass conservation equation is
specified using a `WCNSFVMassFluxBC`. The mass flux is specified using the mass flow rate
and the inlet area.





### WCNSFVMomentumFluxBC


The momentum flux is:

\phi = \rho v^2 = \dfrac{\dot{m}^2}{\rho A^2}

with $\phi$ the momentum flux, $\rho$ the density, $v$ the fluid velocity (assumed normal to the surface),
$\dot{m}$ the mass flow rate and $A$ the inlet area.

There are two options for specifying the momentum flux:

- specifying a mass flow rate postprocessor, which is then divided by the area of the inlet,
  which may also be a postprocessor.

- specifying an inlet velocity postprocessor and a density functor. The functor is
  usually a functor material property, defined by a [GeneralFunctorFluidProps.md].


The scaling factor may be used if the inlet is not aligned with the X or Y direction,
in which case a projection is necessary and this boundary condition should be used for
both components of the momentum equation.

This boundary condition works with postprocessors, which may be replaced by constant
values in the input. The intended use case for this boundary condition is to be receiving its value from
a coupled application, using a [Receiver.md] postprocessor.

#### Example input syntax

In this example input, the inlet boundary condition to the momentum conservation equation is
specified using a `WCNSFVMomentumFluxBC`. The momentum flux is specified using the mass flow rate
and the inlet area.





### WCNSFVScalarFluxBC


The flux for scalar quantity $c$ is:

\phi = v c = \dfrac{\dot{m} c}{\rho A}

with $\phi$ the scalar quantity flux, $\rho$ the density, $v$ the fluid speed,
$c$ the inlet value of the scalar quantity, $\dot{m}$ the mass flow rate and $A$ the inlet area.

There are three options for specifying the scalar flux:

- specifying the surface integrated scalar quantity flow rate directly, which is then divided
  by the area of the inlet to obtain the local flux.

- specifying an inlet velocity postprocessor and an inlet value for the scalar quantity.

- specifying the inlet value for the scalar quantity, a postprocessor for the mass flow rate,
  a density functor and the inlet surface area. These last three quantities are used to compute
  the inlet velocity.


This boundary condition works with postprocessors, which may be replaced by constant
values in the input. The intended use case for this boundary condition is to be receiving its value from
a coupled application, using a [Receiver.md] postprocessor.

#### Determining Flow Direction

The `isInflow()` method is used to determine if the boundary is an inflow boundary.
The user must at least set one of the following parameters [!param](/FVBCs/WCNSFVScalarFluxBC/scalar_flux_pp), [!param](/FVBCs/WCNSFVScalarFluxBC/mdot_pp), or [!param](/FVBCs/WCNSFVScalarFluxBC/velocity_pp). The code checks the parameters in the following order:


  -  if [!param](/FVBCs/WCNSFVScalarFluxBC/mdot_pp) is provided, [!param](/FVBCs/WCNSFVScalarFluxBC/mdot_pp) $>0$ indicates inflow,

  -  else if [!param](/FVBCs/WCNSFVScalarFluxBC/velocity_pp) is provided, [!param](/FVBCs/WCNSFVScalarFluxBC/velocity_pp) $>0$ indicates inflow,

  -  else if [!param](/FVBCs/WCNSFVScalarFluxBC/scalar_flux_pp) is provided, [!param](/FVBCs/WCNSFVScalarFluxBC/scalar_flux_pp) $>0$ indicates inflow.

#### Example input syntax

In this example input, the inlet boundary conditions to the scalar quantity conservation equation is
specified using a `WCNSFVScalarFluxBC`. The scalar quantity flux is specified using the mass flow rate
and the inlet area.





### WCNSFVSwitchableInletVelocityBC


The file is similar to [WCNSFVInletVelocityBC.md] but it allows the boundary conditions to be switched on/off.

The `switch_bc` parameter is a boolean that is used to turn the boundary condition on/off.
The parameter is controllable during runtime and can be controlled via a `BoolFunctionControl`.

The switch works as follows:

- If `switch = true`: the boundary condition is applied as described in [WCNSFVInletVelocityBC.md].

- If `switch = false`: the boundary condition is not applied and a single sided extrapolation to the boundary
  is applied from internal extrapolation.

In both cases, the interpolated value at the face is controlled by `face_limiter`.
By default, `face_limiter = 1.0`.
`face_limiter` value is controllable during runtime.

#### Example input syntax

In this example input, the boundary conditions to the mass conservation equation and the
momentum equations are specified using two `WCNSFVSwitchableInletVelocityBC`, one for each component of the velocity.
The inlet velocity is specified using a mass flow rate postprocessor.





## fviks

### FVConvectionCorrelationInterface


The surface convective flux to the fluid is then:
\begin{equation}
q_s = h_{correlation} (T_{solid} - T_{fluid})
\end{equation}
with $q_s$ the surface convective heat flux, $h_{correlation}$ the heat transfer coefficient
defined by the correlation as a material property and $T_{solid/fluid}$ the temperature of the
adjacent solid and fluid.

This kernel supports interfaces between variables which belong to different nonlinear systems.
For instructions on how to set these cases up, visit the [FVInterfaceKernels syntax page](syntax/FVInterfaceKernels/index.md).

#### Example input file syntax

In this example, a cold fluid is flowing next to a centrally-heated solid region. The heat diffuses
through the solid region, and convection at the interface transfers the heat to the fluid.





## fvkernels

### CNSFVFluidEnergyHLLC


#### Overview

This object implements the energy equation inter-cell fluxes for the
Harten-Lax-Van Leer-Contact (HLLC) formulation described in [CNSFVHLLCBase.md].




### CNSFVHLLCBase

`CNSFVHLLCBase` is the base class from which all Harten-Lax-Van Leer-Contact
(HLLC) residual computing objects inherit from. It computes the wave speeds for
the HLLC formulation. Because it is the base class for all HLLC residual
objects, we will use its documentation page to outline the HLLC equations. The
HLLC flux is defined as:

\begin{equation}
\bm{F}_{HLLC} =
\begin{cases}
\bm{F}_L & \textrm{if } 0 \leq S_L \\
\bm{F}_{*L} & \textrm{if } S_L \leq 0 \leq S_* \\
\bm{F}_{*R} & \textrm{if } S_* \leq 0 \leq S_R \\
\bm{F}_R & \textrm{if } 0 \geq S_R
\end{cases}
\end{equation}

where $\bm{F}_{L,R}$ are the left and right evaluations respectively of the
convective flux:

\begin{equation}
\bm{F} =
\begin{bmatrix}
\rho a_n\\
\rho a_n u + p n_x\\
\rho a_n v + p n_y\\
\rho a_n w + p n_z\\
\rho e_t + p
\end{bmatrix}
\end{equation}

where $a_n = \bm{a}\cdot\hat{n}$ where $\bm{a} = \lbrace u, v, w\rbrace$ and
$\hat{n}$ is the normal vector at the face. $n_x$, $n_y$, and $n_z$ represent
the $x$, $y$, and $z$ components of the normal vector respectively, while $u$,
$v$, and $w$ represent the $x$, $y$, and $z$ components of the velocity $\bm{a}$
respectively. $p$ is the static pressure and $e_t = e +
\lparen\bm{v}\cdot\bm{v}\rparen/2$ where $e$ is the specific internal
energy. $\rho$ is the density. $S_L$, $S_*$, and $S_R$ are the left, middle, and
right wave speeds respectively. $S_*$ is given by [!citep](toro2009riemann):

\begin{equation}
S_* = \frac{p_R - p_L + \rho_L a_{n,L}\left(S_L - a_{n,L}\right) - \rho_R a_{n,R}
\left(S_R - a_{n,R}\right)}{\rho_L \left(S_L - a_{n,L}\right) -
\rho_R\left(S_R - a_{n,R}\right)}
\end{equation}

The intermediate flux states (denoted by *) are described by [!citep](toro2009riemann):

\begin{equation}
\bm{F}_{*L} = \bm{F}_L + S_L\left(\bm{U}_{*L} - \bm{U}_L\right)\\
\bm{F}_{*R} = \bm{F}_R + S_R\left(\bm{U}_{*R} - \bm{U}_R\right)
\end{equation}

where the solution states $\bm{U}_{L,R}$ are given by the left and right
evaluations of

\begin{equation}
\bm{U}_K =
\begin{bmatrix}
\rho_K\\
\rho_K u_K\\
\rho_K v_K\\
\rho_K w_K\\
\rho_K e_{t,K}
\end{bmatrix}
\end{equation}

where $K=L$ and $K=R$ respectively and the intermediate solution states (the * states) are described by the left
and right evaluations of [!citep](toro2009riemann):

\begin{equation}
\bm{U}_{*K} = \rho_K \left(\frac{S_K - a_{n,K}}{S_K - S_*}\right)
\begin{bmatrix}
1\\
n_x \left(S_* - a_{n,K}\right) + u_K\\
n_y \left(S_* - a_{n,K}\right) + v_K\\
n_z \left(S_* - a_{n,K}\right) + w_K\\
e_{t,K} + \left(S_* -
a_{n,K}\right)\left[S_* + \frac{p_K}{\rho_K\left(S_K - a_{n,K}\right)}\right]
\end{bmatrix}
\end{equation}

The final piece to finish the definition of the HLLC flux is to specify the
evaluation of the left and right wave speeds, $S_L$ and $S_R$. These can be
evaluated in a variety of ways, but the current `CNSFVHLLCBase` implementation
evaluates them as follows, following [!citep](batten1997average):

\begin{equation}
S_L = \text{min}\lparen a_{n,L} - c_L, a_{n,\text{Roe}} - c_{\text{Roe}}\rparen\\
S_R = \text{max}\lparen a_{n,R} + c_R, a_{n,\text{Roe}} + c_{\text{Roe}}\rparen
\end{equation}

where $c$ denotes the local speed of sound in the medium and $\text{Roe}$
denotes Roe-averaged quantities which are computed via

\begin{equation}
b_{\text{Roe}} = \frac{\sqrt{\rho_L} b_{L} + \sqrt{\rho_R}
b_{R}}{\sqrt{\rho_L} + \sqrt{\rho_R}}
\end{equation}

where $b$ can be any quantity such as $a_n$ or $c$.


### CNSFVMassHLLC


#### Overview

This object implements the mass equation inter-cell fluxes for the
Harten-Lax-Van Leer-Contact (HLLC) formulation described in [CNSFVHLLCBase.md].




### CNSFVMomentumHLLC


#### Overview

This object implements the momentum equation inter-cell fluxes for the
Harten-Lax-Van Leer-Contact (HLLC) formulation described in [CNSFVHLLCBase.md].




### FVMatPropTimeKernel


#### Overview

This object simply populates the residual with the value of the material
property passed in (specified by `mat_prop_time_derivative`). It is the
responsibility of the material providing this property to ensure that the time
derivative is computed properly.




### FVPorosityTimeDerivative


#### Overview

This object simply multiplies the residual of [FVTimeKernel.md] by the
porosity. In other words this object computes:

\begin{equation}
\int_{\Omega_C} \epsilon\frac{\partial u}{\partial t} dV
\end{equation}

where $u$ corresponds to the `variable` parameter.




### INSFVBodyForce

This object implements both the functionalities as [FVBodyForce.md] and [FVCoupledForce.md] but it's
dedicated to use in the Navier-Stokes momentum equation.

A body force in the momentum equation can be a momentum source,
like a pump, or a momentum sink, like a volumetric friction term. Friction terms may also be modeled with [PINSFVMomentumFriction.md].

#### Example input syntax

In this example, the `INSFVBodyForce` is used to apply a forcing function to the momentum equation in a method of manufactured solution study.





### INSFVEnergyAdvection

This object adds a $\rho c_p \vec u \cdot \nabla T$ term to a finite volume
formulation of a heat transport equation. The user can control what (material) quantity is
advected through the `advected_quantity` parameter. The default value is the
name `rho_cp_temp` which corresponds to a material property name declared by
[INSFVEnthalpyFunctorMaterial.md].




### INSFVEnergyTimeDerivative

#### Description

The `INSFVEnergyTimeDerivative` kernel implements a time derivative for the domain $\Omega$ given by

\begin{equation}
\underbrace{\rho c_p \frac{\partial T}{\partial t}}_{\textrm{INSFVEnergyTimeDerivative}} +
\sum_{i=1}^n \beta_i = 0 \in \Omega.
\end{equation}
where $\rho$ is the material density, $c_p$ is the specific heat, $T$ is the fluid temperature and the
second term on the left hand side corresponds to the strong forms of other kernels.

The Jacobian is computed with automatic differentiation.

#### Implementation

The derivative is obtained from the definition of the fluid energy. The isobaric and isochoric heat
capacities being equal for incompressible fluids,

\begin{equation}
U(T(t), p(t)) = \rho(T(t), p(t)) \int_0^T(t) dT cp(T(t), p(t))
\end{equation}

we take the partial derivative with regards to time:

\begin{equation}
\frac{\partial U}{\partial t} = \frac{\partial \rho(T, p)}{\partial t} \int_0^T dT cp(T, p) + \rho(T, p) \frac{\partial T}{\partial t} cp(T, p)
\end{equation}

The variation of the kinetic energy is not considered in this kernel.

The specific energy, $u = \int_0^T dT cp(T, p)$, is currently approximated as $c_p T$.




### INSFVMassAdvection

This object computes the residual and Jacobian contribution of the
incompressible version of the mass continuity equation, e.g. $\nabla\cdot \rho \vec
u$. We apply the divergence theorem and compute the advective flux of mass
across cell/element faces.




### INSFVMeshAdvection

As outlined in [!citep](maury1996characteristics), when converting a time
derivative term in the reference frame to a time derivative term in the
arbitrary Lagrangian-Eulerian (ALE) frame, the following equation should be used

\begin{equation}
\label{maury}
\frac{\partial\phi}{\partial t} = \frac{\partial \phi_{\tau}}{\partial t} -
\vec{c}_{\tau} \nabla\phi_{\tau}
\end{equation}

where $\phi$ is an arbitrary quantity we are taking the time derivative of,
$\tau$ denotes the ALE frame at a given time point, and $\vec{c}$ denotes the
mesh velocity or rate of change of coordinates in the ALE frame; this is
equivalent to $\partial\vec{d}/\partial t$, e.g. the partial derivative of the
displacement field with respect to time on the reference mesh.

In a Navier-Stokes setting, we are interested in implementing [maury] multiplied
through by the density $\rho$:

\begin{equation}
\label{NS_ALE}
\rho\frac{\partial\phi}{\partial t} = \rho\frac{\partial \phi_{\tau}}{\partial t} -
\rho\vec{c}_{\tau} \nabla\phi_{\tau}
\end{equation}

In the finite volume setting we compute advective fluxes on faces. This requires
constructing divergence terms of the form $\nabla \cdot \Box$. To do so we
rewrite the last term on the right hand side of [NS_ALE] using the product rule
(dropping the $\tau$ subscripts from here on out) as

\begin{equation}
-\rho\vec{c}\nabla\phi = -\nabla\cdot\left(\rho\vec{c}\phi\right) +
\phi\nabla\cdot\left(\rho\vec{c}\right)
\end{equation}

For a constant density $\rho$ can be moved outside of divergence operator
leaving the last term on the right hand side as

\begin{equation}
\label{mesh_advection}
\rho\phi\nabla\cdot\vec{c}
\end{equation}

where again $\vec{c} = \partial\vec{d}/\partial t$. `INSFVMeshAdvection`
implements [mesh_advection]. The `advected_quantity` parameter  specifies $\phi$. For
energy transport, this would be the specific enthalpy $h$. For momentum
transport it is the velocity, e.g. the `variable` parameter itself. The momentum
transport version of this object is [INSFVMomentumMeshAdvection.md]. It
suppresses the `advected_quantity` parameter in order to advect the `variable`.




### INSFVMixingLengthReynoldsStress

This kernel uses a mixing-length model to compute the Reynolds stress,
$-\rho \overline{ \vec u' \vec u' }$, which appears in Reynolds-averaged
momentum equations. The velocity scaling is computed using Smagorinsky's
formulation.




### INSFVMixingLengthScalarDiffusion

This kernel uses a mixing-length model to compute the turbulent diffusion of a
passive scalar, $\nabla \cdot \overline{ c' \vec u'}$, which appears in
Reynolds-averaged conservation equations.

Example passive scalars include energy and trace chemicals. In the case of
energy, the turbulent Schmidt number parameter is actually referred to as the
turbulent Prandtl number.




### INSFVMomentumAdvection

This object implements the $\nabla \cdot \left(\rho\vec u \otimes \vec u\right)$ component
terms of the
incompressible Navier Stokes momentum equation. An average or Rhie-Chow
interpolation can be used for the advecting velocity interpolation. An average
or upwind interpolation can be used for the advected quantity, which in this
case is the momentum component $\rho u_i$ where $u_i$ denotes the x, y, or z
component of the velocity in Cartesian coordinates, or the r or z component of
the velocity in RZ coordinates.

The default is to use the same $a$ coefficients when computing the kernel residuals
that strongly affect the solution and when computing the Rhie-Chow
velocity which weakly affects the solution by perturbing the linearly
interpolated velocity as shown in the Rhie-Chow velocity computation shown in
[INSFVRhieChowInterpolator.md], which we reproduce here:

\begin{equation}
\label{rcvel}
\bm{v}_f = \overline{\bm{v}_f} - \overline{\bm{D}_f}\left(\nabla p_f - \overline{\nabla p_f}\right)
\end{equation}

where

\overline{D_{fi}} = \overline{\frac{V}{a_i}}

where $V$ corresponds to element volumes and $i$ denotes a Cartesian component,
e.g. $x$, $y$, $z$.

However, this default treatment
creates some challenges. It adds additional nonlinearity to the already
nonlinear momentum advection term because of the presence of $\vec{u}\cdot\hat{n}$ in
the $a$ coefficients. This additional nonlinearity may be eliminated by
performing an approximated calculation of $a$. The approximation of $a$
substitutes $\vec{u}\cdot\hat{n}$ with a `characteristic_speed` provided by the
user. This has the effect of converting the default anisotropic,
solution-dependent advection contribution to $a$ to a constant (as long as the
density is constant), isotropic contribution more analogous to the
[INSFVMomentumDiffusion.md] contribution to $a$.

This approximate calculation of the contribution of advection to $a$ may change the amount of velocity
perturbation in [rcvel]. Increasing perturbation may decrease error in the
pressure solution due to decreasing the pressure checkerboard and increase error
in the velocity solution.




### INSFVMomentumBoussinesq

This object adds a $\rho\alpha\vec{g}(T - T_{ref})$ term to the incompressible
Navier Stokes (INS) equations where $\rho$ is the density, $\alpha$ is the thermal
expansion coefficient, $\vec{g}$ is the gravity vector, $T$ is the temperature,
and $T_{ref}$ is a reference temperature. The term above introduces the
Boussinesq approximation into the INS equations, which allows for modeling
natural convection.




### INSFVMomentumDiffusion

This object implements the Laplace form of the viscous stress in the
Navier-Stokes momentum equation, e.g.

\begin{equation}
-\nabla \cdot \mu \nabla \bm{v}
\end{equation}

where $\mu$ is the dynamic viscosity, and $\bm{v}$ is the velocity.

The object also takes a parameter
[!param](/FVKernels/INSFVMomentumDiffusion/complete_expansion) which is
`false` by default. If [!param](/FVKernels/INSFVMomentumDiffusion/complete_expansion)
is activated, the following complete formulation is used for the momentum viscous stress:

\begin{equation}
- \left[ \nabla \cdot \mu \left( \nabla \bm{v} +  (\nabla \bm{v})^T \right) \right]
\end{equation}

The term $\nabla \cdot \mu (\nabla \bm{v})^T = 0$ for incompressible flow if a constant
dynamic viscosity is used.




### INSFVMomentumGravity

This object adds a simple gravitational force term to the incompressible Navier
Stokes equations of the form $-\rho\vec{g}$ where $\rho$ is the density and
$\vec{g}$ is the gravity vector.




### INSFVMomentumMeshAdvection

This object is the momentum-specific implementation of [INSFVMeshAdvection.md]
in which the velocity component, specified with the `variable` parameter, is
advected.




### INSFVMomentumPressure

This object adds the $\nabla p$ term of the
incompressible Navier Stokes momentum equation. The pressure is a Lagrange
Multiplier that ensures the incompressibility constraint.




### INSFVMomentumPressureFlux

This object adds the $\nabla p$ pressure gradient term of the incompressible
Navier Stokes momentum equation as a surface term using the divergence theorem.

The pressure is a Lagrange Multiplier that ensures the incompressibility constraint.




### INSFVMomentumTimeDerivative

This object adds the $\rho\frac{\partial \vec u_i}{\partial t}$ term of the
incompressible Navier Stokes momentum equation where $\rho$ is the density,
$\vec u_i$ refers to the i'th component of the velocity $\vec{u}$, and $t$ is
time. This kernel must be applied for every component of the velocity.




### INSFVPump

This object sets the volumetric force of the pump in the momentum system
via the pump functor provided by [NSFVPumpFunctorMaterial.md].




### INSFVScalarFieldAdvection

This object adds a $\nabla \cdot \vec u \phi$ term for an arbitrary scalar field
$\phi$, where $\phi$ corresponds to the nonlinear variable that this kernel acts
on. The nonlinear `variable` can be of type `MooseVariableFVReal` or for
consistency with other INSFV naming conventions, can be of type
[`INSFVScalarFieldVariable`](INSFVScalarFieldVariable.md).

When using a mixture model for multiphase flows, this kernel also allows us
to add the slip velocity, which is modeled by the following term:

\begin{equation}
  \nabla \cdot \bm{v}_{slip,d} \phi \,,
\end{equation}

where:

- $\bm{v}_{slip,d}$ is the slip velocity of the transported phase

When adding the slip velocity, the net advection term that is added is the following
$\bm{v}_{d} = \bm{v} + \bm{v}_{slip,d}$, where $\bm{v}$ is the mixture velocity.




### INSFVTKEDSourceSink

The object computes the turbulent source and sink term for the turbulent kinetic energy dissipation rate equation.

Two terms are computed: `destruction` and `production` and the term `destruction - production` is
passed to the residual.
A different treatment is used for the bulk and the near wall regions.

#### Bulk formulation:

The production of turbulent kinetic energy dissipation $G_\epsilon$ is modeled as follows:

\begin{equation}
G_{\epsilon} = C_{1,\epsilon} \frac{\epsilon}{k} G_k \,,
\end{equation}

where:

- $C_{1,\epsilon} = 1.44$ is a closure parameter,
- $G_k$ is the limited turbulent kinetic energy production. For more details please refer to [INSFVTKESourceSink](INSFVTKESourceSink.md).

The destruction of the turbulent kinetic energy dissipation rate is modeled as follows:

\begin{equation}
\epsilon_{\epsilon} = \frac{C_{2,\epsilon} \rho \epsilon}{t_k} \,,
\end{equation}

where:

- $C_{2,\epsilon} = 1.92$ is a closure parameter,
- $\epsilon$ is the solution variable, i.e., the dissipation rate of the turbulent kinetic energy,
- $k$ is the turbulent kinetic energy,
- $t_k = \frac{k}{\epsilon}$ is the turbulent time scale; if the [!param](/FVKernels/INSFVTKEDSourceSink/linearized_model) is `true`, this timescale is computed from the previous iteration; if [!param](/FVKernels/INSFVTKEDSourceSink/linearized_model) is `false`, in a nonlinear solve, this timescale is aded to the Jacobian.

#### Wall formulation:

All cells in contact with a boundary identified in the [!param](/FVKernels/INSFVTKEDSourceSink/walls) list are applied a different
treatment in which the equilibrium value for the $\epsilon = \epsilon_{eq}$ is set.
A separate formulation is used for the `sub-laminar` and `logarithmic` boundary layers.
The determination of whether the near-wall cell lies in the laminar or logarithmic region
is performed via the non-dimensional wall distance $y^+$.
The non-dimensional wall distance can be defined differently according to the
[!param](/FVKernels/INSFVTKEDSourceSink/wall_treatment) parameter. 

The four formulations are described in more detail in [INSFVTurbulentViscosityWallFunction.md]. 

If an equilibrium [!param](/FVKernels/INSFVTKEDSourceSink/wall_treatment) is defined, i.e. `eq_newton`,`eq_incremental` or `eq_linearized`, the standard wall function formulations are used in which $y^+$ is found:

\begin{equation}
y^+ = \frac{\rho y_p u_{\tau}}{\mu} \,,
\end{equation}

where:

- $\rho$ is the density,
- $y_p$ is the distance from the wall to the centroid of the next-to-wall cell,
- $u_{\tau}$ is the friction velocity, defined as $u_{\tau} = \sqrt{\frac{\tau_w}{\rho}}$ with $\tau_w$ the shear stress at the wall for which the condition is applied,
- $\mu$ is the dynamic molecular viscosity.

If a non-equilibrium [!param](/FVKernels/INSFVTKEDSourceSink/wall_treatment) is defined, i.e. `neq`,
the $y^+$ is defined non-iteratively as follows:

\begin{equation}
y^+ = \frac{y_p \sqrt{\sqrt{C_{\mu}}k}}{\mu} \,,
\end{equation}

Using non-equilibrium wall functions is recommended for problems with recirculations and boundary layer detachment. However, using non-equilibrium wall functions will deteriorate results for standard problems such as flow developing over walls.

The cells with $y^+ < 11.25$ belong to `sub-laminar` boundary layer.
The ones belonging to the `logarithmic` boundary layer are those for which $y^+ \ge 11.25$.

A different value is used for $\epsilon_{eq}$ in each of the two regions.
For the `sub-laminar` boundary layer, the equilibrium value is determined as follows:

\begin{equation}
\epsilon_{eq} = 2 \frac{k \mu}{y_p^2}\,,
\end{equation}

where:

- $\mu_t$ is the turbulent dynamic viscosity.

For the `logarithmic` boundary layer, the value is determined as follows:

\begin{equation}
\epsilon_{eq} = \frac{C_{\mu}^{0.75} \rho k^{1.5}}{\kappa y_p}\,,
\end{equation}

where:

- $\kappa = 0.4187$ is the von Kármán constant.

When using wall functions, since the equilibrium value for $\epsilon$ is set in the cells near the wall, the user is recommended to deactivate advection and diffusion for those near wall cells.

When the wall treatment is specified in this kernel, any boundary condition for $\epsilon$ will be ignored.
In other words, there is no need to impose boundary conditions for $\epsilon$ when the wall treatment
is specified in his kernel.

When using near-wall treatment, we assume that the $\mu_t$ functor is computed by an object
that performs near-wall treatment. Otherwise, the results obtained won't be physically correct.




### INSFVTKESourceSink

The object computes the turbulent source and sink term for the turbulent kinetic energy equation.

Two terms are computed `destruction` = $\epsilon$ and `production` = $G_k$ and the term $\epsilon - G_k$ is
passed to the residual.
A different treatment is used for the bulk and the near wall regions.

#### Bulk formulation:

The turbulent production $G_k$ is modeled as:

\begin{equation}
G_k = \mu_t S^2 \,,
\end{equation}

where:

- $\mu_t$ is the turbulent dynamic viscosity,
- $S$ is the shear strain tensor internal norm, defined as $S = \sqrt{2\mathbf{S}:\mathbf{S}}$ with the shear strain tensor defined as $\mathbf{S} = \frac{1}{2} [\nabla \vec{u} + (\nabla \vec{u})^T]$.

The turbulent kinetic energy dissipation rate $\epsilon$ is generally coming from a coupled
transport equation for $\epsilon$.
However, for canonical or measured cases, e.g., isotropic decaying turbulence,
the user can utilize predefined fields through functors in MOOSE.

To avoid the overproduction of turbulent kinetic energy in stagnation zones \cite{durbin1996k}, a production limiter is imposed in relation to the dissipation using the formulation in \cite{menter1994two}:

\begin{equation}
G_k = min \left( G_k , C_{PL} \rho \epsilon \right) \,,
\end{equation}

where:

- $C_{PL}$ it the limiter constant, and set by default to a recommended value of 10 \cite{durbin1996k}.

#### Wall formulation:

All cells in contact with a boundary identified in the [!param](/FVKernels/INSFVTKESourceSink/walls) list are applied a different
treatment for production and destruction.
A different formulation is used for the `sub-laminar` and `logarithmic` boundary layers.
The determination of whether the near-wall cell lies in the laminar or logarithmic region
is performed via the non-dimensional wall distance $y^+$.
The non-dimensional wall distance is defined as

\begin{equation}
y^+ = \frac{\rho y_p u_{\tau}}{\mu} \,,
\end{equation}

where:

- $\rho$ is the density,
- $y_p$ is the distance to the wall to the centroid of the next-to-wall cell,
- $u_{\tau}$ is the friction velocity, defined as $u_{\tau} = \sqrt{\frac{\tau_w}{\rho}}$ with $\tau_w$ the shear stress at the wall for which the condition is applied,
- $\mu$ is the dynamic molecular viscosity.

For every next-to-wall cell and every iteration step, $y^+$ is found via an
incremental fixed-point search algorithm.
The cells belonging to the `sub-laminar` boundary layers are defined as those
for which $y^+ < 11.25$.
The ones belonging to the `logarithmic` boundary layer are those for which $y^+ \ge 11.25$.
The imposed threshold of $y^+ = 11.25$ is given by the value of $y^+$ at which the `sub-laminar`
and `logarithmic` boundary profiles intersect.

In the `sub-laminar` region production of turbulent kinetic energy is negligible, therefore, if $y^+ \lt 11.25$:

\begin{equation}
G_k = 0.0 \,,
\end{equation}

In the `logarithmic` boundary layers the production term is no longer negligible and is defined as:

\begin{equation}
G_k = \tau_w ||\nabla \vec{u}|| = \mu_w ||\nabla \vec{u}|| \frac{ C_{\mu}^{0.25} \sqrt(k)}{\kappa y_p} \,,
\end{equation}

where:

- $C_{\mu} = 0.09$ is a closure parameter,
- $k$ is the turbulent kinetic energy,
- $||\nabla \vec{u}||$ is the near wall velocity gradient norm, which is defined as $||\nabla \vec{u}|| = (\nabla \vec{u} \cdot \hat{n}) \cdot \hat{n}$,
- $\kappa = 0.41$ is the von Kármán constant.

The formulation assumes that the near wall value is already imposed in the $\mu_t$ functor. 

When solving a linear problem, instead of the nonlinear formulation, the production term is formulated as:

\begin{equation}
G_k =  \mu_w ||\nabla \vec{u}|| \frac{ C_{\mu}^{0.25} k}{\sqrt{k_{old}} \kappa y_p} \,.
\end{equation}

where:

- $k_{old}$ is the value of the turbulent kinetic energy in the previous iteration.

Whether the linear or nonlinear formulation is used can be controlled by the
[!param](/FVKernels/INSFVTKESourceSink/linearized_model) parameter.

For the destruction, formulation is different for the `sub-laminar` and `logarithmic` layers.
For the `sub-laminar` layer, the destruction is defined as follows:

\begin{equation}
\epsilon = \frac{2 \mu k}{y_p ^2} \,.
\end{equation}

For the `logarithmic` layer, the destruction is defined as follows:

\begin{equation}
\epsilon = C_{\mu}^{0.75} \frac{\rho k^{\frac{3}{2}}}{\kappa y_p} \,.
\end{equation}

When the wall treatment is specified in this kernel, any boundary condition for $k$ will be ignored.
In other words, there is no need to impose boundary conditions for $k$ when the wall treatment
is specified in his kernel.

When using near-wall treatment, we assume that the $\mu_t$ functor is computed by an object
that performs near-wall treatment.
Otherwise, the results obtained won't not physically correct




### INSFVTurbulentAdvection

This object adds a $\nabla \cdot \vec u \phi$ term for an arbitrary scalar field
$\phi$, where $\phi$ corresponds to the nonlinear variable that this kernel acts
on. The nonlinear `variable` can be of type `MooseVariableFVReal` or for
consistency with other INSFV naming conventions, can be of type
[`INSFVEnergyVariable`](INSFVEnergyVariable.md).

The particularity of this kernel is that it allows us to skip computing advection
for near-wall elements. The key for this skip are the boundaries identified in
the [!param](/FVKernels/INSFVTurbulentAdvection/walls) list.
For any element that is in contact with a boundary identified
in the [!param](/FVKernels/INSFVTurbulentAdvection/walls) list,
advection will be skipped for that element over all faces.

This kernel is mainly used for applying wall functions to turbulent problems.




### INSFVTurbulentDiffusion

This object extends [`FVDiffusion`](FVDiffusion.md) to allow diffusion to be skipped
at certain boundaries.

The particularity of this kernel is that it allows us to skip computing diffusion
for near-wall elements. The key for this skip are the boundaries identified in
the [!param](/FVKernels/INSFVTurbulentDiffusion/walls) list.
For any element that is in contact with a boundary identified
in the [!param](/FVKernels/INSFVTurbulentDiffusion/walls) list,
diffusion contributions will be skipped for that element over all faces.




### NSFVEnergyAmbientConvection





### NSFVMixturePhaseInterface

This terms models the volumetric exchange between two phases.
The term added reads as follows:

\begin{equation}
  \alpha_{1,2} (\phi_1 - \phi_2) \,,
\end{equation}

where:

- $\alpha_{1,2}$ is the volumetric exchange coefficient between phases 1 and 2
- $\phi_1$ is the volume fraction of phase 1,
- $\phi_2$ is the volume fraction of phase 2

The kernel adds to the residual for the phase identified in `variable`.
The complementary kernel for the second phase is needed to preserve the phase fraction.




### NSFVPhaseChangeSource


The power source is computed as:

\begin{equation}
q''' = - \rho_l L \frac{d f_l}{dt} \,,
\end{equation}

where $\rho_l \left[ \frac{kg}{m^3} \right]$ is the liquid density, $L \left[ \frac{J}{kg} \right]$ is the latent heat, and $f_l$ is the liquid fraction.

#### Example

For an example on how to use this object see the model of the Gallium
melting experiment below [!cite](gau1986melting)





### PCNSFVDensityTimeDerivative


#### Overview

This object computes the residual

\begin{equation}
\int_{\Omega_C} \epsilon \frac{\partial\left(\rho u\right)}{\partial t} dV
\end{equation}

where $\epsilon$ is the porosity, $\rho$ is the density, and $u$ corresponds to
the variable specified with the `variable` parameter. This object currently only
works if $\rho$ is a variable (e.g. this doesn't work if the only computation of
$\partial \rho/\partial t$ occurs in a material).




### PCNSFVFluidEnergyHLLC


#### Overview

This object implements the fluid energy equation portion of the porous HLLC
implementation described in detail in [PCNSFVHLLC.md].




### PCNSFVHLLC

The derivation of the porous HLLC discretization that follows is based
extensively on the material in [!citep](toro2009riemann), drawing mostly from
chapters 2, 3, and 10. Details pertinent to the MOOSE
implementation of the free-flow
HLLC discretization can be found in [CNSFVHLLCBase.md].

#### Solution Properties Across the Contact Wave

HLLC restores the middle contact wave to the HLL formulation. Generalized
Riemann Invariants reveal what quantities change or are constant across the
wave. We perform the Generalized Riemann Invariants analysis on the porous Euler
equations in the following way: we convert the $\epsilon \nabla p$ term into $\nabla
\cdot\left(\bm{I}\epsilon p\right) - p \nabla \epsilon$ and ignore the latter
term when composing the flux vector $\bm{F}$ (the term is instead treated as
part of a source vector $\bm{S}$). Then we define our conserved variable set
(for one-dimension for simplicity here)

\begin{equation}
\label{eq:conserved_variable_set}
\bm{U} =
\begin{bmatrix}
\rho \epsilon\\
\rho \epsilon u\\
\rho \epsilon e_t
\end{bmatrix}
\end{equation}

and our flux vector

\begin{equation}
\bm{F} =
\begin{bmatrix}
\rho \epsilon u\\
\rho \epsilon u^2 + \epsilon p\\
\rho \epsilon u  \left(e_t + \frac{p}{\rho}\right)
\end{bmatrix}
\end{equation}

and our source vector

\begin{equation}
\bm{S} =
\begin{bmatrix}
0\\
p \nabla \epsilon\\
0
\end{bmatrix}
\end{equation}

Armed with these definitions we can write the Euler equations succinctly as

\begin{equation}
\label{eq:general_euler}
\bm{U}_t + \bm{F}_x = \bm{S}.
\end{equation}

We can also write [eq:general_euler] in a quasi-linear form

\begin{equation}
\bm{U}_t + \bm{A}\bm{U}_x = \bm{S}
\end{equation}

where $\bm{A}$ is the Jacobian matrix of partial derivatives of $\bm{F}$ with
respect to $\bm{U}$. It can be shown for an ideal gas that the eigenvalues of $\bm{A}$ are

\begin{equation}
\lambda_1 = u - c\ ,\ \lambda_2 = u\ ,\ \lambda_3 = u + c
\end{equation}

where $c$ is the speed of sound in the medium. The corresponding eigenvectors
are

\begin{equation}
\label{eq:eigenvectors}
\bm{K}^{(1)} =
\begin{bmatrix}
1\\
u - c\\
h_t - uc
\end{bmatrix}
\ ,\ \bm{K}^{(2)} =
\begin{bmatrix}
1\\
u\\
\frac{1}{2}u^2
\end{bmatrix}
\ ,\ \bm{K}^{(3)} =
\begin{bmatrix}
1\\
u + c\\
h_t + uc
\end{bmatrix}
\end{equation}

where $h_t = e_t + p/\rho$ is the total specific enthalpy. The second
eigenvector $K^{(2)}$ corresponds to the middle contact wave. For a general $m
\times m$ system, with variable set:

\begin{equation}
\bm{W} = \left[w_1,w_2,\ ...\ ,w_m\right]
\end{equation}

and eigenvectors

\begin{equation}
\bm{K}^{(i)} = \left[k_1^{(i)},k_2^{(i)},\ ...\ ,k_m^{(i)}\right]
\end{equation}

the $i\text{-th}$
Generalized Riemann Invariants are given by the $\left(m - 1\right)$ ODEs:

\begin{equation}
\label{eq:gri}
\frac{dw_1}{k_1^{(i)}} = \frac{dw_2}{k_2^{(i)}} =\ ...\ = \frac{dw_m}{k_m^{(i)}}
\end{equation}

Taking our conserved variable set ([eq:conserved_variable_set]) and the contact
wave eigenvector from [eq:eigenvectors] and substituting into [eq:gri] yields
the relations

\begin{equation}
\frac{d\left(\rho\epsilon\right)}{1} = \frac{d\left(\rho\epsilon u\right)}{u} =
\frac{d\left(\rho\epsilon e_t\right)}{\frac{1}{2}u^2}
\end{equation}

These equalities can be algebraically manipulated to yield the following
relationships across the contact wave:

\begin{equation}
\label{eq:contact_relationships}
u = constant\ ,\ \epsilon p = constant
\end{equation}

We will use [eq:contact_relationships] when constructing the porous HLLC fluxes
below.

#### Porous HLLC Fluxes

For discontinuous wave solutions over a wave-speed $S_i$ associated with the
$\lambda_i$ characteristic, the Rankine-Hugoniot conditions state that the flux
changes according to

\begin{equation}
\Delta \bm{F} = S_i\Delta \bm{U}
\end{equation}

We can apply the Rankine-Hugoniot conditions to help us establish a
discretization for the porous HLLC fluxes. Applying Rankine-Hugoniot conditions
over the left wave results in

\begin{equation}
\label{eq:left_wave}
\bm{F}_{*L} = \bm{F}_L + S_L\left(\bm{U}_{*L} - \bm{U}_L\right)
\end{equation}

Analogously over the center contact wave:

\begin{equation}
\label{eq:center_wave}
\bm{F}_{*R} = \bm{F}_{*L} + S_*\left(\bm{U}_{*R} - \bm{U}_{*L}\right)
\end{equation}

and the right wave

\begin{equation}
\label{eq:right_wave}
\bm{F}_R = \bm{F}_{*R} + S_R\left(\bm{U}_R - \bm{U}_{*R}\right)
\end{equation}

The star fluxes can be written $\bm{F}_{*K}$ = $\bm{F}\left(\bm{U}_{*K}\right)$,
where $K$ denotes $L$ or $R$ and preliminarily we will write

\begin{equation}
\label{eq:unknown_u}
\bm{U}_{*K} =
\begin{bmatrix}
\rho_{*K}\\
\rho_{*K} u_{*K}\\
\rho_{*K} e_{t,*K}
\end{bmatrix}
\end{equation}

Our goal is to eventually express $\bm{U}_{*K}$ and consequently $\bm{F}_{*K}$ in terms of known left and right
quantities, We can leverage the information from [eq:contact_relationships] to help us
construct star region solutions

\begin{equation}
\label{eq:star_region_info}
\begin{cases}
\epsilon_L p_{*L} &= \epsilon_R p_{*R}\\
u_{*L} &= u_{*R} = u_*
\end{cases}
\end{equation}

Per [!citep](toro2009riemann) it is justifiable to select that the middle wave
speed be equal to the star region velocity

\begin{equation}
\label{eq:velocity_star_eqn}
S_* = u_*
\end{equation}

Manipulating the mass, momentum, and energy components of [eq:left_wave] and
[eq:right_wave], we can construct equations for the star region density, pressure, and
total specific energy as functions of the known left and right states and the middle wave
speed $S_*$ (where we have substituted $S_*$ anyplace we encountered $u_{*L}$ or
$u_{*R}$). The star region density relationships are given by

\begin{equation}
\label{eq:densities}
\rho_{*K} = \rho_K \frac{S_K - u_K}{S_K - S_*};
\end{equation}

the star region pressure relationships are given by

\begin{equation}
\label{eq:pressure_eqns}
p_{*K} = p_K + \rho_K\left(S_K - u_K\right)\left(S_* - u_K\right);
\end{equation}

and the total specific energy relationships are given by

\begin{equation}
\label{eq:energy_eqns}
e_{t,*K} = e_{t,K} + \left(S_* -
u_K\right)\left[S_* + \frac{p_K}{\rho_K\left(S_K - u_K\right)}\right]
\end{equation}

Substituting [eq:densities], [eq:pressure_eqns], and [eq:energy_eqns] into
[eq:unknown_u] and
using $u_* = S_*$ from [eq:velocity_star_eqn], we arrive at the vector
expression for $\bm{U}_{*K}$:

\begin{equation}
\bm{U}_{*K} = \epsilon_K \rho_K \left(\frac{S_K - u_K}{S_K - S_*}\right)
\begin{bmatrix}
1\\
S_*\\
e_{t,K} + \left(S_* -
u_K\right)\left[S_* + \frac{p_K}{\rho_K\left(S_K - u_K\right)}\right]
\end{bmatrix}
\end{equation}

We must now establish an equation for $S_*$. Combining [eq:pressure_eqns] with the pressure information from
[eq:star_region_info], we arrive at:

\begin{equation}
\label{eq:star_velocity}
S_* = \frac{\epsilon_R p_R - \epsilon_L p_L + \rho_L \epsilon_L u_L \left(S_L -
u_L\right) - \rho_R \epsilon_R u_R \left(S_R - u_R\right)}{\epsilon_L \rho_L
\left(S_L - u_L\right) - \epsilon_R \rho_R \left(S_R - u_R\right)}
\end{equation}

Left and right wave speeds $S_L$ and $S_R$ are computed in the same way as for
free flow as outlined in [CNSFVHLLCBase.md]. With $S_L$ and $S_R$ the final HLLC
flux can be constructed:

\begin{equation}
\label{eq:porous_hllc}
\bm{F}_{HLLC} =
\begin{cases}
\bm{F}_L & \textrm{if } 0 \leq S_L \\
\bm{F}_{*L} & \textrm{if } S_L \leq 0 \leq S_* \\
\bm{F}_{*R} & \textrm{if } S_* \leq 0 \leq S_R \\
\bm{F}_R & \textrm{if } 0 \geq S_R
\end{cases}
\end{equation}

Note that although in the derivation above we assumed a one-dimensional setup,
the intermediate solution states $\bm{U}_{*K}$ can be generalized to
three-dimensions in a way analogously to the multidimensional free-flow
intermediate solutions expressed in [CNSFVHLLCBase.md]. Indeed, the porous
intermediate states can be simply expressed as

\begin{equation}
\bm{U}_{*K,porous} = \epsilon_K \bm{U}_{*K,free}
\end{equation}

and with  $S_*$ expressed according to [eq:star_velocity].

The mass component of [eq:porous_hllc] is implemented in [PCNSFVMassHLLC.md],
momentum in [PCNSFVMomentumHLLC.md], and fluid energy in
[PCNSFVFluidEnergyHLLC.md].


### PCNSFVKT


#### Overview

This object implements the Kurganov-Tadmor [!citep](kurganov2000new) (KT) scheme for
computing inter-cell advective fluxes for the Euler equations. We will outline
some of the important equations below, drawing from
[!citep](greenshields2010implementation). The KT flux is a second-order
generalization of the Lax-Friedrichs flux. For a given face $f$ it can be written as

\begin{equation}
\label{eq:kt_flux}
\bm{F} = \alpha \phi_{f+}\bm{\Psi}_{f+} + \left(1 -
\alpha\right)\phi_{f-}\bm{\Psi}_{f-} + \omega_f\left(\bm{\Psi}_{f-} -
\bm{\Psi}_{f+}\right)
\end{equation}

where $\bm{\Psi}_{f\pm}$ represents the vector of advected quantities, and

\begin{equation}
\phi_{f\pm} = \epsilon_{f\pm}\bm{a}_{f\pm}\cdot\hat{n}
\end{equation}

where $\epsilon$ is the porosity, $\bm{a} = \lbrace u,v,w\rbrace$ where $u$,
$v$, and $w$ are the component particle velocities, and $\hat{n}$ is the normal
vector pointing from $+$ to $-$. This definition of $\phi$ is slightly different
from that in [!citep](greenshields2010implementation) in that it does not
contain the face area. This is because here we are essentially describing the
implementation in `PCNSFVKT` while area multiplication happens in the base class
`FVFluxKernel`. $\alpha$ is defined as

\begin{equation}
\alpha=
\begin{cases}
\frac{1}{2} &\text{for Kurganov-Tadmor}\\
\frac{\psi{_f+}}{\psi_{f+} + \psi_{f-}} &\text{for Kurganov, Noelle, Petrova}
\end{cases}
\end{equation}

where

\begin{equation}
\psi_{f+} = \text{max}\left(c_{f+} + \phi_{f+},\ c_{f-} + \phi_{f-},\ 0\right)\\
\psi_{f-} = \text{max}\left(c_{f+} - \phi_{f+},\ c_{f-} - \phi_{f-},\ 0\right)
\end{equation}

where $c$ is the locally computed speed of sound. The default method when
computing $\alpha$ and $\omega$ is Kurganov, Noelle, Petrova
[!citep](kurganov2001semidiscrete) (KNP) since it's reported [!citep](greenshields2010implementation) as being less
diffusive (enabling sharper front capturing) than the KT method of computing
$\alpha$ and $\omega$. $\omega$ is given by

\begin{equation}
\omega_f=
\begin{cases}
\alpha \text{max}\left(\psi_{f+},\ \psi_{f-}\right) &\text{for KT}\\
\alpha\left(1 - \alpha\right)\left(\psi_{f+} + \psi_{f-}\right) &\text{for KNP}
\end{cases}
\end{equation}

Interpolation of $\bm{\Psi}_{f\pm}$ is described in [Limiters/index.md].





### PCNSFVKTDC


#### Overview

This object implements a deferred correction approach in the following way for a
transient simulation

\begin{equation}
\bm{F}_n = f \bm{F}_{n,ho} + \left(1 - f\right)\left(\bm{F}_{n-1,ho} +
\bm{F}_{n,lo} - \bm{F}_{n-1,lo}\right)
\end{equation}

where $\bm{F}$ is the flux, $ho$ denotes high order, $lo$ denotes low order, $n$ refers to the current
time-step, $n-1$ refers to the previous timestep, and $f$ corresponds to the
`ho_implicit_fraction` parameter. The default value for $f$
(`ho_implicit_fraction`) is 0, which corresponds to the canonical deferred
correction approach. This default value will result in the best nonlinear
convergence when using an implicit time integration scheme. However, if the
fluid variables have significant gradients, it may take a very long time (in terms of
actual `time`) to march to a steady-state solution (if that is the intent
of the simulation). Setting `ho_implicit_fraction = 1` will result in the same
solution behavior as directly using [PCNSFVKT.md], which this object inherits
from. This will result in the worst nonlinear convergence but will also have the
most transient accuracy, and will converge most rapidly to a steady-state
solution if it exists (in terms of `time`). In terms of `Time Steps` a lower
`ho_implicit_fraction` will generally converge to a steady-state solution
quicker if the `steady_state_tolerance` is not tight.




### PCNSFVMassHLLC


#### Overview

This object implements the mass equation portion of the porous HLLC
implementation described in detail in [PCNSFVHLLC.md].




### PCNSFVMomentumFriction

This kernel adds the friction term to the fully compressible porous media Navier
Stokes momentum equations. This kernel requires that the parameter
`momentum_name` is provided.  Darcy and Forchheimer models, as well as the
superposition of the two, are supported for the friction force:

Darcy drag model
\begin{equation}
F_i = - \dfrac{d_i}{\epsilon} p_i
\end{equation}
Forchheimer drag model
\begin{equation}
F_i = - \dfrac{f_i}{\epsilon} \rho p_i
\end{equation}
where $F_i$ is the i-th component of the friction force, $d_i$ is the i-th
component of the Darcy friction factor,
$\epsilon$ is the porosity, $p_i$ is the ith-component of the momentum, and
$f_i$ is the ith-component of the Forchheimer friction factor. If both
`Darcy_name` and `Forchheimer_name` parameters are supplied, then the drag
forces from the two models will be summed. The component is determined by the
`momentum_component` parameter.




### PCNSFVMomentumHLLC


#### Overview

This object implements the momentum equation portion of the porous HLLC
implementation described in detail in [PCNSFVHLLC.md].




### PINSFVEnergyAdvection

This object adds a $\rho \epsilon c_p \vec u \cdot \nabla T$ term to a finite volume
formulation of a heat transport equation. The user can control what (material) quantity is
advected through the `advected_quantity` parameter. The default value is the
name `rho_cp_temp` which corresponds to a material property name declared by
[INSFVEnthalpyFunctorMaterial.md].




### PINSFVEnergyAmbientConvection

#### Description

This kernel implements a volumetric convection heat transfer term for the fluid and solid energy equation.
It adds the following terms to the RHS of the equations:

For the fluid energy equation:
\begin{equation}
h (T_s - T_f)
\end{equation}

For the solid energy equation:
\begin{equation}
h (T_f - T_s)
\end{equation}
where $h$ is the heat transfer coefficient, $T_s$ the solid temperature and $T_f$ the fluid temperature.




### PINSFVEnergyAnisotropicDiffusion

#### Description

This kernel implements a diffusion term for the fluid energy equation.
This kernel accepts an anisotropic thermal conductivity material property, an isotropic thermal conductivity may be
specified using a [PINSFVEnergyDiffusion.md] kernel.

\begin{equation}
\nabla \cdot \left( \epsilon k \nabla T \right)
\end{equation}
where $\epsilon$ is the porosity, $k$ is the thermal conductivity, and $T$ the fluid temperature. The
multiplication by $\epsilon$ may be removed by specifying the
[!param](/FVKernels/PINSFVEnergyAnisotropicDiffusion/effective_conductivity) parameter. This effectively
switches from using a $k$ thermal conductivity to a $\kappa$ effective thermal conductivity.

More information may be found on effective thermal conductivity models in the Pronghorn manual. They
generally account for heat conduction, radiation and some convective effects like changes in flow directions
due to the porous media, recirculation flow within the pores and eddy diffusion in turbulence.




### PINSFVEnergyDiffusion

#### Description

This kernel implements a diffusion term for the fluid energy equation. The thermal conductivity
is isotropic for this kernel. For anisotropic diffusion, use the [PINSFVEnergyAnisotropicDiffusion.md] kernel.


\begin{equation}
\nabla \cdot \left( \epsilon k \nabla T \right) = \epsilon \nabla \cdot k \nabla T + k \nabla T \nabla \epsilon
\end{equation}
where $\epsilon$ is the porosity, $k$ is the thermal conductivity, and $T$ the fluid temperature.

The porosity gradient term creates oscillations in the presence of porosity discontinuities and is
generally neglected. It is not computed by this kernel.

To switch from using a regular conductivity to an effective conductivity, use the
[!param](/FVKernels/PINSFVEnergyDiffusion/effective_conductivity) parameter.

If the thermal conductivity is null or negative, the harmonic interpolation method for the face value of the thermal
conductivity is not well-defined and will be automatically changed to an average interpolation.




### PINSFVEnergyTimeDerivative

#### Description

This kernel implements a time derivative for the domain $\Omega$ given by

\begin{equation}
\epsilon \frac{\partial \rho c_{pf} T_f}{\partial t}
\end{equation}
for the fluid phase and
\begin{equation}
(1 - \epsilon) \frac{\partial \rho_s c_{ps} T_s}{\partial t}
\end{equation}
for the solid phase, where $\epsilon$ is the porosity, $\rho_{f/s}$ the fluid/solid material density, $c_{pf/s}$ the fluid/solid specific heat and $T_{f/s}$ the fluid/solid temperature.

The time derivative of the density is ignored if [!param](/FVKernels/PINSFVEnergyTimeDerivative/drho_dt) is not provided. For incompressible flows, the former should not be provided.

The variation of the kinetic energy is not considered in this kernel.




### PINSFVMassAdvection

This object computes the residual and Jacobian contribution of the
incompressible version of the mass continuity equation, e.g. $\nabla\cdot \rho \vec
u_d$. We apply the divergence theorem and compute the advective flux of mass
across cell/element faces.




### PINSFVMomentumAdvection

This object implements the $\nabla \cdot \left(\epsilon \rho\vec u \otimes \vec
u\right) = \nabla \cdot \left(\dfrac{1}{\epsilon} \rho\vec u_d \otimes \vec u_d\right)$ component
terms of the incompressible porous media Navier Stokes momentum equation where
$u$ represents the free-flow velocity and $u_d$ represents the superficial
velocity. The nonlinear variables used in PINSFV correspond to the superficial velocity.

An average or Rhie-Chow interpolation can be used for the advecting velocity interpolation.
An average or upwind interpolation can be used for the advected quantity, which in this
case is the momentum component $\rho u_{di}$ where $u_{di}$ denotes the x, y, or z
component of the superficial velocity in Cartesian coordinates, or the r or z component of
the velocity in RZ coordinates.




### PINSFVMomentumBoussinesq

This object adds a $\epsilon\rho\alpha\vec{g}(T - T_{ref})$ term to the incompressible porous media
Navier Stokes (PINS) momentum equations where $\epsilon$ is the porosity, $\rho$ is the density, $\alpha$
is the thermal expansion coefficient, $\vec{g}$ is the gravity vector, $T$ is the temperature,
and $T_{ref}$ is a reference temperature. The term above introduces the
Boussinesq approximation into the PINS equations, which allows for modeling
natural convection and the effect of buoyancy.




### PINSFVMomentumDiffusion

This kernel implements the diffusion term of the porous media Navier Stokes momentum equation.
This diffusion term represents a Brinkman-type viscous stress.

The incompressible approximation simplifies the expression of the stress tensor and the
diffusion term is expressed in terms of the superficial velocity:

\begin{equation}
-\nabla \cdot \left( \mu \nabla \dfrac{\vec{u_d}}{\epsilon} \right) = -\nabla \cdot \left( \dfrac{\mu}{\epsilon} \nabla \vec{u_d} \right) -\nabla \cdot \left( \mu u_d \nabla \dfrac{1}{\epsilon} \right)
\end{equation}

The divergence theorem is used to compute this term by examining its flux through the element's faces.
The second term is challenging to compute near discontinuities in porosity and is not included by default.
For continuous porosity variations, the `smooth_porosity` parameter may be used to include it.




### PINSFVMomentumFriction

This kernel adds the friction term to the porous media Navier Stokes momentum
equations. This kernel must be used with the canonical PINSFV variable set,
e.g. pressure and superficial velocity, and supports Darcy and
Forchheimer friction models in two flavors:

#### Standard friction formulation

Set parameter: [!param](/FVKernels/PINSFVMomentumFriction/standard_friction_formulation) = 'true'

Darcy drag model
\begin{equation}
\label{darcy}
\epsilon F_i = - f_i \mu \epsilon \frac{v_{D,i}}{\epsilon} = -f_i \mu v_{D,i}
\end{equation}
Forchheimer drag model
\begin{equation}
\label{forchheimer}
\epsilon F_i = - f_i \frac{\rho}{2} \epsilon \frac{v_{D,i}}{\epsilon}\frac{|\vec{v_D}|}{\epsilon} = - f_i \frac{\rho}{2} v_{D,i} \frac{|\vec{v_D}|}{\epsilon}
\end{equation}

#### Simplified friction formulation

Set parameter: [!param](/FVKernels/PINSFVMomentumFriction/standard_friction_formulation) = 'false'

Darcy drag model
\begin{equation}
\label{darcy2}
\epsilon F_i = - f_i \epsilon \frac{v_{D,i}}{\epsilon} = -f_i v_{D,i}
\end{equation}
Forchheimer drag model
\begin{equation}
\label{forchheimer2}
\epsilon F_i = - f_i \epsilon \frac{v_{D,i}}{\epsilon}\frac{|\vec{v_D}|}{\epsilon} = - f_i v_{D,i} \frac{|\vec{v_D}|}{\epsilon}
\end{equation}

where $F_i$ is the i-th component of the friction force (denoted by
$\mathbf{F_f}$ in [!eqref](pinsfv.md#eq:pinsfv_mom)), $f_i$ the friction factor,
which may be anisotropic, $\mu$ the fluid dynamic viscosity, $\rho$ the fluid density,
and $v_{D,i}$ the i-th component of the fluid superficial velocity.
We have used a negative sign to match the notation
used in [!eqref](pinsfv.md#eq:pinsfv_mom) where the friction force is on the
right-hand-side of the equation. When moved to the left-hand side, which is done
when setting up a Newton scheme, the term becomes positive which is what is
shown in the source code itself.  Darcy and Forchheimer terms represent
fundamentally different friction effects. Darcy is meant to represent viscous
effects and as shown in [darcy],[darcy2], it has a linear dependence on the fluid
velocity. Meanwhile, Forchheimer is meant to represent inertial effects and as
shown in [forchheimer], [forchheimer2] it has a quadratic dependence on velocity.

For the non-porous medium version of the above equations set parameter [!param](/FVKernels/PINSFVMomentumFriction/is_porous_medium)  to `false`.
(epsilon = 1)

#### Computation of friction factors and pre-factors id=friction_example

To outline how friction factors for Darcy and Forchheimer may be calculated,
let's consider a specific example. We'll draw from the Ergun equation, which is
outlined [here](https://en.wikipedia.org/wiki/Ergun_equation). Let's consider
the form:

\begin{equation}
\Delta p = \frac{150\mu L}{d_p^2} \frac{(1-\epsilon)^2}{\epsilon^3} v_D + \frac{1.75 L \rho}{d_p} \frac{(1-\epsilon)}{\epsilon^3} |v_D| v_D
\end{equation}

where $L$ is the bed length, $\mu$ is the fluid dynamic viscosity and $d_p$ is
representative of the diameter of the pebbles in the pebble bed. We can divide
the equation through by $L$, recognize that $\Delta p$ denotes $p_0 - p_L$ such
that $\Delta p/L \approx -\nabla p$, multiply the equation through by
$-\epsilon$, move all terms to the left-hand-side, and do
some term manipulation in order to yield:

\begin{equation}
\epsilon \nabla p + 150\mu\epsilon\frac{(1-\epsilon)^2}{\epsilon^2 d_p^2} \frac{\vec{v_D}}{\epsilon} +
1.75\epsilon\frac{1-\epsilon}{\epsilon d_p} \rho \frac{|\vec{v}_D|}{\epsilon} \frac{\vec{v_D}}{\epsilon} = 0
\end{equation}

If we define the hydraulic diameter as $D_h = \frac{\epsilon d_p}{1 - \epsilon}$,
then the above equation can be rewritten as:

\begin{equation}
\epsilon \nabla p + \frac{150\mu}{D_h^2} \vec{v_D} +
\frac{1.75}{D_h} \rho \vec{v_D} \frac{|\vec{v}_D|}{\epsilon} = 0
\end{equation}

Let's introduce the interstitial fluid velocity $v = \vec{v_D} / \epsilon$ to rewrite
the above equation as:

\begin{equation}
\epsilon \nabla p + \epsilon\frac{150\mu}{D_h^2} \vec{v} +
\epsilon\frac{1.75}{D_h} \rho \vec{v} |\vec{v}| = 0
\end{equation}

Then dividing through by $\epsilon$:

\begin{equation}
\label{derived_ergun}
\nabla p + \frac{150\mu}{D_h^2} \vec{v} +
\frac{1.75}{D_h} \rho \vec{v} |\vec{v}| = 0
\end{equation}

We are now very close the forms for Darcy and Forchheimer espoused by
[Holzmann](https://holzmann-cfd.com/community/blog-and-tools/darcy-forchheimer)
and
[SimScale](https://www.simscale.com/knowledge-base/predict-darcy-and-forchheimer-coefficients-for-perforated-plates-using-analytical-approach/)
which is:

\begin{equation}
\label{holzmann}
\nabla p + \mu D \vec{v} + \frac{\rho}{2} F |\vec{v}| \vec{v}
\end{equation}

Looking at [holzmann] we can rearrange [derived_ergun]:

\begin{equation}
\nabla p + \mu \frac{150}{D_h^2} \vec{v} +
\frac{\rho}{2} \frac{2(1.75)}{D_h} \vec{v} |\vec{v}| = 0
\end{equation}

and arrive at the Ergun expression for the Darcy coefficient:

\begin{equation}
\frac{150}{D_h^2}
\end{equation}

and the Ergun expression for the Forchheimer coefficient:

\begin{equation}
\frac{2 \cdot 1.75}{D_h}
\end{equation}

where we have made the $2 \cdot 1.75$ multiplication explicit to make the 1.75 factor
from the [Ergun wikipedia page](https://en.wikipedia.org/wiki/Ergun_equation)
more recognizable. We perform a similar separation in the implementation of the
Ergun Forchheimer coefficient outlined in [FunctorErgunDragCoefficients.md].




### PINSFVMomentumFrictionCorrection


Since the friction corrector in the pressure interpolation scheme is not explained elsewhere,
we provide a complete explanation in this document.

##### Pressure interpolation at the interfaces

Assume $\vec{d}_e$ to be the vector position of the center node of the current cell,
$\vec{d}_n$ to be the center node of the neighbor cell,
$\vec{d}_{ne} = \vec{d}_n - \vec{d}_e$ to be the distance vector between both cells,
and $\vec{d}_{n,int} = \vec{d}_n - \vec{d}_{ne}$ and $\vec{d}_{e,int} = \vec{d}_e - \vec{d}_{ne}$
the distance vectors to the interface.
Assuming that the pressure for the collocated node at the current and neighbor cells are
$p_e$ and $p_n$, respectively, the pressure at the interface can be computed as follows:

\begin{equation}
p_ne = f(\vec{d}_{n,int}) p_n + g(\vec{d}_{e,int}) p_e \,,
\end{equation}

where $f$ and $g$ are some generic functions.
In MOOSE finite volume, and in cell-centered finite volume methods generally, cell-centered fields are often interpolated to faces
using arithmetic means, i.e.,
$f(\vec{d}_{n,int}) = \frac{|\vec{d}_{e,int}|}{|\vec{d}_{ne}|}$
and $f(\vec{d}_{e,int}) = \frac{|\vec{d}_{n,int}|}{|\vec{d}_{ne}|} = 1 - \frac{|\vec{d}_{e,int}|}{|\vec{d}_{ne}|}$,
which yields:

\begin{equation}
\tilde{p}_{ne} = \frac{|\vec{d}_{e,int}|}{|\vec{d}_{ne}|} p_n + \frac{|\vec{d}_{n,int}|}{|\vec{d}_{ne}|} p_e \,.
\end{equation}

This interpolation is exact as long as there is no variation in the pressure gradient
between the current and neighbor cells.
Otherwise, it introduces an interpolation error proportional to the difference in the gradients
for the current and neighbor cells and the distance between cells.
Large differences in pressure gradient can happen for instance in sharp porous media, due to differences in friction loss and/or effective flow area.

##### Correction of the interpolated pressure at the interfaces

The pressure correction interpolation is based on the introduction of a correction term
provided by considering the upwind and downwind linear interpolation at the cell faces.


Upwinding the pressure from the current cell to the interface yields:

\begin{equation}
p_{ne}^u = p_e + \alpha_c \nabla{p}_e \vec{d}_{e,int} \,,
\end{equation}

where $\alpha_c \in \mathbb{R}^+$ is a factor that defines the advection character in the pressure interpolation.

Similarly, approximating the pressure at the interface by down-winding from the neighbor yields:

\begin{equation}
p_{ne}^d = p_n - \alpha_c \nabla{p}_n \vec{d}_{n,int} \,.
\end{equation}

Now we define the interface pressure as the arithmetic means of the upwind and downwind pressures
to yield:

\begin{equation}
p_{ne} =
\frac{|\vec{d}_{e,int}|}{|\vec{d}_{ne}|} p_{ne}^d + \frac{|\vec{d}_{n,int}|}{|\vec{d}_{ne}|} p_{ne}^u
= \frac{|\vec{d}_{e,int}|}{|\vec{d}_{ne}|} p_n + \frac{|\vec{d}_{n,int}|}{|\vec{d}_{ne}|} p_e
- \alpha_c \frac{|\vec{d}_{e,int}|}{|\vec{d}_{ne}|} \nabla{p}_n \vec{d}_{n,int}
+ \alpha_c \frac{|\vec{d}_{n,int}|}{|\vec{d}_{ne}|} \nabla{p}_e \vec{d}_{e,int}
= \tilde{p}_{ne}
- \alpha_c \frac{|\vec{d}_{e,int}|}{|\vec{d}_{ne}|} \nabla{p}_n \vec{d}_{n,int}
+ \alpha_c \frac{|\vec{d}_{n,int}|}{|\vec{d}_{ne}|} \nabla{p}_e \vec{d}_{e,int}
\end{equation}

Next, we approximate the pressure gradients by the body forces as
$\nabla{p}_e \approx \vec{F}_e$ and $\nabla{p}_n \approx \vec{F}_n$,
i.e., we neglect the effects of flow acceleration and inertia on the pressure correction.
This yields the following interpolation field for the pressure at the interfaces:

\begin{equation}
p_{ne} =
\tilde{p}_{ne}
+ \frac{\alpha_c}{|\vec{d}_{ne}|}
(\vec{F}_e \vec{d}_{e,int} |\vec{d}_{n,int}| - \vec{F}_n \vec{d}_{n,int} |\vec{d}_{e,int}|)
\end{equation}

##### Setting the parameter $\alpha_c$

During finite-volume integration, we will sum over the control volume the fluxes at the faces.
For the correction in the pressure interpolation this yields:

\begin{equation}
\sum_{int} \frac{\alpha_c}{|\vec{d}_{ne}|}
(\vec{F}_e \vec{d}_{e,int} |\vec{d}_{n,int}| - \vec{F}_n \vec{d}_{n,int} |\vec{d}_{e,int}|) \,,
\end{equation}

which defines a diffusion term of the form:

\begin{equation}
\nabla \cdot (\alpha_c \vec{d}_{e,int} |\vec{d}_{n,int}|) \nabla \vec{F} \,.
\end{equation}

When increasing the value of the advection parameter $\alpha_c$,
oscillations are reduced as the arithmetic means interpolation error becomes less significant
with respect to the advection interpolation.
However, note that in a sharp porous media, the term $\vec{F}$ may be sharp and discontinuous.
Hence, increasing the value of the advection parameter adds stiffness to the problem,
which deteriorates the performance of iterative solvers.
In practice, a value of $alpha_c \approx 10$ have shown good performance in reducing
porous-media-driven oscillations without causing convergence issues




### PINSFVMomentumGravity

This object adds a simple gravitational force term to the incompressible porous
media Navier Stokes momentum equations of the form $-\epsilon \rho \vec{g}$
where $\epsilon$ is the porosity, $\rho$ the density and $\vec{g}$ the gravity
vector.




### PINSFVMomentumPressure


This object adds the $\epsilon \nabla p$ term of the
incompressible Navier Stokes momentum equation as a volumetric term.
This formulation causes oscillation near porosity discontinuities and the
[PINSFVMomentumPressureFlux.md] kernel should be preferred then.

The pressure is a Lagrange Multiplier that ensures the incompressibility constraint.




### PINSFVMomentumPressureFlux


This object adds the $\nabla (\epsilon p)$ pressure gradient term of the
incompressible porous media Navier Stokes momentum equation as a surface term
using the divergence theorem. Note that the porosity gradient that originates
from the integration by part is added by
`PINSFVMomentumPressurePorosityGradient`.

The pressure is a Lagrange Multiplier that ensures the incompressibility constraint.




### PINSFVMomentumPressurePorosityGradient


This object adds the $-P \nabla \epsilon$ pressure gradient term of the
incompressible porous media Navier Stokes momentum equation as an elemental source term. It should be used in conjunction with a
`PINSFVMomentumPressureFlux` kernel.




### PINSFVMomentumTimeDerivative

This object adds the $\rho\frac{\partial \vec u_{di}}{\partial t}$ term of the
porous media incompressible Navier Stokes momentum equation where $\rho$ is the density,
$\vec u_{di}$ refers to the i'th component of the superficial velocity $\vec{ud}$, and $t$ is
time. This kernel must be applied for every component of the velocity.




### PNSFVMomentumPressureFluxRZ


#### Overview

This object adds a residual equivalent to

\begin{equation}
\int_{\Omega_C} -\epsilon \frac{p}{r} dV
\end{equation}

for use when performing axisymmetric simulations with `Mesh/coord_type=RZ`
and when the $\epsilon \nabla p$ term has been integrated by parts as is done
for [PCNSFVKT.md] and for [PCNSFVHLLC.md].




### PNSFVPGradEpsilon


#### Overview

This object adds a residual equivalent to

\begin{equation}
\int_{\Omega_C} -p \nabla \epsilon dV
\end{equation}

This object must be included in any simulations where the $\epsilon \nabla p$
term has been integrated by parts as is done by the [PCNSFVKT.md] and
[PCNSFVHLLC.md] objects.

This object only accepts porosity as a function. If the porosity profile is
complicated, a [SolutionFunction](SolutionFunction.md) may be used to represent
it.

We have yet to see good results when the porosity is represented by a
discontinuous function. On straight-channel porosity jump tests with no momentum
or energy sources/sinks, if the porosity steps down and up again and this change
is represented in a discontinuous fashion, then the outlet pressure and density
(the latter when solving a compressible problem) do not match the inlet pressure
and density. However, if the step changes are approximated by steep continuous
ramps, then the inlet and outlet pressure and density match as they should. This
behavior has been observed both with [Kurganov-Tadmor](PCNSFVKT.md) and
[HLLC](PCNSFVHLLC.md) discretizations of the advective fluxes.




### PWCNSFVMassAdvection

This object computes the residual and Jacobian contribution of the mass
advection term for a (weakly) compressible version of the mass continuity
equation in a porous medium, e.g. this object adds the term $\nabla\cdot
\rho\vec u_d$. We apply the divergence theorem and compute the advective flux
of mass across cell/element faces.




### PWCNSFVMassTimeDerivative

This object adds the $\frac{\partial \epsilon \rho}{\partial t}$ term of the
weakly compressible porous medium Navier Stokes mass equation where $\epsilon$ denotes
the fluid fraction, $\rho$ the density, and $t$ the time.
This kernel is applied along with a [INSFVMassAdvection.md] kernel
to form the conservation of mass equation.




### WCNSFV2PInterfaceAreaSourceSink

The interfacial area concentration is defined as the interface area between
two phases per unit volume, i.e.,$[\xi_p] = \frac{m^2}{m^3}$. This parameter is important
for predicting mass, momentum, and energy transfer at interfaces in two-phase flows.

The general equation for interfacial area concentration transport via the mixture model reads as follows:

\begin{equation}
\frac{\partial (\rho_d \xi_p)}{\partial t} + \nabla \cdot \left( \rho_d \vec{u} \xi_p \right) - \nabla \left( D_b \nabla \xi_p \right) =
-\frac{1}{3} \frac{D \rho_d}{Dt} + S_T + \rho_d (S_C + S_B)\,,
\end{equation}

where:

- $\rho_d$ is the density of the dispersed phase $d$, e.g., the density of the gas in bubbles,
- $t$ is time,
- $\vec{u}$ is the velocity vector,
- $D_b$ is a diffusion coefficient for the interface area concentration, which may be assumed to be `0` if unknown,
- $\frac{D (\bullet)}{Dt} = \frac{\partial (\bullet)}{\partial t} + \vec{u} \cdot \nabla (\bullet)$ is the material derivative,
- $S_T$, $S_C$, and $S_B$ are the interface area concentration sources due to mass transfer, coalescence, and breakage, respectively.

The terms on the left-hand side of this equation are modeled via standard kernels for the mixture model.
For example, in an open flow case, the time derivative may be modeled using [FVFunctorTimeKernel.md],
the advection term using [INSFVScalarFieldAdvection.md], and the diffusion term using [FVDiffusion.md].

The terms on the right-hand side are modeled using a multidimensional version of
Hibiki and Ishii's model [!citep](hibiki2000interface).
In this one, the sources are approximated as follows:


#### Interface area concentration source due to mass transfer

The interface area concentration source due to mass transfer is modeled as follows:

\begin{equation}
S_T =
\begin{cases}
  \frac{6 \alpha_d}{d_p}, & \text{if } \alpha_d < \alpha_d^{co} \\
  \frac{2}{3} \cdot h^{b \rightarrow d} \left( \frac{1}{\alpha_d} - 2.0 \right), & \text{otherwise}
\end{cases}\,,
\end{equation}

where:

- $\alpha_d$ is the volumetric fraction of the dispersed phase, e.g., the void fraction if the dispersed phase is a gas,
- $\alpha_d^{co}$ is a cutoff fraction for mass transfer model selection,
- $d_p$ is the best estimate for the dispersed phase particle diameter,
- $h^{b \rightarrow d}$ is the mass exchange coefficient from the bulk to the dispersed phase,

The cutoff volumetric fraction $\alpha_d^{co}$ is included because the mass transfer term
in Hibiki and Ishii's model is not physical for low volumetric fractions of the dispersed phase.
Below the cutoff limit, the dispersed phase is modeled as spherical particles.

The user should select the cutoff volumetric fraction $\alpha_d^{co}$ as the limit at which
the modeled flows transition away from bubbly flow, i.e., below the cutoff limit there is an
implicit assumption that the flow behaves as a bubbly flow.


#### Interface area concentration source due to coalescence

The reduction in interface area concentration due to coalescence of the dispersed phase is modeled as follows:

\begin{equation}
S_C = -\left( \frac{\alpha_d}{\xi_p} \right)^2 \frac{\Gamma_C \alpha_d^2 u_{\epsilon}}{\tilde{d_p}^{11/3} (\alpha_d^{max}- \alpha_d)}
\operatorname{exp} \left( -K_C \frac{\tilde{d_p}^{5/3} \rho_b^{1/2} u_{\epsilon}^{1/3}}{\sigma^{1/2}} \right)\,,
\end{equation}

where:

- $\alpha_d$ is the volumetric fraction of the dispersed phase, e.g., the void fraction if the dispersed phase is a gas,
- $u_{\epsilon} = \left( \| \vec{u} \| \ell \| \nabla p \| / \rho_m \right)^{1/3}$ is the friction velocity due to pressure gradients, with $\| \vec{u} \|$ being the norm of the velocity vector, $\ell$ a characteristic mixing length, $\| \nabla p \|$ the norm of the pressure gradient, and $\rho_m$ the mixture density,
- $\tilde{d_p} = \psi \frac{\alpha_d}{\xi_p}$ is the model estimate for the dispersed phase particle diameter, with $\psi$ being a shape factor, which is, for example, $\psi=6$ for spherical particles,
- $\alpha_d^{max}$ is the maximum volumetric fraction admitted by the model, in absence of data we recommend taking $\alpha_d^{max}=1$,
- $\rho_b$ is the bulk phase density, e.g., for air bubbles in a water flow it would be the density of water,
- $\sigma$ is the surface tension between the two phases,
- $\Gamma_C = 0.188$ and $K_C = 0.129$ are closure coefficients of the model.

Many of the parameters in the coalescence model are provided as functors,
which means that spatially dependent fields may be specified for these parameters.
However, the validation of this model has only been performed using constant parameters.

#### Interface area concentration source due to breakage

The increase in interface area concentration due to breakage of the dispersed phase is modeled as follows:

\begin{equation}
S_B = \left( \frac{\alpha_d}{\xi_p} \right)^2 \frac{\Gamma_B \alpha_d (1 - \alpha_d) u_{\epsilon}}{\tilde{d_p}^{11/3} (\alpha_d^{max}- \alpha_d)}
\operatorname{exp} \left( -K_B \frac{\sigma}{\rho_b \tilde{d_p}^{5/3} u_{\epsilon}^{2/3}} \right)\,,
\end{equation}

where:

- $\alpha_d$ is the volumetric fraction of the dispersed phase, e.g., the void fraction if the dispersed phase is a gas,
- $u_{\epsilon} = \left( \| \vec{u} \| \ell \| \nabla p \| / \rho_m \right)^{1/3}$ is the friction velocity due to pressure gradients, with $\| \vec{u} \|$ being the norm of the velocity vector, $\ell$ a characteristic mixing length, $\| \nabla p \|$ the norm of the pressure gradient, and $\rho_m$ the mixture density,
- $\tilde{d_p} = \psi \frac{\alpha_d}{\xi_p}$ is the model estimate for the dispersed phase particle diameter, with $\psi$ being a shape factor, which is, for example, $\psi=6$ for spherical particles,
- $\alpha_d^{max}$ is the maximum volumetric fraction admitted by the model, in absence of data we recommend taking $\alpha_d^{max}=1$,
- $\rho_b$ is the bulk phase density, e.g., for air bubbles in a water flow it would be the density of water,
- $\sigma$ is the surface tension between the two phases,
- $\Gamma_B = 0.264$ and $K_B = 1.370$ are closure coefficients of the model.

Many of the parameters in the breakage model are provided as functors,
which means that spatially dependent fields may be specified for these parameters.
However, the validation of this model has only been performed using constant parameters.





### WCNSFV2PMomentumAdvectionSlip

This object implements the $\nabla \cdot \left(\rho\vec u_{slip} \otimes \vec u_{slip} \right)$
component terms of the mixture model in the two-phase Navier Stokes momentum equation.
The term is added to the Rhie-Chow interpolation in a similar way than the momentum advection
kernel. See [INSFVMomentumAdvection.md] for more details.




### WCNSFV2PMomentumDriftFlux

This object implements the contribution to the momentum equation
from the drift flux term

\begin{equation}
- \nabla \cdot \alpha_d \rho_d \bm{v}_{slip,d} \bm{v}_{slip,d} \,,
\end{equation}

where:

- $\alpha_d$ is the fraction of the dispersed phase $d$,
- $\rho_d$ is the density of the dispersed phase $d$,
- $\bm{v}_{slip,d}$ is the slip velocity of the dispersed phase $d$.

The user can set the slip velocity from their specific calculations.
However, we recommend the usage of [WCNSFV2PSlipVelocityFunctorMaterial.md] for
computing the slip velocity.

This term can be interpreted as the extra convection that is added
due to the particles being transported in the flow field.

If the mixture model is used to capture more than one dispersed phase,
a different `WCNSFV2PMomentumDriftFlux` kernel should be added for each
of the transported phases with the corresponding slip velocity for
each phase.

Because the mixture density is computed inside `WCNSFV2PMomentumDriftFlux`, this kernel
is not compatible with mixture fluid properties in the fluid properties module that do
not use a linear volume mixing for densities.




### WCNSFVEnergyTimeDerivative

#### Description

The `WCNSFVEnergyTimeDerivative` kernel implements a time derivative for the domain $\Omega$ given by

\begin{equation}
\rho c_p \frac{\partial u}{\partial t} +
\rho \frac{\partial c_p}{\partial t} u +
\frac{\partial \rho}{\partial t} c_p u +
\sum_{i=1}^n \beta_i = 0 \in \Omega.
\end{equation}
where $\rho$ is the material density, $c_p$ is the specific heat, and the second term on the left hand side corresponds to the strong forms of
other kernels.

The Jacobian is computed with automatic differentiation.




### WCNSFVMassAdvection

This object computes the residual and Jacobian contribution of the mass
advection term for a (weakly) compressible version of the mass continuity
equation, e.g. this object adds the term $\nabla\cdot \rho \vec u$. We apply the
divergence theorem and compute the advective flux of mass across cell/element
faces.




### WCNSFVMassTimeDerivative

This object adds the $\frac{\partial \rho}{\partial t}$ term of the
weakly compressible Navier Stokes mass equation where $\rho$ is the density,
and $t$ is time. This kernel is applied along with a [INSFVMassAdvection.md] kernel
to form the conservation of mass equation.




### WCNSFVMixingLengthEnergyDiffusion

This kernel uses a mixing-length model to compute the turbulent diffusion of energy,
$\nabla \cdot \overline{ c' \vec T}$, which appears in
Reynolds-averaged conservation equations.

where c' is the ratio

c' = \dfrac{\rho c_p \nu_t}{Pr_t}

with $\rho$ the fluid density, $c_p$ the specific heat capacity, $\nu_t$ the turbulent kinematic viscosity
and $Pr_t$ the turbulent Prandtl number.




### WCNSFVMomentumTimeDerivative

This object adds the $\rho\frac{\partial \vec u_i}{\partial t} + \frac{\partial \rho}{\partial t} \vec u_i $ term of the
weakly compressible Navier Stokes momentum equation where $\rho$ is the density,
$\vec u_i$ refers to the i'th component of the velocity $\vec{u}$, and $t$ is
time. This kernel must be applied for every component of the velocity.




## hdgbcs

### NavierStokesHDGOutflowBC

This class implements an outflow boundary condition for use with the
hybridized kernel [NavierStokesHDGKernel.md]. The condition imposed is

\begin{equation}
\vec{n}p -\mu\nabla\vec{u}\cdot{n} = \vec{0}
\end{equation}

where $\vec{n}$ is the outward-facing normal on the boundary, $p$ is the
pressure, $\nu$ is the kinematic viscosity, and $\vec{u}$ is the velocity.




### NavierStokesHDGVelocityDirichletBC

This class weakly imposes Dirichlet boundary conditions for the velocity for a
hybridized discretization of the Navier-Stokes equations. This class should be
used with the [NavierStokesHDGKernel.md]. Any `FunctionName` parameters
that are not provided are defaulted to 0.




## hdgkernels

### NavierStokesHDGKernel

This class implements the steady incompressible Navier-Stokes equations. These include the conservation of mass:

\nabla \cdot \vec{u} = 0

where $\vec{u}$ is the velocity and conservation of momentum:

\nabla \cdot \left(\rho \vec{u} \otimes \vec{u}\right) - \nabla \cdot \left(\mu
\nabla\vec{u}\right) + \nabla p = 0

where $\rho$ is the density, $\mu$ is the dynamic viscosity and $p$ is the pressure. This class uses
the hybridization laid out in [!citep](nguyen2011implicit). Note that, as shown
in the reference, the pressure field is integrated by parts which has
consequences for boundary conditions on momentum flux boundaries.




## ics

### NSFunctionInitialCondition

`NSFunctionInitialCondition` can be used to initialize variables by evaluating fluid properties,
using [functions](syntax/Functions/index.md) for the pressure, temperature and velocity.

#### Example input file syntax

In this example, we initialize the density at the desired initial temperature and pressure conditions.





### NSInitialCondition

`NSInitialCondition` can be used to initialize variables by evaluating fluid properties.

#### Example input file syntax

In this example, we initialize the density at the desired initial temperature and pressure conditions.





### PNSInitialCondition

`PNSInitialCondition` can be used to initialize variables by evaluating fluid properties
for porous flow calculations. It can accept both interstitial and superficial velocities for
initializing superficial or interstitial velocity variables and energy.

#### Example input file syntax

In this example, we initialize the first component of the superficial momentum with a specified superficial velocity. The superficial velocity is specified as a vector. We could have alternatively specified
an interstitial velocity and the porosity.





## kernels

### DistributedForce





### DistributedPower





### INSADBoussinesqBodyForce

This object adds a $\rho\alpha\vec{g}(T - T_{ref})$ term to the incompressible
Navier Stokes (INS) equations where $\rho$ is the density, $\alpha$ is the thermal
expansion coefficient, $\vec{g}$ is the gravity vector, $T$ is the temperature,
and $T_{ref}$ is a reference temperature. The term above introduces the
Boussinesq approximation into the INS equations, which allows for modeling
natural convection.




### INSADEnergyAdvection

This object adds a $\rho c_p \vec u \cdot \nabla T$ term, likely to a heat
conduction-convection equation, where $\rho$ is the density, $c_p$ is the
specific heat capacity,
$\vec u$ is the velocity (represented by `_U` in the code), and $\nabla T$ is the temperature gradient
(represented by `_grad_u` in the code). The divergence form of this term is
given by

\begin{equation}
\nabla \cdot \rho c_p \vec{u} T
\end{equation}

which assuming constant $\rho$ and $c_p$ (a big assumption) can be split into
the two terms

\begin{equation}
\rho c_p\left(T \nabla \cdot \vec{u} + \vec{u} \nabla T\right)
\end{equation}

Applying the incompressibility constraint $\nabla \cdot \vec{u}$ yields the
final form used in the `INSADEnergyAdvection` object

\begin{equation}
\rho c_p \vec{u} \cdot \nabla T
\end{equation}

stated above.





### INSADEnergyAmbientConvection

This object adds a term of the incompressible energy equation of the form
$\alpha \left(T - T_{ambient}\right)$ where $\alpha$ is based on the `Real` `alpha`
parameter set by the user and $T_{ambient}$ is similarly set through the `Real`
`T_ambient` parameter. This term addition is meant to represent a volumetric
approximation of an energy exchange between an external heat exchanger or some
other ambient surrounding heat source/sink.





### INSADEnergyMeshAdvection


`INSADEnergyMeshAdvection` implements the corresponding weak form for the components of
the term:

\begin{equation}
-\rho c_p \left(\frac{\partial\vec{d_m}}{\partial t} \cdot \nabla\right) T
\end{equation}

where $\rho$ is the density, $c_p$ is the constant pressure specific heat
capacity, $\vec{d_m}$ is the fluid mesh displacements, and $T$ is the fluid
temperature. This is the energy equation analog of the momentum equation object
[INSADMomentumMeshAdvection.md]. This term is essential for obtaining the
correct convective derivative of the fluid temperature in cases where the fluid
mesh is dynamic, e.g. in simulations of fluid-structure interaction or Arbitrary
Eulerian Lagrangian (ALE) simulations.




### INSADEnergySource

This object adds a heat source to the incompressible energy equation in the form
of a function with name set through the `source_function` parameter. Note that
if the function evaluates positive, this kernel is a source term. If the
function evaluates negative, then this kernel is a sink term.





### INSADEnergySUPG

This object adds stabilization to the incompressible energy equation in
the form of $\left(\tau \vec u \cdot \nabla\psi_i, \vec R\right)$ where $\tau$
is the stabilization parameter, $\vec u$ is the velocity vector and $\vec R$ is the strong
residual of the momentum equation. $\tau$ is calculated based on the advection velocity, thermal
conductivity, density, heat capacity, time step size, and mesh size.  This term adds additional (consistent)
streamline diffusion such that higher Reynolds numbers can be simulated without
producing crippling oscillations.





### INSADGravityForce

This object adds a simple gravitational force term to the incompressible Navier
Stokes equations of the form $-\rho\vec{g}$ where $\rho$ is the density and
$\vec{g}$ is the gravity vector.




### INSADHeatConductionTimeDerivative

#### Description

The `INSADHeatConductionTimeDerivative` kernel implements a time derivative for the domain $\Omega$ given by

\begin{equation}
\underbrace{\rho c_p \frac{\partial u}{\partial t}}_{\textrm{INSADHeatConductionTimeDerivative}} +
\sum_{i=1}^n \beta_i = 0 \in \Omega.
\end{equation}
where $\rho$ is the material density, $c_p$ is the specific heat, and the second term on the left hand side corresponds to the strong forms of
other kernels. The corresponding `INSADHeatConductionTimeDerivative` weak form using inner-product notation is

\begin{equation}
R_i(u_h) = (\psi_i, \rho c_p\frac{\partial u_h}{\partial t}) \quad \forall \psi_i,
\end{equation}
where $u_h$ is the approximate solution and $\psi_i$ is a finite element test function.

The Jacobian is given by automatic differentiation, and should be perfect as long as $c_p$ and $\rho$
are provided using `ADMaterial` derived objects.




### INSADMass

This object computes the residual and Jacobian contribution of the
incompressible version of the mass continuity equation, e.g. $\nabla\cdot\vec u$.





### INSADMassPSPG

This object adds stabilization to the incompressible mass continuity equation in
the form of $\left(\nabla\psi_i, -\frac{\tau}{\rho}\vec R\right)$ where $\tau$
is the stabilization parameter, $\rho$ is the density and $\vec R$ is the strong
residual of the momentum equation. This is stabilizing because $\vec R$ includes
a pressure gradient term, producing a diffusion term like so:
$\left(\nabla\psi_i, \nabla p\right)$. Because the mass equation now has an
on-diagonal dependence, the saddle point nature of the incompressible equations
is removed and equal order shape functions can be used for velocity and pressure
variables.





### INSADMomentumAdvection

This object adds the $\rho\left(\vec u \cdot\nabla\right)\vec u$ term of the
incompressible Navier Stokes momentum equation. Note that in the code we right
multiply by $\vec u$, e.g. we perform $\nabla\vec u \cdot \vec u$ because
$\nabla \vec u$ is stored in [Jacobian matrix form](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant).





### INSADMomentumCoupledForce

This object adds a term to the incompressible momentum equation directly
proportional to a coupled vector variable `coupled_vector_var` or a vector
function `vector_function`. Positive coupled variable or function components represent
momentum sources in that component direction, e.g. if the x-component is positive then this
object imposes a momentum source in the +x direction.




### INSADMomentumGradDiv

This kernel implements grad-div stabilization for the purpose of building
scalable preconditioners at high Reynolds numbers for Navier-Stokes as introduced in
[!citep](benzi2006augmented). Its weak form is given by

\begin{equation}
\gamma\left(\textrm{div}\ \mathbf{u}_h, \textrm{div}\ \mathbf{v}_h\right)
\end{equation}

where $\gamma$ is a penalty parameter, $\mathbf{u}_h$ is the velocity vector
approximate solution, and $\mathbf{v}_h$ are its associated test functions. For
$\gamma$ not too small, the Schur complement inverse of a linearized (via Newton or
Picard) stable (no pressure on-diagonal) Navier-Stokes discretization is well
approximated by

\begin{equation}
S^{-1} = -\left(\nu + \gamma\right)M_p^{-1}
\end{equation}

where $\nu$ is the kinematic viscosity and $M_p$ is the pressure mass matrix
([!citep](farrell2019augmented)). In [!citep](benzi2006augmented) the authors
found that $\gamma$ on the order of the velocity magnitude provides $\nu$- and
$h$-independent (the latter denoting element size) convergence for a wide range
of values for $\nu$ and $h$. For using the (scaled) pressure mass matrix as the
preconditioner for the Schur complement, the [NavierStokesProblem.md] should be
used in conjunction with [FieldSplitPreconditioner.md]. A demonstration of this
combination is given in the `steady_vector_fsp_al.i` input


where we have indicated that we should use the pressure mass matrix as the
preconditioner for the Schur complement using the
[!param](/Problem/NavierStokesProblem/use_pressure_mass_matrix) parameter. The
scaled pressure mass matrix is built using the [MassMatrix.md] kernel with block


The field split options are shown in


In this case we only wish to display the effectiveness of the pressure mass
matrix as a preconditioner for the Schur complement, so we use LU solves for
inverting the velocity block and $M_p$. Indeed for $\nu=10^{-3}$ (equivalent to
$\textrm{Re}=1000$), the solution of the Schur complement system to a relative tolerance of ($10^{-2}$) takes no more
than 4 Krylov iterations when running on grids ranging from 8x8 to
32x32. Scalable solves for the velocity block in the context of augmented
Lagrange formulations are the subject of [!cite](benzi2023solving).




### INSADMomentumMeshAdvection


`INSADMomentumMeshAdvection` implements the corresponding weak form for the components of
the term representing the contribution of the mesh displacement to the conservation of momentum:

\begin{equation}
-\rho \left(\frac{\partial\vec{d_m}}{\partial t} \cdot \nabla\right) \vec{u}
\end{equation}

where $\rho$ is the density, $\vec{d_m}$ is the fluid mesh displacements, and
$\vec{u}$ is the fluid velocity. This term is essential for obtaining the
correct convective derivative of the fluid in cases where the fluid mesh is
dynamic, e.g. in simulations of fluid-structure interaction or Arbitrary
Eulerian Lagrangian (ALE) simulations.




### INSADMomentumPressure

This object adds the $\nabla p$ term of the
incompressible Navier Stokes momentum equation. The user can specify a boolean
for the `integrate_p_by_parts` input parameter to determine whether this term
will be integrated by parts for the weak form.





### INSADMomentumSUPG

This object adds stabilization to the incompressible momentum equation in
the form of $\left(\tau \vec u \cdot \nabla\psi_i, \vec R\right)$ where $\tau$
is the stabilization parameter, $\vec u$ is the velocity vector and $\vec R$ is the strong
residual of the momentum equation. This term adds additional (consistent)
streamline diffusion such that higher Reynolds numbers can be simulated without
producing crippling oscillations.





### INSADMomentumTimeDerivative

This object adds the $\rho\frac{\partial \vec u}{\partial t}$ term of the
incompressible Navier Stokes momentum equation where $\rho$ is the density,
$\vec u$ is the velocity, and $t$ is time.





### INSADMomentumViscous


This object adds the viscous term of the
incompressible Navier Stokes momentum equation. Through use of the
`viscous_form` parameter, the user can select different forms of the viscous
stress. The `laplace` and `traction` forms are described in [INSMomentumLaplaceForm.md] and
[INSMomentumTractionForm.md] respectively.




### INSADSmagorinskyEddyViscosity

This object computes the residual and Jacobian contribution of the eddy viscosity term
as given by the Smagorinsky large eddy simulation model. For some details on how this
tends to be used, the paper [!cite](bouffanais2007) is recommended. Using this kernel
adds this term to the momentum equation:

\begin{equation}
-\nu_{sgs} \rho \nabla^2 \vec u
\end{equation}

Where the subgrid-scale eddy viscosity is calculated as:

\begin{equation}
\nu_{sgs} = (C_s \bar{\Delta})^2 ||\bar{\bar{S}}||
\end{equation}

Where the symmetric strain rate tensor magnitude is calculated by:
\begin{equation}
||\bar{\bar{S}}||^2 = \sum_{i=0}^3 \sum_{j=0}^3 (\nabla \vec u + \nabla \vec u^T)^2
\end{equation}

The filter length can be calculated in a few ways, and this kernel uses the common approach
of using the cube root of the element volume as the filter length, divided by the local
element polynomial degree for the velocity variable. The Smagorinsky constant $C_s$ comes
from theory [!cite](smagorinsky1963), and is set by default to a reasonable value.







### INSChorinCorrector





### INSChorinPredictor





### INSChorinPressurePoisson





### INSCompressibilityPenalty





### INSFEFluidEnergyKernel


This kernel implements most terms in the conservation of energy equation for a continuous Galerkin discretization.
Both regular and porous media flow can be represented in this kernel, by specifying the [!param](/Kernels/INSFEFluidEnergyKernel/porosity) parameter.
The following terms are implemented:

- a convective term, modeling the advection of energy
- a diffusive term, including turbulence effects through the thermal conductivity computed by an [INSFEMaterial.md]
- a volumetric heat source term. It can be provided as a field using the [!param](/Kernels/INSFEFluidEnergyKernel/power_density)
  parameter or as a scalar variable (single value, uniform over the volume) with the [!param](/Kernels/INSFEFluidEnergyKernel/pke_power_var)


If selecting the conservative form using the [!param](/Kernels/INSFEFluidEnergyKernel/conservative_form) boolean
parameter, the convective term of the equation is expressed in the conservative form, i.e., $\nabla \cdot (\rho \vec{v} h)$, and integration by parts is applied to obtain the weak form.
Otherwise, the primitive form, i.e., $\rho c_p \vec{v} \cdot \nabla T$, is used, and integration by parts is **not** applied.




### INSFEFluidMassKernel


This kernel supports both regular and porous media flow, with the porosity specified
as a material property using the [!param](/Kernels/INSFEFluidMassKernel/porosity) parameter.

The mass equation is computed with the following residual for incompressible flow:

- \rho \vec{v} \nabla \psi

This kernel computes the PSPG stabilization terms from the momentum equation:

- the transient term $\rho \dot{\vec{v}} \psi_{pspg}$
- the convection term $\rho \ \epsilon \vec{v} * \nabla \vec{v} \psi_{pspg}$
- the pressure term $\epsilon \nabla p \psi_{pspg}$
- the gravity term $-\epsilon \rho \vec{g} \psi_{pspg}$
- a viscous term for regular media flow
- a viscous and a friction term for porous media flow


with $\psi_{pspg} = \tau_c \nabla \psi$, $\rho$ the density, $\vec{v}$ the superficial velocity,
$\vec{g}$ the gravity vector, $\epsilon$ the porosity, $p$ the pressure, $\tau_c$ a stabilization term computed by
the [INSFEMaterial.md], $\psi$ the test functions.




### INSFEFluidMomentumKernel


This kernel supports both regular and porous media flow, with the porosity specified
as a material property using the [!param](/Kernels/INSFEFluidMassKernel/porosity) parameter.

This kernel computes the following terms in the momentum equation:

- the convection term $\rho \ \epsilon \vec{v} * \nabla \vec{v} \psi$ (non-conservative form)
- the pressure term $\epsilon \nabla p \psi$ (volumetric form)
- the gravity term $-\epsilon \rho \vec{g} \psi$
- a viscous term for regular media flow
- a viscous and a friction term for porous media flow


The pressure term can also be computed with an integration by parts. If so, the
boundary conditions for the momentum equations should also use an integration by parts.

The convection term can also be computed using a conservative form. If so, other kernels
such as the [PINSFEFluidVelocityTimeDerivative.md] must also use a conservative form.


This kernel computes the SUPG stabilization terms for the momentum equation:

- the transient term $\rho \dot{\vec{v}} \psi_{supg}$
- the convection term $\rho \ \epsilon \vec{v} * \nabla \vec{v} \psi_{supg}$
- the pressure term $\epsilon \nabla p \psi_{supg}$
- the gravity term $-\epsilon \rho \vec{g} \psi_{supg}$
- a viscous term for regular media flow
- a viscous and a friction term for porous media flow





### INSMass





### INSMassRZ





### INSMomentumLaplaceForm


This class implements the same terms as described in
[INSMomentumTractionForm.md] but with a simplification applied to the viscous
stress. For constant density and viscosity, the following simplification can be
applied, as described in [!citep](peterson2018overview):

\begin{aligned}
\nabla\cdot\sigma &= \nabla\cdot\left(-p\bm{I} + \mu\left(\nabla\vec{u} + \left(\nabla\vec{u}\right)^T\right)
                  &= -\nabla p + \mu\left(\nabla\cdot\nabla\vec{u} + \nabla\cdot\left(\nabla\vec{u}\right)^T\right)
                  &= -\nabla p + \mu[left(\nabla\left(\nabla\cdot\vec{u}\right) + \nabla\cdot\left(\nabla\vec{u}\right)^T\right)
                  &= -\nabla p + \mu\nabla\cdot\left(\nabla\vec{u}\right)^T
                  &= -\nabla p + \mu\nabla^2\vec{u}
\end{aligned}

Moving from lines 2 to 3 in the above equation we assumed sufficient smoothness in
$\vec{u}$ to interchange the divergence and gradient operations. In moving from
lines 3 to 4 we applied the incompressibility constraint $\nabla\cdot\vec{u} =
0$. The final form is a vector Laplacian (which can be different in
non-Cartesian coordinate systems from a componentwise scalar Laplacian), hence
the designation the "Laplace" form.




### INSMomentumLaplaceFormRZ





### INSMomentumTimeDerivative





### INSMomentumTractionForm


This object adds the following terms for the Navier-Stokes momentum equation

\begin{equation}
\rho\left(\vec{u}\cdot\nabla\right)\vec{u} - \nabla\cdot\sigma - \vec{f}
\end{equation}

where $\rho$ is the density, $\vec{u}$ is the velocity, $\sigma$ is the total
stress tensor, and $\vec{f}$ is a body force per unit volume. The total stress
tensor is generally defined by

\begin{equation}
\label{traction}
\sigma = -p\bm{I} + \mu\left(\nabla\vec{u} + \left(\nabla\vec{u}\right)^T\right)
\end{equation}

where $p$ is the pressure, $\bm{I}$ is the identity matrix, and $\mu$ is the
dynamic viscosity. The second term on the RHS of [traction] is what we call the
"traction" form of the viscous stress. For incompressible fluids with a constant
viscosity, this term can be simplified as described in [INSMomentumLaplaceForm.md].




### INSMomentumTractionFormRZ





### INSPressurePoisson





### INSProjection





### INSSplitMomentum





### INSTemperature





### INSTemperatureTimeDerivative





### MassConvectiveFlux





### MomentumConvectiveFlux





### NSEnergyInviscidFlux





### NSEnergyThermalFlux





### NSEnergyViscousFlux





### NSGravityForce





### NSGravityPower





### NSMassInviscidFlux





### NSMomentumInviscidFlux





### NSMomentumInviscidFluxWithGradP





### NSMomentumViscousFlux





### NSSUPGEnergy





### NSSUPGMass





### NSSUPGMomentum





### NSTemperatureL2





### PINSFEFluidPressureTimeDerivative


Assuming porosity not changing with time, the time derivative for the porous media mass equation is computed as:

\epsilon (\dfrac{\partial \rho}{\partial T} \dot{T} + \dfrac{\partial \rho}{\partial p} \dot{p}) \psi

with $\rho$ the density, $T$ the temperature, $p$ the pressure, and $\psi$ the test functions.

This kernel refers to the pressure as the mass equation is assigned to the pressure
degrees of freedom in the nonlinear systems.





### PINSFEFluidTemperatureTimeDerivative


If using a conservative form of the energy equation, the time derivative
of the energy will include the time derivative of the density, computed from
the fluid properties in the [!param](/Kernels/PINSFEFluidTemperatureTimeDerivative/eos)
parameter.

The porosity is assumed to be constant in time.




### PINSFEFluidVelocityTimeDerivative


If using the conservative form, the time derivative of the density is taken into account in the contribution to
the residual $R_{time}$. If not, only the time derivative of velocity is considered.

R_{time} = (\rho \dfrac{\partial v_i}{\partial t} + v_i \dfrac{\partial \rho}{\partial t})\psi

with $\rho$ the fluid density, $v_i$ the component of the (superficial) velocity specified
with the [!param](/Kernels/PINSFEFluidVelocityTimeDerivative/variable) parameter, and $\psi$
the test function.

The porosity is assumed to be constant in time.




### PressureGradient





### TotalEnergyConvectiveFlux





### VectorMassMatrix

This object is the vector analog of [MassMatrix.md].




## linearfvbcs

### LinearFVExtrapolatedPressureBC

#### Description

This boundary condition is created for pressure variables in the pressure Poisson
equation. It behaves just like a [LinearFVAdvectionDiffusionExtrapolatedBC.md] but
its response depends on the usage:

  - When it is used for the computation of gradients, the user can prescribe two-term extrapolation
    to the boundary faces to increase accuracy.
  - When it is used for building the pressure Poisson equation, it assumes a one-term expansion. The
    reason behind this is that for cases when the pressure needs to be pinned, adding boundary-related
    terms to the right hand side of the system will emulate a boundary source which yields unphysical results.





## linearfvkernels

### LinearFVDivergence


#### Overview

The element-wise integral of the divergence operator acting on a vector
field $\vec{u}$ in a finite volume setting can be approximated as follows:

\int\limits_{V_C} \nabla \cdot \vec{u} \approx \sum\limits_\text{f} \vec{u}_f \cdot \vec{n_f} |S_f|

where $\vec{u}_f$, $\vec{n_f}$ and $|S_f|$ are the approximated field value, normal and area of surface $f$.
Unlike [FVDivergence.md], this kernel expects the face flux
($\vec{u}_f \cdot \vec{n_f}$) as an input through the [!param](/LinearFVKernels/LinearFVDivergence/face_flux) parameter.




### LinearFVEnergyAdvection

This kernel adds the contributions of the energy advection term to the matrix and right hand side of the energy equation system for the finite volume SIMPLE segregated solver [SIMPLE.md].

This kernel currently supports the advection of specific enthalpy $h$ or temperature $T$. Important consideration: Temperature advection is only supported for constant specific heat, where $h$ can be defined as $h=c_p T$. For variable $c_p$, the user should use the enthalpy formulation. Parameter [!param](/LinearFVKernels/LinearFVEnergyAdvection/advected_quantity) lets the user select "enthalpy" or "temperature".

This term is described by $\nabla \cdot \left(\rho\vec{u} h \right)$ for enthalpy or $\nabla \cdot \left(\rho\vec{u} c_p T \right)$ for constant specific heat. This term is present in the energy equation conservation for an incompressible/weakly-compressible formulation.

For FV, the integral of the advection term over a cell can be expressed as:

\begin{equation}
\int\limits_{V_C} \nabla \cdot \left(\rho\vec{u} h \right) dV \approx \sum\limits_f (\rho \vec{u}\cdot \vec{n})_{RC} h_f |S_f| \,
\end{equation}

where $h_f$ is a face enthalpy. The enthalpy acts as the advected quantity and an interpolation scheme (e.g. upwind) can be used to compute the face value. This kernel adds the face contribution for each face $f$ to the right hand side and matrix.

The face mass flux $(\rho \vec{u}\cdot \vec{n})_{RC}$ is provided by the [RhieChowMassFlux.md] object which uses pressure
gradients and the discrete momentum equation to compute face velocities and mass fluxes.
For more information on the expression that is used, see [SIMPLE.md].




### LinearFVMomentumBoussinesq

This kernel adds the contributions of the Boussinesq buoyancy treatment for density through a force/source term to the right hand side of the momentum equation system for the finite volume SIMPLE segregated solver [SIMPLE.md]. The Boussinesq buoyancy treatment is applicable for low changes in density, and assumes constant density value in all other equation terms.

This term is described by $-\rho_{ref}\alpha\vec{g}(T - T_{ref})$ present in the momentum equation conservation when describing an incompressible fluid, where $\rho_{ref}$ is the reference density, $\alpha$ is the thermal expansion coefficient, $\vec{g}$ is the gravity vector, $T$ is the temperature, and $T_{ref}$ is a reference temperature. The Boussinesq buoyancy model assumes the changes in density as a function of temperature are linear and relevant only in the buoyant force term of the equation system. The Boussinesq kernel allows for modeling natural convection.

This term deals only with the force due to the variation in density $\Delta \rho \vec{g}$, with the fluid density being $\rho = \rho_{ref}+\Delta\rho$. Thus, with no extra added terms to the conventional incompressible Navier Stokes equations, the system will solve for the total pressure minus the hydrostatic pressure.
For natural convection simulations, it is advisable to compute relevant dimensionless numbers such as the Rayleigh number or the Richardson number to decide on the need for turbulence models, mesh refinement and stability considerations.




### LinearFVMomentumPressure

This object adds the $-\nabla p$ term to the right hand side of
the Navier Stokes momentum equations.




### LinearFVScalarAdvection

This kernel adds the contributions of the scalar advection term to the matrix and right hand side of the scalar equation system for the finite volume SIMPLE segregated solver [SIMPLE.md].

This term is described by $\nabla \cdot \left(\vec{u} C_i \right)$ present in the scalar equation conservation for an incompressible/weakly-compressible formulation.

For FV, the integral of the advection term of scalar $C_i$ over a cell can be expressed as:

\begin{equation}
\int\limits_{V_C} \nabla \cdot \left(\vec{u} C_i \right) dV \approx \sum\limits_f ( \vec{u}\cdot \vec{n})_{RC} C_if |S_f| \,
\end{equation}

where $C_{if}$ is the face value of the scalar concentration. An interpolation scheme (e.g. upwind) can be used to compute the face value. This kernel adds the face contribution for each face $f$ to the right hand side and matrix.

The volumetric face flux $(\vec{u}\cdot \vec{n})_{RC}$ is provided by the [RhieChowMassFlux.md] object which uses pressure
gradients and the discrete momentum equation to compute face velocities and mass fluxes.
For more information on the expression that is used, see [SIMPLE.md].




### LinearFVVolumetricHeatTransfer

This object adds the following volumetric heat transfer term to the
energy equation that relies on the linear FV assembly routines:

\begin{equation}
\pm h (T_\mathrm{fluid}-T_\mathrm{solid}),
\end{equation}

where

- $h=h_\mathrm{surface}\frac{A}{V}$ is the volumetric heat transfer coefficient
  with $A$ the total approximated surface area, $V$ the total approximated
  volume and $h_\mathrm{surface}$ the approximated surface heat transfer coefficient.
- $T_\mathrm{fluid}$ is the fluid temperature,
- $T_\mathrm{solid}$ is the solid temperature.

The sign ($\pm$) depends on if the kernel is added to the fluid or
solid energy equation. This can be controlled by the
[!param](/LinearFVKernels/LinearFVVolumetricHeatTransfer/is_solid) parameter.





### LinearWCNSFVMomentumFlux

This kernel adds the contributions of two terms that require face fluxes
in the momentum equations of the incompressible/weakly-compressible Navier Stokes equations:

- Momentum advection term
- Viscous stress term

We discuss these two terms in detail below.

### Momentum advection term

This term is described by the $\nabla \cdot \left(\rho\vec{u} \otimes \vec{u}\right)$
component of the incompressible/weakly-compressible Navier Stokes
momentum equation.

The face mass flux is provided by the [RhieChowMassFlux.md] object which uses pressure
gradients and the discrete momentum equation to compute face velocities and mass fluxes.
For more information on the expression that is used, see [SIMPLE.md].

Once the face flux is given ($(\rho \vec{u}\cdot \vec{n})_{RC} $), the integral of the
advection term over a cell can be expressed as:

\begin{equation}
\int\limits_{V_C} \nabla \cdot \left(\rho\vec{u} \otimes \vec{u}\right) dV \approx \sum\limits_f (\rho \vec{u}\cdot \vec{n})_{RC} \vec{u}_f |S_f| \,
\end{equation}

where `\vec{u}_f` is a face velocity. This face velocity acts as the advected quantity and a linear average or upwind scheme can be used to compute it. This kernel adds the
face contribution for each face $f$ to the right hand side and matrix.

### Viscous stress term

This term is described by the $\nabla \cdot \left(\mu_\text{eff} \left(\nabla\vec{u} +\nabla \vec{u}^T - \frac{2}{3} \nabla \cdot \vec{u} \mathbb{I} \right)\right)$
component of the incompressible/weakly-compressible Navier Stokes
momentum equation. Using the divergence theorem and the finite volume approximation,
this term can be expressed as

\begin{equation}
\int\limits_{V_C} \nabla \cdot \left(\mu_\text{eff} \left(\nabla\vec{u} +\nabla \vec{u}^T - \frac{2}{3} \nabla \cdot \vec{u} \mathbb{I} \right)\right) dV
\approx \sum\limits_f \mu_\text{eff} \left(\nabla\vec{u} +\nabla \vec{u}^T - \frac{2}{3} \nabla \cdot \vec{u} \mathbb{I} \right) \cdot \vec{n}_f |S_f| \,
\end{equation}

where the first term ($\mu_\text{eff}\nabla\vec{u} \cdot \vec{n}_f |S_f|$) can be
discretized using the same method as in [LinearFVDiffusion.md]. The other two terms,
($\left(\mu_\text{eff}\nabla\vec{u}^T - \frac{2}{3} \nabla \cdot \vec{u} \mathbb{I} \right)\cdot \vec{n}_f |S_f|$) are treated explicitly meaning that they don't contribute to
the system matrix, only to the right hand side.

For incompressible simulations with constant viscosity fields, the last two terms are
provably 0. Furthermore, in most scenarios, these two terms are negligible compared to
the first term so the user can elect to disable them using [!param](/LinearFVKernels/LinearWCNSFVMomentumFlux/use_deviatoric_terms) parameter.

Similarly to [LinearFVDiffusion.md], once can select to utilize nonorthogonal corrections
for the first term using the [!param](/LinearFVKernels/LinearWCNSFVMomentumFlux/use_nonorthogonal_correction) parameter.





## materials

### Air





### ConservedVarValuesMaterial


#### Overview

This object takes a conserved free-flow variable set and computes all the
necessary quantities for solving the compressible free-flow Euler equations. The
conserved variable set in this case is

\begin{equation}
\begin{bmatrix}
\rho\\
\rho u\\
\rho v\\
\rho w\\
\rho e_t
\end{bmatrix}
\end{equation}

where $\rho$ is the density, $u$, $v$, and $w$ are the component velocities, and
$e_t$ is the total specific energy equivalent to $e + \left(\bm{a}\cdot\bm{a}\right)/2$ where
$e$ is the specific internal energy and $\bm{a} = \lbrace u, v, w\rbrace$.




### GeneralFluidProps


#### Overview

This object uses a `SinglePhaseFluidProperties` derived-object to compute

- specific heat at constant volume, $c_v$
- specific heat at constant pressure, $c_p$
- dynamic viscosity, $\mu$
- thermal conductivity, $k$
- Prandtl number, $\text{Pr}$
- pore/particle Reynolds number $\text{Re}$
- hydraulic Reynolds number $\text{Re}_h$
- interstitial Reynolds number $\text{Re}_i$




### INSAD3Eqn

This object computes strong residuals for the incompressible energy equation that are then used in stabilization
kernels as well as in the core `INSADEnergy` kernels where the strong and weak forms are
the same, e.g. terms that have no integration by parts.





### INSADMaterial

This object computes strong residuals that are then used in stabilization
kernels as well as in the core INSAD kernels where the strong and weak forms are
the same, e.g. terms that have no integration by parts.





### INSADStabilized3Eqn

This object computes the stabilization parameter $\tau_E$ for use in
streamline-upwind kernels for the energy equation.





### INSADTauMaterial

This object computes the stabilization parameter $\tau$ for use in
pressure-stabilized and streamline-upwind kernels.





### INSFEMaterial


The fluid properties are computed as [material properties](Materials/index.md)
from the flow variables -- velocity, pressure, temperature -- and from the fluid properties.
The fluid properties computed are:

- density
- dynamic viscosity
- thermal diffusivity
- specific heat capacity


Additionally, several turbulence quantities are computed using a mixing length
model:

- the turbulent dynamic viscosity
- the turbulent heat conductivity
- the viscous stress tensor from both dynamic and turbulent viscosity


The stabilization terms for [PSPG/ SUPG stabilization](navier_stokes/cgfe.md) are also computed:

- the minimum dimension of the element 'hmin'
- the mass PSPG stabilization term $\tau_c$
- the momentum and energy equation SUPG stabilization $\tau$ terms





### PINSFEMaterial


This material is the porous media version of [INSFEMaterial.md]. It declares and computes
the same material properties. It additionally can set constant user-input values for the following
properties:

- the inertia resistance coefficient
- the viscous resistance coefficient
- the porous media heat transfer coefficient between the solid and fluid phase
- the porous media wetted area


Non-constant properties can be defined for these quantities by creating a derived class of the
[PINSFEMaterial.md] and implementing correlations for the properties there.




### PorousConservedVarMaterial


#### Overview

This object is the porous version of the free-flow object
[ConservedVarValuesMaterial.md]. It uses the variable set

\begin{equation}
\begin{bmatrix}
\rho\\
\epsilon \rho u\\
\epsilon \rho v\\
\epsilon \rho w\\
\rho e_t
\end{bmatrix}
\end{equation}

where $\epsilon$ is the porosity, $\rho$ is the density, $u$, $v$, and $w$ are the component velocities, and
$e_t$ is the total specific energy equivalent to $e + \left(\bm{a}\cdot\bm{a}\right)/2$ where
$e$ is the specific internal energy and $\bm{a} = \lbrace u, v,
w\rbrace$. `PorousConservedVarMaterial` takes these variables and computes all the
necessary quantities for solving the compressible porous version of the Euler equations.




### PorousMixedVarMaterial


#### Overview

This object uses the variable set

\begin{equation}
\begin{bmatrix}
p\\
\epsilon \rho u\\
\epsilon \rho v\\
\epsilon \rho w\\
T_f
\end{bmatrix}
\end{equation}

where $\epsilon$ is the porosity, $\rho$ is the density, $u$, $v$, and $w$ are
the component velocities, $p$ is the pressure, and $T_f$ is the fluid
temperature.`PorousMixedVarMaterial` takes these variables and computes all the
necessary quantities for solving the compressible porous version of the Euler
equations.




### PorousPrimitiveVarMaterial


#### Overview

This object uses the variable set

\begin{equation}
\begin{bmatrix}
p\\
\epsilon u\\
\epsilon v\\
\epsilon w\\
T_f
\end{bmatrix}
\end{equation}

where $\epsilon$ is the porosity, $u$, $v$, and $w$ are
the component velocities, $p$ is the pressure, and $T_f$ is the fluid
temperature.`PorousPrimitiveVarMaterial` takes these variables and computes all the
necessary quantities for solving the compressible porous version of the Euler
equations.




### SoundspeedMat


#### Overview

This object simply computes the `sound_speed` material property given a
`SinglePhaseFluidProperties` derived object specified by the `fp`
parameter. This object relies on pressure and fluid temperature being computed
as material properties by some other material object.




## physics

### NavierStokesPhysicsBase

The `[Physics/NavierStokes]` syntax is used to nest parameters for [Physics](Physics/index.md)
solving the Navier Stokes equations or affiliated.

The `NavierStokesPhysicsBase` is a base class designed to hold routines commonly used
for solving the Navier Stokes equations.

### Navier Stokes Solid Heat Transfer / PNSFVSolidHeatTransfer


#### Equation

This [Physics](Physics/index.md) object creates the kernels and boundary conditions to solve the heat transfer
equation for the solid phase in a porous media flow problem.

\dfrac{\partial (1-\epsilon) \rho h_s}{\partial t} - \nabla \cdot (\kappa_s \nabla T_s) - \alpha (T_f - T_s) - (1-\epsilon) \dot{Q} = 0

where:

- $h_s$ is the solid specific enthalpy, computed from the specific heat $c_{ps}$ and the solid temperature
- $\rho$ is the solid density
- $\epsilon$ is the porosity
- $T_s$ is the solid temperature
- $T_f$ is the fluid temperature
- $k_s$ the solid thermal conductivity
- $(1-\epsilon) Q$ is the source term, corresponding to energy deposited directly in the solid phase
- $\alpha$ is the ambient convection volumetric heat transfer coefficient

The enthalpy is used in lieu of $\rho c_p T$ to be able to model solids with temperature dependent
specific heat.

The kernels potentially created for this equation are:

- [INSFVEnergyTimeDerivative.md] for the time derivative of the energy
- [PINSFVEnergyDiffusion.md] for energy diffusion with an isotropic thermal diffusivity
- [PINSFVEnergyAnisotropicDiffusion.md] for energy diffusion with an anisotropic thermal diffusivity
- [FVCoupledForce.md] for the energy source term
- [PINSFVEnergyAmbientConvection.md] for the volumetric ambient convection term, if present

Additional details on porous media flow equations can be found on this [page](navier_stokes/pinsfv.md).

#### Automatically created variables

The `PNSFVSolidHeatTransferPhysics` by default will automatically create a nonlinear variable
for the solid phase temperature. It should be named as follows:


#### Coupling with other Physics

In the presence of fluid flow, a [WCNSFVFluidHeatTransferPhysics.md] should be created
using the `[Physics/NavierStokes/FluidHeatTransfer/<name>]` syntax. The following input performs
the coupling between the fluid equations and the solid temperature equations. The coupling
between the fluid and solid domain is performed through a volumetric ambient convection term.


Conjugate heat transfer on a surface on the boundary of the fluid domain is not currently implemented
with the `Physics` syntax. Please use a [FVConvectionCorrelationInterface.md] for that purpose.




### Navier Stokes Flow / WCNSFVFlowPhysics


#### Equations

This [Physics](Physics/index.md) object creates the kernels and boundary conditions to solve the mass and momentum Navier Stokes equations for the flow.
The time derivatives in the mass equations are omitted for incompressible flow.
For regular flow in a non-porous medium:

\dfrac{\partial \rho}{\partial t} + \nabla \cdot \rho \vec{v} = 0

\dfrac{\partial \rho \mathbf{v}}{\partial t} + \nabla \cdot (\rho \mathbf{v} \otimes \mathbf{v}) = \nabla \cdot (\mu \nabla \mathbf{v}) - \nabla p + (\mathbf{F}_g + \mathbf{F}_f)

For porous media flow:

\epsilon \dfrac{\partial \rho}{\partial t} + \nabla \cdot \rho \vec{v}_D = 0

\dfrac{\partial \rho \mathbf{v}_D}{\partial t} + \nabla \cdot (\dfrac{\rho}{\epsilon} \mathbf{v}_D \otimes \mathbf{v}_D) = \nabla \cdot (\mu \nabla \dfrac{\mathbf{v}_D}{\epsilon}) - \epsilon \nabla p + \epsilon (\mathbf{F}_g + \mathbf{F}_f)

where:

- $\rho$ is the density
- $\mu$ is the dynamic viscosity
- $\epsilon$ is the porosity
- $\mathbf{v}$ is the velocity (non-porous flow)
- $\mathbf{v}_D$ is the superficial velocity (porous flow)
- $p$ is the pressure
- $\mathbf{F}_g$ is the gravity term
- $\mathbf{F}_f$ is the friction / inter-phase friction term


Additional details on porous media flow equations can be found on this [page](navier_stokes/pinsfv.md).

The kernels created for free flow for the mass equation:

- [WCNSFVMassTimeDerivative.md] for weakly-compressible flow in a transient case
- [INSFVMassAdvection.md] for the mass advection term

for porous media flow:

- [PWCNSFVMassTimeDerivative.md] for weakly-compressible flow
- [PINSFVMassAdvection.md] for mass advection

The kernels created for the momentum equation for free flow:

- [WCNSFVMomentumTimeDerivative.md] for the time derivative for weakly-compressible flow in a transient case
- [INSFVMomentumTimeDerivative.md] for the time derivative incompressible flow in a transient case
- [INSFVMomentumAdvection.md] for the momentum advection term
- [INSFVMomentumDiffusion.md] for the momentum diffusion term
- [INSFVMomentumPressure.md] for the pressure gradient term
- [PINSFVMomentumFriction.md] for the friction term if specified
- [INSFVMomentumGravity.md] for the gravity term if specified

for porous media flow:

- [PINSFVMomentumTimeDerivative.md] for the time derivative
- [PINSFVMomentumAdvection.md] for the momentum advection term
- [PINSFVMomentumDiffusion.md] for the momentum diffusion term
- [PINSFVMomentumPressure.md] for the pressure gradient term
- [PINSFVMomentumFriction.md] for the friction term if specified
- [PINSFVMomentumGravity.md] for the gravity term if specified

#### Automatically defined variables

The `WCNSFVFlowPhysics` automatically sets up the variables which are
necessary for the solution of a given problem. These variables can then be used
to couple fluid flow simulations with other physics. The list of variable names
commonly used in the action syntax is presented below:

- Velocities for non-porous-medium simulations:


- Velocities for porous medium simulations:


- Pressure:


For the default names of other variables used in this action, visit [this site](include/base/NS.h).


#### Coupling with other Physics

The energy advection equation can be solved concurrently with the flow equations using an additional [WCNSFVFluidHeatTransferPhysics.md].
The following input performs this coupling for incompressible flow in a 2D flow channel.
No system parameters are passed, so the equations are solved in a fully coupled manner in the same [nonlinear system](systems/NonlinearSystem.md).


Other advected scalar equations can be solved concurrently with the flow equations using an additional [WCNSFVScalarTransportPhysics.md].
The following input performs this coupling for incompressible flow in a 2D flow channel.
No system parameters are passed, so the equations are solved in a fully coupled manner in the same [nonlinear system](systems/NonlinearSystem.md).


#### Modeling options and implementation details


This physics only supports Rhie-Chow interpolation for the determination
of face velocities in the advection terms. The face interpolation of the
advected quantities (e.g. upwind, average) can be controlled through the
`*_advection_interpolation` physics parameters.


###### Bernoulli pressure jump treatment

Please see [the Bernoulli pressure variable documentation](BernoulliPressureVariable.md) for more information.




### Navier Stokes Fluid Heat Transfer / WCNSFVFluidHeatTransferPhysics


#### Equation

This [Physics](Physics/index.md) object creates the kernels and boundary conditions to solve the advection-diffusion
equation for the fluid temperature.
For free flow in a non-porous media:

\dfrac{\partial \rho h}{\partial t} + \nabla \cdot (\rho h \mathbf{v}) - \nabla \cdot (k_f \nabla T_f) - Q + \alpha (T_f - T_{ambient}) = 0

For flow in a porous medium:

\dfrac{\partial \epsilon \rho h}{\partial t} + \nabla \cdot (\rho h \mathbf{v}_D) - \nabla \cdot (k_f \nabla T_f) - Q + \alpha (T_f - T_{ambient}) = 0

where:

- $h$ is the fluid enthalpy, computed from the specific heat $c_p$
- $\rho$ is the fluid density
- $\epsilon$ is the porosity
- $T_f$ is the fluid temperature
- \mathbf{v} is the advecting velocity (clean flow)
- \mathbf{v}_D is the advecting superficial velocity (porous media flow)
- $kappa_f$ the fluid effective thermal conductivity
- $Q$ is the source term, corresponding to energy deposited directly in the fluid
- $\alpha$ is the ambient convection volumetric heat transfer coefficient
- $T_{ambient}$ is the ambient temperature

The enthalpy is used in lieu of $\rho c_p T$ to be able to model gases with temperature dependent
specific heat.

The kernels created for flow in a non-porous medium are:

- [INSFVEnergyTimeDerivative.md] for the time derivative for incompressible flow a transient solve
- [WCNSFVEnergyTimeDerivative.md] for the time derivative for weakly-compressible flow a transient solve
- [INSFVEnergyAdvection.md] for advection
- [FVDiffusion.md] for diffusion
- [FVCoupledForce.md] for the energy source term
- [PINSFVEnergyAmbientConvection.md] for the volumetric ambient convection term, if present

For flow in a porous medium:

- [PINSFVEnergyTimeDerivative.md] for the time derivative in a transient solve
- [PINSFVEnergyAdvection.md] for energy advection
- [PINSFVEnergyDiffusion.md] for energy diffusion with an isotropic thermal diffusivity
- [PINSFVEnergyAnisotropicDiffusion.md] for energy diffusion with an anisotropic thermal diffusivity
- [FVCoupledForce.md] for the energy source term
- [PINSFVEnergyAmbientConvection.md] for the volumetric ambient convection term, if present

Additional details on porous media flow equations can be found on this [page](navier_stokes/pinsfv.md).

#### Automatically defined variables

The `WCNSFVFluidHeatTransferPhysics` automatically sets up the variables which are
necessary for solving the energy transport equation:

- Fluid temperature:


For the default names of other variables used in this action, visit [this site](include/base/NS.h).


#### Coupling with other Physics

The heat advection equation can be solved concurrently with the flow equations by combining both the [WCNSFVFluidHeatTransferPhysics.md]
and the [WCNSFVFlowPhysics.md].
The following input performs this coupling for incompressible flow in a 2D channel.
No system parameters are passed, so the equations are solved in a fully coupled manner in the same [nonlinear system](systems/NonlinearSystem.md).





### Navier Stokes Scalar Transport / WCNSFVScalarTransportPhysics


#### Equation

This [Physics](Physics/index.md) object creates the kernels and boundary conditions to solve the advection-diffusion-reaction
equation for several scalar quantities advected by the flow.

\dfrac{\partial \phi_i}{\partial t} + \nabla \cdot (\phi_i \mathbf{v}) - \nabla \cdot (k_i \nabla \phi_i) - Q_i - \lambda_i \phi_i = 0

where:

- $\phi_i$ is the i-th scalar quantity
- \mathbf{v} is the advecting velocity
- $k_i$ the i-th scalar diffusivity
- $Q_i$ is the i-th precursor source
- $\lambda_i$ is a reaction coefficient. It should be negative for a loss term

The kernels created are:

- [FVFunctorTimeKernel.md] for the time derivative for a transient solve
- [INSFVScalarFieldAdvection.md] for the scalar advection term
- [FVDiffusion.md] for the scalar diffusion term
- [FVCoupledForce.md] for the reaction terms
- [FVCoupledForce.md] for the source terms

#### Coupling with other Physics

Scalar advection equations can be solved concurrently with the flow equations by combining the [WCNSFVFlowPhysics.md] with the `WCNSFVScalarTransportPhysics`.
The following input performs this coupling for incompressible flow in a 2D channel.
No system parameters are passed, so the equations are solved in a fully coupled manner in the same [nonlinear system](systems/NonlinearSystem.md).





### Navier Stokes Turbulence / WCNSFVTurbulencePhysics


#### Mixing length turbulence model

See the [mixing length theory page](rans_theory.md) for additional information.

If the turbulence model is selected to be the mixing-length model, a field variable representing the mixing length
is computed using the [WallDistanceMixingLengthAux.md].

The turbulent dynamic viscosity is then computed using a [MixingLengthTurbulentViscosityFunctorMaterial.md].
The following kernels are then added:

- [INSFVTurbulentDiffusion.md] to the flow equation if the flow equations are being solved
- [WCNSFVMixingLengthEnergyDiffusion.md] to the fluid energy equation if the fluid energy equation is being solved
- [INSFVMixingLengthScalarDiffusion.md] to the scalar transport equations if the scalar transport is being solved

These kernels are only added if each of these equations are being defined using their respective `Physics`.

#### K-Epsilon turbulence model

The `WCNSFVTurbulencePhysics` can be set to create the k-epsilon two-equation model.

The turbulent viscosity is then computed with:

- a [kEpsilonViscosityAux.md] if [!param](/Physics/NavierStokes/Turbulence/WCNSFVTurbulencePhysics/mu_t_as_aux_variable) is set to true
- a [INSFVkEpsilonViscosityFunctorMaterial.md] otherwise


The k equation is created with:

- a [FVFunctorTimeKernel.md] for the time derivative if simulating a transient
- a [INSFVTurbulentAdvection.md] for the turbulent kinetic energy advection term
- a [INSFVTurbulentDiffusion.md] for the turbulent kinetic energy diffusion term
- a [INSFVTKESourceSink.md] for the turbulent kinetic energy source and dissipation (sink) terms


The epsilon equation is created with:

- a [FVFunctorTimeKernel.md] for the time derivative if simulating a transient
- a [INSFVTurbulentAdvection.md] for the turbulent kinetic energy dissipation rate advection term
- a [INSFVTurbulentDiffusion.md] for the turbulent kinetic energy dissipation rate diffusion term
- a [INSFVTKEDSourceSink.md] for the turbulent kinetic energy dissipation rate source and removal (sink) terms


The boundary conditions are not set in this object for the `TKE` and `TKED` variables, as they
are computed by the wall-functions in the relevant kernels. A boundary condition is set for the turbulent
viscosity when using an auxiliary variable, with a [INSFVTurbulentViscosityWallFunction.md].


#### Coupling with other Physics

A turbulence model can be added to a heat advection solve by using both a `WCNSFVTurbulencePhysics` and a [WCNSFVFluidHeatTransferPhysics.md].
The following input performs this coupling for weakly compressible flow for the mixing length turbulence model in a 2D channel.
No system parameters are passed, so the equations are solved in a fully coupled manner in the same [nonlinear system](systems/NonlinearSystem.md).


A turbulence model can be added to a scalar advection solve by using both a `WCNSFVTurbulencePhysics` and a [WCNSFVScalarTransportPhysics.md].
The following input performs this coupling for incompressible flow for the mixing length turbulence model in a 2D channel.
No system parameters are passed, so the equations are solved in a fully coupled manner in the same [nonlinear system](systems/NonlinearSystem.md).





### Navier Stokes Two Phase Mixtures / WCNSFVTwoPhaseMixturePhysics


#### Equation(s)

This [Physics](Physics/index.md) adds terms to the flow and energy equations to account for the presence of a
two-phase mixture. If specified with the [!param](/Physics/NavierStokes/TwoPhaseMixture/WCNSFVTwoPhaseMixturePhysics/add_phase_transport_equation)
parameter, it can also solve for the advection-diffusion equation of a moving phase fraction.

If the other phase is solid, the [!param](/Physics/NavierStokes/TwoPhaseMixture/WCNSFVTwoPhaseMixturePhysics/add_phase_transport_equation)
parameter should be set to false.

The phase advection-diffusion equation is:

\dfrac{\partial \phi}{\partial t} + \nabla \cdot (\phi \mathbf{v}) - \nabla \cdot (k \nabla \phi) -\alpha \phi = 0

where:

- $\phi$ is the phase fraction
- $\mathbf{v}$ is the advecting velocity
- $k$ the phase diffusivity
- $\alpha$ is the phase exchange coefficient

The kernels created are:

- [FVFunctorTimeKernel.md] for the time derivative for a transient solve
- [INSFVScalarFieldAdvection.md] for the scalar advection term
- [FVDiffusion.md] for the scalar diffusion term
- [NSFVMixturePhaseInterface.md] for the phase exchange term if a phase exchange coefficient is specified

The momentum equations, if defined using a [WCNSFVFlowPhysics.md], are modified in the presence of a two-phase
mixture. Density and viscosity should be set to their mixture values, see [#materials] for more information.
If specified with the [!param](/Physics/NavierStokes/TwoPhaseMixture/WCNSFVTwoPhaseMixturePhysics/add_drift_flux_momentum_terms) parameter,
a drift flux term is added to the momentum equations with the [WCNSFV2PMomentumDriftFlux.md] kernels. If specified with the [!param](/Physics/NavierStokes/TwoPhaseMixture/WCNSFVTwoPhaseMixturePhysics/add_advection_slip_term) parameter,
an advection slip term is added to the momentum equations with the [WCNSFV2PMomentumAdvectionSlip.md] kernels.

The fluid energy equation, if defined using a [WCNSFVFluidHeatTransferPhysics.md], is modified in the presence of
a two-phase mixture. If specified with the
[!param](/Physics/NavierStokes/TwoPhaseMixture/WCNSFVTwoPhaseMixturePhysics/add_phase_change_energy_term) parameter,
a phase change source term is added to the fluid phase energy equation with the [NSFVPhaseChangeSource.md] kernel.

#### Mixture fluid properties id=materials

The fluid properties of mixture fluids depend on the phase fraction of each phase.
For two-phases, the properties can currently be computed with a [NSFVMixtureFunctorMaterial.md].
This material is defined by default by the `WCNSFVTwoPhaseMixturePhysics` unless the
[!param](/Physics/NavierStokes/TwoPhaseMixture/WCNSFVTwoPhaseMixturePhysics/use_external_mixture_properties)
is set to true.

The gas mixture models defined in the fluid properties module cannot currently be used by this physics
without additional development.




### Navier Stokes Flow / WCNSLinearFVFlowPhysics


#### Equations

This [Physics](Physics/index.md) object creates the kernels and boundary conditions to solve the Navier Stokes equations for the flow
using the [SIMPLE.md] algorithm.
For regular flow in a non-porous medium:

\nabla \cdot \rho \vec{v} = 0

\nabla \cdot (\rho \mathbf{v} \otimes \mathbf{v}) = \nabla \cdot \left(\mu \left[\nabla \mathbf{v}+\nabla \mathbf{v}^T\right]\right) - \nabla p + \mathbf{F}_g

where:

- $\rho$ is the density
- $\mu$ is the dynamic viscosity
- $\mathbf{v}$ is the velocity (non-porous flow)
- $p$ is the pressure
- $\mathbf{F}_g$ is the gravitational force

The kernels created for the momentum equation for free flow:

- [LinearWCNSFVMomentumFlux.md] for the momentum advection and diffusion terms
- [LinearFVMomentumPressure.md] for the pressure gradient term
- [LinearFVSource.md] for the gravity term if specified


The kernels created for free flow for the pressure correction equation:

- [LinearFVAnisotropicDiffusion.md] for the pressure diffusion term
- [LinearFVDivergence.md] for the divergence of $A^{-1}H$. For more information, see [SIMPLE.md].


#### Automatically defined variables

The `WCNSLinearFVFlowPhysics` automatically sets up the variables which are
necessary for the solution of a given problem. These variables can then be used
to couple fluid flow simulations with other physics. The list of variable names
commonly used in the action syntax is presented below:

- Velocities for non-porous-medium simulations:


- Pressure:


For the default names of other variables used in this action, visit [this site](include/base/NS.h).


#### Coupling with other Physics

Coupling with other Physics has not been implemented for `WCNSLinearFVFlowPhysics`.
Coupling can only be performed at the moment by leveraging [MultiApps](syntax/MultiApps/index.md).




### Navier Stokes Fluid Heat Transfer / WCNSLinearFVFluidHeatTransferPhysics


#### Equation

This [Physics](Physics/index.md) object creates the kernels and boundary conditions to solve the advection-diffusion
equation for the fluid temperature.
For free flow in a non-porous media:

\dfrac{\partial \rho h}{\partial t} + \nabla \cdot (\rho h \mathbf{v}) - \nabla \cdot (k_f \nabla T_f) - Q + \alpha (T_f - T_{ambient}) = 0

Porous medium treatment is not implemented for the linear finite volume discretization yet.

where:

- $h$ is the fluid specific enthalpy
- $\rho$ is the fluid density
- $T_f$ is the fluid temperature
- \mathbf{v} is the advecting velocity (clean flow)
- $kappa_f$ the fluid effective thermal conductivity
- $Q$ is the source term, corresponding to energy deposited directly in the fluid
- $\alpha$ is the ambient convection volumetric heat transfer coefficient
- $T_{ambient}$ is the ambient temperature

The kernels created for flow in a non-porous medium are:

- [LinearFVEnergyAdvection.md] for advection
- [LinearFVDiffusion.md] for diffusion
- [LinearFVSource.md] for the energy source term
- [LinearFVVolumetricHeatTransfer.md] for the volumetric ambient convection term, if present


#### Automatically defined variables

The `WCNSLinearFVFluidHeatTransferPhysics` automatically sets up the variables which are
necessary for solving the energy transport equation:

- Fluid temperature:


For the default names of other variables used in this action, visit [this site](include/base/NS.h).

#### Automatically defined functors / materials

The following functor materials are defined:

- [INSFVEnthalpyFunctorMaterial.md] to define functors to compute the specific enthalpy and its time derivative


#### Coupling with other Physics

The enthalpy advection equation can be solved concurrently with the flow equations by combining both the `WCNSLinearFVFluidHeatTransferPhysics`
and the [WCNSLinearFVFlowPhysics.md] using the [!param](/Physics/NavierStokes/FluidHeatTransferSegregated/WCNSLinearFVFluidHeatTransferPhysics/coupled_flow_physics) parameter.




### Navier Stokes Linear Scalar Transport / WCNSLinearFVScalarTransportPhysics


#### Equation

This [Physics](Physics/index.md) object creates the kernels and boundary conditions to solve the advection-diffusion-reaction
equation for several scalar quantities advected by the flow.

\dfrac{\partial \phi_i}{\partial t} + \nabla \cdot (\phi_i \mathbf{v}) - \nabla \cdot (k_i \nabla \phi_i) - Q_i - \lambda_i \phi_i = 0

where:

- $\phi_i$ is the i-th scalar quantity
- \mathbf{v} is the advecting velocity
- $k_i$ the i-th scalar diffusivity
- $Q_i$ is the i-th scalar source
- $\lambda_i$ is a reaction coefficient. It should be negative for a loss term

The kernels created are:

- [LinearFVScalarAdvection.md] for the scalar advection term
- [LinearFVDiffusion.md] for the scalar diffusion term
- [LinearFVSource.md] for the source terms

Reaction terms can be expressed as source terms by using a negative coefficient in the
[!param](/Physics/NavierStokes/ScalarTransportSegregated/WCNSLinearFVScalarTransportPhysics/passive_scalar_coupled_source_coeff)
parameter, and the scalar variable as one of the
[!param](/Physics/NavierStokes/ScalarTransportSegregated/WCNSLinearFVScalarTransportPhysics/passive_scalar_coupled_source)(s).

#### Coupling with other Physics

Scalar advection equations can be solved concurrently with the flow equations by combining the [WCNSLinearFVFlowPhysics.md] with the `WCNSLinearFVScalarTransportPhysics`.
The following input performs this coupling for incompressible flow in a 2D channel.





## postprocessors

### CFLTimeStepSize


#### Overview

This object computes the timestep necessary to satisfy a
[CFL number](https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition)
specified by the `CFL` parameter. The default value for `CFL` is $0.5$. The
timestep is computed as the global minimum of

\begin{equation}
dt = \frac{\text{CFL}\ h_{min}}{a_k + c_k}
\end{equation}

where $h_{min}$ is the minimum element side length, $a_k$ is the fluid speed for
the $k\text{-th}$ phase and $c_k$ is the speed of sound in the $k\text{-th}$
phase.




### INSElementIntegralEnergyAdvection


This class performs volumetric (global, or by block) integration of the energy advection term defined in
[INSADEnergyAdvection.md], which is defined by

\begin{equation}
\rho c_p \vec u \cdot \nabla T
\end{equation}

where $\rho$ is the density, $c_p$ is the
specific heat capacity,
$\vec u$ is the velocity, and $\nabla T$ is the temperature gradient. AD
instantiations of this object are denoted by
`INSADElementIntegralEnergyAdvection`, hand-coded by
`INSElementIntegralEnergyAdvection`. The former retrieves the density and
specific heat capacity as `ADReal` material properties while the former
retrieves the same properties as `Real`.

This class performs volumetric integration (element-based as opposed to
side-based) of the advection term because the incompressibility constraint is
applied to the energy advection term and the term is not integrated by
parts. Details about the finite element implementation of the energy advection
term can be found on the [INSADEnergyAdvection.md] page.

#### Example input syntax

The `INSADElementIntegralEnergyAdvection` instance is used in a global energy
balance calculation in


for Q2Q1 elements, e.g. second order velocity and temperature and first order
pressure on `QUAD9` elements and in


for Q1Q1 elements, e.g. fist order velocity, pressure, and temperature on
`QUAD4` elements.




### INSExplicitTimestepSelector





### IntegralDirectedSurfaceForce


#### Explanation

This postprocessor which computes the directed force coming from friction and pressure
differences on a surface defined as:

F_d = \int\limits_S (\sigma \vec{n}) \cdot \vec{d} ~dS

where $\sigma$ is the Cauchy stress tensor. One can use this in combination with other postprocessors
to compute representative drag and lift coefficients.

#### Example input syntax

In this case, the lift and drag coefficients are computed on the surface of a cylinder.





### MassFluxWeightedFlowRate


#### Explanation

This postprocessor computes:

\frac{\int_{\partial \Omega} \vec{v} \cdot \vec{n} \rho f ds }
{\int_{\partial \Omega} \vec{v} \cdot \vec{n} \rho ds},

where $f$ is the advected quantity, $\partial \Omega$ is the boundary
we integrate over, $\vec{v}$ is the fluid velocity, $\rho$ is density,
and $\vec{n}$ is the face normal.

#### Example input syntax

In this example, the mass-flow rate weighted average of temperature
is computed over the right outflow and one interior face. This temperature
should be $500$ K above the inlet temperature.

The `mfr-weighted-T-out` and `mfr-weighted-T-interior` satisfy this condition
when the problem is run to steady-state. However `outlet-temp` does not, because
it is a simple side average and does not take into account differences of
$\rho \vec{v}$ over the face.





### MfrPostprocessor


#### Overview

This object is a receptor for boundary mass flow rates computed in advection
boundary condition objects like [PCNSFVStrongBC.md]. As long as the
`mfr_postprocessor` parameter is set in objects like [PCNSFVStrongBC.md] this
object will do the right thing, e.g. the boundary condition object will set the
mass flow rate on a per-`FaceInfo` basis and then this object will perform the
aggregation process over processes and threads.




### NSEntropyError





### PressureDrop


The convention used is that if the pressure is decreasing from the upstream to downstream boundaries,
then the pressure drop is positive.

If using mesh refinement, and if the upstream and downstream boundary are touching, the boundary between the
two may not lie within a refined element, on a node inside a refined side.

#### Using a weighting functor on local pressures

The weighting functor, a vector, is dotted with the normal of the boundary and can help compute more
representative pressure drops for the cases of non-constant
pressure profiles across a boundary or for handling multiple upstream/downstream boundaries.
This is effectively a weighting flux, which should usually be set to a momentum functor so
that the effective weighting factor is the local mass flux.

\begin{equation}
\begin{split}
P_{upstream} &= \dfrac{\int_{\delta \Omega} P(x,y,z) \vec{W}(x,y,z) \cdot \vec{n} }{ \int_{\delta \Omega} \vec{W}(x,y,z) \cdot \vec{n} } \\
P_{downstream} &= \ ... \\
P_{drop} &= P_{upstream} - P_{downstream}
\end{split}
\end{equation}

where $\delta \Omega$ is the boundary (upstream or downstream) of interest for each pressure evaluation,
$P$ is the local pressure (on the element side on the boundary for finite volume variables), $\vec{W}$ is
the vector weighting functor and $\vec{n}$ is the local element side normal.

#### Example input syntax

In this example, we measure the pressure drop between the inlet and outlet of a flow channel,
as well as between the inlet and a midsection.





### RayleighNumber


The Rayleigh number is computed as:

Ra = \dfrac{\Delta \rho l^3 g}{\mu k} = \dfrac{\rho \beta \Delta T l^3 g}{\mu k}

where:

- $\Delta \rho$ is the density difference between the warm and cool region
- $\Delta T$ is the temperature difference between the warm and cool region
- $\beta$ is the fluid expansion coefficient
- $l$ is the size of the system in the direction of the temperature difference
- $g$ is the magnitude of the gravity
- $\mu$ is the dynamic viscosity of the fluid
- $k$ is the thermal diffusivity of the fluid


The density difference may be provided either directly or using the fluid expansion coefficient
and the temperature difference.
All quantities but gravity may be provided as postprocessors.




### VolumetricFlowRate


#### Example input syntax

In this example, we measure:

- the mass flow rate
- the momentum flow rate
- the enthalpy flow rate

with numerous `VolumetricFlowRate` postprocessors to prove the conservation of mass, momentum and energy
of the finite volume discretization of the incompressible Navier Stokes equations.





## problems

### NavierStokesProblem

The `NavierStokesProblem` solves the saddle point incompressible Navier-Stokes
equations using Schur complement field split preconditioning. It focuses on the
Least Squares Commutator (LSC) preconditioner, also known as the BFBt
preconditioner, developed by Elman in [!citep](elman1999preconditioning) and
[!citep](elman2006block). The PETSc manual page on the LSC preconditioner can be
found [here](https://petsc.org/release/manualpages/PC/PCLSC/).

A linearized version of the incompressible Navier-Stokes equations discretized
with stable finite element pairings may be written as:

\begin{equation}
\begin{bmatrix}
A & B^T\\
B & 0
\end{bmatrix}
\begin{bmatrix}
u\\
p
\end{bmatrix}
=
\begin{bmatrix}
f\\
0
\end{bmatrix}
\end{equation}

where $u$ denotes velocity degrees of freedom, $p$ denotes pressure degrees of
freedom, and $f$ denotes the effect of body forces not dependent on the
velocity/pressure degrees of freedom (e.g. gravity). The LSC preconditioner
proposed by Elman approximates the Schur complement inverse via

\begin{equation}
\hat{S}^{-1} := (B\hat{M}_u^{-1}B^T)^{-1}B\hat{M}_u^{-1}A\hat{M}_u^{-1}B_T(B\hat{M}_u^{-1}B_T)^{-1}
\end{equation}

where $\hat{M}_u$ is a diagonal approximation of the velocity mass matrix. In
the case of continuous pressure elements (per [!citep](olshanskii2007pressure)),
the above can be re-written as

\begin{equation}
\hat{S}^{-1} := L_p^{-1}B\hat{M}_u^{-1}A\hat{M}_u^{-1}B^TL_p^{-1}
\end{equation}

where $L_p$ represents a Poisson-like operator with dimension corresponding to
the number of pressure degrees of freedom, hence the $p$ subscript. PETSc has
full support for LSC preconditioning. The PETSc user may optionally provide two
"auxiliary" matrices for LSC preconditioning, corresponding to $L_p$ and
$\hat{M}_u$, which correspond to the `NavierStokesProblem` parameters
[!param](/Problem/NavierStokesProblem/L_matrix) and
[!param](/Problem/NavierStokesProblem/mass_matrix) respectively. Note that in
order to have $\hat{M}_u^{-1}$ scaling, the PETSc option `-pc_lsc_scale_diag`
must be supplied. If `-pc_lsc_scale_diag` is not provided, then $\hat{M}_u$ is
implicitly the identity vector. If `-pc_lsc_scale_diag` is supplied and
[!param](/Problem/NavierStokesProblem/mass_matrix) is not provided, then
$\hat{M}_u$ will be populated with the diagonal of $A$. If
[!param](/Problem/NavierStokesProblem/L_matrix) is not provided, then it will be
computed automatically via

\begin{equation}
L_p = B\hat{M}_u^{-1}B^T
\end{equation}

[!citep](olshanskii2007pressure) proposed a modification to the LSC preconditioner:

\begin{equation}
\hat{S}^{-1} := \hat{M}_p^{-1}BL_u^{-1}AL_u^{-1}B^T\hat{M}_p^{-1}
\end{equation}

The Olshanskii preconditioner replaces the velocity mass matrix with a pressure
mass matrix ($\hat{M}_u \rightarrow \hat{M}_p$) and a Poisson-like operator of
pressure degree of freedom dimension with a Poisson-like operator of velocity
degree of freedom dimension ($L_p \rightarrow L_u$). The Olshanskii
preconditioning variant can be activated by setting the
[!param](/Problem/NavierStokesProblem/commute_lsc) to `true` and passing the
PETSc option `-pc_lsc_commute`. Note that if the commuted LSC preconditioner has
been requested, then [!param](/Problem/NavierStokesProblem/L_matrix) *must* be
provided since it cannot be formed from system matrix data. Similarly,
[!param](/Problem/NavierStokesProblem/mass_matrix) must also be provided.

A final option available to users is the [!param](/Problem/NavierStokesProblem/use_pressure_mass_matrix) parameter. For Stokes flow (no advective term in the momentum equation) it is known that the pressure mass matrix is spectrally equivalent to the Schur complement, in which case the pressure mass matrix is an ideal choice for forming a preconditioner. If the user sets this option to `true`, then

\begin{equation}
\hat{S}^{-1} := \hat{M}_p^{-1}
\end{equation}

in which case a "standard" preconditioner can be used (e.g. `-pc_type lu`,
`-pc_type hypre -pc_hypre_type boomeramg`, etc.) as opposed to LSC.

#### Which preconditioner to choose

[!citep](zanetti2020scalable) compares the Elman and Olshanskii LSC
preconditioners for "high" Reynolds numbers. The overarching result from that
paper is that Olshanskii is better performing, although the largest kinematic
viscosity explored in that article direclty comparing the two methods is
$10^{-1}$. The Olshanskii preconditioner is known to be sub-optimal for high
viscosities. In the limit of Stokes flow in which the advective term is dropped,
the Schur complement preconditioned with Olshanskii has a condition number that
is the square of the optimally preconditioned (using the pressure mass matrix)
Schur complement, which leads roughly to a doubling in iterations for the Schur
complement solve (see [!citep](olshanskii2007pressure)). Below we compare three
different preconditioning methods for the Schur complement, Elman LSC,
Olshanskii LSC, and direct preconditioning of the Schur complement with the
pressure mass matrix, for three different kinematic viscosities and mesh sizes
for the lid driven cavity with a peak lid velocity of 1 and mesh dimension 1
(consequently the Reynolds number is the reciprocal of the kinematic
viscosity). The values shown in the table are the maximum number of linear
iterations observed during Krylov solves of the Schur complement during
the steady Newton solve.  For this test, the Elman preconditioner outperforms Olshanskii at
high viscosities. However, for low viscosities, Elman shows an iteration count
that scales with the mesh size whereas Olshanskii iteration counts are
independent of the mesh size. This is likely due to the better clustering of
eigenvalues by the Olshanskii preconditioner compared to Elman shown in
[!citep](zanetti2020scalable). Direct preconditioning with the pressure mass
matrix is very effective for high viscosities (as theory predicts), but performs
worse than Olshanskii (and Elman for smaller meshes) for low viscosities. In
summary, we recommend that users use Elman or the pressure mass matrix directly
for high viscosities (low Reynolds numbers) and Olshanskii for low viscosities
(high Reynolds numbers)

Elman:

| $nu$      | n = 20 | n = 40 | n = 80 |
| ---       | ---    | ---    | ---    |
| 100       | 5      | 6      | 8      |
| 1         | 5      | 7      | 8      |
| $10^{-2}$ | 13     | 16     | 22     |

Olshanskii:

| $nu$      | n = 20 | n = 40 | n = 80 |
| ---       | ---    | ---    | ---    |
| 100       | 11     | 12     | 12     |
| 1         | 11     | 12     | 12     |
| $10^{-2}$ | 17     | 18     | 17     |

Pressure

| $nu$      | n = 20 | n = 40 | n = 80 |
| ---       | ---    | ---    | ---    |
| 100       | 6      | 6      | 6      |
| 1         | 6      | 6      | 6      |
| $10^{-2}$ | 21     | 21     | 21     |

The tables above were created by running the `steady_vector_fsp_elman.i`,
`steady_vector_fsp.i`, and `steady_vector_fsp_stokes.i` inputs respectively. To
focus the comparison on the preconditioning of the Schur complement itself, all
multigrid preconditioners were replaced with LU decompositions (`-pc_type lu
-pc_factor_mat_solver_type mumps`). In the `steady_vector_fsp_stokes.i` input,
an [INSADMomentumAdvection.md] kernel was added as well.





## userobjects

### HLLCUserObject


#### Overview

This object computes the HLLC left, middle, and right wave-speeds (see
[CNSFVHLLCBase.md]) from velocity, speed, pressure, density, and specific
internal energy element and neighbor material properties (or left and right
material properties if you want to think of
it that way) on internal faces. These wave speeds can then be used in
objects like [WaveSpeedVPP.md]




### INSADObjectTracker

The `INSADObjectTracker` user object is used to track the kernels added to an
incompressible Navier Stokes (INS) simulation. The object is then queried by
`INSADMaterial` to determine what material properties/strong residuals it needs
to calculate both for the base kernels and potentially for contributions from
PSPG and SUPG stabilization kernels. Creation of this object prevents
duplication of parameters between the kernels themselves and
`INSADMaterial`. For example, in the input file the user used to have to specify
to `INSADMaterial` whether there was a transient term in the
simulation. However, with the addition of `INSADObjectTracker` this input is no
longer required. By simply putting an `INSADMomentumTimeDerivative` object in
the input file, `INSADMaterial` will know to calculate a transient term because
of the `INSADObjectTracker`.




### INSFVRhieChowInterpolator


#### Overview

This object coordinates everything about an incompressible Navier-Stokes finite
volume (INSFV) simulation related to Rhie-Chow. This object performs the
following activities

- Loops through all momentum residual objects and gathers information related to
- $a$ coefficients: these are the coefficients that multiply the
  on-diagonal/current-cell velocity solution in a linearized writing of the
  momentum equation

- Computes the Rhie-Chow velocity according to [rcvel] when requested by
  advection kernels or postprocessors

\begin{equation}
\label{rcvel}
\bm{v}_f = \overline{\bm{v}_f} - \overline{\bm{D}_f}\left(\nabla p_f - \overline{\nabla p_f}\right)
\end{equation}

##### Accessing 'a' coefficient data in nonstandard locations

If you ever come across an error like

```
Attempted access into CellCenteredMapFunctor 'a' with a key that does not yet
exist in the map. Make sure to fill your CellCenteredMapFunctor for all elements
you will attempt to access later.
```

then it means an object you're using in your input file is attempting to access
Rhie-Chow data in unexpected locations. This can potentially be remedied by
setting the parameter `pull_all_nonlocal_a = true`. This will tell all processes
to pull 'a' coefficient data for all elements they have access to (which may not
be all the elements in the mesh if the mesh is distributed) from the processes
that own the 'a' coefficient data.

##### Correcting for non-velocity-dependent volume forces

The standard Rhie-Chow interpolation may introduce oscillatory errors in the velocity
field under block-localized volume forces that do not depend on velocity, e.g., a pump force.

The user can activate the correction for body forces by setting `correct_volumetric_force = true`.
Then, the list of the names of the functors representing the body forces must be defined under
the `volumetric_force_functors` parameter.
Finally, the user can select two possible methods for correcting for volume force under the
`volume_force_correction_method` parameter:

-  `pressure-consistent`, which deactivates the Rhie-Chow correaction on faces in which the pressure
  correction is inconsistent due to the volume forces
-  `force-consistent`, which deactivates the Rhie-Chow correction in the regions with localized
  volume forces since the pressure-velocity system is already linked by the volume force in these regions.

The latter method is the default and is generally preferred due to its lower computational cost.




### INSFVRhieChowInterpolatorSegregated


#### Overview

This object is responsible for generating the following fields for a [SIMPLENonlinearAssembly.md]-type
segregated solver:

- $A^{-1}$ (inverse of the matrix diagonal) which is used as a diffusivity for the pressure equation.
  This field is stored in a cell-based functor, so centroid values are easy to access but
  face values need to be reconstructed.
- $A^{-1}H(u)$ whose divergence is used as a source in the pressure equation. This field is
  stored in a face-based functor, so face values are easy to access, but cell-center values
  need to be reconstructed.

This object operates on the matrices and right hand sides of the linearized momentum equations.




### PINSFVRhieChowInterpolator


#### Overview

This object inherits from [INSFVRhieChowInterpolator.md] and does all the same
operations, but in addition optionally performs successive
interpolation-reconstruction operations on the porosity, which in effect is a
smoothing operation, helping to create monotone behavior near porosity
discontinuities. These interpolation-reconstruction operations are triggered by
setting the `smoothing_layers` parameter. One reconstruction corresponds to one
interpolation to the face and reconstruction back to the center, effectively
increasing the "stencil" of the porosity by one layer per `smoothing_layer`. If
performing smoothing_layers on the porosity, the input porosity functor cannot
be a MOOSE variable or a function of a MOOSE variable, as `smoothing_layers`
would then require algebraic ghosting of the solution vectors.




### PINSFVRhieChowInterpolatorSegregated


#### Overview

Similarly to [INSFVRhieChowInterpolatorSegregated.md], this object is responsible for generating the coupling fields between the momentum and pressure equations in [SIMPLENonlinearAssembly.md].
The main difference between this object and [INSFVRhieChowInterpolatorSegregated.md] is that
this object needs to account for the fact that in the porous medium equations there is a
porosity multiplier on the pressure gradient term in the momentum equation: $-\epsilon \nabla p$.




### RhieChowMassFlux


#### Overview

This object is responsible for generating the following fields for a [SIMPLE.md]-type
segregated solver:

- $A^{-1}$ (inverse of the matrix diagonal) which is used as a diffusivity for the pressure equation.
  This field is stored in a face-based functor, so face values are easy to access but
  cell values need to be reconstructed. This is mainly used in the pressure Poisson equation
  where only face values are queried.
- $A^{-1}H(u)$ whose divergence is used as a source in the pressure Poisson equation.
  This field is also stored in a face-based functor, so face values are easy to access,
  but cell-center values need to be reconstructed.
- $(\rho \vec{u} \vec{n})_{RC}$ which is the Rhie-Chow corrected face mass flux. This is
  also stored in a face-based functor, so face values are easy to access,
  but cell-center values need to be reconstructed.

Besides these capabilities, this user object is also responsible for reconstructing
cell velocities at the end of the pressure corrector step.
For more information on these fields and processes, we suggest visiting [SIMPLE.md].




## variables

### BernoulliPressureVariable

This variable type is specific to the porous media incompressible Navier Stokes
equations. When used instead of a typical finite volume variable, faces for
which the neighboring elements have different porosity values will be treated as
either Dirichlet or extrapolated boundary faces. When this variable is queried for a face value
on the downwind side of the face, only downwind information is used to
extrapolate and reconstruct the downwind side face value. The upwind side face
value is computed using the reconstructed downwind face pressure value and the
Bernoulli equation:

\begin{equation}
p_1 + \frac{1}{2}\rho_1\vec{v}_1^2 = p_2 + \frac{1}{2}\rho_2\vec{v}_2^2
\end{equation}

where $p$ is the pressure, $\rho$ is the density, and $\vec{v}$ is the
interstitial velocity (not the superficial velocity). Bernoulli's equation
typically contains gravitational terms; however, we have omitted them under the
assumption that $\rho_1 = \rho_2$ which should be true when density does not
depend on pressure (the incompressible or "weakly" compressible case).

The decision to use downstream information to compute the upstream pressure value
is based on eigenvalue reasoning for the subsonic Euler equations. For the
subsonic Euler equations, mesh dimension + 1 upstream explicit/physical (as
opposed to implicit) boundary conditions are required while one downstream
explicit/physical boundary condition is required
[!citep](novak2018pronghorn). In practice this often corresponds to mesh
dimension explicit inlet boundary conditions related to velocity, one explicit
inlet boundary condition related to temperature, and one explicit outlet
boundary condition related to pressure. Thus physics-based discretizations of
Euler flows typically (at least partially) upwinds information being advected by
the flow field. However, given the propagation of pressure information upstream
from the explicit outlet pressure boundary condition, we believe it reasonable
to do the same for computing the Bernoulli pressure jump at porosity
discontinuities.


In certain cases multiple porosity jump faces may be connected by cells in a
chain. For example at corners or when porous medium zones are one-cell wide. In such
scenarios, the two-term expansion for the determination of the
face pressure on the downstream side requires a considerably extended stencil which may not be accommodated by the
number of ghosting layers set in the kernels. For this reason, the default value of
[!param](/Variables/BernoulliPressureVariable/allow_two_term_expansion_on_bernoulli_faces)
is `false`. If the user wants to enable two-term expansion for the pressure
computation on the porosity jump faces, special attention should be paid to
moving the porosity jump faces sufficiently far from each other (at least two layers
if skewness correction is disabled and three if it is enabled) or adding
additional layers of ghosted elements (which can potentially increase local computational and memory costs)
using the following `FVKernel` parameter [!param](/FVKernels/FVDiffusion/ghost_layers).






### INSFVEnergyVariable

`INSFVEnergyVariable` is a finite volume variable that
toggles the `two_term_boundary_expansion` to `true` by default. This is the
parameter that determines whether extrapolated boundary face values are
determined from both the boundary cell centroid value and boundary cell centroid
gradient or just the boundary cell centroid value.




### INSFVPressureVariable

`INSFVPressureVariable` is a finite volume variable that
toggles the `two_term_boundary_expansion` to `true` by default. This is the
parameter that determines whether extrapolated boundary face values are
determined from both the boundary cell centroid value and boundary cell centroid
gradient or just the boundary cell centroid value.




### INSFVScalarFieldVariable

`INSFVScalarFieldVariable` is a finite volume variable that
toggles the `two_term_boundary_expansion` to `true` by default. This is the
parameter that determines whether extrapolated boundary face values are
determined from both the boundary cell centroid value and boundary cell centroid
gradient or just the boundary cell centroid value.




### INSFVVelocityVariable

`INSFVVelocityVariable` is a finite volume variable. It overrides the default
computation of cell gradients because it must account for a modified computation
of boundary face values along a fully developed flow boundary. In addition it
toggles the `two_term_boundary_expansion` to `true` by default, which is the
parameter that determines whether extrapolated boundary face values are
determined from both the boundary cell centroid value and boundary cell centroid
gradient or just the boundary cell centroid value.




### PiecewiseConstantVariable

When this type of variable is used instead of a typical finite volume variable, faces for
which the neighboring elements have different cell-center values will be treated as
extrapolated boundary faces. E.g. when this variable is queried for a face value
on the "element" side of the face, the element cell center value will be
returned; when this variable is queried for a face value on the "neighbor" side
of the face, the neighbor cell center value will be returned. This variable type
can be used to ensure that interpolation is not performed between potentially
sharply discontinuous values.




### PINSFVSuperficialVelocityVariable

This variable type is specific to the porous media incompressible Navier Stokes equations.
Kernels for these equations will expect this variable type to be used, because they are
written for superficial velocity non-linear variables.




## vectorpostprocessors

### WaveSpeedVPP


#### Overview

This object takes `elem_id` and `side_id` input parameters and outputs the wave
speeds associated with them. The user has to be careful when using this
object. They should be aware of the following:

- A `FaceInfo` object may not be associated with the given `elem_id` and
  `side_id`. For instance if the `FaceInfo` lives on a face associated with
  `elem_id = 0` and `side_id = 1` on the left and `elem_id = 1` and `side_id = 0`
  on the right, then `FaceInfo` data will only be retrievable for the `elem_id =
  0` and `side_id = 1` pair because `FaceInfo` objects are always associated with
  lower element id. So if in this case a user requested wave speeds for
  `elem_id = 1` and `side_id = 0` no wave speeds would be output.
- Element numbering will be different between replicated and distributed mesh
  modes so even if a user gets the desired output for a given `elem_id` and
  `side_id` pair when running with a replicated mesh, they may not get any output
  when running with a distributed mesh for the reason stated in the above bullet





# MOOSE Optimization Module

## Optimization Code

The MOOSE optimization module provides functionality for solving optimization
problems in moose. It uses the TAO optimization interface from PETSc for solving PDE-constrained optimization problems.

### [Inverse Optimization Theory](theory/InvOptTheory.md) class=center style=font-weight:200;

Learn the theory behind PDE constrained optimization as implemented in the MOOSE optimization module.

### [Syntax](optimization/systems.md) class=center style=font-weight:200;

The MOOSE optimization module provides capabilities that can be applied to a wide variety of problems. The syntax
provides detailed documentation of specific code features.

### [Examples](optimization/examples/index.md) class=center style=font-weight:200;

There are a number of inverse optimization example problems to demonstrate usage of the optimization module. Details of those models are
provided here.

## actions

### AddOptimizationReporterAction

This class sets up the OptimizationReporter input block used to move data between the optimization executioner and the sub-app transfers, please refer to
[OptimizationReporter](/OptimizationReporter/index.md) for more information.

### OptimizationAction

This class defines the behavior of the Optimization input block, please refer to
[syntax/Optimization/index.md] for more information.


## dirackernels

### ReporterTimePointSource


#### Overview

A `ReporterTimePointSource` reads in multiple point sources from a [Reporter](Reporters/index.md) or [VectorPostprocessor](VectorPostprocessors/index.md).  The point source values and coordinates are updated as the values are changed.

For exposition, the data determining the coordinates and values can be represented as a five-column matrix:

\mathbf{S} \equiv
\begin{bmatrix}
x_1 & y_1 & z_1 & t_1 & s_1 \\
x_2 & y_2 & z_2 & t_2 & s_2 \\
\vdots & \vdots & \vdots & \vdots & \vdots \\
x_N & y_N & z_N & t_N & s_N
\end{bmatrix} ,

where $N$ is the number of 4-dimensional coordinates supplied. $x_i$, $y_i$, $z_i$, and $t_i$ are the x, y, z, and time value at coordinate $i$, respectively. And $s_i$ is the source value at coordinate $i$. During the simulation, only the sources where $t_i$ matches the simulation time ($t_{\mathrm{sim}}$) are applied. So at particular $t_{\mathrm{sim}}$ during the simulation the sources being applied can be represented as:

\vec{S}_i(t_{\mathrm{sim}}) = 
\begin{bmatrix}
x_i & y_i & z_i & s_i\delta_{t_i, t_{\mathrm{sim}}}
\end{bmatrix},\quad
i=1,...,N.

For maximum flexibility, the coordinates and values can change during the simulation based on the evaluation of these vectors in the [Reporter](Reporters/index.md) or [VectorPostprocessor](VectorPostprocessors/index.md). As such, $\mathbf{S}$ can depend on time ($\mathbf{S}(t)$). So [!eqref](eq:coord_value) can be represented as:

\vec{S}_i(t_{\mathrm{sim}}) = 
\begin{bmatrix}
x_i(t_{\mathrm{sim}}) & y_i(t_{\mathrm{sim}}) & z_i(t_{\mathrm{sim}}) & s_i(t_{\mathrm{sim}})\delta_{t_i(t_{\mathrm{sim}}), t_{\mathrm{sim}}}
\end{bmatrix},\quad
i=1,...,N(t_{\mathrm{sim}}).

It is important for the `ReporterTimePointSource` to never use a [VectorPostprocessor](VectorPostprocessors/index.md) with [!param](/VectorPostprocessors/PointValueSampler/contains_complete_history)` = true`, as this can modify the ordering of the coordinates and points.

#### Example Input Syntax

An example of a `ReporterTimePointSource` using a [ConstantReporter](/ConstantReporter.md):


This reporter essentially creates:

\mathbf{S} = 
\begin{bmatrix}
x    & y    & z    & t    & s \\
\hline
0.25 & 0.25 & 0.25 & 0.10 & 0.00 \\
0.75 & 0.25 & 0.25 & 0.10 & 1.00 \\
0.25 & 0.75 & 0.25 & 0.10 & 2.00 \\
0.75 & 0.75 & 0.25 & 0.10 & 3.00 \\
0.25 & 0.25 & 0.75 & 0.10 & 4.00 \\
0.75 & 0.25 & 0.75 & 0.10 & 5.00 \\
0.25 & 0.75 & 0.75 & 0.10 & 6.00 \\
0.75 & 0.75 & 0.75 & 0.10 & 7.00 \\
0.25 & 0.25 & 0.25 & 0.20 & 8.00 \\
0.75 & 0.25 & 0.25 & 0.20 & 9.00 \\
0.25 & 0.75 & 0.25 & 0.20 & 10.0 \\
0.75 & 0.75 & 0.25 & 0.20 & 11.0 \\
0.25 & 0.25 & 0.75 & 0.20 & 12.0 \\
0.75 & 0.25 & 0.75 & 0.20 & 13.0 \\
0.25 & 0.75 & 0.75 & 0.20 & 14.0 \\
0.75 & 0.75 & 0.75 & 0.20 & 15.0 \\
0.25 & 0.25 & 0.25 & 0.30 & 16.0 \\
0.75 & 0.25 & 0.25 & 0.30 & 17.0 \\
0.25 & 0.75 & 0.25 & 0.30 & 18.0 \\
0.75 & 0.75 & 0.25 & 0.30 & 19.0 \\
0.25 & 0.25 & 0.75 & 0.30 & 20.0 \\
0.75 & 0.25 & 0.75 & 0.30 & 21.0 \\
0.25 & 0.75 & 0.75 & 0.30 & 22.0 \\
0.75 & 0.75 & 0.75 & 0.30 & 23.0 \\
\end{bmatrix}.

During the simulation, only the values where the time value (fourth column) is applied. So at $t_{\mathrm{sim}}=0.10$ only the first eight rows are applied.




## executioners

### Optimize


#### Overview

This is executioner performs optimization using the [TAO](https://petsc.org/release/docs/manual/tao/) optimization toolkit. The specific algorithm used is specified using the [!param](/Executioner/Optimize/tao_solver) parameter. The options and connection with [TAO algorithms](https://petsc.org/release/docs/manual/tao/#sec-tao-solvers) is shown in [tab:tao_solver]. Additional solver options can be given to the TAO solver using the [!param](/Executioner/Optimize/petsc_options), [!param](/Executioner/Optimize/petsc_options_iname), and [!param](/Executioner/Optimize/petsc_options_value) parameters or from command-line.

| Algorithm | [!param](/Executioner/Optimize/tao_solver) | TAO Option | `tao_type` |
| - | - | - | - |
| Newton Trust Region | `taontr` | [TAONTR](https://petsc.org/release/docs/manualpages/Tao/TAONTR/) | `ntr` |
| Bounded Newton Trust Region | `taobntr` | [TAOBNTR](https://petsc.org/release/docs/manualpages/Tao/TAOBNTR/) | `bntr` |
| Bounded Conjugate Gradient | `taobncg` | [TAOBNCG](https://petsc.org/release/docs/manualpages/Tao/TAOBNCG/) | `bncg` |
| Newton Line Search | `taonls` | [TAONLS](https://petsc.org/release/docs/manualpages/Tao/TAONLS/) | `nls` |
| Bounded Newton Line Search | `taobnls` | [TAOBNLS](https://petsc.org/release/docs/manualpages/Tao/TAOBNLS/) | `bnls` |
| Limited Memory Variable Metric | `taolmvm` | [TAOLMVM](https://petsc.org/release/docs/manualpages/Tao/TAOLMVM/) | `lmvm` |
| Bounded Limited Memory Variable Metric | `taoblmvm` | [TAOBLMVM](https://petsc.org/release/docs/manualpages/Tao/TAOBLMVM/) | `blmvm` |
| Nelder-Mead | `taonm` | [TAONM](https://petsc.org/release/docs/manualpages/Tao/TAONM/) | `nm` |
| Bounded Quasi-Newton Line Search | `taobqnls` | [TAOBQNLS](https://petsc.org/release/docs/manualpages/Tao/TAOBQNLS/) | `bqnls` |
| Orthant-wise Limited Memory | `taoowlqn` | [TAOOWLQN](https://petsc.org/release/docs/manualpages/Tao/TAOOWLQN/) | `taoowlqn` |
| Gradient Projection Conjugate Gradient | `taogpcg` | [TAOGPCG](https://petsc.org/release/docs/manualpages/Tao/TAOGPCG/) | `gpcg` |
| Bundle Method for Regularized Risk Minimization | `taobmrm` | [TAOBMRM](https://petsc.org/release/docs/manualpages/Tao/TAOBMRM/) | `bmrm` |
| Augmented Lagrangian Multiplier Method | `taoalmm` | [TAOALMM](https://petsc.org/release/manualpages/Tao/TAOALMM/) | `almm` |

This executioner relies on a
[OptimizationReporter](OptimizationReporter/index.md) to define the constraints,
bounds, objective, and gradient of the form function. The objective is defined by the
`computeObjective` member in the [OptimizationReporter](OptimizationReporter.h)
class. The gradient is defined by `computeGradient` and the bounds are defined
by `getUpperBounds` and `getLowerBounds`. Whether it is necessary to define each
of these members is based on whether the selected algorithm needs it, see
[Summary of Tao Solvers](https://petsc.org/release/overview/tao_solve_table/)
for more information. The Hessian is computed using a matrix-free method, where
it evaluates the action of the Hessian on the form function parameters (the
values that are being optimized). It does this by evaluating a homogeneous
version of the objective function and subsequently computes the gradient. For
constrained optimization the `taoalmm` algorithm needs to be used. When the
`taoalmm` algorithm is selected the necessary methods for that algorithm are
generated and only in an OptimizationReporter does the user need to provide
the type and number of constraints.

To aid in the computation of the objective, gradient, and Hessian, this executioner includes additional execution flags that MOOSE objects (like [MultiApps](MultiApps/index.md)) can be evaluated on. Having `execute_on = forward` will execute the object(s) just before `computeObjective` is called and `execute_on = adjoint` will execute the object()s just before `computeGradient` is called.  Having `execute_on = homogeneous_forward` will execute the object(s) during the matrix-free Hessian computation, before calling `adjoint` and `computeGradient`.

The form function's parameters are represented as a vector of values and is tied to reporter values within the [OptimizationReporter](OptimizationReporter/index.md).

#### Example Input Syntax

The following performs optimization using th Newton line search algorithm. The additional options set the optimization tolerance to $10^{-5}$, set the max iterations to 10, and set the linear solver type to conjugate gradient with no preconditioning.

         block=Executioner




### SteadyAndAdjoint


#### Overview

This executioner can be used to solve a steady-state forward problem with its adjoint. The forward solve is performed the same way as in [Steady.md], but with the [!param](/Executioner/Steady/solve_type) set to `NEWTON`. This performs the nonlinear iteration in the form:

\mathbf{J}(\mathbf{u}^{i-1}) \delta \mathbf{u}^{i} = \mathbf{R}(\mathbf{u}^{i-1}), i=1,...,I,

where $I$ is the number of iterations it took to converge the problem. The adjoint problem is then defined as:

\mathbf{J}^{\top}(\mathbf{u}^{I})\lambda = -\mathbf{R}_{\lambda},

where $\lambda$ is the adjoint solution, $\mathbf{R}_{\lambda}$ is the residual of the adjoint system with $\lambda\equiv 0$, and $\mathbf{J}^{\top}(\mathbf{u}^{I})$ is the transpose of the forward system's Jacobian evaluated with the converged forward solution. The adjoint system is basically a linearized and homogenized version of the forward problem with it's own definition of sources.

In order to accurately define the adjoint system, the fully consistent Jacobian must be evaluated. As such, the `computeQpJacobian` routines in the forward problem kernels must be accurately defined or [automatic_differentiation/index.md] must be used. Consider using the [Jacobian debugger](analyze_jacobian.md) to ensure the Jacobian is computed accurately.

#### Example Input File Syntax

##### Solving Adjoint Problems

The first step is to add an adjoint nonlinear system using the [!param](/Problem/FEProblem/nl_sys_names) parameter in the [Problem](Problem/index.md) input block. It is convenient to define the forward system as `nl0`.


Next we need to add an adjoint variable for each forward variable, which is associated with the `adjoint` system:




Next we add kernels and BCs associated with the forward and adjoint variables. Only source-like kernels should be added to the adjoint variables like [BodyForce.md], [ConstantPointSource.md], or [NeumannBC.md].


For nonlinear, problems one should use `AD` Kernels, BCs, and Materials.


Finally, we will add this executioner and set the forward/adjoint system tags. Note that the tolerance for the adjoint system solve is set solely by linear solver parameters like [!param](/Executioner/SteadyAndAdjoint/l_tol), [!param](/Executioner/SteadyAndAdjoint/l_abs_tol), and [!param](/Executioner/SteadyAndAdjoint/l_max_its).


##### Utilization in Gradient-Based Optimization

Utilizing this executioner for gradient-based optimization is quite powerful since the adjoint used to compute the gradient is automatically assembled with this executioner, given that the forward problem Jacobian can be fully constructed.

To include the source for the adjoint problem, the [ReporterPointSource.md] can be used to add the simulation misfit from the forward solve, which is calculated in [OptimizationData.md].


The gradient can then be computed using an inner-product vector-postprocessor like [ElementOptimizationSourceFunctionInnerProduct.md]. Note that these vector-postprocessors must be executed on `ADJOINT_TIMESTEP_END` which occurs after the adjoint system is solved.


The driving optimize app will thus have only have a single [FullSolveMultiApp.md] which then transfers both the simulation data (for the objective evaluation) and the inner products (for the gradient evaluation).





### TransientAndAdjoint


#### Overview

Similar to [SteadyAndAdjoint.md], this executioner can be used to solve a transient forward problem and it's adjoint. Like it's steady-state counterpart, this executioner has a two-step procedure, whereby performing the full forward transient solve (as in [Transient.md]) then stepping backward through the forward timesteps to solve the adjoint problem. To give context on what a transient adjoint looks like, let's start with the general time-dependent partial differential equation (PDE):

c(\vec{r}, t, u)\frac{\partial u(\vec{r}, t)}{\partial t} + R^{\mathrm{ss}}(u(\vec{r}, t)) = q(\vec{r}, t),

u(\vec{r}, t = 0) = u_0(\vec{r}),

\vec{r}\in \Omega, \quad t\in [0, t_N],

where $c$ is a nonlinear coefficient on the time derivative, $R^{\mathrm{ss}}$ is the parts of the PDE that do not contain a time-derivative, and $q$ is some time-space-dependent source.
The first step in formulating an adjoint for this system is to linearize it around $u(t)$.
Generally, this can be given in operator notation as:

\mathbf{M}(\mathbf{u}(t))\dot{\mathbf{u}}(t) + \mathbf{K}(\mathbf{u}(t))\mathbf{u}(t) = \mathbf{q}(t).

Using [ImplicitEuler.md] time integration, a given time step's ($n$) solve resembles:

\frac{1}{\Delta t_n}\mathbf{M}(\mathbf{u}_n)\mathbf{u}_n + \mathbf{K}(\mathbf{u}_n)\mathbf{u}_n = \mathbf{q}_n + \frac{1}{\Delta t_n}\mathbf{M}(\mathbf{u}_n)\mathbf{u}_{n-1}, \quad n=1,...,N.

This system can be represented by a large system for all time steps:

\begin{bmatrix}
\mathbf{1}       &                  &                  &                    &                  \\
\mathbf{A_{1,0}} & \mathbf{A_{1,1}} &                  &                    &                  \\
                 & \mathbf{A_{2,1}} & \mathbf{A_{2,2}} &                    &                  \\
                 &                  & \ddots           & \ddots             &                  \\
                 &                  &                  & \mathbf{A_{N-1,N}} & \mathbf{A_{N,N}} \\
\end{bmatrix}
\begin{bmatrix}
\mathbf{u}_0 \\
\mathbf{u}_1 \\
\mathbf{u}_2 \\
\vdots \\
\mathbf{u}_N \\
\end{bmatrix}
=
\begin{bmatrix}
\mathbf{u}_0 \\
\mathbf{q}_1 \\
\mathbf{q}_2 \\
\vdots \\
\mathbf{q}_N \\
\end{bmatrix}
,

where,

\mathbf{A_{n,n}} \equiv \frac{1}{\Delta t_n}\mathbf{M}(\mathbf{u}_n) + \mathbf{K}(\mathbf{u}_n) \quad \text{and} \quad \mathbf{A_{n,n-1}} \equiv \frac{1}{\Delta t_n}\mathbf{M}(\mathbf{u}_n)

The adjoint equation is then the transpose of this operator, with its own source ($q_\lambda(\vec{r},t)$):

\begin{bmatrix}
\mathbf{A_{1,1}}^{\top} & \mathbf{A_{2,1}}^{\top} &                         &                             &                           \\
                        & \mathbf{A_{2,2}}^{\top} & \mathbf{A_{3,2}}^{\top} &                             &                           \\
                        &                         & \ddots                  & \ddots                      &                           \\
                        &                         &                         & \mathbf{A_{N-1,N-1}}^{\top} & \mathbf{A_{N,N-1}}^{\top} \\
                        &                         &                         &                             & \mathbf{A_{N,N}}^{\top}   \\
\end{bmatrix}
\begin{bmatrix}
\mathbf{\lambda}_1 \\
\mathbf{\lambda}_2 \\
\vdots \\
\mathbf{\lambda}_{N-1} \\
\mathbf{\lambda}_N \\
\end{bmatrix}
=
\begin{bmatrix}
\mathbf{q_\lambda}_1 \\
\mathbf{q_\lambda}_2 \\
\vdots \\
\mathbf{q_\lambda}_{N-1} \\
\mathbf{q_\lambda}_N \\
\end{bmatrix}
.

To solve this system, the adjoint problem is solved backward in time:

\left( \frac{1}{\Delta t_n}\mathbf{M}(\mathbf{u}_n) + \mathbf{K}(\mathbf{u}_n) \right)^{\top}\mathbf{\lambda}_n = \mathbf{q_\lambda}_n + \frac{1}{\Delta t_{n+1}}\mathbf{M}^{\top}(\mathbf{u}_{n+1})\lambda_{n+1}, \quad n=N,...,1,

with $\lambda_{N+1} \equiv \mathbf{0}$.

#### Executioner Algorithm

[!state text=Set forward initial condition: $\mathbf{u}_0$]
[!state text=Execute user-objects, auxiliary kernels, and multi-apps on `INITIAL`]
[!state text=Cache forward solution and time: $\mathbf{u}_0$, $t_0$]
[!for!begin condition=$n\leftarrow 1,..,N$]
[!state text=Execute user-objects, auxiliary kernels, and multi-apps on `TIMESTEP_BEGIN`]
[!state text=Solve forward time step: $\mathbf{u}_n \leftarrow \mathbf{A_{n,n}}^{-1}\left(\mathbf{q}_n + \mathbf{A_{n,n-1}}\mathbf{u}_{n-1}\right)$]
[!state text=Execute user-objects, auxiliary kernels, and multi-apps on `TIMESTEP_END`]
[!state text=Cache forward solution and time: $\mathbf{u}_n$, $t_n$]
[!for!end]
[!state text=Execute user-objects, auxiliary kernels, and multi-apps on `FINAL`]
[!state text=Set previous time residual: $\mathbf{R^{\mathrm{old}}}\leftarrow 0$]
[!for!begin condition=$n\leftarrow N,..,1$]
[!state text=Set forward solution: $\mathbf{u}_n$]
[!state text=Execute user-objects, auxiliary kernels, and multi-apps on `ADJOINT_TIMESTEP_BEGIN`]
[!state text=Compute forward Jacobian: $\mathbf{A_{n,n}}$]
[!state text=Compute adjoint source: $\mathbf{q_\lambda}_n$]
[!state text=Solve adjoint system: $\mathbf{\lambda}_n \leftarrow \left(\mathbf{A_{n,n}}^{\top}\right)^{-1}\left(\mathbf{q_\lambda}_n + R^{\mathrm{old}}\right)$]
[!state text=Execute user-objects, auxiliary kernels, and multi-apps on `ADJOINT_TIMESTEP_END`]
[!state text=Evaluate time residual: $\mathbf{R^{\mathrm{old}}}\leftarrow \frac{1}{\Delta t_n}\mathbf{M}^{\top}(\mathbf{u}_n)\mathbf{\lambda}_n$]
[!for!end]

#### Limitations of Adjoint Solve

1. The adjoint solver only supports a consistent adjoint with [ImplicitEuler.md] time integration.
1. Saving the forward solution at every time step can be extremely memory intensive, so there may be limitations on the number of timesteps of the forward problem based on system memory.
1. [Exodus.md] cannot output the resulting adjoint solution. [CSV.md] and [JSONOutput.md] work as expected.

#### Example Input File Syntax

The input syntax for this executioner is identical to [SteadyAndAdjoint.md]. One key difference is the way the adjoint solution is outputted. Currently, [Exodus.md] does not support the backward time-stepping of the adjoint solve, but [CSV.md] can be outputted with two separate output objects. Furthermore, in order to see a table of postprocessors during the adjoint solve, the [!param](/Outputs/Console/execute_on) parameter must be modified in the [Console.md] output:





## functions

### NearestReporterCoordinatesFunction


#### Overview

This function computes values based on coordinate and time data. This data comes in the form of vector reporter or vectorpostprocessor values. The required parameter [!param](/Functions/NearestReporterCoordinatesFunction/value_name) is the name of the vector containing the values used to set the variable to. [!param](/Functions/NearestReporterCoordinatesFunction/x_coord_name)/[!param](/Functions/NearestReporterCoordinatesFunction/y_coord_name)/[!param](/Functions/NearestReporterCoordinatesFunction/z_coord_name) are vectors with the x-/y-/z-coordinate data. The auxkernel will set the variable's nodal/elemental values based on the nearest point in this data. [!param](/Functions/NearestReporterCoordinatesFunction/time_name) is the name of the time data; the kernel will linearly interpolate between two closest times for a certain coordinate, without extrapolating. [!param](/Functions/NearestReporterCoordinatesFunction/x_coord_name), [!param](/Functions/NearestReporterCoordinatesFunction/y_coord_name), [!param](/Functions/NearestReporterCoordinatesFunction/z_coord_name), and [!param](/Functions/NearestReporterCoordinatesFunction/time_name) will assume to be 0 when not specified. When specified, [!param](/Functions/NearestReporterCoordinatesFunction/x_coord_name), [!param](/Functions/NearestReporterCoordinatesFunction/y_coord_name), [!param](/Functions/NearestReporterCoordinatesFunction/z_coord_name), and [!param](/Functions/NearestReporterCoordinatesFunction/time_name) must all be the same length as [!param](/Functions/NearestReporterCoordinatesFunction/value_name).

#### Example Input File Syntax

Here are several examples of different combinations where x, y, z, and time data is specified:


Run this test to see how the function interpolates the data between specified times.




### ParameterMeshFunction


#### Overview

This function is similar to [NearestReporterCoordinatesFunction.md], except it uses an inputted exodus mesh ([!param](/Functions/ParameterMeshFunction/exodus_mesh)) to represent the parameter field and uses finite-element shape functions (defined with [!param](/Functions/ParameterMeshFunction/family) and [!param](/Functions/ParameterMeshFunction/order)) to perform spatial interpolation. This function also interpolates in time using [!param](/Functions/ParameterMeshFunction/time_name), which can be a [vector-postprocessor](VectorPostprocessors/index.md) or a vector [reporter](Reporters/index.md). The parameter data is specified using [!param](/Functions/ParameterMeshFunction/parameter_name), which can be a [vector-postprocessor](VectorPostprocessors/index.md) or a vector [reporter](Reporters/index.md). [!ref](tab:fe_types) shows common interpolation types for the parameters.

| Interpolation Type | Family | Order |
| :- | - | - |
| Piecewise constant | `MONOMIAL` | `CONSTANT` |
| Linear | `LAGRANGE` | `FIRST` |
| Quadratic | `LAGRANGE` | `SECOND` |

The mesh created +must+ be replicated. Ensure this by having `Mesh/parallel_type=REPLICATED` when creating the mesh.

#### Example Input File Syntax

First step is to define a mesh for the parameters, which is most easily done by creating a separate input file. The following creates a two-by-two mesh and sets an auxiliary variable to $x(x-1)y(y-1)$, which is then outputted using [NodalValueSampler.md].


Running this input will create a `create_mesh_out.e` exodus file and `create_mesh_out_param_vec_0001.csv` CSV file. The CSV file is read by a [CSVReaderVectorPostprocessor.md] to create a vector-postprocessor of the parameter data. A ParameterMeshFunction then reads in the exodus file and retrieves the vector for the interpolation.





### ParsedOptimizationFunction


#### Overview

This function is similar to [MooseParsedFunction.md] except it has some dedicated routines relevant to optimization, particularly the ability to differentiate the function with respect to parameters. The [!param](/Functions/ParsedOptimizationFunction/expression) parameter indicates the function expression. Users may specify `x`, `y`, `z`, and `t` for space-time dependence. They may also define variables with constant values in the expression by specifying [!param](/Functions/ParsedOptimizationFunction/constant_symbol_names) and [!param](/Functions/ParsedOptimizationFunction/constant_symbol_values) pairs. Finally, parameter variables can be specified which correspond to the definitions in [!param](/Functions/ParsedOptimizationFunction/param_symbol_names). The values of these parameter variables are evaluated from the inputted vector in [!param](/Functions/ParsedOptimizationFunction/param_vector_name). The vector specified in [!param](/Functions/ParsedOptimizationFunction/param_vector_name) can either be a [vector-postprocessor](VectorPostprocessors/index.md) vector or a vector [reporter](Reporters/index.md) value. An error will occur if the length of this vector does not match the number of values specified in [!param](/Functions/ParsedOptimizationFunction/param_symbol_names).

#### Example Input File Syntax

Here is an example where the parsed function represents the following expression:

f(x,y,z,t; \vec{v}) = xv_1 + yv_2^2 + zv_3^3 + tv_4^4


`params/vals` is the name of a vector reporter value, define as:





## materials

### CostSensitivity


#### Overview

This material takes a [`DerivativeParsedMaterial`](/DerivativeParsedMaterial.md) and uses its
derivative with respect to a variable. Such a variable can be a pseudo-density which is
employed to solve a solid isotropic material penalization (SIMP) topology optimization
problem.

#### Example Input File Syntax

This material can be used to optimize a multimaterial topology problem, in which the
constraints are not only based on volume but also on an additional cost function.





### MisfitReporterOffsetFunctionMaterial


#### Overview

The `MisfitReporterOffsetFunctionMaterial` material computes the misfit and its gradient with respect to a simulation variable , using a user-defined offset function to weight the contribution of measurement points. This material is particularly useful for inverse optimization problems where you want to match simulation results to experimental or observed data.  The material name given to the misfit is [!param](/Materials/MisfitReporterOffsetFunctionMaterial/property_name) and the misfit gradient material uses the naming convention [!param](/Materials/MisfitReporterOffsetFunctionMaterial/property_name)+`_gradient`.

##### Measurement data:

Measurement values are provide by the reporter [!param](/Materials/MisfitReporterOffsetFunctionMaterial/measurement_value_name) and the corresponding measurement locations are given by a reporter containing either a vector of points [!param](/Materials/MisfitReporterOffsetFunctionMaterial/point_name) or three separate reporters each containing the x, y and z coordinates respectively of the points using [!param](/Materials/MisfitReporterOffsetFunctionMaterial/x_coord_name), [!param](/Materials/MisfitReporterOffsetFunctionMaterial/y_coord_name), and [!param](/Materials/MisfitReporterOffsetFunctionMaterial/z_coord_name).

- Measurement values: $\mathbf{u}_m = \{u_{m,1}, u_{m,2}, \ldots, u_{m,n}\}$
- Measurement locations: $\mathbf{p}_m = \{\mathbf{p}_{m,1}, \mathbf{p}_{m,2}, \ldots, \mathbf{p}_{m,n}\}$, where $\mathbf{p}_{m,i} = (x_{m,i}, y_{m,i}, z_{m,i})$ for 3D data
- Simulation variable: $u(\mathbf{x})$
- Offset function: $g(\mathbf{p}, \mathbf{x}; \mathbf{\theta})$, where $\mathbf{\theta}$ are the parameters defining the offset function
- Simulation point: $\mathbf{x}$

##### Misfit and gradient calculation:

The `misfit` at a given simulation point $\mathbf{x}$ is calculated as:

$m(\mathbf{x}) = \sum_{i=1}^{n} \left( u_{m,i} g(\mathbf{p}_{m,i}, \mathbf{x}; \mathbf{\theta}) - u(\mathbf{x}) g(\mathbf{p}_{m,i}, \mathbf{x}; \mathbf{\theta}) \right)^2,$

and the `misfit_gradient` with respect to the simulation variable $u(\mathbf{x})$ is:

$\frac{\partial m(\mathbf{x})}{\partial u(\mathbf{x})} = -2 \sum_{i=1}^{n} g(\mathbf{p}_{m,i}, \mathbf{x}; \mathbf{\theta}) \left( u_{m,i} g(\mathbf{p}_{m,i}, \mathbf{x}; \mathbf{\theta}) - u(\mathbf{x}) g(\mathbf{p}_{m,i}, \mathbf{x}; \mathbf{\theta}) \right).$

These equations represent the misfit value and its gradient computed by the `MisfitReporterOffsetFunctionMaterial` material at each quadrature point in the simulation. The misfit value quantifies the discrepancy between the measured data and the simulation variable, while the misfit gradient provides the sensitivity of the misfit with respect to changes in the simulation variable.

#### Example Input File Syntax

The following input file contains an example of how to use this material to define gaussian shaped measurement points in a heat source inversion problem where the misfit is used in the computation of the objective function and the misfit_gradient is used to compute the right hand side in the adjoint problem.


#### Syntax parameters and inputs




### ReporterOffsetFunctionMaterial


This creates a material that is the sum of a function shifted by a set of points contained in a reporter.  The reporter can contain points by specifying [!param](/Materials/ReporterOffsetFunctionMaterial/point_name) or by three seperate reporters containing the (x,y,z) coordinates of the points using [!param](/Materials/ReporterOffsetFunctionMaterial/x_coord_name), [!param](/Materials/ReporterOffsetFunctionMaterial/y_coord_name), and [!param](/Materials/ReporterOffsetFunctionMaterial/z_coord_name). This can be useful for creating a field containing multiple sources, as shown in [offset] and described in the equation below.


\tilde f(\mathbf{x}) = \sum_{i=1}^{n} \left(f(\mathbf{x} - \mathbf{p}_{offset}) \right)

       id=offset
       caption=Field with multiple offsets of (left) gaussian function and (right) constant circle function.

#### Example Input File Syntax

In this example, `ReporterOffsetFunctionMaterial` is used to define the two materials shown in [offset]. The value at a point is the sum of all the shifted functions.  In this example, the gaussian and constant circle functions are defined at (x,y,z)=(0,0,0), shown by the source in the lower left corner of each domain.  This function is then shifted according to the offset vectors given by the Reporter.





## optimizationreporters

### GeneralOptimization


#### Overview


`GeneralOptimization` is responsible for creating parameter vector(s) for
optimization, setting the parameter initial condition for the optimization, and setting
parameter bounds and constraints. Although the [Optimize.md] executioner holds a single vector
for parameter values, this vector can be split into groups of parameters. This
is done by specifying a name for each group with
[!param](/OptimizationReporter/GeneralOptimization/parameter_names) and the
number of parameters in each group with
[!param](/OptimizationReporter/GeneralOptimization/num_values) or [!param](/OptimizationReporter/GeneralOptimization/num_values_name). The total number
of parameters is ultimately defined by the sum of
[!param](/OptimizationReporter/GeneralOptimization/num_values) or the values
inside of the reporter defined by [!param](/OptimizationReporter/GeneralOptimization/num_values_name). The initial
condition for the optimization can then be defined with
[!param](/OptimizationReporter/GeneralOptimization/initial_condition), where a
vector of data must defined for each group.  This vector can be a single value in
which case all parameters in that group are set to that value or a value can be
set for every parameter in that group.  The lower and upper bounds for the
parameters can then specified by
[!param](/OptimizationReporter/GeneralOptimization/lower_bounds) and
[!param](/OptimizationReporter/GeneralOptimization/upper_bounds), respectively.
The bounds follow the same input format rules as the `initial_condition`.  If no
initial conditions are provided, the parameters are initialized with 0.  Default
values for `upper_bounds` and `lower_bounds` are `std::numeric<Real>::max()` and
`std::numeric<Real>::lower()`, respectively.  These bounds are only applied if a
bounded optimization algorithm is used. The reporter that holds the objective
value is defined by
[!param](/OptimizationReporter/GeneralOptimization/objective_name).
Additionally, equality and inequality constraints can be defined by
[!param](/OptimizationReporter/GeneralOptimization/equality_names) and
[!param](/OptimizationReporter/GeneralOptimization/inequality_names),
respectively.




### OptimizationReporter


#### Overview

This optimization reporter provides a basic interface for inverse optimization with measurement data where all data is provided in the input file or from csv file. The objective function is defined as:

f(\mathbf{u}, \mathbf{p}) = \frac{1}{2}\sum^N_i \left(u_i - \tilde u_i\right)^2 +R(\mathbf{u}, \mathbf{p}),

where $\mathbf{u}$ represents the simulation solution with $u_i$ being the solution value at measurement location $i$. $\tilde u_i$ is the measurement value at location $i$. $\mathbf{p}$ is the vector of parameters being optimized that the simulation solution depends on.  $R(\mathbf{u}, \mathbf{p})$ provides regularization of the objective function.  We currently only support the Tikhonov regularization given by

R(\mathbf{u}, \mathbf{p}) = \frac{\alpha}{2}\|\mathbf{p}\|^2,

where $\alpha$ is the Tikhonov coefficient specified in the input file by [!param](/OptimizationReporter/OptimizationReporter/tikhonov_coeff).

#### Measurement Data id=sec:measure_data

The measurement locations and values are defined either by a CSV file or are specified at input.

The CSV file is specified with the [!param](/OptimizationReporter/OptimizationReporter/measurement_file). This file must be at least four columns: x-coordinates indicated by [!param](/OptimizationReporter/OptimizationReporter/file_xcoord), y-coordinates indicated by [!param](/OptimizationReporter/OptimizationReporter/file_ycoord), z-coordinates inidicated by [!param](/OptimizationReporter/OptimizationReporter/file_zcoord), and values indicated by [!param](/OptimizationReporter/OptimizationReporter/file_value). A column for time coordinates can also be included and indicated by [!param](/OptimizationReporter/OptimizationReporter/file_time).

Additionally, locations and values can be specified at input using [!param](/OptimizationReporter/OptimizationReporter/measurement_points) for x-y-z coordinates, [!param](/OptimizationReporter/OptimizationReporter/measurement_times) for time coordinates, and [!param](/OptimizationReporter/OptimizationReporter/measurement_values) for the values.

#### Optimization Parameters

`OptimizationReporter` is also responsible for creating parameter vector(s) for optimization, setting the initial condition for the optimization, and setting parameter bounds. Although the [Optimize.md] executioner holds a single vector for parameter values, this vector can be split into groups of parameters. This is done by specifying a name for each group with [!param](/OptimizationReporter/OptimizationReporter/parameter_names) and the number of parameters in each group with [!param](/OptimizationReporter/OptimizationReporter/num_values). The total number of parameters is ultimately defined by the sum of [!param](/OptimizationReporter/OptimizationReporter/num_values). The initial condition for the optimization can then be defined with [!param](/OptimizationReporter/OptimizationReporter/initial_condition), where a vector of data must defined for each group.  This vector an be a single value in which case all parameters in that group are set to that value or a value can be set for every parameter in that group.  The lower and upper bounds for the parameters can then specified by [!param](/OptimizationReporter/OptimizationReporter/lower_bounds) and [!param](/OptimizationReporter/OptimizationReporter/upper_bounds), respectively. The bounds follow the same input format rules as the `initial_condtion`.  If no initial conditions are provided, the parameters are initialized with 0.  Default values for `upper_bounds` and `lower_bounds` are `std::numeric<Real>::max()` and `std::numeric<Real>::lower()`, respectively.  These bounds are only applied if a bounded optimization algorithm is used.

#### Declared Data

`OptimizationReporter` declares a number of vector reporter values that can be read by other objects and/or transferred to sub-applications with [MultiAppReporterTransfer.md]. [tab:or_vectors] lists each of these vectors. These vectors can be supplied or transferred by specifying `OptimizationReporter/<Vector Name>` at input.

| Description | Vector Name | Size |
| :- | - | - |
| $x$-coordinate | `measurement_xcoord` | $N$ |
| $y$-coordinate | `measurement_ycoord` | $N$ |
| $z$-coordinate | `measurement_zcoord` | $N$ |
| Time coordinate | `measurement_time` | $N$ |
| Measured values | `measurement_values` | $N$ |
| Simulation values | `simulation_values` | $N$ |
| $u_i - \tilde{u}_i$ | `misfit_values` | $N$ |
| Values of parameter group $g$ | [!param](/OptimizationReporter/OptimizationReporter/parameter_names)$_g$ | [!param](/OptimizationReporter/OptimizationReporter/num_values)$_g$ |
| Parameter Gradient of parameter group $g$ | `grad_`[!param](/OptimizationReporter/OptimizationReporter/parameter_names)$_g$  | [!param](/OptimizationReporter/OptimizationReporter/num_values)$_g$ |


#### Example Input Syntax

The following example creates three groups of parameters named `p1`, `p2`, and `p3` with two, four, and six parameters, respectively. There are several ways to define the initial conditions and upper and lower bounds.  Starting with the `initial_condition`, all parameters are specified for the `p1` parameter group, only one parameter is defined for the `p2` group making all parameter values in this group set to this value, and all parameters are defined for the `p3` group.  A similar mix of defining one or all of the lower and upper bounds are demonstrated in this input file.

It sets an initial condition and upper and lower bounds for every parameter. The measurement data is taken from a CSV file where the x-coordinate, y-coordinate, z-coordinate, and measurement value columns are specified with the header names of the file.



The measurement data can also be given directly, like in the following example.





### ParameterMeshOptimization


#### Overview

This optimization reporter performs the same type of optimization as [OptimizationReporter.md], except the parameters are defined by a mesh and is meant to be used in conjunction with [ParameterMeshFunction.md]. The idea is that the parameters are defined as variables on the inputted mesh and the resulting values on the problem being optimized is based on the finite-element shape functions of the variable. The parameter mesh does not need to conform to the physics mesh, but every point in the physics mesh must be contained in parameter mesh. The parameters are defined with [!param](/OptimizationReporter/ParameterMeshOptimization/parameter_names) and each name has the following options associated with it:

- mesh ([!param](/OptimizationReporter/ParameterMeshOptimization/parameter_meshes)) (+Required+),
- finite-element family ([!param](/OptimizationReporter/ParameterMeshOptimization/parameter_families)) where a single value input is applied to all parameters,
- finite-element order ([!param](/OptimizationReporter/ParameterMeshOptimization/parameter_orders)) where a single value input is applied to all parameters,
- initial condition which can be set by the following inputs:

  - from the input file using ([!param](/OptimizationReporter/OptimizationReporter/initial_condition)) where all values or one value per group can be specified
  - from the parameter mesh using ([!param](/OptimizationReporter/ParameterMeshOptimization/initial_condition_mesh_variable)) where each parameter in the group is initialized from data read from the parameter mesh exodus file,
  - default is zero

- lower bound which can be set by the following inputs:

  - from the input file using ([!param](/OptimizationReporter/ParameterMeshOptimization/lower_bounds)) where all values or one value per group can be specified
  - from the parameter mesh using ([!param](/OptimizationReporter/ParameterMeshOptimization/lower_bound_mesh_variable)) where each parameter in the group is initialized from data read from the parameter mesh exodus file
  - default is no bounds

- upper bound can be set by the following inputs:

  - from the input file using ([!param](/OptimizationReporter/ParameterMeshOptimization/upper_bounds)) where all values or one value per group can be specified.
  - from the parameter mesh using ([!param](/OptimizationReporter/ParameterMeshOptimization/upper_bound_mesh_variable)) where each parameter in the group is initialized from data read from the parameter mesh exodus file
  - default is no bounds

[!ref](ParameterMeshFunction.md#tab:fe_types) shows common interpolation types for the parameters.

The mesh created +must+ be replicated. Ensure this by having `Mesh/parallel_type=REPLICATED` when creating the mesh.

#### Example Input File Syntax

The first step in doing mesh-based inverse optimization is creating the parameter mesh. The easiest way of doing this is defining the mesh in a separate input file and run it with `--mesh-only` on command-line. The input below creates a two-by-two mesh outputted to exodus as `parameter_mesh_in.e`:


In the main optimization input, this mesh is then inputted into the ParameterMeshOptimization object:


The mesh is also used in the [ParameterMeshFunction.md] objects in the forward and adjoint inputs:



The transfer of parameters is the same as in other inverse optimization problems, see [OptimizationReporter.md].

#### Example Input File Syntax For Restarting An Optimization Simulation

A good guess for the initial parameter values will help with the convergence of the optimization problem.  In this example, initial conditions for the controllable parameters are given on an exodus mesh.  The parameter values on the exodus mesh are the optimized parameter values found in the previous example.  The parameter values from the above optimization problem are output by its forward problem onto the 10x10 mesh used by the FEM simulation.  The forward problem parameter field is then projected onto a coarser two-by-two parameter mesh as a first order Lagrange nodal AuxVariable called `restart_source` using [SolutionUserObject.md] and [SolutionAux.md] in the following input file


After the parameter mesh is initialized with parameter values, it can be used as an initial guess in the optimization problem.  The AuxVariable `restart_source` is then read in by `OptimizationReporter` using `initial_condition_mesh_variable` as the initial guess for the parameter field:


This optimization simulation is restarted with the optimized parameter values from the first example and convergence occurs in a single step.  The `ParameterMeshOptimization` reporter also defined an `exodus_timesteps_for_parameter_mesh_variable` to identify which step to read from the exodus file.  Constant lower and upper bounds were also given by `lower_bounds` and `upper_bounds` but do not have an effect on the optimization algorithm because it was started from the exact solution for the parameter field.  To use bounds, the `tao_solver` in the `Executioner` block was changed to `taoblmvm` (bounded lmvm).  For difficult optimization problems, it is better to start with a good guess for the parameters than to tighten up their bounds.  Multi-resolution optimization strategies [!citet](eslaminia2022full) find better initial guesses for the parameters by starting with an easier to solve optimization problem containing a few controllable parameters and then reusing those optimized parameters as an initial guess for a more difficult optimization problem with more parameters.



## outputs

### ExodusOptimizationSteady


#### Overview

This Exodus output object has the features of [Exodus](Exodus.md) and allows for [SteadyAndAdjoint](SteadyAndAdjoint.md) and [Steady](Steady.md) solves to output a per-iteration output. This allows users to analyze the
evolution of the optimization process solution as it converges to optimal values.

A test example is listed below:





## reporters

### OptimizationData


#### Overview

`OptimizationData` is a reporter typically used for storing measurement data in a inverse optimization simulation. This reporter creates the following vectors:

- `measurement_xcoord`
- `measurement_ycoord`
- `measurement_zcoord`
- `measurement_time`
- `measurement_values`
- `simulation_values`
- `misfit_values`

The `measurement_` vectors can be filled in using [!param](/Reporters/OptimizationData/measurement_values), [!param](/Reporters/OptimizationData/measurement_points), and [!param](/Reporters/OptimizationData/measurement_times) or with a CSV file using [!param](/Reporters/OptimizationData/measurement_file), [!param](/Reporters/OptimizationData/file_xcoord), [!param](/Reporters/OptimizationData/file_ycoord), [!param](/Reporters/OptimizationData/file_zcoord), [!param](/Reporters/OptimizationData/file_value), and [!param](/Reporters/OptimizationData/file_time). The `simulation_values` and `misfit_values` are calculated in this object if [!param](/Reporters/OptimizationData/variable) is specified and the measurement location and values are filled. See [OptimizationData.md] for more information on these input parameters and what the vectors mean.

For cases where more than one variable is being sampled, the contribution of each sampled variable to the measurement value are specified by weights in csv file input using [!param](/Reporters/OptimizationData/file_variable_weights).  These weights are then multiplied by each variable in the forward problem by specifying [!param](/Reporters/OptimizationData/variable_weight_names).  There must be one [!param](/Reporters/OptimizationData/variable_weight_names) per [!param](/Reporters/OptimizationData/variable) being sampled and their ordering must be the same.  A typical use case for this would be to specify [!param](/Reporters/OptimizationData/file_variable_weights) in the main optimization application input file to be read in along with the other parameters normally read from file.  Next, these reporter weights would be transferred to the forward and adjoint problem subapps.  In the forward subapp, [!param](/Reporters/OptimizationData/file_variable_weights) and [!param](/Reporters/OptimizationData/variable) would both be specified in the `OptimizationData` block and would weight the different variable contributions to the `simulation_values` and `misfit_values`.  In the adjoint subapp, the weights are transferred into a reporter that is used to scale the misfit applied by the [ReporterPointSource.md] using [!param](/DiracKernels/ReporterPointSource/weight_name).

If the [!param](/Reporters/OptimizationData/objective_name) is set by the user
`OptimizationData` will create and store the L2 Norm of the misfit
values divided by two. This can be useful for running an inverse optimization problem with the
[GeneralOptimization.md] reporter.

#### Example Input File Syntax

`OptimizationData` is typically used in the forward and homogeneous optimization
sub-applications to sample the solution for `simulation_values`, calculating
`misfit_values`, and storing the objective value provided by `objective_name`.
The measurement data can either be specified directly on each subapp or
 transferred from the optimization main application which would also require the simulation and misfit values to be transferred back to the main application. `OptimizationData` is also
used in the adjoint/gradient sub-application to hold the misfit values
to apply the [ReporterPointSource.md] Dirac kernel.
The following code blocks demonstrate this utilization of `OptimizationData`. The [OptimizationData.md] in the main application reads the measurement locations and values. A [MultiAppReporterTransfer.md] transfers the measurement data to the forward, adjoint/gradient, and homogeneous application within the `OptimizationData` reporter declared in those inputs. The forward and homogeneous applications then sample the specified vector specified in [!param](/Reporters/OptimizationData/variable). The main application then receives the simulation data using a [MultiAppReporterTransfer.md], which [OptimizationReporter.md] uses to calculate the misfit and transfer to the adjoint/gradient sub-application, which uses that data to apply the [ReporterPointSource.md] kernel.








### OptimizationInfo


#### Overview

`OptimizationInfo` provides the ability to output optimization solve information from [Optimize.md] for each [Tao iteration](https://petsc.org/release/docs/manualpages/Tao/TaoGetSolutionStatus/). The information outputted can be specified with [!param](/Reporters/OptimizationInfo/items). If this parameter is left unspecified, all information is outputted. The values that are optionally declared are shown in [tab:opt_info].

| Description | Name | [!param](/Reporters/OptimizationInfo/items) |
| :- | - | - |
| Objective Function Value | `function_value` | `function_value` |
| Gradient Norm | `gnorm` | `gnorm` |
| Infeasibility Norm | `cnorm` | `cnorm` |
| Step Length | `xdiff` | `xdiff` |
| Total Model Evaluations | `current_iterate` | `current_iterate` |
| Forward Model Evaluations | `objective_iterate` | `current_iterate` |
| Adjoint/Gradient Model Evaluations | `gradient_iterate` | `current_iterate` |
| Homogeneous Model Evaluations | `hessian_iterate` | `current_iterate` |
| Total Tao Iterations | `function_solves` | `current_iterate` |




### ParsedScalarReporter


#### Overview

`ParsedScalarReporter` operates on scalars contained in series of scalar reporters using a [parsed function expression](MooseParsedFunction.md) as shown in [vectorMath].  This reporter allows several scalar reporters to be combined into scalar.  Variables in the [parsed function expression](MooseParsedFunction.md) are given by the [!param](/Reporters/ParsedScalarReporter/reporter_symbols).  There is one [!param](/Reporters/ParsedScalarReporter/reporter_names) for each [!param](/Reporters/ParsedScalarReporter/reporter_symbols).
This is a scalar version of the [ParsedVectorReporter.md] reporter.

block=Reporters/vecs Reporters/scalarOperation

#### Optimization use case

This reporter was created to compute the objective function from the misfit reporter created by [OptimizationData.md].  The scalar reporter created can then be transferred as the objective value into [GeneralOptimization.md].




### ParsedVectorRealReductionReporter


#### Overview

`ParsedVectorRealReductionReporter` performs a reduction on the elements of a vector in a reporter using a [parsed function expression](MooseParsedFunction.md) containing only two variables, `reduction_value` and `indexed_value`.  `reduction_value` is the variable containing the reduced value and is initialized by [!param](/Reporters/ParsedVectorRealReductionReporter/initial_value).  `indexed_value` is the current vector element being operated on by the parsed function.

Different initial conditions and [parsed function expressions](MooseParsedFunction.md) will provide a vector sum, vector multiplication, vector sum of squares, and max as shown in [vectorMath].


#### Optimization use case

`ParsedVectorRealReductionReporter` and [ParsedVectorVectorRealReductionReporter.md] were created to process data cloned into a `StochasticReporter` from a `SamplerReporterTransfer` as shown in [sampler].
In this case, A `ParsedVectorRealReductionReporter` is needed to sum each samplers objective function returned to the `StochasticReporter`.
This set-up allows us to optimize parameters that combine multiple forward problems created and run in parallel using the sampler system.
The scalar reporter computed by `ParsedVectorRealReductionReporter` is then be transferred as the objective value into [GeneralOptimization.md].





### ParsedVectorReporter


#### Overview

`ParsedVectorReporter` operates on the elements contained in series of vector reporters using a [parsed function expression](MooseParsedFunction.md) as shown in [vectorMath].  This reporter allows several vector reporters to be combined into single vector.  This reporter operates on multiple vectors of the same size and returns a vector of that size.  There must be one [!param](/Reporters/ParsedVectorReporter/reporter_names) for each [!param](/Reporters/ParsedVectorReporter/reporter_symbols).
This is a vector version of the [ParsedScalarReporter.md] reporter.

block=Reporters/vecs Reporters/vectorOperation




### ParsedVectorVectorRealReductionReporter


#### Overview

`ParsedVectorVectorRealReductionReporter` performs a reduction across the rows of a vector of vectors contained in a reporter using a [parsed function expression](MooseParsedFunction.md) containing only two variables, `reduction_value` and `indexed_value`.  `reduction_value` is the variable containing the reduced value and is initialized by [!param](/Reporters/ParsedVectorVectorRealReductionReporter/initial_value).  `indexed_value` is the current vector element being operated on by the parsed function.  The output from `ParsedVectorVectorRealReductionReporter` is a column vector of the same size as the column size of the vector of vectors.  The vector of vectors reporter can be thought of as containing a matrix with the [parsed function expression](MooseParsedFunction.md) providing the row operation.  It is an error for the vectors contained in the vector of vectors to be different sizes.

Different initial conditions and [parsed function expressions](MooseParsedFunction.md) will provide different row operations on the matrix.  Examples are shown in [vectorMath] for a matrix row sum, matrix row multiplication, matrix row sum of squares, and max across the rows of a matrix.


#### Optimization use case

`ParsedVectorVectorRealReductionReporter` and [ParsedVectorRealReductionReporter.md] were created to process data cloned into a `StochasticReporter` from a `SamplerReporterTransfer` as shown in [sampler].
In this case, a `ParsedVectorVectorRealReductionReporter` is needed to sum each sampler's parameter gradient vector returned to the `StochasticReporter` as a vector of vectors.
This set-up allows us to optimize parameters that combine multiple forward problems created and run in parallel using the sampler system.
The scalar reporter computed by `ParsedVectorVectorRealReductionReporter` is then be transferred as the objective value into [GeneralOptimization.md].





## userobjects

### AdjointSolutionUserObject


#### Overview

This user-object is meant to be used for transient inverse optimization where the forward solution is needed to compute the adjoint and subsequent gradient (i.e. nonlinear problems and material inversion).
The object acts similarly to [SolutionUserObject.md] and can be used by objects such as [SolutionAux.md] and [SolutionFunction.md].
The difference stems from the [!param](/UserObjects/AdjointSolutionUserObject/reverse_time_end) parameter where the solution loaded is reversed in time. This is due to the reverse time-stepping required to evaluate the adjoint solution.
Due to specificity of this object's application, only exodus files can be loaded.

#### Example Input File Syntax

Here is a material inversion example where the forward and adjoint models are defined as:


The forward app outputs using [Exodus.md], which results in the file `optimize_grad_out_forward0.e` being generated:


The adjoint app reads in this outputted file and a [SolutionAux.md] sets the `u` auxiliary variable to it's values, while reversing the time:





### Density Update


#### Description

The `DensityUpdate` class is an `ElementUserObject` that calculates and updates
the design densities based on the filtered sensitivities. The density update is
performed using the Solid Isotropic Material with Penalization (SIMP) method.
The class requires the design density variable, the filtered design density
variable, the density sensitivity variable, the penalty power, and the volume
fraction as inputs.

#### Example Input File

An example of how to use the `DensityUpdate` class in an input file:

listing test/tests/materials/compliance_sensitivity/2d_mbb.i block=UserObjects/update





### Density Update for Multimaterial Topology Optimization


#### Description

The `DensityUpdateTwoConstraints` class is an `ElementUserObject`
that calculates and updates the design densities based on the
filtered cost and compliance sensitivities. The density update is performed
using the multi-material Solid Isotropic Material with Penalization
(SIMP) method (see [!cite](zuo2017multi)). The class requires
the design density variable, the filtered
design density variable, the density sensitivity variable, the penalty power,
the volume fraction, the cost fraction, the cost variable, and the cost
sensitivity variable as inputs.

#### Example Input File

An example of how to use the `DensityUpdateTwoConstraints` class in an input file:

listing test/tests/materials/compliance_sensitivity/2d_mmb_2material_cost_initial.i block=UserObjects/update





### Density Sensitivities


#### Description

The `SensitivityFilter` class is an `ElementUserObject` that calculates the density sensitivities
for topology optimization problems. It uses a radial average filter to distribute the
sensitivities across elements. The class requires the `RadialAverage` user object,
the density sensitivity variable, and the design density variable as inputs.

In general, the radius for filtering the sensitivity variables should be selected that
numerical instabilities are avoided but good spatial resolution is obtained. Typically,
selecting a radius value such that it encompasses a few finite elements works best.
#### Example Input File

An example of how to use the `SensitivityFilter` class in an input file:

listing test/tests/materials/compliance_sensitivity/2d_mbb.i block=UserObjects/calc_sense





## vectorpostprocessors

### AdjointStrainSymmetricStressGradInnerProduct

This object is designed to compute the gradient of the objective function concerning specific properties. It achieves this by computing the inner product of the property derivative (`SymmetricRankTwoTensor`) and the strain (`RankTwoTensor`) resulting from the forward simulation.

#### Example Input Syntax





### ElementOptimizationDiffusionCoefFunctionInnerProduct


#### Overview

This vector-postprocessor computes the inner product of the gradient of two variables with the derivative of an `OptimizationFunction` like [NearestReporterCoordinatesFunction.md]. For steady-state problems, the inner product is defined as:

V_i = \left(\vec{\nabla}u,\frac{df}{dp_i}\vec{\nabla}v\right) = \int_{\Omega}\vec{\nabla}u(\vec{r})\cdot\left.\frac{df(\vec{r},\vec{p})}{dp_i}\right|_{\vec{p}=\vec{p}_0}\vec{\nabla}v(\vec{r})d\vec{r},

which uses a quadrature rule to perform the integration. $u$ and $v$ are the variables specified by [!param](/VectorPostprocessors/ElementOptimizationDiffusionCoefFunctionInnerProduct/variable) and [!param](/VectorPostprocessors/ElementOptimizationDiffusionCoefFunctionInnerProduct/forward_variable), respectively. $f(\vec{r}, \vec{p})$ is the `OptimizationFunction` specified by [!param](/VectorPostprocessors/ElementOptimizationSourceFunctionInnerProduct/function), $\vec{p}$ is the vector of parameters that is defined in the function, and $\vec{p}_0$ is the current values of the parameters in the function. 

#### Example Input File Syntax

This function is primarily used for computing the gradient in an optimization routine where the value of a diffusion coefficient is being optimized. See [bimaterial/grad.i] as an example.




### ElementOptimizationReactionFunctionInnerProduct


#### Overview

This vector-postprocessor computes the inner product of two variables with the derivative of an `OptimizationFunction` like [NearestReporterCoordinatesFunction.md]. For steady-state problems, the inner product is defined as:

V_i = \left(u,-\frac{df}{dp_i}v\right) = \int_{\Omega}u(\vec{r})\cdot-\left.\frac{df(\vec{r},\vec{p})}{dp_i}\right|_{\vec{p}=\vec{p}_0}v(\vec{r})d\vec{r},

which uses a quadrature rule to perform the integration. $u$ and $v$ are the variables specified by [!param](/VectorPostprocessors/ElementOptimizationReactionFunctionInnerProduct/variable) and [!param](/VectorPostprocessors/ElementOptimizationReactionFunctionInnerProduct/forward_variable), respectively. $f(\vec{r}, \vec{p})$ is the `OptimizationFunction` specified by [!param](/VectorPostprocessors/ElementOptimizationReactionFunctionInnerProduct/function), $\vec{p}$ is the vector of parameters that is defined in the function, and $\vec{p}_0$ is the current values of the parameters in the function.

#### Example Input File Syntax

This function is primarily used for computing the gradient in an optimization routine where the value of a reaction coefficient is being optimized. See [diffusion_reaction/forward_and_adjoint.i] as an example.




### ElementOptimizationSourceFunctionInnerProduct


#### Overview

This vectorpostprocessor computes inner product of a variable with the derivative of an `OptimizationFunction` like [NearestReporterCoordinatesFunction.md]. For steady-state problems, the inner product is defined as:

V_i = \left(u,\frac{df}{dp_i}\right) = \int_{\Omega}u(\vec{r})\left.\frac{df(\vec{r},\vec{p})}{dp_i}\right|_{\vec{p}=\vec{p}_0}d\vec{r},

which uses a quadrature rule to perform the integration. $u$ is the variable specified by [!param](/VectorPostprocessors/ElementOptimizationSourceFunctionInnerProduct/variable), and $f(\vec{r}, \vec{p})$ is the `OptimizationFunction` specified by [!param](/VectorPostprocessors/ElementOptimizationSourceFunctionInnerProduct/function), $\vec{p}$ is the vector of parameters that is defined in the function, and $\vec{p}_0$ is the current values of the parameters in the function. For transient problems:

V_i = \left(u,\frac{df}{dp_i}\right) = \int_{t_0}^{t_N}\int_{\Omega}u(\vec{r},t)\left.\frac{df(\vec{r},t,\vec{p})}{dp_i}\right|_{\vec{p}=\vec{p}_0}d\vec{r}dt,

where $t_0$ and $t_N$ are the initial and final time points, respectively. The time integration is done using a trapezoid rule:

V_i \approx \sum_{n=0}^{N-1}\frac{V^{r}_i(t_{n+1}) + V^{r}_i(t_{n})}{2}\left(t_{n+1} - t_{n}\right),

where,

V^r_i(t) = \int_{\Omega}u(\vec{r},t)\left.\frac{df(\vec{r},t,\vec{p})}{dp_i}\right|_{\vec{p}=\vec{p}_0}d\vec{r}




### SideOptimizationNeumannFunctionInnerProduct


#### Overview

This vector-postprocessor computes the side inner product of a variable with the derivative of an `OptimizationFunction` like [NearestReporterCoordinatesFunction.md]. For steady-state problems, the inner product is defined as:

V_i = \left(u,\frac{df}{dp_i}\right)_{\partial\Omega} = \oint_{\partial\Omega}u(\vec{r})\left.\frac{df(\vec{r},\vec{p})}{dp_i}\right|_{\vec{p}=\vec{p}_0}d\vec{r},

which uses a quadrature rule to perform the integration. $u$ is the variable specified by [!param](/VectorPostprocessors/SideOptimizationNeumannFunctionInnerProduct/variable), $\partial\Omega$ is the side-set of the domain the integration is taking place specified by [!param](/VectorPostprocessors/SideOptimizationNeumannFunctionInnerProduct/boundary), $f(\vec{r}, \vec{p})$ is the `OptimizationFunction` specified by [!param](/VectorPostprocessors/SideOptimizationNeumannFunctionInnerProduct/function), $\vec{p}$ is the vector of parameters that is defined in the function, and $\vec{p}_0$ is the current values of the parameters in the function.

#### Example Input File Syntax

This function is primarily used for computing the gradient in an optimization routine where the value of a [Neumann boundary condition](FunctionNeumannBC.md) is being optimized. See [bc_load_linearFunction/adjoint.i] as an example.




# Peridynamics Module

       caption=Peridynamics results of 3D fuel fragmentation

The MOOSE peridynamic module is a library for solving classical solid mechanics and heat transfer problems using the peridynamics theory. For advanced deformation modeling, such as plasticity and creep, the peridynamics module should be used in conjunction with material classes from solid mechanics module. More information about this module is found below:

- [System Documentation List](peridynamics/systems.md)

## Basic Concepts in Peridynamics Theory

- [Horizon and States](peridynamics/HorizonStates.md): Material points, family and states

- [Deformation Gradients](peridynamics/DeformationGradients.md): Weighted least squares technique based nonlocal deformation gradients

## Peridynamic Models

- [Bond-based Mechanics Models](peridynamics/PeridynamicModels.md): Force state only depends on the bond itself, action and reaction in the opposite direction

- [Ordinary State-based Mechanics Models](peridynamics/PeridynamicModels.md): Force state depends on all bonds within two families, action and reaction in the opposite direction

- [Non-ordinary State-based Mechanics Models](peridynamics/PeridynamicModels.md): Force state depends on all bonds within two families, action and reaction in different directions

- [Bond-based Heat Conduction Models](peridynamics/PeridynamicModels.md): Response function only depends on the bond itself, action and reaction in the opposite direction

- [Coupled Thermo-Mechanical Models](peridynamics/PeridynamicModels.md): Peridynamic mechanics models coupled with peridynamic heat conduction models

## Using Materials From Tensor Mechanics in Correspondence Material Models

In peridynamic correspondence material model, concepts such as strain and stress tensors from classical Continuum Mechanics still apply, i.e., given the nonlocal deformation gradient calculated in peridynamics, calculations based on nonlocal deformation gradient to establish the constitutive relationship between stress and strain follows the same methodology as in local continuum theory. Strain and stress tensors from Continuum Mechanics reside at each discrete material point rather than quadrature point in peridynamic correspondence material model. Plasticity and creep material models from solid mechanics can be directly used in peridynamics for nonlinear deformation modeling.

- [Strains](solid_mechanics/Strains.md)

- [Stresses](solid_mechanics/Stresses.md)

## Spatial Discretization

Similar to mesh generation in finite element methods, a spatial discretization is required to discretize the domain of interest into discrete material points. Family, or connectivity, information needs to be built for each material points. Current peridynamic module supports two type of discretization schemes: build-in regular (i.e., 2D & 3D rectangular) domain discretization and external ExodusII FEM elements based domain discretization.

## actions

### Peridynamic Generalized Plane Strain Action

#### Description

The `GeneralizedPlaneStrainActionPD` Action can be used to setup the UserObject `GeneralizedPlaneStrain**UserObject`, ScalarKernel `GeneralizedPlaneStrainPD` and Kernel `GeneralizedPlaneStrain**OffDiag` for a peridynamic generalized plane strain model. More details about this action can be found at the [GeneralizedPlaneStrainActionPD](Peridynamics/Mechanics/GeneralizedPlaneStrain/index.md) system page.

### Peridynamic Mechanics Action

#### Description

The `MechanicsActionPD` Action can be used to setup the Kernel for each component of displacements, the UserObject `GhostElemPD` to ghost connected solutions from other processors due to nonlocality, and AuxVariable `bond_status` for peridynamic mechanics models. More details about this action can be found at the [MechanicsActionPD](Peridynamics/Mechanics/Master/index.md) system page.

## auxkernels

### Boundary Offset AuxKernel

#### Description

The `BoundaryOffsetPD` AuxKernel is used to retrieve the offset of a material point compared to initial FE element from the PD mesh object.




### Nodal Rank Two AuxKernel

#### Description

The `NodalRankTwoPD` AuxKernel is used to output the components of strain and stress tensors and their equivalent scalar quantities for bond-based and ordinary state-based models. And this is only applies to elastic materials. For correspondence models, the UserObjects `NodalRankTwoComponentPD` and `NodalRankTwoScalarPD` should be used.

This is a stand-alone calculation based on the concept of deformation gradient in correspondence model for postprocessing. Given the deformation gradient at each material point, other rank two tensors (strain, stress) can be calculated using the relationships from continuum mechanics theory.

For stress calculation, material constants, i.e., Young's modulus and Poisson's ratio, are required as input parameters.




### Nodal Area AuxKernel

#### Description

The `NodalVolumePD` AuxKernel is used to output the area or volume of a material point from the PD mesh object.




### Rank Two Based Failure Criteria AuxKernel

#### Description

The `RankTwoBasedFailureCriteriaNOSPD` AuxKernel is to determine the status of each individual bond using rank two tensors, i.e., strain and stress, based scalar quantities, i.e., axial strain/stress, maximum principal strain/stress, Tresca strain/stress and von Mises strain/stress. It should be noted that the listed failure criteria in this class only applies to non-ordinary state-based model. This auxKernel can be expanded to include other rank two tensor based failure criteria.





### Stretch-based Failure Criterion AuxKernel

#### Description

The `StretchBasedFailureCriterionPD` AuxKernel is to determine the status $\mu$ of each individual bond using critical stretch failure criterion. For critical stretch failure criterion, if the bond's mechanical stretch $s$ less than its critical value $s_{0}$ and intact in previous simulation step, the bond is considered as intact and a value of 1 is returned, otherwise, the bond is broken and a value of 0 is returned.

##### Critical stretch failure criterion

\begin{equation}
  \mu \left( \mathbf{X}^{\prime} - \mathbf{X}, t \right) = \left\{\begin{matrix}
  1 & s < s_{0} \\
  0 & s > s_{0}
  \end{matrix}\right.
\end{equation}

The bond critical stretch value can be calculated for the bond-based models from the critical energy release rate $G_c$ as

\begin{equation}
  s_{0} = \left\{\begin{matrix}
  \sqrt{\frac{\pi G_{c}}{3K \delta}} & \text{two dimensional} \\
  \sqrt{\frac{5 G_{c}}{9K \delta}} & \text{three dimensional}
  \end{matrix}\right.
\end{equation}
where $K$ is the bulk modulus and $\delta$ is the horizon size.

Derivation of above relationships can be found in Ref. [!citep](Silling2005meshfree).





## bcs

### Rigid Body Motion Preset Old Value Boundary Condition

#### Description

The `RBMPresetOldValuePD` BoundaryCondition applies Dirichlet boundary condition of old variable solution to rigid body motion (RBM) material points based on the singularity of shape tensor which is a concept from non-ordinary state-based peridynamics formulation. The rigid body motion of a material point, i.e., not fully constrained for all degrees of freedom, is equivalent to singularity of its shape tensor. This BC can be used to fix the non-fully-constrained material points hence improve the solvability of the whole system.




## kernels

### Force-stabilized Non-ordinary State-based Peridynamic Mechanics Kernel

#### Description

The `ForceStabilizedSmallStrainMechanicsNOSPD` Kernel calculates the residual and jacobian of the force density integral for fictitious bond force stabilized non-ordinary state-based model under infinitesimal strain assumptions.

#### Force state

With the fictitious bond force to stabilized the formulation, the force state for each `Edge2` element, i.e., bond, is

\begin{equation}
  \mathbf{f} \left( \mathbf{X}, \mathbf{X}^{\prime}, t \right) = \left( \underline{\mathbf{T}} \left[ \mathbf{X}, t \right] \left\langle \mathbf{X}^{\prime} - \mathbf{X} \right\rangle - \underline{\mathbf{T}} \left[ \mathbf{X}^{\prime}, t \right] \left\langle \mathbf{X} - \mathbf{X}^{\prime} \right\rangle \right) + \mathbf{f}_{s} \left( \mathbf{X}^{\prime} - \mathbf{X}, t \right)
\end{equation}
with
\begin{equation}
  \underline{\mathbf{T}} \left[ \mathbf{X}, t \right] \left\langle \mathbf{X}^{\prime} - \mathbf{X} \right\rangle = \underline{\omega} \left\langle \boldsymbol{\xi} \right\rangle \mathbf{P}_{\mathbf{X}} \mathbf{K}_{\mathbf{X}}^{-1} \boldsymbol{\xi}
\end{equation}

\begin{equation}
  \underline{\mathbf{T}} \left[ \mathbf{X}^{\prime}, t \right] \left\langle \mathbf{X} - \mathbf{X}^{\prime} \right\rangle = - \underline{\omega} \left\langle \boldsymbol{\xi} \right\rangle \mathbf{P}_{\mathbf{X}^{\prime}} \mathbf{K}_{\mathbf{X}^{\prime}}^{-1} \boldsymbol{\xi}
\end{equation}

\begin{equation}
  \mathbf{f}_{s} \left( \mathbf{X}^{\prime} - \mathbf{X}, t \right) = E \Delta x \underline{\omega} \left\langle \boldsymbol{\xi} \right\rangle \left( \mathbf{u}_{\mathbf{X}^{\prime}} - \mathbf{u}_{\mathbf{X}} \right)
\end{equation}
where $E$ is young's modulus, $\Delta x$ is grid spacing for regular gird structure or average grid spacing for irregular grid structure, and $\mathbf{u}$ is the solution vector.

We don't distinguish Cauchy stress with the first Piola-Kirchhoff stress under infinitesimal strain assumptions. The stress retrieved from `ComputeLinearElasticStress` is directly used in the force state calculation.




### Kernel for Generalized Plane Strain Off-diagonal Based on the Form I of the Horizon-Stabilized Peridynamic Correspondence Formulation

#### Description

The `GeneralizedPlaneStrainOffDiagNOSPD` Kernel provides the off-diagonal coupling entries for coupling between scalar out-of-plane strain variable with displacement and temperature variables for Form I of the horizon-stabilized peridynamic correspondence model. This kernel is optional for generalized plane strain model, but is usually used for better convergence rate of the solution process.




### Ordinary State-based Peridynamic Generalized Plane Strain Off-diagonal Kernel

#### Description

The `GeneralizedPlaneStrainOffDiagOSPD` Kernel provides the off-diagonal coupling entries to coupled scalar out-of-plane strain variable with displacement and temperature variables for ordinary state-based peridynamic models. This kernel is optional for generalized plane strain model, but is usually used for better convergence rate of the solution process.




### Bond-based Peridynamic Heat Conduction Kernel

#### Description

The `HeatConductionBPD` Kernel calculates the residual and jacobian of the heat flux integral for 2D, and 3D bond-based peridynamic heat conduction models. More details on the residual and Jacobian formulation can be found in Ref. [!citep](Chen2016bondimplicit).




### Bond-based Peridynamic Heat Source Kernel

#### Description

The `HeatSourceBPD` Kernel considers the heat source as a directly contribution to residual calculation of heat conduction models. Since the kernel iterate on each element but the heat source resides at each discrete material point, the repetition of a material point in a element-wise loop should be considered. And this is achieved by dividing the residual for each element by the total number of element connected at a material point.




### Form I of Horizon-stabilized Peridynamic Correspondence Finite Strain Mechanics Kernel

#### Description

The `HorizonStabilizedFormIFiniteStrainMechanicsNOSPD` Kernel calculates the residual and Jacobian of the force density integral for Form I of the horizon-stabilized peridynamic correspondence model under finite strain assumptions.

Details of the various forms of the horizon stabilization approaches are provided on the documentation page that describes all [Peridynamics models](peridynamics/PeridynamicModels.md).





### Form II of Horizon-stabilized Peridynamic Correspondence Finite Strain Mechanics Kernel

#### Description

The `HorizonStabilizedFormIIFiniteStrainMechanicsNOSPD` Kernel calculates the residual and Jacobian of the force density integral for Form II of the horizon-stabilized peridynamic correspondence model under finite strain assumptions.

Details of the various forms of the horizon stabilization approaches are provided on the documentation page that describes all [Peridynamics models](peridynamics/PeridynamicModels.md).





### Form II of Horizon-stabilized Peridynamic Correspondence Small Strain Mechanics Kernel

#### Description

The `HorizonStabilizedFormIISmallStrainMechanicsNOSPD` Kernel calculates the residual and Jacobian entries of the force density integral for Form II of the horizon-stabilized peridynamic correspondence model under infinitesimal strain assumptions.

Details of the various forms of the horizon stabilization approaches are provided on the documentation page that describes all [Peridynamics models](peridynamics/PeridynamicModels.md).





### Form I of Horizon-stabilized Peridynamic Correspondence Small Strain Mechanics Kernel

#### Description

The `HorizonStabilizedFormISmallStrainMechanicsNOSPD` Kernel calculates the residual and Jacobian entries of the force density integral for Form I of the horizon-stabilized peridynamic correspondence model under infinitesimal strain assumptions.

Details of the various forms of the horizon stabilization approaches are provided on the documentation page that describes all [Peridynamics models](peridynamics/PeridynamicModels.md).





### Bond-based Peridynamic Mechanics Kernel

#### Description

The `MechanicsBPD` Kernel computes the residual and jacobian of the force density integral for 2D, and 3D bond-based peridynamic models under infinitesimal strain assumptions.

#### Force function

The force state for each `Edge2` element, i.e., bond, is

\begin{equation}
  \mathbf{f}\left(\mathbf{X}, \mathbf{X}^{\prime}, t\right) = cs\mathbf{M}
\end{equation}
where $c$ is the micro-modulus, $s$ is the bond stretch, and $\mathbf{M}$ being the unit vector in the direction of the deformed bond from $\mathbf{X}$ to $\mathbf{X}^{\prime}$.

More details on the residual and Jacobian formulation can be found in [!citep](Chen2016bondimplicit).





### Ordinary State-based Peridynamic Mechanics Kernel

#### Description

The `MechanicsOSPD` Kernel calculates the residual and jacobian of the force density integral for 2D, and 3D ordinary state-based peridynamic models under infinitesimal strain assumptions.

#### Force state

The force state for each `Edge2` element, i.e., bond, is

\begin{equation}
  \mathbf{f} \left( \mathbf{X}, \mathbf{X}^{\prime}, t \right) = \left( \underline{\mathbf{T}} \left( \mathbf{X}, t\right) - \underline{\mathbf{T}} \left( \mathbf{X}^{\prime},t\right) \right) \cdot\mathbf{M}
\end{equation}
where $\mathbf{M}$ is the unit vector in deformed configuration.

\begin{equation}
  \underline{\mathbf{T}}\left(\mathbf{X}, t\right) = 2 \underline{\omega} \left\langle \boldsymbol{\xi} \right\rangle \left( d_{\mathbf{X}} \cdot a \cdot \theta_{\mathbf{X}} + b \cdot \boldsymbol{\xi} \cdot s\right)
\end{equation}

\begin{equation}
  \underline{\mathbf{T}} \left( \mathbf{X}, t \right) = -2 \underline{\omega} \left\langle \boldsymbol{\xi} \right\rangle \left( d_{\mathbf{X}^{\prime}} \cdot a \cdot \theta_{\mathbf{X}^{\prime}} + b \cdot \boldsymbol{\xi} \cdot s \right)
\end{equation}
where $s$ is the bond stretch, $\theta$ is the dilatation at a material point, parameters $a$, $b$ and $d$ are model parameters which can be expressed in terms of the material constants.

More details on the residual and Jacobian formulation can be found in Ref. [!citep](Hu2018irregular).




### Kernel for Weak Plane Stress Model Based on the Form I of the Horizon-Stabilized Peridynamic Correspondence Formulation

#### Description

The `WeakPlaneStressNOSPD` Kernel calculates the residual and Jacobian entries for the out-of-plane strain variable in the weak formulation of plane stress analysis. The in-plane displacement variables are governed by `HorizonStabilizedFormISmallStrainMechanicsNOSPD` for small strain analysis and `HorizonStabilizedFormIFiniteStrainMechanicsNOSPD` for finite strain analysis.




## materials

### Correspondence Finite Strain Material

#### Description

The `ComputeFiniteStrainNOSPD` Material calculates the strain and rotation increments used in the peridynamic correspondence models under finite strain assumptions. The class first constructs the [deformation gradient](peridynamics/DeformationGradients.md) and uses the Rashid scheme [citep:](rashid1993incremental) to formulate a incremental corotational finite strain model.

Note that Material `ComputeFiniteStrainNOSPD` can be used in general 3D and plane strain modeling and simulation.




### Correspondence Plane Finite Strain Material

#### Description

The `ComputePlaneFiniteStrainNOSPD` Material calculates the strain and rotation increments used in peridynamic correspondence models under finite strain assumptions for two dimensional analysis. The class first constructs the planar [deformation gradient](peridynamics/DeformationGradients.md) and uses the Rashid scheme [!citep](rashid1993incremental) to formulate a incremental corotational finite strain model.

Note that Material `ComputePlaneFiniteStrainNOSPD` must be used for _weak_ plane stress and generalized plane strain models to incorporate the out-of-plane strain components.




### Correspondence Plane Small Strain Material

#### Description

The `ComputePlaneSmallStrainNOSPD` Material calculates the strain tensor used in peridynamic correspondence models under small strain assumptions for two dimensional analysis.

Note that Material `ComputePlaneFiniteStrainNOSPD` must be used for _weak_ plane stress and generalized plane strain models to incorporate the out-of-plane strain components.




### Bond-based Peridynamic Constant Horizon Small Strain Material

#### Description

The `ComputeSmallStrainConstantHorizonMaterialBPD` Material calculates the micro-modulus used in bond-based peridynamic mechanics model for the case of regular uniform spatial discretization. For more details on bond-based peridynamic mechanics model for regular uniform spatial discretization, refer to [Peridynamic Models](peridynamics/PeridynamicModels.md) page and Ref. [!citep](Chen2016bondimplicit)




### Ordinary State-based Peridynamic Constant Horizon Small Strain Material

#### Description

The `ComputeSmallStrainConstantHorizonMaterialOSPD` Material calculates the parameters used in ordinary state-based peridynamic mechanics model for the case of regular uniform spatial discretization. For more details on ordinary state-based peridynamic mechanics model for regular uniform spatial discretization, refer to [Peridynamic Models](peridynamics/PeridynamicModels.md) page and Ref. [!citep](Madenci2014book).




### Correspondence Small Strain Material

#### Description

The `ComputeSmallStrainNOSPD` Material calculates the strain tensors based on [deformation gradient](peridynamics/DeformationGradients.md) for the peridynamic correspondence models under small strain assumptions.

Given the deformation gradient $\mathbf{F}$, the total strain tensor can be obtained as

\begin{equation}
  \boldsymbol{\epsilon}_{\text{total}} = \frac{1}{2} \left( \mathbf{F}^{T} + \mathbf{F} \right) - \mathbf{I}
\end{equation}

and the elastic strain tensor can be obtained by subtracting the eigen strain tensor from the total strain tensor as

\begin{equation}
  \boldsymbol{\epsilon}_{\text{elastic}} = \boldsymbol{\epsilon}_{\text{total}} - \boldsymbol{\epsilon}_{\text{eigen}}
\end{equation}

The computed elastic strain tensor is then used in stress calculator to calculate the stress tensor.

Note that Material `ComputeSmallStrainNOSPD` can be used in general 3D and plane strain modeling and simulation.




### Bond-based Peridynamic Variable Horizon Small Strain Material

#### Description

The `ComputeSmallStrainVariableHorizonMaterialBPD` Material calculates the micro-modulus used in bond-based peridynamic mechanics model for the case of irregular non-uniform spatial discretization. For more details on bond-based peridynamic mechanics model for irregular non-uniform spatial discretization, refer to [Peridynamic Models](peridynamics/PeridynamicModels.md) page and Ref. [!citep](Chen2017bondirregular).




### Ordinary State-based Peridynamic Variable Horizon Small Strain Material

#### Description

The `ComputeSmallStrainVariableHorizonMaterialOSPD` Material calculates the parameters used in ordinary state-based peridynamic mechanics model for the case of irregular non-uniform spatial discretization. For more details on ordinary state-based peridynamic mechanics model for irregular non-uniform spatial discretization, refer to [Peridynamic Models](peridynamics/PeridynamicModels.md) page and Ref. [!citep](Hu2018irregular).




### Bond-based Peridynamic Constant Horizon Thermal Material

#### Description

The `ThermalConstantHorizonMaterialBPD` Material calculates the micro-conductivity used in bond-based peridynamic heat conduction model for the case of regular uniform spatial discretization. For more details on bond-based peridynamic heat conduction model, refer to [Peridynamic Models](peridynamics/PeridynamicModels.md) page and Ref. [!citep](Chen2016bondimplicit).




### Bond-based Peridynamic Variable Horizon Thermal Material

#### Description

The `ThermalVariableHorizonMaterialBPD` Material calculates the micro-conductivity used in bond-based peridynamic heat conduction model for the case of irregular non-uniform spatial discretization. For more details on bond-based peridynamic heat conduction model, refer to [Peridynamic Models](peridynamics/PeridynamicModels.md) page and Ref. [!citep](Chen2017bondirregular).




## mesh

### Peridynamics Mesh

#### Description

The `PeridynamicsMesh` Mesh constructs and stores extra unconventional mesh data for peridynamics. It also provides interface for other class to access these data.




## meshgenerators

### Peridynamics Mesh Generator

#### Description

The `MeshGeneratorPD` MeshGenerator selectively converts finite element meshes and boundary sets to peridynamics meshes and corresponding boundary sets. For cases when more than one element block exist in the finite element mesh, user can specify which element block to convert to peridynamics elements and whether the converted finite elements will be retained with the newly created peridynamics elements or not.

For boundary sideset conversion, phantom elements are constructed based on peridynamics material points that were converted from finite elements adjacent to the specified FE boundary sidesets. For 2D FE meshes of either triangular or quadrilateral finite elements, three-node triangular phantom elements are constructed. For 3D FE meshes, the sideset construction currently only accepts hexahedral elements.




## nodalkernels

### Penalty Dirichlet Old Value Nodal Kernel


#### Description

The `PenaltyDirichletOldValuePD` NodalKernel is used to apply Dirichlet boundary conditions with value of old variable solution using the penalty method for nodesets. It is similar to imposing Dirichlet boundary condition using penalty method, but implemented using nodal kernel.

#### Example Syntax





## postprocessors

### Bond Status Convergence Postprocessor

#### Description

The `BondStatusConvergedPostprocessorPD` Postprocessor computes the number of peridynamic bonds that have changed status during a given Picard iteration. The bond status is held constant during the nonlinear iterations, and after they have converged, bonds are allowed to be considered failed if they meet certain criteria. Every time new bonds fail, the solution should be repeated to check if additional bonds would then fail. This Postprocessor is designed to be used in conjunction with the `PicardSolve` executioner as a criterion for convergence of those Picard iterations that repeatedly find an updated nonlinear solution after additional bonds fail.

Using the results of this Postprocessor for a convergence criterion, the solution is  considered as converged if both the nonlinear solution tolerance has been reached and the number of bonds with updated status at the end of the time step falls within a given tolerance or the maximum allowed Picard iterations have been reached.




### Peridynamic Displacement L2 Difference Postprocessor

#### Description

The `NodalDisplacementDifferenceL2NormPD` Postprocessor is used to calculate the L2 norm of difference between displacements and their analytic solutions using the discrete summation formulation.

\begin{equation}
  \text{L2 difference} = \int_{\Omega} {\left| \mathbf{u}_{prediction} - \mathbf{u}_{analytical} \right|} d{\Omega} = \sum V_{\mathbf{X}} \cdot {\left| \mathbf{u}_{prediction}^{\mathbf{X}} - \mathbf{u}_{analytical}^{\mathbf{X}} \right|}
\end{equation}
where $V_{\mathbf{X}}$ is the area or volume of material point $\mathbf{X}$, and $\mathbf{u}_{prediction}^{\mathbf{X}}$ and $\mathbf{u}_{analytical}^{\mathbf{X}}$ are the prediction and analytical solution at material point $\mathbf{X}$.




### Nodal Functions L2 Norm Postprocessor

#### Description

The `NodalFunctionsL2NormPD` Postprocessor calculates the L2 norm of a set of functions using the discrete summation formulation.

\begin{equation}
  \text{L2} = \int_{\Omega} {\left| \mathbf{f} \right|} d{\Omega} = \sum V_{\mathbf{X}} \cdot {\left| \bar{\mathbf{f}}_{\mathbf{X}} \right|}
\end{equation}
where $V_{\mathbf{X}}$ is the area or volume of material point $\mathbf{X}$, and $\bar{\mathbf{f}}_{\mathbf{X}}$ is the evaluation of functions $\mathbf{f}$ at material point $\mathbf{X}$.




### Nodal Variable Integral Postprocessor

#### Description

The `NodalVariableIntegralPD` Postprocessor calculates the volume (3D) or area (2D) integral of nodal variables using the discrete summation formulation.

\begin{equation}
  \text{val} = \int_{\Omega} u d{\Omega} = \sum V_{\mathbf{X}} \cdot \bar{u}_{\mathbf{X}}
\end{equation}
where $V_{\mathbf{X}}$ is the area or volume of material point $\mathbf{X}$, and $\bar{u}_{\mathbf{X}}$ is the evaluation of variable $u$ at material point $\mathbf{X}$.




## scalarkernels

### Peridynamic Generalized Plane Strain ScalarKernel

#### Description

The `GeneralizedPlaneStrainPD` ScalarKernel computes the residual and Jacobian entry corresponding to the scalar variable. The values of residual and Jacobian are retrieved from the `GeneralizedPlaneStrainUserObjectBasePD` UserObjects.

The residual is calculated based on

\begin{equation}
  r = \int_{\mathcal{A}} \sigma_{zz} d\mathcal{A}
\end{equation}
where $\mathcal{A}$ is solution domain, and $\sigma_{zz}$ is the normal out-of-plane stress component, with default to the $z$ direction.




## userobjects

### UserObject for Generalized Plane Strain Model Based on Form I of Horizon-Stabilized Peridynamic Correspondence Formulation

#### Description

The `GeneralizedPlaneStrainUserObjectNOSPD` UserObject is used to provide the residual and Jacobian for the scalar out-of-plane strain field variable in a generalized plane strain formulation using Form I of the horizon-stabilized peridynamic correspondence formulation. The out-of-plane stress component is retrieved from the `Compute***Stress` Material class. Integration of this component over the whole simulation domain is accomplished by summation of the product of material point area and the component value. The residual is the difference between stress integral and the applied force in the out-of-plane direction. The Jacobian is the derivative of residual with respect to the out-of-plane strain.




### Ordinary State-based Peridynamic Generalized Plane Strain UserObject

#### Description

The `GeneralizedPlaneStrainUserObjectOSPD` UserObject is used to provide the residual and Jacobian for the scalar out-of-plane strain field variable in a generalized plane strain formulation using the ordinary state-based peridynamic model. The out-of-plane stress component is calculated using the `NodalStressStrainPD` AuxKernel class. Integration of this component over the whole simulation domain is accomplished by summation of product of material point area and the component value. The residual is the difference between stress integral and the applied force in the our-of-plane direction. The Jacobian is the derivative of residual with respect to the out-of-plane strain.




### Peridynamic Ghost Element UserObject

#### Description

The `GhostElemPD` UserObject is used to ghost the element information which is required for calculation of properties on current processor from other processors. This is due to the parallel computing and the nonlocality of the interaction in peridynamics theory.




### Nodal Damage Index UserObject

#### Description

The `NodalDamageIndexPD` UserObject computes the value for a AuxVariable by calculating the damage index at each material point as the ratio of total volume of intact bonds to total volume all bonds associated with a material point.

\begin{equation}
  \phi \left( \mathbf{X}^{\prime} - \mathbf{X}, t \right) = 1 -\frac{\int_{\mathcal{H}_{\mathbf{X}}} \mu \left( \mathbf{X}^{\prime} - \mathbf{X}, t \right) dV^{\prime}}{\int_{\mathcal{H}_{\mathbf{X}}} 1 dV^{\prime}}
\end{equation}
where $\mu$ is the bond status parameter whose value is computed using AuxKernel `BondStatusPD`.




### Nodal Intact Bonds Number UserObject

#### Description

The `NodalNumIntactBondsPD` UserObject computes the value of an AuxVariable by calculating the number of intact/unbroken bonds associated with each material point.




### Nodal Rank Two Component UserObject

#### Description

The `NodalRankTwoComponentPD` UserObject is used to compute the values of rank two tensor components at each material point for correspondence material model. The component variable should be defined as aux variable, but its value is computed using UserObject rather than AuxKernel.

In self-stabilized correspondence material model, a rank two tensor (e.g., strain and stress) at a material point is the weighted average of bond-associated corresponding rank two tensors connected at that material point.

\begin{equation}
  \mathbf{A}_{\mathbf{X}} =\frac{\sum_{n=1}^{NP} w \left\langle \boldsymbol{\xi}_n \right\rangle \mathbf{A}_{\boldsymbol{\xi}_n}}{\sum_{n=1}^{NP}w \left \langle \boldsymbol{\xi}_n \right \rangle}
\end{equation}
where $\mathbf{A}_{\boldsymbol{\xi}_n}$ is the bond-associated rank two tensor, $w \left\langle \boldsymbol{\xi}_n \right\rangle$ is the weight for each bond-associated rank two tensor.




### Nodal Rank Two Scalar UserObject

#### Description

The `NodalRankTwoScalarPD` UserObject is used to compute the values of equivalent scalar quantities of a rank two tensor at each material point for correspondence material model. The scalar variable should be defined as aux variable, but its value is computed using UserObject rather than AuxKernel.

In self-stabilized correspondence material model, a equivalent scalar quantity of rank two tensor (e.g., von Mises stress) at a material point is the weighted average of bond-associated corresponding equivalent quantities connected at that material point.

\begin{equation}
  \alpha_{\mathbf{X}} =\frac{\sum_{n=1}^{NP} w \left\langle \boldsymbol{\xi}_n \right\rangle \alpha_{\boldsymbol{\xi}_n}}{\sum_{n=1}^{NP}w \left \langle \boldsymbol{\xi}_n \right \rangle}
\end{equation}
where $\alpha_{\boldsymbol{\xi}_n}$ is the bond-associated scalar quantity of rank two tensor, $w \left\langle \boldsymbol{\xi}_n \right\rangle$ is the weight for each bond-associated scalar quantity of rank two tensor. For current implementation, the volume fraction is used as the weight.




### SingularShapeTensorEliminatorUserObjectPD

#### Description

The `SingularShapeTensorEliminatorUserObjectPD` UserObject is used to eliminate the occurrence of singular shape tensors in peridynamic simulations. This UserObject is executed at end of a timestep, using updated bond status provided by an AuxKernel. The shape tensor is formed using neighboring bonds (including potentially ghosted bonds from neighboring processor(s)) for each node connected to a bond. Any bond with at least one singular associated shape tensor is treated as being broken, just as it would be if determined by a bond-based failure criterion. Because breaking bonds can have make other shape tensors singular, this can have a cascading effect, so this process is repeated until no further singular shape tensors are detected.

Occurrence of singular shape tensor usually happens in material failure problems modeled using formulations based on the peridynamic deformation gradient, such as the correspondence models and the ordinary state-based generalized plane strain model.




# Phase Field Module

       caption=Phase field results produced using the MOOSE Phase Field Module

- [Systems](phase_field/systems.md)

The MOOSE phase field module is a library for simplifying the implementation of simulation tools that
employ the phase field model. Multiphysics capability that includes mechanics and heat conduction can
be obtained by employing the solid mechanics and heat transfer modules. More information about
this module is found below:

## Basic Phase Field Model Information

- [phase_field/Phase_Field_Equations.md]: Basic information about the equations underlying the phase field module
- [phase_field/FunctionMaterials/ExpressionBuilder.md]: Using automatic differentiation of free energy material objects
- [phase_field/Solving.md]: Basic info about solving phase field models
- [phase_field/FunctionMaterialKernels.md]: Working with Function Materials that carry around their own derivatives
- [phase_field/FunctionMaterials.md]: Creating material properties based on the value of an arbitrary function expression
- [phase_field/Phase_Field_Model_Units.md]: Discussion of units in phase field models
- [phase_field/Anisotropy.md]: Support of anisotropic mobilities and interfacial energies
- [phase_field/CALPHAD.md]: Using thermodynamic databases to parameterize phase field models
- [phase_field/Quantitative.md]: Simple two component models using polynomial free energies
- [phase_field/FAQ.md]: Frequently asked questions about the phase field modules

## Multiple Phase Models

MOOSE provides capabilities that enable the easy development of multiphase field model. A free energy expression has to be provided for each individual phase. Different systems exist to combine those _phase free energies_ into a _global free energy_.

- [phase_field/MultiPhase/WBMTwoPhase.md]: Two phases, one phase order parameter
- [phase_field/MultiPhase/KKS.md]: per-phase concentrations, two phases
- [phase_field/MultiPhase/SLKKS.md]: per-phase concentrations, per-sublattice concentrations, multiple phases
- [phase_field/MultiPhase/WBM.md]: $N$ phases, $N$ phase order parameters
- [phase_field/MultiPhase/GrandPotentialMultiphase.md]: solving a Legendre transform of the phase field equations, where the independent variable is the chemical potential


## Multiphysics Coupling

- [phase_field/Mechanics_Coupling.md]: Coupling phase field equations with mechanics

## Phase field sub-systems

### Nucleation

- [phase_field/Nucleation/DiscreteNucleation.md]: Insertion of nuclei according to a nucleation probability density field
- [phase_field/Nucleation/LangevinNoise.md]: Fluctuation based nucleation

### Grain Growth

- [phase_field/Grain_Growth_Model.md]: Background on the phase field model implemented in MOOSE
- [Grain Tracker Algorithm](/GrainTracker.md): Tracking arbitrary features on an unstructured mesh over time
- [phase_field/Grain_Boundary_Anisotropy.md]: For systems with misorientation dependence of GB properties
- [phase_field/Elastic_Driving_Force_Grain_Growth.md]: Coupling mechanics to influence grain growth
- [phase_field/Linearized_Interface_Grain_Growth.md]: Grain growth model using linearized interface to reduce the required mesh size

## Initial Conditions

- [phase_field/Initial_Conditions.md]: Basic phase field initial conditions
- [phase_field/ICs/PolycrystalICs.md]: Creating polycrystalline structures using a variety of methods
- [Image Reader](/ImageFunction.md): Reconstructing initial conditions from images (SEM, optical, etc.)
- [EBSD Reader](phase_field/ICs/EBSD.md): Reconstructing initial conditions from EBSD and EDS data

# Tutorials

- [Fe-Cr Phase Decomposition](phase_field/Tutorial.md): Illustrates using parsed function kernels to create a two phase decomposition simulation

## Misc

- [phase_field/FunctionMaterials/AutomaticDifferentiation.md]: Construct derivatives of a given expression in a symbolic way
- [phase_field/FunctionMaterials/JITCompilation.md]: Compilation of FunctionParser expressions

## actions

### BicrystalBoundingBoxICAction


#### Overview

This action creates the initial conditions (ICs) for the two order parameters used to represent a bicrystal. It creates a grain structure with the first grain represented by a rectangle (2D) or rectangular prism (3D) embedded in the second grain. One common use is to create a bicrystal with a single straight grain boundary between the two grains.

The action creates two ICs with the [BoundingBoxIC](/BoundingBoxIC.md), one for each order parameter. Each are defined with the same bounding box coordinates, but for the first order parameter `inside = 1.0` and `outside = 0.0` and for the second `inside = 0.0` and `outside = 1.0`.

#### Example Input File Syntax

The `BicrystalBoundingBoxICAction` is accessed through the `ICs/PolycrystalICs` block, as shown below.




### BicrystalCircleGrainICAction


#### Overview

This action creates the initial conditions (ICs) for the two order parameters used to represent a bicrystal. It creates a grain structure with the first grain represented by a circle (2D) or sphere (3D) embedded in the second grain.

The action creates two ICs with the [SmoothCircleIC](/SmoothCircleIC.md), one for each order parameter. Each are defined with the same center coordinates and radius, but for the first order parameter `invalue = 1.0` and `outvalue = 0.0` and for the second `invalue = 0.0` and `outvalue = 1.0`.

#### Example Input File Syntax

The `BicrystalCircleGrainICAction` is accessed through the `ICs/PolycrystalICs` block, as shown below.








### ConservedAction


This action simplifies the input file syntax for creating a conserved phase field variable in the phase field module. It creates the variables and kernels needed to solve for a conserved variable. Three solving approaches (`solve_type`) are supported:
- `direct`
- `reverse_split`
- `forward_split`

#### Variables

In each approach, the name of the conserved variable is the block name.

##### `direct`

The direct solve has a second order spatial derivative term in the [CHInterface](/CHInterface.md) residual, and therefore requires a higher order element. For this reason, the variable is always created to be a third-order Hermite, no matter the family and order passed into the action.

##### `reverse_split`

The reverse_split adds two variables. It adds a conserved variable and a coupled variable which stores the chemical potential. Both variables have the same family and order.

##### `forward_split`

The forward_split adds two variables. It adds conserved variable and a coupled variable which stores the Laplacian of the conserved variable. Both variables have the same family and order.

#### Kernels

The kernels that are added depend on the solution approach:

##### `direct`

- [TimeDerivative](/TimeDerivative.md)
- [CahnHilliard](/CahnHilliard.md)
- [CHInterface](/CHInterface.md)

##### `reverse_split`

*Conserved variable*
- [CoupledTimeDerivative](/CoupledTimeDerivative.md)

*Coupled variable*
- [SplitCHWRes](/SplitCHWRes)
- [SplitCHParsed](/SplitCHParsed)

##### `forward_split`

*Conserved variable*
- [TimeDerivative](/TimeDerivative.md)
- [MatDiffusion](/MatDiffusion.md)

*Coupled variable*
- [MatDiffusion](/MatDiffusion.md)
- [CoupledMaterialDerivative](/CoupledMaterialDerivative.md)
- [CoefReaction](/CoefReaction.md)






### GrainGrowthAction


#### Overview

This action creates the variables, kernels, auxvariables, and auxkernels needed to run a polycrystal simulation. All of these various objects could be added manually in an input file, but the input file would be very long and would require many changes in order to change the number of order parameters being used to represent the grains. This action vastly simplifies the input file syntax.

The required input parameter `op_num` defines how many order parameters will be generated. Each order parameter is named based on the `var_name_base` parameter; e.g. for `op_num` = 3, `var_name_base` = `gr`, three nonlinear variables are created (`gr0`, `gr1`, and `gr2`).

When using the action, you can choose to either use the automatic differentiation (AD) versions of the kernels or the versions with hand-coded Jacobians with the parameter `use_automatic_differentiation`. It defaults to 'false'.

The following objects are created:

+Variables+

- A total of `op_num` variables

+AuxVariables+

- `bnds`, used to visualize grain boundaries

+Kernels+

- One per variable, with a total of `op_num`

  - [TimeDerivative](/TimeDerivative.md) or [ADTimeDerivative](/ADTimeDerivative.md)
  - [ACGrGrPoly](/ACGrGrPoly.md) or [ADGrainGrowth](/ADGrainGrowth.md)
  - [ACInterface](/ACInterface.md) or [ADACInterface](/ADACInterface.md)

+AuxKernels+

- [BndsCalcAux](/BndsCalcAux.md), used to define grain boundary visualization AuxVariable `bnds`

#### Example Input File Syntax

The `GrainGrowthAction` is created as shown below.





### GrainGrowthLinearizedInterfaceAction


#### Overview

This action creates the variables, kernels, auxvariables, auxkernels, bounds, and materials needed to implement a polycrystal simulation using a linearized interface. All of these various objects could be added manually in an input file, but the input file would be very long and would require many changes in order to change the number of order parameters being used to represent the grains. This action vastly simplifies the input file syntax and makes the syntax for a traditional phase field grain growth model and one using a linearized interface vey similar.

The required input parameter `op_num` defines how many order parameters will be generated. Each order parameter is named based on the `op_name_base` parameter and the transformed version is named based on the `var_name_base` parameter; e.g. for `op_num` = 3, `op_name_base` = `gr`, and `var_name_base` = `phi`, three variable are created as auxvariables (`gr0`, `gr1`, and `gr2`) and three transformed nonlinear variables (`phi0`, `phi1`, `phi2`).

The following objects are created:

+Variables+

- One per variable, with a total of `op_num`

  - Transformed variable (`var_name_base`)

+AuxVariables+

- `bounds_dummy`, used to save the bounds values
- `bnds`, used to visualize grain boundaries
- One per variable, with a total of `op_num`

  - Actual order parameter value (`op_name_base`)

+Materials+

- One per variable, with a total of `op_num`

  - [LinearizedInterfaceFunction](/LinearizedInterfaceFunction.md)

+Kernels+

- One per variable, with a total of `op_num`

  - [ChangedVariableTimeDerivative](/ChangedVariableTimeDerivative.md)
  - [ACGrGrPolyLinearizedInterface](/ACGrGrPolyLinearizedInterface.md)
  - [ACInterfaceChangedVariable](/ACInterfaceChangedVariable.md)

+AuxKernels+

- [BndsCalcAux](/BndsCalcAux.md)
- One per variable, with a total of `op_num`

  - [LinearizedInterfaceAux](/LinearizedInterfaceAux.md)
  - [ConstantBounds](/ConstantBounds.md) (for upper bound)
  - [ConstantBounds](/ConstantBounds.md) (for lower bound)


#### Example Input File Syntax

The `GrainGrowthLinearizedInterfaceAction` is accessed through the `Module` block, as shown below.





### GrandPotentialKernelAction



For more information on the multi-phase, multi-order parameter grand potential model, see [!cite](AagesenGP2018) (which is based on [!cite](plapp_unified_2011) and
[!cite](moelans_quantitative_2008)). Documentation on the multi-phase, multi-order parameter grand potential model itself, including MOOSE implementation, is available here:

[](/GrandPotentialMultiphase.md)

In this action, the following kernels are generated for each chemical potential variable:

- [`SusceptibilityTimeDerivative`](/SusceptibilityTimeDerivative.md)
- [`MatDiffusion`](/MatDiffusion.md) or [`MatAnisoDiffusion`](/MatAnisoDiffusion.md)
- [`CoupledSwitchingTimeDerivative`](/CoupledSwitchingTimeDerivative.md) (multiple kernels: one that corresponds with each order parameter)

The following kernels are generated for each order parameter:

- [`TimeDerivative`](/TimeDerivative.md)
- [`ACInterface`](/ACInterface.md)
- [`ACSwitching`](/ACSwitching.md)
- [`ACGrGrMulti`](/ACGrGrMulti.md)

Any additional kernels needed for your application will have to be entered manually into the input file.
There is a large number of inputs for this action, but they can be categorized into four
basic groups

##### Global Inputs

These are applied throughout the kernels.

- `switching_function_names`: Vector of names of switching functions. These are used to distinguish between phases.
- `use_displacesd_mesh`: Standard option for kernels. This will be applied to all kernels generated.
- `implicit`: Standard option for kernels. This will be applied to all kernels generated.

##### Chemical Potential Functions

These define the behavior of the chemical potential variables.

- `chemical_potentials`: Vector of names of chemical potential variables.
- `susceptibilities`: Vector of names of susceptibilities, chi. This vector should be the same length as "chemical_potentials" as each entry in this vector corresponds to the same entry in "chemical_potentials".
- `mobilities`: Vector of mobilities--either scalars or tensors--that correspond to the "chemical_potentials" variables. The entries should consist of diffusivities multiplied by susceptibilities.
- `anisotropic`: If the entries in "D" are tensors, set this to "true".
- `free_energies_w`: Vector of density functions that determine the densities corresponding with each "chemical_potentials". The total number of entries is the number of chemical potentials times the number of switching functions.

##### Primary Set of Order Parameter Functions

Inputs affecting a group of auto-generated variables using the PolycrystalVariables
action. These typically represent grains in a polycrystal system.

- `op_num`: Number of order parameters auto-generated in Variable block.
- `var_name_base`: Name of order parameters auto-generated in Variable block.
- `free_energies_gr`: Vector of chemical potential density functions used for this set of order parameters. Each entry corresponds to the phase in the same entry of "switching_function_names".
- `mobility_name_gr`: Name of scalar mobility used with this set of order parameters.
- `energy_barrier_gr`: Name of energy barrier coefficient (m in [!cite](moelans_quantitative_2008).) used with this set of order parameters.
- `gamma_gr`: Name of gamma coefficient used with this set of order parameters which controls interface energy between these order parameters.
- `kappa_gr`: Name of kappa coefficient to be used with this set of order parameters.

##### Second Set of Order Parameter Functions

This optional set can include additional order parameters to distinguish phases
or some other field not associated with the first set of order parameters.

- `additional_ops`: Vector of additional order parameters used in the model. Optional.
- `free_energies_op`: Vector of chemical potential density functions used for this set of order parameters. Each entry corresponds to the phase in the same entry of "switching_function_names".
- `mobility_name_op`: Name of scalar mobility used with this set of order parameters. If "additional_ops" is blank then this value and the others below will not be called and their values do not matter.
- `energy_barrier_op`: Name of energy barrier coefficient used with this set of order parameters.
- `gamma_op`: Name of gamma coefficient used with this set of order parameters which controls interface energy between these order parameters.
- `gamma_grxop`: Cross term gamma coefficient that controls the interface energy between the primary and second set of order parameters.
- `kappa_op`: Name of kappa coefficient to be used with this set of order parameters.


##### Strict Mass Conservation formulation

This optional formulation is enforcing a strict mass conservation by generating kernels for concentration, 
and coupled it with chemical potential from the Grand Potential model.

- 'mass_conservation' : set this to "true" to choose strict mass conservation formulation
- 'concentrations' : Vector of concentration variables used in the model.
- 'h_c_min' : Vector of coefficients for the BodyForce kernel in concentration-chemical potential coupling which indicates the minima of the parabolic free energy functions
- 'h_over_kVa' : Vector of coefficients for the MatReaction kernel in concentration-chemical potential coupling which is related to the coefficients of the parabolic free energy functions

The following kernels are generated for each concentration variables:

- [`TimeDerivative`](/TimeDerivative.md)
- [`MatDiffusion`](/MatDiffusion.md) or [`MatAnisoDiffusion`](/MatAnisoDiffusion.md)

The coupling between concentration and chemical potential is generated using the following kernel:

- [`MatReaction`](/MatReaction.md) 
- [`MatReaction`](/MatReaction.md) (multiple kernels: one that corresponds with each order parameter)
- ['BodyForce'](/BodyForce.md) (multiple kernels: one that corresponds with each order parameter)

The materials associated with strict mass conservation can be created automatically using [GrandPotentialSinteringMaterial.md]

#### Example Input File Syntax

    start=Modules
    end=Preconditioning














### NonconservedAction


This action simplifies the input file syntax for creating a nonconserved phase field variable in the phase field module. It creates the variable and all required kernels needed to solve for a nonconserved variable.

#### Variables

The name of the nonconserved variable is the block name.

#### Kernels

The kernels that are added are:

- [TimeDerivative](/TimeDerivative.md)
- [AllenCahn](/AllenCahn.md)
- [ACInterface](/ACInterface.md)






### PolycrystalColoringICAction


#### Overview

This simplifies the syntax for creating polycrystal ICs. It automatically creates an IC for each variable used in the grain growth model. It works for both the traditional phase field grain growth model and the linearized interface grain growth model. Depending on the value of `linearized_interface`, two different ICs are used for each variable:

- For `linearized_interface = false`, [PolycrystalColoringIC](/PolycrystalColoringIC.md) is used.
- For `linearized_interface = true`, [PolycrystalColoringICLinearizedInterface](/PolycrystalColoringICLinearizedInterface.md) is used.

Both of these ICs require a `UserObject` to define the actual polycrystal geometry. See [Polycrystal ICs](/PolycrystalICs.md) for more information and a full list of the options.


#### Example Input File Syntax

For `linearized_interface = false`



For `linearized_interface = true`








### PolycrystalKernelAction


#### Overview

This action creates the kernels needed to run a polycrystal simulation. All of the kernels could be added manually in an input file, but the input file would be very long and would require many changes in order to change the number of order parameters being used to represent the grains. This action vastly simplifies the input file syntax.

The required input parameter `op_num` defines how many order parameters will be generated. Each order parameter is named based on the `var_name_base` parameter; e.g. for `op_num` = 3, `var_name_base` = `gr`, three nonlinear variables are created (`gr0`, `gr1`, and `gr2`).

The following objects are created:

+Kernels+

- One per variable, with a total of `op_num`

  - [TimeDerivative](/TimeDerivative.md)
  - [ACGrGrPoly](/ACGrGrPoly.md)
  - [ACInterface](/ACInterface.md)

#### Example Input File Syntax

The `PolycrystalKernelAction` is accessed through the `Kernels` block, as shown below.





### PolycrystalRandomICAction


#### Overview

This action creates the initial conditions (ICs) for the `op_num` order parameters used to represent a polycrystal with a random initial condition.

The action creates the IC for each of the variables with [PolycrystalRandomIC](/PolycrystalRandomIC.md).

#### Example Input File Syntax

The `PolycrystalRandomICAction` is accessed through the `ICs/PolycrystalICs` block, as shown below.







### PolycrystalVariablesAction


#### Overview

This action creates a series of variables with a common naming convention. The required input parameter `op_num` defines how many variables will be generated. Each variable is named based on the `var_name_base` parameter; e.g. for `op_num` = 3, `var_name_base` = `gr`, three nonlinear variables are created (`gr0`, `gr1`, and `gr2`).

This action can be used to create variables used for a phase field grain growth model, but can also be used anytime a series of numbered variables is desired.

+Variables+

- Creates a total of `op_num` variables

  - Variables named `var_name_base`0, `var_name_base`1, $\ldots$, `var_name_base`+`op_num`.

#### Example Input File Syntax

The `PolycrystalVariablesAction` is accessed through the `Variables` block, as shown below:









### Tricrystal2CircleGrainsICAction


#### Overview

This action creates the initial conditions (ICs) for the three order parameters used to represent a tricrystal. It creates a grain structure with the second and third grains represented by circles (2D) or spheres (3D) embedded in the first grain.

The action creates the three ICs with the [Tricrystal2CircleGrainsIC](/Tricrystal2CircleGrainsIC.md).

#### Example Input File Syntax

The `Tricrystal2CircleGrainsICAction` is accessed through the `ICs/PolycrystalICs` block, as shown below.





## auxkernels

### BndsCalcAux


This AuxKernel computes the value $v$ as

\begin{equation}
b = \sum_i v_i^2
\end{equation}

where $b$ is the variable the AuxKernel is acting on and $v_i$ (`v`) are a set
of couple order parameters. When used with order parameters of the
polycrystalline grain growth model, the resulting field for $b$ is $1$ in grain
interiors and $<1$ in grain boundaries ($\frac14$ along the mid plan of the
grain boundaries).







### DiscreteNucleationAux


This AuxKernel computes the value $v$ as

\begin{equation}
v = M(r) \cdot (v_1 - v_0) + v_0
\end{equation}

where $v$ ist the variable the auxkernel is acting on and $M$ is the
[DiscreteNucleationMap](/DiscreteNucleationMap.md) data. The map values $M(r)$
range from 0..1 and are remapped using the $v_0$ (`no_nucleus_value`) and $v_1$
(`nucleus_value`) parameters.

The `DiscreteNucleationAux` auxkernel is part of the
[Discrete Nucleation system](Nucleation/DiscreteNucleation.md). Its companion
kernel is [DiscreteNucleationForce](/DiscreteNucleationForce.md).

















### GrainBoundaryVelocity

This will compute the velocity of the grain boundary edge and display those values for
visualization purposes. Only one AuxVariable is required, and optional variables for
the range we are interested in are also available.

#### Overview

we are using the equation:
\begin{equation}
\frac{1}{\left | \triangledown \eta \right |} \frac{d\eta}{dt} = v
\end{equation}
which computes the perpendicular velocity at each quadrature point in the range
specified.

#### Example Input File Syntax










### LinearizedInterfaceAux


#### Overview

This auxkernel calculates the order parameter value from the linearized interface converted variable according to the expression

\begin{equation}
    \phi_i = \frac{1}{2} \left[ 1 + \tanh\left( \frac{\psi_i}{\sqrt{2}} \right) \right],
\end{equation}

where $\phi_i$ is the order parameter and $\psi_i$ is the transformed variable.

#### Example Input File Syntax

The auxkernel is defined in the input file using the syntax:


Alternatively, this auxkernel is added automatically by the [GrainGrowthLinearizedInterfaceAction](/GrainGrowthLinearizedInterfaceAction.md).










### SolutionAuxMisorientationBoundary

This AuxKernel computes the value $v$ as

\begin{equation}
\chi = s + (1-s) \sum_i v_i^2
\end{equation}

where $\chi$ is the variable the AuxKernel is acting on, $v_i$ (`v`) are a set
of coupled order parameters, and $s$ is defined as 

\begin{equation}
s = |t_\text{specific}-t_\text{imported}|
\end{equation}

where $t_\text{imported}$ is the GB type imported from a [SolutionUserObject](/SolutionUserObject.md) and the $t_\text{specific}$ is the specific GB type to calculate the `bnds` parameter. When used with order parameters of the polycrystalline grain growth model, the resulting field for $\chi$ is $<1$ in grain boundaries with specific GB type and $1$ in grain interiors and other grain boundaries.





## functions

### FourierNoise


This object generates a Fourier series with random coefficients $s_{\vec k}$,
$c_{\vec k}$, and an amplitude factor $\sigma$ (`scale`). The series can be cut
off at a given length scale $\lambda$ (`lambda`) resulting in a low pass
filtered white noise. For efficiency lambda should be chosen larger than the
smallest mesh element size.

\begin{equation}
\sigma \sum_{\vc k, |\vec k| < \frac 1\lambda} s_{\vec k}\sin \vec r\cdot \vec k + c_{\vec k}\cos \vec r\cdot \vec k
\end{equation}

Alternatively the series can be constructed with an entirely random set of
series terms by specifying the number of terms `num_terms` resulting in a
non-periodic noise.





## ics





### BndsCalcIC


BndsCalcIC initializes the location of the grain boundaries in a polycrystalline sample. This is beneficial for executing the initial adaptivity based on the grain boundary locations.

Note: This is only useful when the order parameters are initialized with a diffused interface.

#### Example Input Syntax








### CoupledValueFunctionIC


CoupledValueFunctionIC initializes the value of a variable with the value of a
coupled MOOSE Function which is evaluated with a set of up to four coupled
variable values `v` as its input parameters. The coupled variable values are
substituted for the `x`,`y`,`z`, and `t` function variables in that order.

One example application is the use of a
[`PiecewiseMultilinear`](PiecewiseMultilinear.md) function with a data file
containing a pretabulation of dependent variable values as a function of up to
four primary variable values.

This capability can be used when internal degrees of freedom, such as phase
concentrations in a [KKS model](KKS.md), need to be initialized to a good
initial guess to improve the convergence of the first timestep. In the KKS case,
and physical IC will be applied to the primary global alloy concentration
variables, and the phase concentrations will be initialized from pretabulated
data containing good approximations of the phase concentrations for each primary
global alloy concentration.







### IsolatedBoundingBoxIC

IsolatedBoundingBoxIC allows setting the initial condition of a value of a field inside and outside
multiple isolated bounding boxes. Each box is axis-aligned and is specified by passing in the x,y,z
coordinates of the corners with the smallest and the largest coordinates for each box. An interfacial
width can be assigned for diffused interfaces.

#### Example input:


       caption=Initial condition of the variable defined in the above example.
       style=width:80%;display:block;margin-left:auto;margin-right:auto;

#### Class Description








### MultiBoundingBoxIC

MultiBoundingBoxIC allows setting the initial condition of a value of a field inside and outside
multiple bounding boxes. Each box is axis-aligned and is specified by passing in the x,y,z
coordinates of opposite corners for each box.

#### Example input:

In the example input that you may either supply a single "inside" value, or one value for
each box.


#### Class Description










### NestedBoundingBoxIC

NestedBoundingBoxIC allows setting the initial condition of a value of a field inside multiple nested
bounding boxes and the value outside the outermost box. Each box is axis-aligned and is specified by
passing in the x,y,z coordinates of the corners with the smallest and the largest coordinates for each
box. The order of defining the box coordinates must be from the innermost to the outermost box. An
interfacial width can be assigned for diffused interfaces. Partially overlapping boxes are not supported.

#### Example input:


       caption=Initial condition of the variable defined in the above example.
       style=width:80%;display:block;margin-left:auto;margin-right:auto;

#### Class Description








### PolycrystalColoringIC


#### Overview

Initializes the order parameter values for the polycrystal grain growth ICs. It works with the various [Polycrystal ICs](/PolycrystalICs.md) UserObjects.

#### Example Input File Syntax

We never recommend using this IC directly, but rather creating the full set of ICs for all of the transformed variables using [PolycrystalColoringICAction](/PolycrystalColoringICAction.md).




### PolycrystalColoringICLinearizedInterface


#### Overview

  style=width:40%;margin-left:1%;float:right;
  caption=Figure 2: Initial condition for linearized interface variable from PolycrystalColoringICLinearizedInterface with bounds of $\pm5$

  style=width:40%;margin-left:1%;float:right;
  caption=Figure 1: Initial condition for order parameter from PolycrystalColoringIC

This IC is for use with the linearized interface grain growth model. It converts the output from [PolycrystalColoringIC](/PolycrystalColoringIC.md) from an order parameter $\phi_i$ for the traditional grain growth model (see Fig. 1) to the changed variable for linearized interface $\psi_i$ (see Fig. 2). It works with the various [Polycrystal ICs](/PolycrystalICs.md).

For the linearized interface, it uses the function from [!cite](glasner2001nonlinear):

\begin{equation}
  \phi_i = \frac{1}{2} \left[ 1 + \tanh\left( \frac{\psi_i}{\sqrt{2}} \right) \right],
\end{equation}

So, the equation for the initial condition of the transformed variables $\psi_i$ is

\begin{equation}
  \psi_i = \sqrt{2} \tanh^{-1} (2 \phi_i - 1).
\end{equation}

The initial condition also has to consider the bounds values, $\pm b$ (defined by `bound_value`). When the function value of the order parameter initial condition is outside the bounds, the transformed variable value is equal to the bounds value. However, to make this evaluation, the bounds values have to be converted to order parameter values, such that:

- For $\phi_i > \frac{1}{2} \left[ 1 + \tanh\left( \frac{b}{\sqrt{2}} \right) \right]$, $\psi_i = b$.
- For $\phi_i <\ \frac{1}{2} \left[ 1 + \tanh\left( \frac{-b}{\sqrt{2}} \right) \right]$, $\psi_i = -b$.

#### Example Input File Syntax

We never recommend using this IC directly, but rather creating the full set of ICs for all of the transformed variables using [PolycrystalColoringICAction](/PolycrystalColoringICAction.md).




### PolycrystalRandomIC


#### Overview

This initial condition (IC) sets the variable values to initialize a grain structure from a pseudo random structure. There are two options for how the IC functions:

-  `Random_type = continuous`: The variable value is randomly generated between 0 and 1 at every node.
-  `Random_type = discrete`: One of the order parameter variables representing the polycrystal is randomly selected to equal 1 at the node, and all others equal 0.

#### Example Input File Syntax

We never recommend using this IC directly, but rather creating the full set of ICs for all of the variables using [PolycrystalRandomICAction](PolycrystalRandomICAction.md).




### PolycrystalVoronoiVoidIC

The PolycrystalVoronoiVoidIC generates a Voronoi tessellation to produce a grain structure with voids randomly distributed along the grain boundaries. The centroids of grains can be either generated from a set of random points or assigned from a file. It requires the number of voids to be greater than zero. In general, you should use [PolycrystalVoronoi](/PolycrystalVoronoi.md) to represent Voronoi grain structures without voids.

#### Typical usage in an input file:


#### Description and Syntax















### SmoothCircleIC


Insert a single disk or sphere with radius $R$ (`radius`) and a smooth interface
of width $w_i$ (`int_width`) with a user specified value range $[v_0, v_1]$ and
functional dependence of the interface (`profile`). $v_0$ (`outvalue`) is the
variable value outside of the disk/sphere and $v_1$ (`invalue`) is the value on
the interior.

##### Cosine profile (`COS`)

\begin{equation}
v(\vec r) = x\begin{cases}
        v_1, & \text{for } |\vec r| \leq R - \frac w2\\
        v_0 +  \frac12(v_1 - v_0) \left(1.0 + \cos(\pi\frac{|\vec r| - R\ + \frac w2}w)\right)
, & \text{for } R - \frac w2\lt |\vec r| \lt R + \frac w2\\
        v_0, & \text{for } R + \frac w2 \leq |\vec r|
        \end{cases}
\end{equation}

##### Hyperbolic tangent profile (`TANH`)

\begin{equation}
\label{eq-tanh}
v(\vec r) = (v_1 - v_0) \frac12 \left(\tanh(\pi \frac{R - |\vec r|}w ) + 1\right) + v_0;
\end{equation}

In both cases $v(\vec r)$ is the initial condition value at $\vec r + \vec r_0$,
where $\vec r_0$ is the center point (`x1`, `y1`, `z1`) of the circle (making
$\vec r$ a radius vector).

       caption=The hyperbolic tangent interface is scaled to have the same slope at
       its midpoint as the cosine interface.

For the `COS` interface, which is strictly zero outside the particle and
strictly inside the particle the interface width `int_width` denotes exactly the
width of the transition region where the order parameter values are in the open
interval $(v_0,v_1)$. The `TANH` interface function is asymptotic and requires a
different definition for the interface width. Here we chose to have the slope at
the midpoint match up with the midpoint slope of the `COS` interface (giving
rise to the factor of $\pi$ in eq. [eq-tanh]).





### SmoothCircleICLinearizedInterface


#### Overview

  style=width:40%;margin-left:1%;float:right;
  caption=Figure 2: Initial condition for linearized interface variable from SmoothCircleICLinearizedInterface with bounds of $\pm5$

  style=width:40%;margin-left:1%;float:right;
  caption=Figure 1: Initial condition for order parameter from SmoothCircleIC


This IC is for use with the linearized interface grain growth model. It converts the output from [SmoothCircleIC](/SmoothCircleIC.md) from an order parameter $\phi_i$ for the traditional grain growth model (see Fig. 1) to the changed variable for linearized interface variable $\psi_i$ (see Fig. 2). It uses the function from [!cite](glasner2001nonlinear):

\begin{equation}
  \phi_i = \frac{1}{2} \left[ 1 + \tanh\left( \frac{\psi_i}{\sqrt{2}} \right) \right],
\end{equation}

So, the equation for the initial condition of the transformed variables $\psi_i$ is

\begin{equation}
  \psi_i = \sqrt{2} \tanh^{-1} (2 \phi_i - 1).
\end{equation}

The initial condition also has to consider the bounds values, $\pm b$. When the function value of the order parameter initial condition is outside the bounds, the transformed variable value is equal to the bounds value. However, to make this evaluation, the bounds values have to be converted to order parameter values, such that:

- For $\phi_i > \frac{1}{2} \left[ 1 + \tanh\left( \frac{b}{\sqrt{2}} \right) \right]$, $\psi_i = b$.
- For $\phi_i <\ \frac{1}{2} \left[ 1 + \tanh\left( \frac{-b}{\sqrt{2}} \right) \right]$, $\psi_i = -b$.

#### Example Input File Syntax

The input file syntax for the IC is:













### Tricrystal2CircleGrainsIC


#### Overview

This initial condition (ICs) sets the variable values to represent a grain structure with the two grains represented by circles in 2D and spheres in 3D embedded in a third grain. The locations and radii of the circles are defined in terms of the dimensions of the domain, where $d_x$, $d_y$, and $d_z$ are the domain dimensions in the x-, y-, and z-directions, and the coordinate of the bottom left corner of the domain ($bl_x$, $bl_y$, $bl_z$).

- `op_index` = 0: Matrix grain
- `op_index` = 1: Left grain with radius $= d_x/5$ and center location ($bl_x+d_x/4, bl_y+d_y/2, bl_z+d_z/2$)
- `op_index` = 2: Right grain with radius $= d_x/5$ and center location ($bl_x+3d_x/4, bl_y+d_y/2, bl_z+d_z/2$)

Note that the circle grains are created with sharp interfaces. Similar geometry can be created with the [SpecifiedSmoothCircleIC](/SpecifiedSmoothCircleIC), but the locations, radii, and whether a diffuse interface is used are all determined by the user.

#### Example Input File Syntax

We never recommend using this IC directly, but rather creating the full set of ICs for all of the variables using [Tricrystal2CircleGrainsICAction](Tricrystal2CircleGrainsICAction.md).




### TricrystalTripleJunctionIC


#### Overview

This initial condition (ICs) sets the variable values to represent a grain structure with three grains coming together at a triple junction. The initial triple junction angles are set by the user.

Note that the grains are created with sharp interfaces.

#### Example Input File Syntax






## interfacekernels









## kernels

### ACBarrierFunction / ADACBarrierFunction

The `ACBarrierFunction` (and its automatic differentiation version, `ADACBarrierFunction`) kernel implements the term $\frac{\partial m}{\partial \eta}f(\eta)$
term for the free energy given in [!cite](moelans_quantitative_2008).
$m$ is the barrier energy coefficient.
In many phase field models, $m$ is constant, but in the case where it is a function
of one or more of the variables, this kernel should be included.

#### Description

##### General Information

This kernel should only be used for variables that are used in calculating $m$.
Other variables will do a lot of math to return a value of 0.

$m$ and its derivatives should be calculated in a materials block that uses the
DerivativeMaterialInterface, such as a DerivativeParsedMaterial.

The kernel only supports a single value of $\gamma$.
It should not be necessary to use multiple $\gamma$'s in models with a non-constant
$m$.




### ACGBPoly


This Kernel implements the a coupling term between the non conserved polycrystalline
grain model and a conserved concentration variable that could represent precipitates.
It can be added through the [GrainGrowthAction](/GrainGrowthAction.md).







### ACGrGrMulti


`ACGrGrMulti` (and its automatic differentiation version, `ADACGrGrMulti`) implements the term

\begin{equation}
L \mu \left( \eta_{\alpha i}^3 - \eta_{\alpha i} + 2\eta_{\alpha i} \sum_{\beta=1}^N
\sum_{j=1, \alpha i \neq \beta j}^{p_\beta} \gamma_{\alpha i \beta j} \eta_{\beta j}^2 \right)
\end{equation}

for a multiphase / multigrain Grand Potential model. The parameters $\mu$
(hardcoded material property name `mu`) and $\gamma$ (`gamma_names`) can be
calculated using the [`GrandPotentialInterface`](/GrandPotentialInterface.md)
material.

$L$ (`mob_name`) is an interfacial mobility, $\eta_{\alpha i}$ (`variable`) is
the kernel variable, and $\eta_{\beta j}$ (`v`) are the coupled phase / grain
order parameters. If $L$ is a [Function Material](/FunctionMaterials.md)
depending on any non-linear variable not listed in `v` those will have to be
listed in `args`.





### ACGrGrPoly


This Kernel implements the bulk part of the grain growth model
[!cite](moelans_quantitative_2008) Allen-Cahn equation
\begin{equation}
\left(L\mu(\eta_i^3-\eta_i+2\gamma\eta_i\sum_{j\neq i}\eta_j^2),\psi\right),
\end{equation}
where $L$ is the mobility, $\eta_i$ the kernel variable, and $\eta_j$ are the
other order parameters. $\mu$ and $\gamma$ are model parameters contributing to
the grain boundary energy $\sigma$ as
\begin{equation}
\sigma = g(\gamma)\sqrt{\kappa\mu},
\end{equation}
where $\kappa$ is the gradient energy coefficient from
[ACInterface](/ACInterface.md) and $g$ is a function that needs to be
numerically determined (see [!cite](moelans_quantitative_2008) for details).

$\kappa_{i,j}$ and $\gamma_{i,j}$ could be defined for specific grain boundaries
(grain pairs). This is provided by the [GBAnisotropy](/GBAnisotropy.md)
material.

An automatic differentiation version of this kernel is implemented in
[ADGrainGrowth](/ADGrainGrowth.md).





### ACGrGrPolyLinearizedInterface


#### Overview

This kernel implements the bulk portion of the residual for the Allen-Cahn equation from the multiphase grain growth model using the linearized interface variable substitution. It is the linearized interface version of the [ACGrGrPoly](/ACGrGrPoly.md) kernel. The grain growth model comes from [!cite](moelans_quantitative_2008) and the linearized interface from [!cite](glasner2001nonlinear).

The kernel inherits the same residual function from [ACGrGrPoly](/ACGrGrPoly.md) but uses a linearized interface substitution. The substitution is defined in the material property `this_op`. The most common one is
\begin{equation}
    \phi_i = \frac{1}{2} \left[ 1 + \tanh\left( \frac{\psi_i}{\sqrt{2}} \right) \right],
\end{equation}
where $\phi_i$ is the order parameter and $\psi_i$ is the transformed variable. The substitution is implemented in the material [LinearizedInterfaceFunction](/LinearizedInterfaceFunction.md).


#### Example Input File Syntax

The kernel can be used according to


However, it can also be created automatically using the [GrainGrowthLinearizedInterfaceAction](/GrainGrowthLinearizedInterfaceAction.md).





### ACInterface / ADACInterface


`ACInterface` (and its automatic differentiation version, `ADACInterface`) implements the Allen-Cahn term for the $\frac{\kappa_i}2|\nabla \eta_i|^2$
gradient energy contribution for the isotropic mobility case. Its weak form is

\begin{equation}
\left( \kappa_i \nabla \eta_i, \nabla (L_i \psi_m ) \right),
\end{equation}

where $\kappa_i$ (`kappa_name`) is the gradient energy coefficient, $\eta_i$ the
non-conserved non-linear order parameter variable the kernel is acting on, $L_i$
(`mob_name`) is the scalar (isotropic) mobility associated with the order
parameter, and $\psi_m$ is the test function.




### ACInterface2DMultiPhase1


Implements the Allen-Cahn term for the $\frac{\kappa}2 \sum |\nabla \eta_{\alpha i}|^2$ gradient
energy contribution for the anisotropic interface energy case. Its weak form is
\begin{equation}
\left(\nabla (L \psi), \frac{1}{2} \frac {\partial \kappa} {\partial \nabla \eta_{\alpha i}} \sum (\nabla \eta_{\beta j})^2  \right),
\end{equation}
where $\kappa$ (`kappa_name`) is the gradient energy coefficient, $\eta_{\alpha i}$ the non-conserved
non-linear order parameter variable the kernel is acting on, $L$ (`mob_name`) is
the scalar (isotropic) mobility associated with the order parameter, and $\psi$
is the test function.




### ACInterface2DMultiPhase2


Implements the Allen-Cahn term for the $\frac{\kappa}2 \sum |\nabla \eta_{\alpha i}|^2$ gradient
energy contribution for the isotropic mobility case. Its weak form is
\begin{equation}
\left( \kappa \nabla \eta_{\alpha i}, \nabla (L \psi) \right),
\end{equation}
where $\kappa_i$ (`kappa_name`) is the gradient energy coefficient, $\eta_i$ the non-conserved
non-linear order parameter variable the kernel is acting on, $L$ (`mob_name`) is
the scalar (isotropic) mobility associated with the order parameter, and $\psi$
is the test function. It is assumed $\kappa$ is a function of $\nabla \eta_{\alpha}$
and $\nabla \eta_{\beta}$.Therefore, kappa depends on multiple order parameters.




### ACInterfaceChangedVariable


#### Overview

This kernel implements the gradient energy contribution of the Allen-Cahn equation residual for the isotropic mobility case, using a change of variable. It is the change of variable version of the [ACInterface](/ACInterface.md) kernel. It is used with linearized interface grain growth model from [!cite](glasner2001nonlinear).

With a linearized interface, the weak form is

\begin{equation}
\left( \kappa_i \nabla \phi_i, \nabla (L_i \zeta_m ) \right) = \left( \kappa_i \nabla \psi_i \frac{\partial \phi_i}{\partial \psi_i}, \nabla (L_i \zeta_m ) \right),
\end{equation}

where $\kappa_i$ (`kappa_name`) is the gradient energy coefficient, $\phi_i$ the
non-conserved non-linear order parameter variable, $\psi_i$ is the transformed variable the kernel is acting on, $L_i$
(`mob_name`) is the scalar (isotropic) mobility associated with the order
parameter, and $\zeta_m$ is the test function. The derivative of the change of variable function $\frac{\partial \phi_i}{\partial \psi_i}$ is defined using a derivative parsed material such as [LinearizedInterfaceFunction](/LinearizedInterfaceFunction.md).

#### Example Input File Syntax

The kernel is used in an input file with the syntax


Alternatively, this kernel is added automatically by the [GrainGrowthLinearizedInterfaceAction](/GrainGrowthLinearizedInterfaceAction.md).




### ACInterfaceCleavageFracture


Implements the Allen-Cahn term with crack propagation preferred along weak
cleavage plane specified using cleavage plane normal ($\boldsymbol{M}$). Planes
not normal to $\boldsymbol{M}$ are penalized using $\beta$ parameter
[!cite](ClaytonKnap2015). Setting $\beta=0$ results in isotropic damage with
respect to cleavage planes. The added term is

\begin{equation}
\dfrac{\beta l_0}{2} \left( \boldsymbol{I} - \boldsymbol{M} \otimes \boldsymbol{M} \right) : \left( \nabla d \otimes \nabla d \right)
\end{equation}

Its weak form is

\begin{equation}
\int_{\Omega} \left( - \beta l_0 \left( \nabla^2 d - \boldsymbol{M} \otimes \boldsymbol{M} : \nabla \nabla d \right) \right) \psi dV
\end{equation}

The second term in above expression can be simplified as,

\begin{equation}
\begin{aligned}
\int_{\Omega} \psi \left(\boldsymbol{M} \otimes \boldsymbol{M} : \nabla \nabla d \right) dV
&= \int_{\Omega} \left( \nabla \cdot \left( \psi \boldsymbol{M} \left( \boldsymbol{M} \cdot \nabla d \right) \right) - \left( \boldsymbol{M} \cdot \nabla\psi \right) \left( \boldsymbol{M} \cdot \nabla d \right) - \left( \psi \nabla \cdot \boldsymbol{M} \right) \left( \boldsymbol{M} \cdot \nabla d \right) \right) dV
\\
&= \int_{\Omega} \nabla \cdot \left( \psi \boldsymbol{M} \left( \boldsymbol{M} \cdot \nabla d \right) \right) dV - \int_{\Omega} \left( \boldsymbol{M} \cdot \nabla \psi \right) \left( \boldsymbol{M} \cdot \nabla d \right) dV - \int_{\Omega} \left( \psi \nabla \cdot \boldsymbol{M} \right) \left( \boldsymbol{M} \cdot \nabla d \right) dV
\\
&= \int_{\partial \Omega} \psi \boldsymbol{M} \left( \boldsymbol{M} \cdot \nabla d \right) \cdot \boldsymbol{n} dS - \int_{\Omega} \left( \boldsymbol{M} \cdot \nabla \psi \right) \left( \boldsymbol{M} \cdot \nabla d \right) dV - \int_{\Omega} \left( \psi \nabla \cdot \boldsymbol{M} \right) \left( \boldsymbol{M} \cdot \nabla d \right) dV
\end{aligned}
\end{equation}

In the last expression, the first and last term are zero and thus remains only
middle term.

The Jacobian is

\begin{equation}
\beta l_0 \left( \int_{\Omega} \left( \nabla \psi \cdot \nabla \phi_j \right) dV - \int_{\Omega} \left( \boldsymbol{M} \cdot \nabla \psi \right) \left( \boldsymbol{M} \cdot \nabla \phi_j \right) dV \right)
\end{equation}





### ACInterfaceKobayashi1


Kernel 1 of 2 for interfacial energy anisotropy in the Allen-Cahn equation as
implemented in R. Kobayashi, Physica D, 63, 410-423 (1993).
doi:10.1016/0167-2789(93)90120-P
This kernel implements the first two terms on the right side of eq. (3) of the paper.





### ACInterfaceKobayashi2


Kernel 2 of 2 for interfacial energy anisotropy in the Allen-Cahn equation as
implemented by R. Kobayashi [!cite](Kobayashi1993).
This kernel implements the third term on the right side of eq. (3) of the paper.





### ACInterfaceStress


Implements the Allen-Cahn term for the $-L_i\nabla\frac{\partial E_{el}}{\partial \nabla \eta_i}$
elastic energy contribution for the interface stress, where
$E_{el}=\frac12\sigma_{int}:\epsilon$. Its weak form is

\begin{equation}
R=-\frac12L\left(\nabla \frac{\partial \sigma_{int}}{\partial\nabla\eta_i}:\epsilon, \psi_m \right),
\end{equation}

where $\eta_i$ the non-conserved non-linear order parameter variable the kernel is
acting on, $L_i$ (`mob_name`) is the scalar (isotropic) mobility associated with
the order parameter, and $\psi_m$ is the test function.

Integrating by parts and applying the divergence theorem yields

\begin{equation}
R=\frac12L\left[
\left(\frac{\partial \sigma_{int}}{\partial\nabla\eta_i}:\epsilon, \nabla\psi_m\right) - \left<\frac{\partial \sigma_{int}}{\partial\nabla\eta_i}:\epsilon\cdot\vec n,\psi_m\right>
\right].
\end{equation}




### ACKappaFunction / ADACKappaFunction

The `ACKAppaFunction` (and its automatic differentiation version, `ADACKappaFunction`) Kernel calculates the term
$\frac12 L \frac{\partial \kappa}{\partial \eta} f_g(\nabla \eta)$
for the case where $\kappa$ is a function of $\eta$ and $f_g$ is the gradient
energy function used in the phase field method.

#### Description

##### General Information

This kernel should only be used for variables for which $\kappa$ has derivatives.
Otherwise it wastes computational resources.

$\kappa$ and its derivatives should be calculated in a material block which uses
the ```DerivativeMaterialInterface```, such as ```DerivativeParsedMaterial```.




### ACMultiInterface


Implements Allen-Cahn interface terms for a multiphase system. This includes
cross terms of the form

\begin{equation}
\sum_j\frac12\kappa_{ij}\left( \eta_i\nabla\eta_j - \eta_j\nabla\eta_i \right)^2
\end{equation}

where $\eta_i$ is the non-linear variable the kernel is acting on, $\eta_j$ (`etas`
are all non-conserved order parameters in the system, $\kappa_{ij}$ (`kappa_name`)
are the gradient energy coefficients, and $L_i$ (`mob_name`) is the scalar (isotropic)
mobility associated with the $\eta_i$ order parameter.

#### Derivation

The interfacial free energy density $f_{int}$ is implemented following [!cite](Nest98) equations
 (7) and (8) (also see footnote 1)

\begin{equation}
f_{int} = \sum_{\substack{a,b \\ b\neq a}} \frac12 \kappa_{ab} \left| \eta_a\nabla\eta_b - \eta_b\nabla\eta_a\right|^2,
\end{equation}

Where the sum is taken over unique tuples _a,b_ (i.e. without the permutations _b,a_).
We take the functional derivative taken using the lemma

\begin{equation}
\frac{\delta f}{\delta\eta} = \frac{\partial f}{\partial\eta} - \nabla\frac{\partial f}{\partial\nabla\eta}.
\end{equation}

We obtain a one dimensional sum for each of the $\eta$-derivatives.

\begin{equation}
\begin{aligned}
\frac{\delta f_{int}}{\delta\eta_a} & = \sum_b \kappa_{ab} \left[ (\eta_a\nabla\eta_b - \eta_b\nabla\eta_a)\nabla\eta_b + \nabla\left((\eta_a\nabla\eta_b - \eta_b\nabla\eta_a)\eta_b\right) \right] \\
&= \sum_{\substack{b\\b\neq a}} \kappa_{ab} \left[ \underbrace{2(\eta_a\nabla\eta_b - \eta_b\nabla\eta_a)\nabla\eta_b}_{\text{order 1}} + \underbrace{\eta_b(\eta_a\nabla^2\eta_b - \eta_b\nabla^2\eta_a)}_{\text{order 2}} \right]
\end{aligned}
\end{equation}

We transform this expression into the weak form and see that the derivative order on the _order 2_ term has to be reduced by shifting a gradient onto the test function by applying the product rule

\begin{equation}
v \nabla\cdot\mathbf{w} = -\nabla v \cdot \mathbf{w}  + \nabla\cdot (v\mathbf{w}),
\end{equation}

after multiplying with the test function $\psi$ and integrating over the volume $\Omega$. We identify $v$ and $w$ as follows

\begin{equation}
\int_\Omega\psi\eta_b(\eta_a\nabla^2\eta_b - \eta_b\nabla^2\eta_a) =
\int_\Omega\underbrace{\psi\eta_a\eta_b}_{v_1}\nabla\cdot\underbrace{\nabla\eta_b}_{\mathbf{w}_1} -
\int_\Omega\underbrace{\psi\eta_b^2}_{v_2}\nabla\cdot\underbrace{\nabla\eta_a}_{\mathbf{w}_2}
\end{equation}

\begin{equation}
  \int_\Omega\left[ -\nabla(\psi\eta_a\eta_b)\cdot\nabla\eta_b\right]
- \int_\omega\left[-\nabla(\psi\eta_b^2)\cdot\nabla\eta_a\right]
+ \int_\Omega \nabla\cdot(\psi\eta_a\eta_b\nabla\eta_b)
- \int_\Omega \nabla\cdot(\psi\eta_b^2\nabla\eta_a).
\end{equation}

We get rid of the last two terms by applying the divergence theorem and obtain

\begin{equation}
\underbrace{
  \int_\Omega\left[ -\nabla(\psi\eta_a\eta_b)\cdot\nabla\eta_b\right]
- \int_\Omega\left[-\nabla(\psi\eta_b^2)\cdot\nabla\eta_a\right]
}_{\text{volume terms}}
+ \underbrace{
  \int_{\partial\Omega} \mathbf{n}\cdot(\psi\eta_a\eta_b\nabla\eta_b)
- \int_{\partial\Omega} \mathbf{n}\cdot(\psi\eta_b^2\nabla\eta_a).
}_{\text{boundary terms}}
\end{equation}

to convert them from volume to surface/boundary integrals. We again apply the product rule to expand the gradient of the product in the _volume terms_ and obtain

\begin{equation}
\int_\Omega\left[
 -\left(
\eta_a\eta_b\nabla\psi + \psi\eta_b\nabla\eta_a + \psi\eta_a\nabla\eta_b
\right) \cdot\nabla\eta_b\right]
- \int_\Omega\left[
-\left(
\eta_b^2\nabla\psi
+ 2\psi\eta_b\nabla\eta_b
\right)\cdot\nabla\eta_a\right].
\end{equation}

##### Residual

The total residual $R_a$ is then

\begin{equation}
\begin{aligned}
R_a = L_a\sum_{\substack{b\\b\neq a}}\kappa_{ab}
\Bigg[ &\,&
\int_\Omega\left[
2\psi(\eta_a\nabla\eta_b - \eta_b\nabla\eta_a)\nabla\eta_b
\right]& \\
&+& \int_\Omega\left[
 -\left(
\eta_a\eta_b\nabla\psi + \psi\eta_b\nabla\eta_a + \psi\eta_a\nabla\eta_b
\right) \cdot\nabla\eta_b\right] & \\
&-& \int_\Omega\left[
-\left(
\eta_b^2\nabla\psi
+ 2\psi\eta_b\nabla\eta_b
\right)\cdot\nabla\eta_a\right]&
\Bigg].
\end{aligned}
\end{equation}

##### On-diagonal Jacobian

The on-diagonal jacobian $J_a$ is obtained by taking the derivative with respect to $\eta_{aj}$, where $\frac{\partial \eta_a}{\partial \eta_{aj}} = \phi_j$ and $\frac{\partial \nabla\eta_{aj}}{\partial \eta_{aj}} = \nabla\phi_j$

\begin{equation}
\begin{aligned}
J_a = L_a\sum_{\substack{b\\b\neq a}}\kappa_{ab}
\Bigg[
&\,&\int_\Omega2\psi\left[
(\phi_j\nabla\eta_b - \eta_b\nabla\phi_j)\nabla\eta_b
\right]& \\
&+& \int_\Omega\left[
-\left(
\phi_j\eta_b\nabla\psi + \psi\eta_b\nabla\phi_j + \psi\phi_j\nabla\eta_b
\right)\cdot\nabla\eta_b
\right]& \\
&-& \int_\Omega\left[
-\left(
\eta_b^2\nabla\psi
+ 2\psi\eta_b\nabla\eta_b
\right)\cdot\nabla\phi_j
\right]& \Bigg].
\end{aligned}
\end{equation}

##### Off-diagonal jacobian

For the off diagonal Jacobian entry $J_{ab}$ we take the derivative $\frac{\partial R_a}{\partial \eta_{bj}}$ and obtain

\begin{equation}
\begin{aligned}
J_{ab} =
&\,&
L_a\kappa_{ab}\int_\Omega2\psi\left[
(\eta_a\nabla\phi_j - \phi_j\nabla\eta_a)\nabla\eta_b
+ (\eta_a\nabla\eta_b - \eta_b\nabla\eta_a)\nabla\phi_j
\right] \\
&+& \int_\Omega\left[
-\left( \eta_a\phi_j\nabla\psi + \psi\phi_j\nabla\eta_a + \psi\eta_a\nabla\phi_j \right) \cdot\nabla\eta_b
-\left( \eta_a\eta_b\nabla\psi + \psi\eta_b\nabla\eta_a + \psi\eta_a\nabla\eta_b \right) \cdot\nabla\phi_j
\right] \\
&-& \int_\Omega\left[
%-\left( \eta_b^2\nabla\psi + 2\psi\eta_b\nabla\eta_b \right)\cdot\nabla\eta_a
-\left( 2\eta_b\phi_j\nabla\psi + 2\psi(\phi_j\nabla\eta_b + \eta_b\nabla\phi_j) \right)\cdot\nabla\eta_a
\right]
\end{aligned}\end{equation}

----

1) Note, that in the two-phase case with $\eta_b=1-\eta_a$ this reduces to

\begin{equation}
\begin{aligned}
f_{int}  & = \frac12 \kappa_{ab} \left| \eta_a\nabla(1-\eta_a) - (1-\eta_a)\nabla\eta_a\right|^2 \\
& = \frac12 \kappa_{ab} \left| -\eta_a\nabla\eta_a - \nabla\eta_a + \eta_a\nabla\eta_a\right|^2 \\
& = \frac12 \kappa_{ab} \left| \nabla\eta_a \right|^2,
\end{aligned}
\end{equation}

which is the familiar form implemented by [`ACInterface`](/ACInterface.md).






### ACSwitching / ADACSwitching


`ACSwitching` (and its automatic differentiation version, `ADACSwitching`) implements the terms of the form
\begin{equation}
\frac{\partial h_a}{\partial\eta_{ai}} F_a + \frac{\partial h_b}{\partial\eta_{ai}} F_b + \dots,
\end{equation}
where $a,b,\dots$ are the phases, $h_a, h_b,\dots$ are the switching functions,
$\eta_{ai}$ is the order parameter for the phase/grain that is the nonlinear variable,
and $F_a, F_b,\dots$ are the free energies or grand potentials.





### ADACInterface


Implements the Allen-Cahn term for the $\frac{\kappa_i}2|\nabla \eta_i|^2$
gradient energy contribution for the isotropic mobility case. Its weak form is

\begin{equation}
\left( \kappa_i \nabla \eta_i, \nabla (L_i \psi_m ) \right),
\end{equation}

where $\kappa_i$ (`kappa_name`) is the gradient energy coefficient, $\eta_i$ the
non-conserved non-linear order parameter variable the kernel is acting on, $L_i$
(`mob_name`) is the scalar (isotropic) mobility associated with the order
parameter, and $\psi_m$ is the test function.




### ADACInterfaceKobayashi1


Kernel 1 of 2 for interfacial energy anisotropy in the Allen-Cahn equation as
implemented by R. Kobayashi [!cite](Kobayashi1993).
This kernel implements the first two terms on the right side of eq. (3) of the paper.





### ADACInterfaceKobayashi2


Kernel 2 of 2 for interfacial energy anisotropy in the Allen-Cahn equation as
implemented by R. Kobayashi [!cite](Kobayashi1993).
This kernel implements the third term on the right side of eq. (3) of the paper.





### ADAllenCahn


Implements the term

\begin{equation}
L\frac{\partial f_{bulk}}(\eta)}{\partial\eta},
\end{equation}

where $\eta$ is the variable the kernel is acting on, $L$ (`mob_name`) its
associated mobility, and $f_{bulk}$ (`f_name`) is the bulk free energy density
of the system which is provided by a [function material](../../introduction/FunctionMaterials).

The $\nabla \eta$ dependent terms in the free energy functional of the system
that arise from the gradient interface energy are handled separately in the
[`ADACInterface`](/ADACInterface.md) kernel.





### ADCHSoretMobility


Uses automatic differentiation to add a contribution due to thermo-migration to the Cahn-Hilliard
equation.  Typically used with [ADCHSplitChemicalPotential](/ADCHSplitChemicalPotential.md) and
[ADCHSplitConcentration](/ADCHSplitConcentration.md).   




### ADCHSplitChemicalPotential


Uses automatic differentiation to solve for chemical potential in a weak sense (mu-mu_prop=0).  Can
be coupled to Cahn-Hilliard equation to solve species diffusion.  Allows spatial derivative of
chemical potential when coupled to material state such as stress, etc.  Can be used to model
species diffusion mediated creep.  Typically used with
[ADCHSplitConcentration](/ADCHSplitConcentration.md) and can combined with
[ADCHSoretMobility](/ADCHSoretMobility.md) to incorporate the effects of thermodiffusion.  




### ADCHSplitConcentration


Uses automatic differentiation to solve the Cahn-Hilliard equation using chemical potential as
non-linear variable.  Typically used with
[ADCHSplitChemicalPotential](/ADCHSplitChemicalPotential.md) and can combined with
[ADCHSoretMobility](/ADCHSoretMobility.md) to incorporate the effects of thermodiffusion.  




### ADCoefCoupledTimeDerivative


[`ADCoupledTimeDerivative`](/ADCoupledTimeDerivative.md) with a scalar prefactor $\lambda$ (`coef`)
\begin{equation}
\left(\lambda\frac{\partial v}{\partial t},\psi\right),
\end{equation}
where $v$ (`v`) is a coupled variable.





### ADGrainGrowth


ADGrainGrowth is the automatic differentiation version of the
[ACGrGrPoly](/ACGrGrPoly.md) Kernel and can be activated in the
[GrainGrowthAction](/GrainGrowthAction.md) through the
`use_automatic_differentiation` parameter.

The Kernel implements the bulk part of the grain growth model
[!cite](moelans_quantitative_2008) Allen-Cahn equation
\begin{equation}
\left(L\mu(\eta_i^3-\eta_i+2\gamma\eta_i\sum_{j\neq i}\eta_j^2),\psi\right),
\end{equation}
where $L$ is the mobility, $\eta_i$ the kernel variable, and $\eta_j$ are the
other order parameters. $\mu$ and $\gamma$ are model parameters contributing to
the grain boundary energy $\sigma$ as
\begin{equation}
\sigma = g(\gamma)\sqrt{\kappa\mu},
\end{equation}
where $\kappa$ is the gradient energy coefficient from
[ADACInterface](/ADACInterface.md) and $g$ is a function that needs to be
numerically determined (see [!cite](moelans_quantitative_2008) for details).

$\kappa_{i,j}$ and $\gamma_{i,j}$ could be defined for specific grain boundaries
(grain pairs). This is provided by the [GBAnisotropy](/GBAnisotropy.md)
material.





### ADMatAnisoDiffusion


This is anisotropic version of [`ADMatDiffusion`](/ADMatDiffusion.md), which
expects a tensor valued diffusion coefficient $D$ (`diffusivity`).




### ADSplitCHParsed


Implements the weak form

\begin{equation}
(\frac{\partial F}{\partial c}, \psi) - (\mu,\psi) + (\kappa\nabla c,\nabla\psi)
\end{equation}

where $c$ is the concentration variable the kernel is operating on, $F$ is a
free energy material property (with accompanying derivative properties), $\mu$
is the chemical potential variable, and $\kappa$ is the gradient energy
coefficient.

It is used together with [`ADSplitCHWRes`](/ADSplitCHWRes.md) and
[`ADCoupledTimeDerivative`](/ADCoupledTimeDerivative.md) to set up a system of
two first order PDEs using a concentration order parameter and a chemical
potential variable.





### ADSplitCHWRes


This kernel implements the weak form

\begin{equation}
(M \nabla u, \nabla\psi)
\end{equation}

for the a reverse split Cahn-Hilliard equation, where the kernel variable $u$ is
a chemical potential and $M$ (`mob_name`) is a scalar mobility. It is used
together with [`ADSplitCHParsed`](/ADSplitCHParsed.md) and
[`ADCoupledTimeDerivative`](/ADCoupledTimeDerivative.md) to set up a system of
two first order PDEs using a concentration order parameter and a chemical
potential variable.

For an implementation with an anisotropic (tensorial) mobility see
[`ADSplitCHWResAniso`](/ADSplitCHWResAniso.md).





### ADSplitCHWResAniso


This is anisotropic version of [`ADSplitCHWRes`](/ADSplitCHWRes.md) and expects
a tensor valued mobility $M$.





### AllenCahn


\begin{equation}
L(\eta,a,b,\dots)\frac{\partial f_{bulk}}(\eta,a,b,\dots)}{\partial\eta},
\end{equation}

where $\eta$ is the variable the kernel is acting on, $L$ (`mob_name`) its
associated mobility, and $f_{bulk}$ (`f_name`) is the bulk free energy density
of the system which is provided by a [function material](../../introduction/FunctionMaterials).
$a,b,\dots$ (`args`)  are additional variable dependencies of the mobility and
free energy density.

The $\nabla \eta$ dependent terms in the free energy functional of the system
that arise from the gradient interface energy are handled separately in the
[`ACInterface`](/ACInterface.md) kernel.




### AllenCahnElasticEnergyOffDiag


Calculates the off-diagonal term

\begin{equation}
\frac{\partial\left({L\frac{\delta E}{\delta c}}\right)}{\partial{\mathbf{u}}} = \frac{\partial\left({L\frac{\delta E}{\delta c}}\right)}{\partial{\boldsymbol{\epsilon}}}\frac{\partial{\boldsymbol{\epsilon}}}{\partial{\mathbf{u}}}
\end{equation}

$E$ is the elastic energy, $\boldsymbol{\epsilon}$ is the strain. The first term on the right is a material property called 'd2Fdcdstrain'.

#### Example Input File Syntax

         block=Kernels/off_disp




### AntitrappingCurrent


Implements the antitrapping current term corresponding to alloy solidification [!cite](plapp_unified_2011). The weak form is

\begin{equation}
\left( F(u,v,a,b,\dots) \frac{\nabla v}{|\nabla v|} \frac{\partial v}{\partial t}, \nabla \psi \right),
\end{equation}

where $F$ (`f_name`) is a [FunctionMaterial](/FunctionMaterials.md) providing derivatives, $u$ is the variable the kernel is acting on, $v$ (`v`) is the coupled variable the time derivative is taken of, and $a, b, \dots$ (`args`) are further arguments of the susceptibility function $F$ that contributes to off-diagonal Jacobian entries, and $\psi$ is the test function. Here, $\frac{\nabla v}{|\nabla v|}$ represents the unit normal to the interface.

See also [CoupledSusceptibilityTimeDerivative](/CoupledSusceptibilityTimeDerivative.md)





### CahnHilliard


The kernel acts on the concentration variable $c_i$ and implements the weak form

\begin{equation}
\left(M \sum_j\nabla c_j\frac{\partial^2 f}{\partial c_i c_j}, \nabla \psi\right)
\end{equation}

of the strong form term

\begin{equation}
\nabla M\nabla \frac{\partial f}{\partial c_i},
\end{equation}

where $f(c_i)$ is the local free energy density of the system which depends on an arbitrary
number of concentration variables $c_j$. It uses the relation

\begin{equation}
\nabla \frac{\partial f}{\partial c_i} = \sum_j\nabla c_j\frac{\partial^2 f}{\partial c_i c_j},
\end{equation}

which implies that $f$ cannot be a function of anything but the listed MOOSE variables $c_j$.

$M$ (`mob_name`) is a scalar (isotropic) mobility, and $f$ (`f_name`) is a free energy density
provided by the [function material](../../introduction/FunctionMaterials).

Note that this kernel implements only the component of the free energy functional $F$ that is
*not* depending on $\nabla c$. The $\nabla c$ dependent terms that arise from the gradient
interface energy are handled separately in the [`CHInterface`](/CHInterface.md) kernel.

#### See also

For an anisotropic version of this kernel see [`CahnHilliardAniso`](/CahnHilliardAniso.md),
which expects a tensor valued mobility $M$.




### CahnHilliardAniso


This is anisotropic version of [`CahnHilliard`](/CahnHilliard.md) and expects a tensor valued mobility $M$.

Note that this kernel implements only the component of the free energy functional $F$ that is
*not* depending on $\nabla c$. The $\nabla c$ dependent terms that arise from the gradient
interface energy are handled separately in the [`CHInterface`](/CHInterface.md) kernel.




### ChangedVariableTimeDerivative


#### Overview

This kernel implements the time derivative of a variable that has been converted using a change of variable transformation. So, we transform variable $\phi_i$ to $\psi_i$. It is used in kinetic equations that use a change of variable.

The time derivative becomes
\begin{equation}
    \frac{\partial \phi_i}{\partial t} = \frac{\partial \psi}{\partial t} \frac{\partial \phi}{\partial \psi}.
\end{equation}
The derivative of the transformation $\frac{\partial \phi}{\partial \psi}$ is accessed from a material property, like the linearized interface function implemented in [LinearizedInterfaceFunction](LinearizedInterfaceFunction.md)

#### Example Input File Syntax

The kernel is defined in the input file using the syntax:


Alternatively, this kernel is added automatically by the [GrainGrowthLinearizedInterfaceAction](/GrainGrowthLinearizedInterfaceAction.md).





### CHBulkPFCTrad


Cahn-Hilliard kernel implementing the free energy density
\begin{equation}
f = \frac12c^2\cdot(1-C_0)-\frac16ac^3+\frac1{12}bc^4,
\end{equation}
where $c$ is a PFC density and the coefficients $C_0,a,b$ are provided by
the [`PFCTradMaterial`](PFCTradMaterial.md).




### CHInterface


Implements the Cahn-Hilliard term for the $\frac{\kappa_i}2|\nabla c_i|^2$ gradient
energy contribution for the isotropic mobility case. Its weak form is
\begin{equation}
\left( \kappa_i \nabla^2 c_i, \nabla \cdot (M_i \nabla \psi_m ) \right),
\end{equation}
where $\kappa_i$ (`kappa_name`) is the gradient energy coefficient, $c_i$ the conserved
non-linear order parameter variable the kernel is acting on, $M_i$ (`mob_name`) is
the scalar (isotropic) mobility associated with the order parameter, and $\psi_m$
is the test function.

#### See also

For an anisotropic version of this kernel see [`CHInterfaceAniso`](/CHInterfaceAniso.md),
which expects a tensor valued mobility $M$.




### CHInterfaceAniso


Implements the Cahn-Hilliard term for the $\frac{\kappa_i}2|\nabla c_i|^2$ gradient
energy contribution for the anisotropic mobility case. Its weak form is
\begin{equation}
\left( \kappa_i \nabla^2 c_i, \nabla \cdot (M_i \nabla \psi_m ) \right),
\end{equation}
where $\kappa_i$ (`kappa_name`) is the gradient energy coefficient, $c_i$ the conserved
non-linear order parameter variable the kernel is acting on, $M_i$ (`mob_name`) is
the tensorial (anisotropic) mobility associated with the order parameter, and $\psi_m$
is the test function.




### CHMath


Cahn-Hilliard bulk kernel with a hardcoded free energy density $f$
\begin{equation}
f=\frac14c^4-\frac12c^2,
\end{equation}
where $c$ is the conserved non-linear order parameter variable the kernel is acting
on. The free energy density is minimized at $c=\pm1$.












### CoefCoupledTimeDerivative


[`CoupledTimeDerivative`](/CoupledTimeDerivative.md) with a scalar prefactor $\lambda$ (`coef`)
\begin{equation}
\left(\lambda\frac{\partial v}{\partial t},\psi\right),
\end{equation}
where $v$ (`v`) is a coupled variable.

See [`ADCoefCoupledTimeDerivative`](/ADCoefCoupledTimeDerivative.md) for an AD
version of this object.





### ConservedLangevinNoise







### CoupledAllenCahn


Implements the term
\begin{equation}
L(\eta,a,b,\dots)\frac{\delta F}{\delta\eta} = L(\eta,a,b,\dots)\frac{\partial f(\eta,a,b,\dots)}{\partial\eta}.
\end{equation}

$F$ is the free energy functional of the system that is defined as $F=\int f(\eta) d\Omega$.

$\eta$ (`v`) is a coupled non-conserved order parameter, $L$ (`mob_name`) its associated mobility,
$f$ (`f_name`) is a free energy density provided by a [function material](../../introduction/FunctionMaterials), and
$a,b,\dots$ (`args`) are additional variable dependencies of the mobility and free energy density.

#### See also

For the more common case where $\eta$ is the variable the kernel is acting on see
[`AllenCahn`](/AllenCahn.md).




### CoupledMaterialDerivative


This kernel adds the first derivative $\frac{\partial F}{\partial v}$ of a given
[function material](/phase_field/FunctionMaterials.md) property $F$ (`F`) with respect
to a coupled variable $v$ (`v`).





### CoupledSusceptibilityTimeDerivative


Implements

\begin{equation}
F(u,v,a,b,\dots)\cdot\frac{\partial v}{\partial t},
\end{equation}

where $F$ (`f_name`) is a [FunctionMaterial](/FunctionMaterials.md) providing derivatives
(for example defined using the [DerivativeParsedMaterial](/DerivativeParsedMaterial.md)),
$u$ is the variable the kernel is acting on, $v$ (`v`) is the coupled variable the time
derivative is taken of, and $a, b, \dots$ (`args`) are further arguments of the susceptibility
function $F$ which should contribute to off-diagonal Jacobian entries.

See also [CoupledTimeDerivative](/CoupledTimeDerivative.md).s




### CoupledSwitchingTimeDerivative / ADCoupledSwitchingTimeDerivative


`CoupledSwitchingTimeDerivative` (and its automatic differentiation version, `ADCoupledSwitchingTimeDerivative`) is a coupled time derivative Kernel that multiplies the time derivative term by the following
\begin{equation}
\frac{\partial h_a}{\partial\eta_{ai}} F_a + \frac{\partial h_b}{\partial\eta_{ai}} F_b + \dots,
\end{equation}
where $a,b,\dots$ are the phases, $h_a, h_b,\dots$ are the switching functions,
$\eta_{ai}$ is the order parameter for the phase/grain that is the nonlinear variable,
and $F_a, F_b,\dots$ are the free energies or grand potentials.

See also [CoupledTimeDerivative](/CoupledTimeDerivative.md).




### DiscreteNucleationForce


It implements the weak form term

\begin{equation}
(-M(r) \cdot (v_1 - v_0) + v_0, \psi),
\end{equation}

where $u$ ist the variable the kernel is acting on, $M$ is the
[DiscreteNucleationMap](/DiscreteNucleationMap.md) data, and $\psi$ is a  test
function. The map values $M(r)$ range from 0..1 and are remapped using the $v_0$
(`no_nucleus_value`) and $v_1$ (`nucleus_value`) parameters.

This kernel can be used together with the [Reaction](/Reaction.md) kernel to set
a non-linear variable field to an affine transformation of the discrete
nucleation map data.

The `DiscreteNucleationForce` kernel is part of the
[Discrete Nucleation system](Nucleation/DiscreteNucleation.md). Its companion
AuxKernel is [DiscreteNucleationAux](/DiscreteNucleationAux.md).




### GradientComponent


Implements the weak form residual
\begin{equation}
(u - \nabla_\alpha v, \psi),
\end{equation}
where $u$ is the kernel variable, $\alpha$ (`component`) is a coordinate system
direction, and $v$ is a coupled variable. This term effectively sets the value of the
kernel variable to the value of the selected component of the gradient of a coupled
variable.




### HHPFCRFF


Implements

\begin{equation}
\pm P u,
\end{equation}

where the sign is determined by the `positive` parameter, $P$ (`prop_name`) is a
material property, and $u$ is either a coupled variable (`coupled_var`)
or - if not explicitly specified - the non-linear variable the kernel is operating on.




### KKSACBulkC


KKS Allen-Cahn kernel for the terms with a direct composition dependence.
An instance of this kernel is needed for each solute species of the problem.

##### Residual

\begin{equation}
\begin{aligned}
R&=&-\frac{dh}{d\eta}\left(-\frac{dF_a}{dc_a}(c_a-c_b)\right)\\
&=&\frac{dh}{d\eta}\frac{dF_a}{dc_a}(c_a-c_b)
\end{aligned}
\end{equation}

##### Jacobian

###### On-diagonal

We are looking for the $\frac \partial{\partial u_j}$ derivative of $R$, where
$u\equiv\eta$. We need to apply the chain rule and will again only keep terms
with the $\frac{\partial \eta}{\partial u_j}\frac{\partial}{\partial \eta} = \phi_j \frac{\partial}{\partial \eta}$
derivative.
\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial}{\partial \eta} \left( \frac{dh}{d\eta}\frac{dF_a}{dc_a}(c_a-c_b) \right)\\
&=& \frac{d^2h}{d\eta^2}\phi_j\frac{dF_a}{dc_a}(c_a-c_b)\\
\end{aligned}
\end{equation}

###### Off-diagonal

Since $c_a$ and $c_b$ appear in the residual, their effect must be calculated
separately from any other variable dependence. For $c_a$, we are looking for the
$\frac \partial{\partial u_j}$ derivative of $R$, where $u\equiv c_a$. We need to
apply the chain rule and will again only keep terms with the
$\frac{\partial c_a}{\partial u_j}\frac{\partial}{\partial c_a} = \phi_j \frac{\partial}{\partial c_a}$
derivative.
\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial}{\partial c_a} \left( \frac{dh}{d\eta}\frac{dF_a}{dc_a}(c_a-c_b) \right)\\
&=& \frac{dh}{d\eta} \phi_j \left( \frac{d^2 F_a}{dc_a^2}(c_a-c_b) + \frac{d F_a}{d c_a}\right)\\
\end{aligned}
\end{equation}

Similarly for $c_b$,
\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial}{\partial c_b} \left( \frac{dh}{d\eta}\frac{dF_a}{dc_a}(c_a-c_b) \right)\\
&=& -\frac{dh}{d\eta} \phi_j  \frac{d F_a}{d c_a}\\
\end{aligned}
\end{equation}

For any variable other than $c_a$ or $c_b$, for example temperature $T$:

\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial}{\partial T} \left( \frac{dh}{d\eta}\frac{dF_a}{dc_a}(c_a-c_b) \right)\\
&=& \frac{dh}{d\eta} \phi_j  \frac{\partial}{\partial T}\left(\frac{d F_a}{d c_a}\right) ( c_a - c_b)\\
\end{aligned}
\end{equation}

The off-diagonal Jacobian contributions are again multiplied by the Allen-Cahn
mobility $L$ at each point for consistency with the other terms in the Allen-Cahn
equation.




### KKSACBulkF


KKS Allen-Cahn kernel for the terms without a direct composition dependence.

##### Residual

\begin{equation}
R=-\frac{dh}{d\eta}(F_a-F_b)+w\frac{dg}{d\eta}.
\end{equation}

##### Jacobian

###### On-diagonal

We are looking for the $\frac \partial{\partial u_j}$ derivative of $R$, where
$u\equiv\eta$. We need to apply the chain rule and will again only keep terms
with the $\frac{\partial \eta}{\partial u_j}\frac{\partial}{\partial \eta}=\phi_j \frac{\partial}{\partial\eta}$
derivative.

\begin{equation}
\begin{aligned}
J &=& -\phi_j \frac{\partial}{\partial \eta}\left( \frac{dh}{d\eta}(F_a-F_b) \right) + w \phi_j \frac{\partial}{\partial \eta}\frac{dg}{d\eta} \\
&=&-\frac{d^2h}{d\eta^2}\phi_j(F_a-F_b) + w\frac{d^2g}{d\eta^2}\phi_j \\
\end{aligned}
\end{equation}

(The implicit dependence of $F_a(c_a)$ and $F_b(c_a)$ on $\eta$ through $c_a(c,\eta)$
and $c_b(c,\eta)$ does not contribute to the Jacobian, so
$\frac{\partial F_a}{\partial \eta} = \frac{\partial F_a}{\partial \eta} = 0)$.

###### Off-Diagonal

The off-diagonal components are calculated for any other variables that $F_a$
and $F_b$ depend on. For example, for $c_a$:

\begin{equation}
J = \frac{dh}{d\eta}\left( \frac{\partial F_a}{\partial c_a} - \frac{\partial F_b}{\partial c_a}\right)\phi_j
\end{equation}

$\frac{\partial F_b}{\partial c_a} = 0$ in the KKS formulation, so this term
would not need to be included if $c_a$ was the only variable $F_a$ depended on.
However, the code calculates derivatives with respect to all variables that
$F_a$ and $F_b$ depend on in a general way so that the Jacobian entries for other
dependencies are correctly computed using the same piece of code. For example,
both $F_a$ and $F_b$ could depend on temperature $T$, in which case

\begin{equation}
J = \frac{dh}{d\eta}\left( \frac{\partial F_a}{\partial T} - \frac{\partial F_b}{\partial T}\right)\phi_j
\end{equation}

which is computed using the same code. The off-diagonal Jacobian contribution is
also multiplied by the Allen-Cahn mobility $L$ at each point for consistency with
the other terms in the Allen-Cahn equation.




### KKSCHBulk


Non-split KKS Cahn-Hilliard bulk kernel, which is +not fully implemented+.
The non-linear variable for this Kernel is the concentration $c$.

##### Residual

In the residual routine we need to calculate the term $R=\nabla \frac{dF}{dc}$.
We exploit the KKS identity $\frac{dF}{dc}=\frac{dF_a}{dc_a}=\frac{dF_b}{dc_b}$
and arbitrarily use the a-phase instead.
The gradient can be calculated through the chain rule (note that $F_a(c_a, p_1,p_2,\dots,p_n)$
is potentially a function of many variables).

\begin{equation}
R = \nabla \frac{dF_a}{dc_a} = \frac{d^2F_a}{dc_a^2}\nabla c_a + \sum_i \frac{d^2F_a}{dc_adp_i}\nabla p_i
\end{equation}

With $a = \{c_a, p_1,p_2,\dots,p_n\}$ being the vector of all arguments to $F_a$ this simplifies to

\begin{equation}
R=\sum_i \frac{d^2F_a}{dc_ada_i}\nabla a_i  = \sum_i R_i \nabla a_i
\end{equation}

using $R_i$ as a shorthand for the term $\frac{d^2F_a}{dc_ada_i}$ (and represented
in the code as the array `_second_derivatives[i]`). We do have access to the
gradients of $a_i$ through MOOSE (stored in `_grad\_args[i]`).

##### Jacobian

The calculation of the Jacobian involves the derivative of the Residual term $R$
w.r.t. the individual coefficients $u_j$ of all parameters of $F_a$. Here $u$ can
stand for any variable $a_i$.

\begin{equation}
\frac{dR}{du_j} = \sum_i \left[ \frac d{du_j} R_i\nabla a_i \right] = \sum_i \left[  R_i\frac{d\nabla a_i}{du_j} + \nabla a_i \sum_k \frac {dR_i}{da_k}\frac{da_k}{du_j} \right]
\end{equation}

In the code $u$ is given by `jvar` for the off diagonal case, and $c$
(not $c_a$ or $c_b$!) in the on diagonal case.

###### Off-diagonal

Let's focus on off diagonal first. Here $\frac{da_k}{du_j}$ is zero, if `jvar`
is not equal $k$. Allowing us to remove the sum over $k$ and replace it with the
single non-zero summand

\begin{equation}
\frac{dR}{du_j} = \sum_i \left[  R_i\frac{d\nabla a_i}{du_j} + \nabla a_i \frac {dR_i}{da_\text{jvar}}\frac{da_\text{jvar}}{du_j} \right]
\end{equation}

In the first term in the square brackets the derivative $\frac{d\nabla a_i}{du_j}$
is only non-zero if $i$ is `jvar`. We can therefore pull this term out of the
sum.

\begin{equation}
\frac{dR}{du_j} = R_\text{jvar}\frac{d\nabla a_\text{jvar}}{du_j} + \sum_i  \nabla a_i \frac {dR_i}{da_\text{jvar}}\frac{da_\text{jvar}}{du_j}
\end{equation}

With the rules for $\frac d{du_j}$ derivatives we get

\begin{equation}
R_\text{jvar} \nabla \phi_j + \sum_i \nabla a_i \frac {dR_i}{da_\text{jvar}} \phi_j
\end{equation}

where $j$ is `_j` in the code.

###### On-diagonal

For the on diagonal terms we look at the derivative w.r.t. the components of the
non-linear variable $c$ of this kernel. Note, that $F_a$ is only indirectly a
function of $c$. We assume the dependence is given through $c(c_a)$. The chain
rule will thus yield terms of this form

\begin{equation}
\frac{dc_a}{dc} = \frac{\frac{d^2F_b}{dc_b^2}}{[1-h(\eta)]\frac{d^2F_b}{dc_b^2}+h(\eta)\frac{d^2F_a}{dc_a^2}},
\end{equation}

which is given as equation (23) in KKS. Following the off-diagonal  derivation we get

\begin{equation}
\frac{d^2F_a}{dc_a^2}\frac{dc_a}{dc} \nabla \phi_j + \sum_i \nabla a_i \frac {dR_i}{dc_a} \frac{dc_a}{dc} \phi_j
\end{equation}

###### On-diagonal second approach

Let's get back to the original residual with $\frac{dF}{dc}$. Then

\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{d}{dc} \nabla \frac{dF}{dc}\\
&=& \phi_j  \nabla \frac{d^2F}{dc^2} \quad,\quad \text{with (29) from KKS}\\
&=& \phi_j  \nabla \frac{\frac{d^2F_b}{dc_b^2}\frac{d^2F_a}{dc_a^2}}{  [1-h(\eta)]\frac{d^2F_b}{dc_b^2}+h(\eta)\frac{d^2F_a}{dc_a^2} }\\
\end{aligned}
\end{equation}




### KKSMultiACBulkC


##### Residual

For the 3-phase KKS model, if the non-linear variable is $\eta_1$,

\begin{equation}
R = -\frac{\partial F_1}{\partial c_1} \left( \frac{\partial h_1}{\partial \eta_1} c_1 + \frac{\partial h_2}{\partial \eta_1} c_2 + \frac{\partial h_3}{\partial \eta_1} c_3 \right)
\end{equation}

where $c_i$ is the phase concentration for phase $i$ and $h_i$ is the interpolation
function for phase $i$ defined in [!cite](Folch05) (referred to as $g_i$ there, but we use $h_i$ to maintain consistency with other interpolation functions in MOOSE). Since in the KKS model, chemical potentials are constrained to be equal at each position, $\frac{\partial F_1}{\partial c_1} = \frac{\partial F_2}{\partial c_2} = \frac{\partial F_3}{\partial c_3}$.

##### Jacobian

###### On-diagonal

If the non-linear variable is $\eta_1$, the on-diagonal Jacobian is

\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial R}{\partial \eta_1} \\
&=& -\phi_j \frac{\partial F_1}{\partial c_1} \left( \frac{\partial ^2 h_1}{\partial \eta_1^2} c_1 + \frac{\partial ^2 h_2}{\partial \eta_1^2} c_2 + \frac{\partial ^2 h_3}{\partial \eta_1^2} c_3 \right)
\end{aligned}
\end{equation}

###### Off-diagonal: Phase Concentrations

Since $\frac{\partial F_1}{\partial c_1}$ appears in the residual, the off-diagonal Jacobian for $c_1$ is a little more complicated than for $c_2$ or $c_3$.
\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial R}{\partial c_1} \\
&=& -\phi_j \left( \frac{\partial ^2 F_1}{\partial c_1^2} \left[ \frac{\partial  h_1}{\partial \eta_1 } c_1 + \frac{\partial  h_2}{\partial \eta_1} c_2 + \frac{\partial  h_3}{\partial \eta_1} c_3 \right] + \frac{\partial F_1}{\partial c_1} \frac{\partial h_1}{\partial \eta_1} \right)
\end{aligned}
\end{equation}
For $c_2$,
\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial R}{\partial c_2} \\
&=& -\phi_j \frac{\partial F_1}{\partial  c_1} \frac{\partial  h_2}{\partial  \eta_1}
\end{aligned}
\end{equation}
and similarly for $c_3$. $c_1$ then $c_2$, and $c_3$ are handled first in the code. For the off-diagonal Jacobians we also need to multiply by $L$, the Allen-Cahn mobility.

###### Off-diagonal: Other Coupled Variables

If the non-linear variable is $\eta_1$, the off-diagonal Jacobian for $\eta_2$ is
\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial R}{\partial \eta_2} \\
&=& -\phi_j \frac{\partial F_1}{\partial c_1} \left( \frac{\partial ^2 h_1}{\partial \eta_1 \partial \eta_2} c_1 + \frac{\partial ^2 h_2}{\partial \eta_1 \partial \eta_2} c_2 + \frac{\partial ^2 h_3}{\partial \eta_1 \partial \eta_3} c_3 \right)
\end{aligned}
\end{equation}
and similar for $\eta_3$.

For any other coupled variables, for example temperature $T$
\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial R}{\partial T} \\
&=& -\phi_j \frac{\partial ^2 F_1}{\partial c_1 \partial T} \left( \frac{\partial  h_1}{\partial \eta_1 } c_1 + \frac{\partial  h_2}{\partial \eta_1} c_2 + \frac{\partial  h_3}{\partial \eta_1} c_3 \right)
\end{aligned}
\end{equation}

What's implemented in the code for the off-diagonal Jacobian for $\eta_2$,$\eta_3$ and any other coupled variables such as $T$ is the generalization for the above two equations for non-linear variable $v$:
\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial R}{\partial v} \\
&=& -\phi_j \left[ \frac{\partial^2 F_1}{\partial c_1 \partial v} \left( \frac{\partial h_1}{\partial \eta_1 } c_1 + \frac{\partial h_2}{\partial \eta_1} c_2 + \frac{\partial h_3}{\partial \eta_1} c_3 \right) +  \frac{\partial F_1}{\partial c_1} \left( \frac{\partial ^2 h_1}{\partial \eta_1 \partial v} c_1 + \frac{\partial ^2 h_2}{\partial \eta_1 \partial v} c_2 + \frac{\partial ^2 h_3}{\partial \eta_1 \partial v} c_3 \right) \right]
\end{aligned}
\end{equation}
(This handles everything except for $c_1$, $c_2$, $c_3$, which are handled separately first). For the off-diagonal Jacobians we also need to multiply by $L$, the Allen-Cahn mobility.




### KKSMultiACBulkF


##### Residual

For the 3-phase KKS model, if the non-linear variable is $\eta_1$,

\begin{equation}
R = \left(\frac{\partial h_1}{\partial \eta_1} F_1 + \frac{\partial h_2}{\partial \eta_1} F_2 + \frac{\partial h_3}{\partial \eta_1} F_3 + W_1 \frac{\partial  g_1}{\partial  \eta_1} \right)
\end{equation}

where $c_i$ is the phase concentration for phase $i$ and $h_i$ is the interpolation
function for phase $i$ defined in [!cite](Folch05) (referred to as $g_i$ there, but we use $h_i$ to maintain consistency with other interpolation functions in MOOSE). Here $g_i = \eta_i^2 (1-\eta_i)^2$, also for consistency with notation in MOOSE. $W_1$ is the free energy barrier height.

##### Jacobian

###### On-diagonal

If the non-linear variable is $\eta_1$, the on-diagonal Jacobian is

\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial R}{\partial \eta_1} \\
&=& \phi_j \left( \frac{\partial ^2 h_1}{\partial  \eta_1^2} F_1 + \frac{\partial ^2 h_2}{\partial  \eta_1^2} F_2 + \frac{\partial ^2 h_3}{\partial  \eta_1^2} F_3 + W_1 \frac{\partial ^2 g}{\partial \eta_1^2} \right)
\end{aligned}
\end{equation}

###### Off-diagonal

Off-diagonal Jacobian for $\eta_2$ (similar for $\eta_3$):

\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial R}{\partial \eta_2} \\
&=& \phi_j \left( \frac{\partial ^2 h_1}{\partial  \eta_1 \partial  \eta_2} F_1 + \frac{\partial ^2 h_2}{\partial  \eta_1 \partial  \eta_2} F_2 + \frac{\partial ^2 h_3}{\partial  \eta_1 \partial  \eta_2} F_3 \right)
\end{aligned}
\end{equation}

Off-diagonal Jacobian for $c_1$ (similar for $c_2, c_3$):

\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial R}{\partial c_1} \\
&=& \phi_j \frac{\partial  h_1}{\partial  \eta_1} \frac{\partial  F_1}{\partial  c_1}
\end{aligned}
\end{equation}

These statements can be generalized for non-linear variable $v$ as:

\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial R}{\partial v} \\
&=& \left( \frac{\partial ^2 h_1}{\partial  \eta_1 \partial  v} F_1 + \frac{\partial ^2 h_2}{\partial  \eta_1 \partial  v} F_2 + \frac{\partial ^2 h_3}{\partial  \eta_1 \partial  v} F_3 + \frac{\partial  h_1}{\partial  \eta_1} \frac{\partial  F_1}{\partial  v} + \frac{\partial  h_2}{\partial  \eta_1} \frac{\partial  F_2}{\partial  v} + \frac{\partial  h_3}{\partial  \eta_1} \frac{\partial  F_3}{\partial  v}\right)
\end{aligned}
\end{equation}

For the off-diagonal Jacobians we also need to multiply by $L$, the Allen-Cahn mobility.




### KKSMultiPhaseConcentration


##### Residual

For a KKS model with $n$ phases, the residual of the phase concentration
constraint equation is

\begin{equation}
R = \left( h_1 c_1 + h_2 c_2 + h_3 c_3 + \dots + h_n c_n - c  \right)
\end{equation}

where $c_i$ is the phase concentration for phase $i$, $c$ is the physical solute
concentration, and $h_i$ is the interpolation function for phase $i$ defined in
[!cite](Folch05) (referred to as $g_i$ there, but we use $h_i$ to maintain
consistency with other interpolation functions in MOOSE).

##### Jacobian

###### On-diagonal

Since the non-linear variable for this kernel is $c_n$, the on-diagonal Jacobian is

\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial R}{\partial c_n} \\
&=& \phi_j h_n
\end{aligned}
\end{equation}

###### Off-diagonal

For the physical concentration $c$, the off-diagonal Jacobian is

\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial R}{\partial c} \\
&=& - \phi_j
\end{aligned}
\end{equation}

For phase concentrations $c_i$ other than $c_n$,:

\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial R}{\partial c_i} \\
&=& \phi_j h_i
\end{aligned}
\end{equation}

Finally for the order parameters, such as $\eta_1$,

\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial R}{\partial \eta_1} \\
&=& \phi_j \left( \frac{\partial h_1}{\partial \eta_1} c_1 + \frac{\partial h_2}{\partial \eta_1} c_2 +  \frac{\partial h_3}{\partial \eta_1} c_3      \right)
\end{aligned}
\end{equation}

For the off-diagonal Jacobians we also need to multiply by $L$, the Allen-Cahn
mobility.




### KKSPhaseChemicalPotential


Enforces the point wise
equality of the phase chemical potentials

\begin{equation}
\frac{dF_a}{dc_a}=\frac{dF_b}{dc_b}.
\end{equation}

The non-linear variable of this Kernel is $c_a$.

##### Residual

\begin{equation}
R=\frac{dF_a}{dc_a} - \frac{dF_b}{dc_b}
\end{equation}

##### Jacobian

For the Jacobian we need to calculate

\begin{equation}
J=\frac \partial{\partial u_j}\left( \frac{dF_a}{dc_a} - \frac{dF_b}{dc_b} \right).
\end{equation}

###### On-Diagonal

\begin{equation}
J = \phi_j \left( \frac{\partial^2 F_a}{\partial c_a^2} - \frac{\partial^2 F_b}{\partial c_a \partial c_b} \right)
\end{equation}

###### Off-Diagonal

With $q$ the union of the argument vectors of $F_a$ and $F_b$ (represented in
the code by `_coupled_moose_vars[]`) we get

\begin{equation}
\sum_i \left( \frac{\partial^2 F_a}{\partial c_a \partial q_i}\frac{\partial q_i}{\partial u_j} - \frac{\partial^2 F_b}{\partial c_b \partial q_i}\frac{\partial q_i}{\partial u_j} \right).
\end{equation}

Again the $\frac{\partial q_i}{\partial u_j}$ is non-zero only if $u\equiv q_i$,
which is the case if $q_i$ is the argument selected through `jvar`.

\begin{equation}
J = \frac{\partial^2 F_a}{\partial c_a \partial q_\text{jvar}}\phi_j - \frac{\partial^2 F_b}{\partial c_b \partial q_\text{jvar}}\phi_j.
\end{equation}

Note that in the code `jvar` is not an index into `_coupled_moose_vars[]` but
has to be resolved through the `_jvar_map`.




### KKSPhaseConcentration


Enforces the split of the
concentration into the phase concentrations, weighted by the switching function.
The non-linear variable of this Kernel is $c_b$.

\begin{equation}
c = [1-h(\eta)]c_a+h(\eta)c_b
\end{equation}

##### Residual

\begin{equation}
R=[1-h(\eta)]c_a + h(\eta)c_b - c
\end{equation}

##### Jacobian

###### On-Diagonal

Since the non-linear variable is $c_b$,

\begin{equation}
J= \phi_j \frac{\partial R}{\partial c_b} = \phi_j h(\eta)
\end{equation}

###### Off-Diagonal

For $c_a$

\begin{equation}
J= \phi_j \frac{\partial R}{\partial c_a} = \phi_j [1-h(\eta)]
\end{equation}

For $c$

\begin{equation}
J= \phi_j \frac{\partial R}{\partial c} = -\phi_j
\end{equation}

For $\eta$

\begin{equation}
J= \phi_j \frac{\partial R}{\partial \eta} = \phi_j \frac{dh}{d\eta}(c_b-c_a)
\end{equation}




### KKSSplitCHCRes


[`KKSSplitCHCRes`](/KKSSplitCHCRes.md) is the split version. In this kernel, we calculate the chemical
potential $\mu$ from $\frac{\partial F}{\partial c}$. The non-linear variable for this Kernel
is the concentration $c$. To calculate $\frac{\partial c}{\partial t}$ and
$\nabla \cdot M(c) \nabla \mu$, we use the [`CoupledTimeDerivative`](/CoupledTimeDerivative.md) and
[`SplitCHWRes`](/SplitCHWRes.md) kernels, respectively, as described
[here](phase_field/Phase_Field_Equations.md).

#### Residual

In the residual routine we need to calculate the term $R= \frac{\partial F}{\partial c} - \mu$.
We exploit the KKS identity $\frac{\partial F}{\partial c}=\frac{dF_a}{dc_a}=\frac{dF_b}{dc_b}$
and arbitrarily use the a-phase instead.

\begin{equation}
R = \frac{\partial F_a}{\partial c_a} - \mu
\end{equation}

##### Jacobian

###### On-Diagonal

Since there is no explicit dependence on the non-linear variable $c$ in the residual
equation, the diagonal components are zero.

###### Off-diagonal

We are looking for the $\frac \partial{\partial u_j}$ derivative of $R$, where
$u\equiv c_a$. We need to apply the chain rule and will again only keep terms
with the $\frac{\partial c_a}{\partial u_j}\frac{\partial}{\partial c_a}=\phi_j \frac{\partial}{\partial c_a}$
derivative.

\begin{equation}
\begin{aligned}
J &=& \frac{\partial R}{\partial u_j} = \phi_j \frac{\partial}{\partial c_a} \left( \frac{\partial F}{\partial c_a} - \mu \right)\\
&=& \phi_j  \frac{\partial^2F}{\partial c_a^2} \\
\end{aligned}
\end{equation}

For $\mu$

\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial}{\partial \mu} \left( \frac{\partial F}{\partial c_a} - \mu \right)\\
&=& -\phi_j \\
\end{aligned}
\end{equation}




### LangevinNoise


Adds a uniform noise source term with the weak form
\begin{equation}
(2\chi-1)\alpha P(\vec r)\psi,
\end{equation}
where $\chi$ is a random number in $[0\dots1)$, $\alpha$ (`amplitude`) is a constant
amplitude factor, and $P(\vec r)$ (`multiplier`) is a material property that can be used
as a location dependent mask for the source term.

This kernel does not produce parallel reproducible results. For a parallel reproducible random
noise system see [`ConservedLangevinNoise`](/ConservedLangevinNoise.md)




### LaplacianSplit


Implements the weak form residual
\begin{equation}
\left(\nabla c,\nabla\psi\right)
\end{equation}
for the strong form
\begin{equation}
-\nabla^2c.
\end{equation}

Used together with a [`Reaction`](/Reaction.md) kernel $u$ this allows the construction
of split formulations,
\begin{equation}
u=\nabla^2c,
\end{equation}
where $u$ can be substituted to reduce the order of a PDE.




### MaskedBodyForce


Implements a kernel for a source term/body force limited to a certain region by
a mask $m$ (material property). A function or a postprocessor can also be supplied
to multiply the source term by. Contributions added by this kernel have the form
\begin{equation}
-m C f P
\end{equation}
where $m$ is the mask (supplied as a material property), $C$ is the constant source
term/body force, $f$ is a function (optional), and $P$ is the value of a postprocessor
(optional).





### MaskedExponential


This kernel implements a term in the variationally-derived equivalent form of Poisson's equation
for the electrochemical grand potential sintering model with dilute solution energetics.
It represents the contribution from vacancy species $i$ with state of charge $Z$.
The weak form of this term is
\begin{equation}
h_p Z e n_{v,i} ^{eq} \exp{ \left( \frac{\mu_i - ZeV}{kT} \right) }
\end{equation}
where $h_p$ is the switching function for phase $p$ (which has a value of 1 in phase $p$ and 0 outside that phase),
$Z$ is the state of charge of the vacancy, $e$ is the fundamental electron charge, $n_{v,i} ^{eq}$ is the equilibrium vacancy concentration of species $i$, $\mu_i$ is the chemical potential of species $i$, $V$ is the electric
potential, $k$ is Boltzmann's constant, and $T$ is the temperature in K.





### MatAnisoDiffusion


This is anisotropic version of [`MatDiffusion`](/MatDiffusion.md), which expects
a tensor valued diffusion coefficient $D$ (`diffusivity`).




### MatGradSquareCoupled


Implements the term
\begin{equation}
-P |\nabla \psi|^2,
\end{equation}
where $P$, the prefactor, is a material property, and $\psi$ is a coupled
variable. For a phase-field model coupled with an electrostatic field, the prefactor
should be set using a DerivativeParsedMaterial to
\begin{equation}
P(\eta) = \frac{1}{2} \frac{\partial \epsilon}{\partial \eta},
\end{equation}
where $\epsilon$ is the phase-dependent permittivity and $\eta$ is the order parameter
(which is the nonlinear variable for this kernel), and $\psi$ is the electric potential.






### NestedKKSACBulkC


Kim-Kim-Suzuki (KKS) nested solve kernel (1 of 3). An Allen-Cahn kernel for the terms with a direct composition dependence. This kernel can be used for one or multiple species.

##### Residual

If a model has N species:

\begin{equation}
\begin{aligned}
R&=&-\frac{dh}{d\eta}\left[-\sum_{c=1}^N\frac{dF_a}{dc_a}(c_a-c_b)\right]\\
&=&\frac{dh}{d\eta}\left[\sum_{c=1}^N\frac{dF_a}{dc_a}(c_a-c_b)\right]
\end{aligned}
\end{equation}

##### Jacobian

###### On-diagonal

We are looking for the $\frac \partial{\partial u_j}$ derivative of $R$, where
$u\equiv\eta$. We need to apply the chain rule and will only keep terms
with the $\frac{\partial \eta}{\partial u_j}\frac{\partial}{\partial \eta} = \phi_j \frac{\partial}{\partial \eta}$ derivative.

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial\eta}\left[\frac{dh}{d\eta}\sum_{c=1}^N\left(\frac{\partial F_a}{\partial c_a}(c_a-c_b)\right)\right]    \\
&=&\phi_j\left[\frac{d^2h}{d\eta^2}\sum_{c=1}^N\left(\frac{\partial F_a}{\partial c_a}(c_a-c_b)\right) + \frac{dh}{d\eta}\frac{\partial}{\partial\eta}\left(\sum_{c=1}^N\frac{\partial F_a}{\partial c_a}(c_a-c_b)\right)  \right] \\
&=&\phi_j\left[\frac{dh}{d\eta^2}\sum_{c=1}^N\left(\frac{\partial F_a}{\partial c_a}(c_a-c_b)\right) + \frac{dh}{d\eta}\sum_{c=1}^N\left(\sum_{b=1}^N(\frac{\partial^2F_a}{\partial c_a \partial b_a}\frac{\partial b_a}{\partial\eta})(c_a-b_a) + \frac{\partial F_a}{\partial c_a}(\frac{\partial c_a}{\partial\eta} - \frac{\partial c_b}{\partial\eta})\right)\right]
\end{aligned}
\end{equation}

###### Off-diagonal

Since the partial derivative of phase concentrations $c_a$ w.r.t global concentration $c$ is hidden when computing the $\frac \partial{\partial u_j}$ derivative of $R$, where $u\equiv c$, the derivative w.r.t $c$ must be calculated separately from any other variable dependence. We need to
apply the chain rule and will again only keep terms with the
$\frac{\partial c}{\partial u_j}\frac{\partial}{\partial c} = \phi_j \frac{\partial}{\partial c}$
derivative.

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{dh}{d\eta}\frac{\partial}{\partial c}\left[\sum_{c=1}^N\left(\frac{\partial F_a}{\partial c_a}(c_a-c_b)\right)\right] \\
&=& \phi_j\frac{dh}{d\eta}\sum_{c=1}^N\left(\sum_{b=1}^N(\frac{\partial^2F_a}{\partial c_a\partial b_a}\frac{\partial b_a}{\partial c})(c_a-c_b) + \frac{\partial F_a}{\partial c_a}(\frac{\partial c_a}{\partial c} - \frac{\partial c_b}{\partial c})\right)
\end{aligned}
\end{equation}

If $F_a$ contains any other *explicit* variables, for example temperature $T$:

\begin{equation}
\begin{aligned}
J &=& \phi_j \frac{\partial}{\partial T} \left( \frac{dh}{d\eta}\frac{dF_a}{dc_a}(c_a-c_b) \right)\\
&=& \frac{dh}{d\eta} \phi_j  \frac{\partial}{\partial T}\left(\frac{d F_a}{d c_a}\right) (c_a - c_b)\\
\end{aligned}
\end{equation}

The off-diagonal Jacobian contributions are multiplied by the Allen-Cahn
mobility $L$ at each point for consistency with the other terms in the Allen-Cahn
equation.




### NestedKKSACBulkF


Kim-Kim-Suzuki (KKS) nested solve kernel (2 of 3). An Allen-Cahn kernel for the terms without a direct composition dependence.

##### Residual

\begin{equation}
R = -\frac{dh}{d\eta}(F_a-F_b) + w\frac{dg}{d\eta}
\end{equation}

##### Jacobian

###### On-diagonal

We are looking for the $\frac \partial{\partial u_j}$ derivative of $R$, where
$u\equiv\eta$. We need to apply the chain rule and will only keep terms
with the $\frac{\partial \eta}{\partial u_j}\frac{\partial}{\partial \eta}=\phi_j \frac{\partial}{\partial\eta}$
derivative.

\begin{equation}
\begin{aligned}
J &=& -\phi_j\frac{\partial}{\partial\eta}\left(\frac{dh}{d\eta}(F_a-F_b)\right) + w\phi_j\frac{\partial}{\partial\eta}\frac{dg}{dh}    \\
&=& -\phi_j\left(\frac{d^2h}{d\eta^2}(F_a-F_b) + \frac{dh}{d\eta}\sum_{c=1}^N(\frac{\partial F_a}{\partial c_a}\frac{\partial c_a}{\partial\eta} - \frac{\partial F_b}{\partial c_b}\frac{\partial c_b}{\partial\eta})\right) + w\phi_j\frac{d^2g}{d\eta^2}
\end{aligned}
\end{equation}

###### Off-diagonal

Since the partial derivative of phase concentrations $c_a$ w.r.t global concentration $c$ is hidden when computing the $\frac \partial{\partial u_j}$ derivative of $R$, where $u\equiv c$, the derivative w.r.t $c$ must be calculated separately from any other variable dependence. We need to apply the chain rule and will again only keep terms
with the $\frac{\partial c}{\partial u_j}\frac{\partial}{\partial c}=\phi_j \frac{\partial}{\partial c}$
derivative.

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial c}\left(-\frac{dh}{d\eta}(F_a-F_b) + w\frac{dg}{d\eta}\right)   \\
&=& -\phi_j\frac{dh}{d\eta}\sum_{c=1}^N(\frac{\partial F_a}{\partial c_a}\frac{\partial c_a}{\partial c} - \frac{\partial F_b}{\partial c_b}\frac{\partial c_b}{\partial c})
\end{aligned}
\end{equation}

If $F_a$ and $F_b$ contain any other *explicit* variables, for example temperature $T$:

\begin{equation}
J = -\phi_j\frac{dh}{d\eta}\left( \frac{\partial F_a}{\partial T} - \frac{\partial F_b}{\partial T}\right)
\end{equation}

The off-diagonal Jacobian contribution is multiplied by the Allen-Cahn mobility $L$ at each point for consistency with the other terms in the Allen-Cahn equation.




### NestedKKSMultiACBulkC


Kim-Kim-Suzuki (KKS) nested solve kernel (1 of 3) for multiphase models. An Allen-Cahn kernel for the terms with a direct composition dependence. This kernel can be used for one or multiple species.

##### Residual

$/eta_p$ is the nonlinear variable of this kernel. For a model with $N$ phases:

\begin{equation}
R=-\frac{\partial F_1}{\partial c_{i,1}}\sum_{j=1}^N\frac{\partial h(\eta_j)}{\partial\eta_p}c_{i,j}
\end{equation}

##### Jacobian

###### On-diagonal

We are looking for the $\frac \partial{\partial u_j}$ derivative of $R$, where
$u\equiv\eta_p$. We need to apply the chain rule and will only keep terms
with the $\frac{\partial \eta_p}{\partial u_j}\frac{\partial}{\partial \eta_p} = \phi_j \frac{\partial}{\partial \eta_p}$ derivative.

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial\eta_p} (-\frac{\partial F_1}{\partial c_{i,1}}\sum_{j=1}^N\frac{\partial h(\eta_j)}{\partial\eta_p}c_{i,j})    \\
&=&-\phi_j \left[\frac{\partial^2F_1}{\partial c_{i,1}^2}\frac{\partial c_{i,1}}{\partial\eta_p} \sum_{j=1}^N\frac{\partial h(\eta_j)}{\partial\eta_p}c_{i,j} + \frac{\partial F_1}{\partial c_{i,j}} \sum_{j=1}^N(\frac{\partial^2h(\eta_j)}{\partial\eta_p^2} + \frac{\partial h(\eta_j)}{\partial\eta_p}\frac{\partial c_{i,j}}{\partial\eta_p})  \right]
\end{aligned}
\end{equation}

###### Off-diagonal

Since the partial derivative of phase concentrations $c_{i,j}$ w.r.t global concentration $c_q$ is hidden when computing the $\frac \partial{\partial u_j}$ derivative of $R$, where $u\equiv c_q$, the derivative w.r.t $c_q$ must be calculated separetely from any other variable dependence. We need to
apply the chain rule and will again only keep terms with the
$\frac{\partial c_q}{\partial u_j}\frac{\partial}{\partial c_q} = \phi_j \frac{\partial}{\partial c_q}$
derivative.

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial c_q} (-\frac{\partial F_1}{\partial c_{i,1}}\sum_{j=1}^N\frac{\partial h(\eta_j)}{\partial\eta_p}c_{i,j}) \\
&=& -\phi_j(\frac{\partial^2 F_1}{\partial c_{i,1}^2}\frac{\partial c_{i,j}}{\partial c_q} \sum_{j=1}^N\frac{h(\eta_j)}{\partial\eta_p}c_{i,j} + \frac{\partial F_1}{\partial c_{i,1}} \sum_{j=1}^N\frac{\partial h_j}{\partial\eta_p}\frac{\partial c_{i,j}}{\partial c_q})
\end{aligned}
\end{equation}

If $F_a$ contains any other *explicit* variables, for example temperature $T$:

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial T} (-\frac{\partial F_1}{\partial c_{i,1}}\sum_{j=1}^N\frac{\partial h(\eta_j)}{\partial\eta_p}c_{i,j}) \\
&=& -\phi_j\frac{\partial^2 F_1}{\partial c_{i,1}\partial T} \sum_{j=1}^N\frac{\partial h(\eta_j)}{\partial\eta_p}c_{i,j}
\end{aligned}
\end{equation}

The off-diagonal Jacobian contributions are multiplied by the Allen-Cahn
mobility $L$ at each point for consistency with the other terms in the Allen-Cahn
equation.




### NestedKKSMultiACBulkF


Kim-Kim-Suzuki (KKS) nested solve kernel (2 of 3) for multiphase models. An Allen-Cahn kernel for the terms without a direct composition dependence.

##### Residual
$/eta_p$ is the nonlinear variable of this kernel. For a model with $N$ phases:

\begin{equation}
R = \sum_{j=1}^N\frac{\partial h(\eta_j)}{\partial \eta_p}F_j + w_p\frac{dg_p}{d\eta_p}
\end{equation}

##### Jacobian

###### On-diagonal

We are looking for the $\frac \partial{\partial u_j}$ derivative of $R$, where
$u\equiv\eta_p$. We need to apply the chain rule and will only keep terms
with the $\frac{\partial \eta_p}{\partial u_j}\frac{\partial}{\partial \eta_p}=\phi_j \frac{\partial}{\partial\eta_p}$
derivative.

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial\eta_p}(\sum_{j=1}^N\frac{\partial h(\eta_j)}{\partial \eta_p}F_j) + w_p\phi_j\frac{\partial}{\partial\eta_p}\frac{dg_p}{d\eta_p}    \\
&=& \phi_j\sum_{j=1}^N(\frac{\partial^2 h(\eta_j)}{\partial\eta_p^2} F_j + \frac{\partial h(\eta_j)}{\partial\eta_p} \frac{\partial F_j}{\partial c_{i,j}} \frac{\partial c_{i,j}}{\partial\eta_p}) + w_p\phi_j\frac{d^2g_p}{d\eta_p^2}
\end{aligned}
\end{equation}

###### Off-diagonal

Since the partial derivative of phase concentrations $c_{i,j}$ w.r.t global concentration $c_i$ is hidden when computing the $\frac \partial{\partial u_j}$ derivative of $R$, where $u\equiv c_i$, the derivative w.r.t $c_i$ must be calculated separately from any other variable dependence. We need to apply the chain rule and will again only keep terms
with the $\frac{\partial c_i}{\partial u_j}\frac{\partial}{\partial c_i}=\phi_j \frac{\partial}{\partial c_i}$
derivative.

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial c_i}(\sum_{j=1}^N\frac{\partial h(\eta_j)}{\partial \eta_p}F_j + w_p\frac{dg_p}{d\eta_p})   \\
&=& \phi_j(\sum_{j=1}^N\frac{\partial h(\eta_j)}{\partial\eta_p} \frac{\partial F_j}{\partial c_{i,j}} \frac{\partial c_{i,j}}{\partial c_i})
\end{aligned}
\end{equation}

Similarly, the partial derivative of phase concentrations $c_{i,j}$ w.r.t phase parameter $\eta_k$ is hidden when computing the $\frac \partial{\partial u_j}$ derivative of $R$, where $u\equiv \eta_k$, the derivative w.r.t $\eta_k$ must be calculated separately from any other variable dependence. We need to apply the chain rule and will again only keep terms
with the $\frac{\partial \eta_k}{\partial u_j}\frac{\partial}{\partial \eta_k}=\phi_j \frac{\partial}{\partial \eta_k}$
derivative.

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial \eta_k}(\sum_{j=1}^N\frac{\partial h(\eta_j)}{\partial \eta_p}F_j + w_p\frac{dg_p}{d\eta_p})   \\
&=& \phi_j\sum_{j=1}^N(\frac{\partial^2 h(\eta_j)}{\partial\eta_p \partial\eta_k}F_j + \frac{\partial h(\eta_j)}{\partial\eta_p} \frac{\partial F_j}{\partial c_{i,j}} \frac{\partial c_{i,j}}{\partial\eta_k})
\end{aligned}
\end{equation}

If $F_j$ contains any other *explicit* variables, for example temperature $T$:

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial T} \sum_{j=1}^N\frac{\partial h(\eta_j)}{\partial \eta_p}F_j + w_p\frac{dg_p}{d\eta_p}  \\
&=& \phi_j\sum_{j=1}^N\frac{\partial h(\eta_j)}{\partial\eta_p} \frac{\partial F_j}{\partial T}
\end{aligned}
\end{equation}

The off-diagonal Jacobian contribution is multiplied by the Allen-Cahn mobility $L$ at each point for consistency with the other terms in the Allen-Cahn equation.




### NestedKKSMultiSplitCHCRes


Kim-Kim-Suzuki (KKS) nested solve kernel (3 of 3). A kernel for the split Cahn-Hilliard term. This kernel operates on the global concentration $c_i$ as the non-linear variable.

#### Residual

\begin{equation}
R = \frac{\partial F_1}{\partial c_{i,1}} - \mu,
\end{equation}

where $c_{i,1}$ is the phase concentration of species $i$ in the first phase.

##### Jacobian

###### On-Diagonal

We need to apply the chain rule and will only keep terms
with the $\frac{\partial c_i}{\partial u_j}\frac{\partial}{\partial c_i}=\phi_j \frac{\partial}{\partial c_i}$
derivative. If a system has C components:

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial c_i}(\frac{\partial F_1}{\partial c_{i,1}} - \mu)   \\
&=& \phi_j\sum_{j=1}^C(\frac{\partial^2F_1}{\partial c_{i,1}\partial c_{j,1}}\frac{\partial c_{j,1}}{\partial c_i})
\end{aligned}
\end{equation}

###### Off-diagonal

Since the partial derivative of phase concentrations $c_{i,1}$ w.r.t phase parameter $eta_p$ is hidden when computing the $\frac \partial{\partial u_j}$ derivative of $R$, where $u\equiv \eta_p$, the derivative w.r.t $\eta_p$ must be calculated separately from any other variable dependence. We need to apply the chain rule and will again only keep terms
with the $\frac{\partial \eta_p}{\partial u_j}\frac{\partial}{\partial \eta_p}=\phi_j \frac{\partial}{\partial \eta_p}$ derivative.

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial\eta_p}(\frac{\partial F_1}{\partial c_{i,1}} - \mu)   \\
&=& \phi_j\sum_{j=1}^C(\frac{\partial^2 F_1}{\partial c_{i,1}\partial c{j,1}}\frac{\partial c_{j,1}}{\partial\eta_p})
\end{aligned}
\end{equation}


If $F_1$ contains any other *explicit* variables, for example temperature $T$:

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial T}(\frac{\partial F_1}{\partial c_{i,1}} - \mu)   \\
&=& \phi_j\frac{\partial^2 F_1}{\partial c_{i,1}\partial T }
\end{aligned}
\end{equation}




### NestedKKSSplitCHCRes


Kim-Kim-Suzuki (KKS) nested solve kernel (3 of 3) for two-phase or multiphase models. A kernel for the split Cahn-Hilliard term. This kernel operates on the global concentration $c_i$ as the non-linear variable.

#### Residual

\begin{equation}
R = \frac{\partial F_1}{\partial c_{i,1}} - \mu,
\end{equation}

where $c_{i,1}$ is the phase concentration of species $i$ in the first phase.

##### Jacobian

###### On-Diagonal

We need to apply the chain rule and will only keep terms
with the $\frac{\partial c_i}{\partial u_j}\frac{\partial}{\partial c_i}=\phi_j \frac{\partial}{\partial c_i}$
derivative. If a system has C components:

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial c_i}(\frac{\partial F_1}{\partial c_{i,1}} - \mu)   \\
&=& \phi_j\sum_{j=1}^C(\frac{\partial^2F_1}{\partial c_{i,1}\partial c_{j,1}}\frac{\partial c_{j,1}}{\partial c_i})
\end{aligned}
\end{equation}

###### Off-diagonal

Since the partial derivative of phase concentrations $c_{i,1}$ w.r.t phase parameter $eta_p$ is hidden when computing the $\frac \partial{\partial u_j}$ derivative of $R$, where $u\equiv \eta_p$, the derivative w.r.t $\eta_p$ must be calculated separately from any other variable dependence. We need to apply the chain rule and will again only keep terms
with the $\frac{\partial \eta_p}{\partial u_j}\frac{\partial}{\partial \eta_p}=\phi_j \frac{\partial}{\partial \eta_p}$ derivative.

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial\eta_p}(\frac{\partial F_1}{\partial c_{i,1}} - \mu)   \\
&=& \phi_j\sum_{j=1}^C(\frac{\partial^2 F_1}{\partial c_{i,1}\partial c{j,1}}\frac{\partial c_{j,1}}{\partial\eta_p})
\end{aligned}
\end{equation}


If $F_1$ contains any other *explicit* variables, for example temperature $T$:

\begin{equation}
\begin{aligned}
J &=& \phi_j\frac{\partial}{\partial T}(\frac{\partial F_1}{\partial c_{i,1}} - \mu)   \\
&=& \phi_j\frac{\partial^2 F_1}{\partial c_{i,1}\partial T }
\end{aligned}
\end{equation}




### SimpleACInterface



This kernel implements the weak form
\begin{equation}
(\kappa L \nabla u, \nabla\psi)
\end{equation}
for the gradient contribution in the Allen-Cahn equation. For a more feature complete
version see the [`ACInterface`](/ACInterface.md) kernel, which allows for variable
dependent mobilities $M$ and gradient energy parameters $\kappa$.




### SimpleCHInterface



This kernel implements the weak form
\begin{equation}
(\kappa M \nabla^2 u, \nabla^2\psi)
\end{equation}
for the gradient contribution in the Cahn-Hilliard equation. For a more feature complete
version see the [`CHInterface`](/CHInterface.md) kernel, which allows for variable
dependent mobilities $M$ and gradient energy parameters $\kappa$.

This kernel requires the use of high order shape functions (e.g. third order Hermite).





### SimpleCoupledACInterface



This kernel implements the weak form
\begin{equation}
(\kappa L \nabla \eta, \nabla\psi)
\end{equation}
for the gradient contribution in a coupled Allen-Cahn equation.
For the more common case where $\eta$ is the variable the kernel is acting on see
[`SimpleACInterface`](/SimpleACInterface.md).





### SimpleSplitCHWRes



This kernel implements the weak form
\begin{equation}
(M \nabla u, \nabla\psi)
\end{equation}
for the a reverse split Cahn-Hilliard equation. For a more feature complete
version see the [`SplitCHWRes`](/SplitCHWRes.md) kernel, which computes a full Jacobian
even for variable dependent mobilities $M$.





This kernel is part of a set of *simplified* phase field kernels that have been
created for educational purposes. These kernels use simplified formulations with
limitations that prohibit spatially varying mobilities and gradient energies.
The source code of these kernels is kept simple without using advanced C++ features.



### SLKKSChemicalPotential


Implements
\begin{equation}
\frac 1{a_{jk}} \frac{\partial F_j}{\partial c_{ijk}} = \frac 1{a_{jk'}} \frac{\partial F_j}{\partial c_{ijk'}}
\end{equation}

where $c_{ijk}$ and $c_{ijk}$ are two sublattice concentrations (for sublattices $k$ and $k'$) in the same phase $j$, for component $i$.




### SLKKSMultiACBulkC


Implements the weak form
\begin{equation}
\left( -M\frac1{a_{jk}}\frac{\partial F_j}{\partial c_ijk} \sum_j \frac{\partial h_j}{\partial \eta_j}\sum_k c_{ijk}a_{jk},\psi\right)
\end{equation}

where $c_i$ is the phase concentration for phase $i$ and $h_i$ is the interpolation
function for phase $i$ defined in [!cite](Folch05) (referred to as $g_i$ there, but we use $h_i$ to maintain consistency with other interpolation functions in MOOSE). Since in the KKS model, chemical potentials are constrained to be equal at each position, $\frac{\partial F_1}{\partial c_1} = \frac{\partial F_2}{\partial c_2} = \frac{\partial F_3}{\partial c_3}$.




### SLKKSMultiPhaseConcentration


For a sub lattice KKS (SLKKS) model with $n$ phases, the phase concentration
constraint equation is
\begin{equation}
 c_i = \sum_j h_j\sum_k a_{jk} c_{ijk},
\end{equation}
where $i$ indexes a component, $j$ a phase, and $k$ a sublattice in the given
phase. $a_{jk}$ is the fraction of $k$ sublattice sites in phase $j$. Thus $c_i$
is the global concentration of component $i$ and $h_j$ is the interpolation
function for phase $j$.

The version of this class for a two phase model with a single switching function
is [SLKKSPhaseConcentration](/SLKKSPhaseConcentration.md).




### SLKKSPhaseConcentration


This class is the two-phase version of
[SLKKSMultiPhaseConcentration](/SLKKSMultiPhaseConcentration.md).

For a sub lattice KKS (SLKKS) model with two phases $\alpha$ and $\beta$, the
phase concentration constraint equation is
\begin{equation}
 c_i = h\sum_k a_{\alpha k} c_{i\alpha k} + (1-h)\sum_k a_{\beta k} c_{i\beta k}
\end{equation}
where $i$ indexes a component and $k$ a sublattice in the given phase.
$a_{\alpha k}$ and $a_{\beta k}$ is the fraction of $k$ sublattice sites in
phases $\alpha$ and $\beta$. Thus $c_i$ is the global concentration of component
$i$ and $h$ is the phase switching function.




### SLKKSSum


#### Overview

This kernel is used if the simulation only contains a single phase with multiple
sublattices. Otherwise
[`SLKKSMultiPhaseConcentration`](SLKKSMultiPhaseConcentration.md) needs to be used.

One potential application is a static solve for the sublattice concentrations
(and free energy) of a single phase. This information can be used to tabulate
sublattice concentrations as functions of total concentrations to inform
initial conditions of full solve simulations.

##### See also

- `modules/phase_field/examples/slkks/CrFe_sigma`  for an example input that tabulates the sublattice concentrations of the Fe-Cr sigma phase
- `modules/phase_field/examples/slkks/CrFe`  for an example input for a full solve that uses the tabulated sublattice concentrations to set the initial conditions

#### Example Input File Syntax





### SoretDiffusion


Implements weak form

\left(\frac{D\cdot Q\cdot c}{k_B\cdot T^2}, \nabla T \cdot\nabla \psi\right),

where $c$ is the concentration variable the kernel is operating on, $Q$ the heat
of transport, and $D$ the diffusivity.

It is used together with [`SplitCHWRes`](/SplitCHWRes.md),
[`SplitCHParsed`](/SplitCHParsed.md), and
[`CoupledTimeDerivative`](/CoupledTimeDerivative.md) to set up a system of two
first order PDEs using a concentration order parameter and a chemical potential
variable.





### SplitCHMath


Implements the bulk free energy density

f_\text{bulk}(c) = \frac14(1-c)^2(1+c)^2

where $c$ is the concentration variable the kernel is operating on. The minima
of this free energy density lie at $c=1$ and $c=-1$.

It is used together with [`SplitCHWRes`](/SplitCHWRes.md) and
[`CoupledTimeDerivative`](/CoupledTimeDerivative.md) to set up a system of two
first order PDEs using a concentration order parameter and a chemical potential
variable.





### SplitCHParsed


Implements the weak form

\begin{equation}
(\frac{\partial F}{\partial c}, \psi) - (\mu,\psi) + (\kappa\nabla c,\nabla\psi)
\end{equation}

where $c$ is the concentration variable the kernel is operating on, $F$ is a
free energy material property (with accompanying derivative properties), $\mu$
is the chemical potential variable, and $\kappa$ is the gradient energy
coefficient.

It is used together with [`SplitCHWRes`](/SplitCHWRes.md) and
[`CoupledTimeDerivative`](/CoupledTimeDerivative.md) to set up a system of two
first order PDEs using a concentration order parameter and a chemical potential
variable.





### SplitCHWRes


This kernel implements the weak form
\begin{equation}
(M \nabla u, \nabla\psi)
\end{equation}
for the a reverse split Cahn-Hilliard equation, where the kernel variable $u$ is
a chemical potential and $M$ (`mob_name`) is a scalar mobility. It is used
together with [`SplitCHParsed`](/SplitCHParsed.md) and
[`CoupledTimeDerivative`](/CoupledTimeDerivative.md) to set up a system of two
first order PDEs using a concentration order parameter and a chemical potential
variable.

#### Off-diagonal Onsager Matrix

The terms containing the off-diagonal components of the Onsager
phenomenological transport coefficients model the driving force resulting from
coupled order parameters. These terms are implemented using this kernel by
specifying a different coupled chemical potential variable $w$ than the kernel
variable using the `w` parameter.
\begin{equation}
(M \nabla w, \nabla\psi)
\end{equation}

The strong form of such a coupled system with two variables $c_1$ and $c_2$
would be
\begin{equation}
\begin{aligned}
\frac{\partial c_1}{\partial t} &= \nabla\cdot M_{11} \nabla \frac{\delta F}{\delta c_1} + \nabla\cdot  M_{12} \nabla \frac{\delta F}{\delta c_2}\\
\frac{\partial c_2}{\partial t} &= \nabla\cdot  M_{21} \nabla \frac{\delta F}{\delta c_1} + \nabla\cdot  M_{22} \nabla \frac{\delta F}{\delta c_2}.
\end{aligned}
\end{equation}

And the MOOSE implementation would be



For an implementation with an anisotropic (tensorial) mobility see
[`SplitCHWResAniso`](/SplitCHWResAniso.md).





### SplitCHWResAniso


This is anisotropic version of [`SplitCHWRes`](/SplitCHWRes.md) and expects a tensor valued mobility $M$.





### SusceptibilityTimeDerivative / ADSusceptibilityTimeDerivative


`SusceptibilityTimeDerivative` (and its automatic differentiation version, `ADSusceptibilityTimeDerivative`) implements

\begin{equation}
F(u,a,b,\dots)\cdot\frac{\partial u}{\partial t},
\end{equation}

where $F$ (`f_name`) is a [FunctionMaterial](/FunctionMaterials.md) providing derivatives
(for example defined using the [DerivativeParsedMaterial](/DerivativeParsedMaterial.md)),
$u$ is the kernel variable the time derivative is taken of, and $a, b, \dots$ (`args`)
are further arguments of the susceptibility function $F$ which should contribute to
off-diagonal Jacobian entries.

See also [TimeDerivative](/TimeDerivative.md).




### SwitchingFunctionConstraintEta


Enforces the constraint $k = \sum_i\eta_i - 1 - \epsilon\lambda$.
See [Multiphase models](/MultiPhase/WBM.md) for the full derivation.




### SwitchingFunctionConstraintLagrange


Enforces the constraint $k = \sum_i\eta_i - 1 - \epsilon\lambda$.
See [Multiphase models](/MultiPhase/WBM.md) for the full derivation.




### SwitchingFunctionPenalty


The penalty is added in the form of a free energy term

F_p=\gamma k(\vec \eta)^2,

where $\gamma$ is the penalty prefactor (`penalty`) and $k = 1-\sum_i\eta_i$ is
the constraint. The constraint is enforced approximately to a tolerance of
$\frac1\gamma$ (depending on the shape and units of the free energy).

Also see: [Multiphase models](/MultiPhase/WBM.md)




## markers

### DiscreteNucleationMarker


The DiscreteNucleationMarker triggers mesh refinement for the nucleus geometry.
It is up to the user to specify refinement for the physics. The nucleation
system marker and the physics marker(s) must be combined using a
[ComboMarker](/ComboMarker.md) to combine their effect.

The `DiscreteNucleationMarker` is part of the
[Discrete Nucleation system](Nucleation/DiscreteNucleation.md).





## materials

### ADInterfaceOrientationMaterial


Material to compute the angular orientation of order parameter interfaces.
See Kobayashi [!cite](Kobayashi1993), final (non-numbered) equation
on p. 412. doi:10.1016/0167-2789(93)90120-P





### ADMathFreeEnergy

This material implements an analytical double well free energy

\begin{equation}
F = \frac14(1 + c)^2(1 - c)^2
\end{equation}

and its first order derivatives. Both provided properties furthermore come with
forward mode automatic derivatives with respect to all degrees of freedom on the
current element.

This free energy can be used with the AD version of the split Cahn-Hilliard
equation ([`ADSplitCHWRes`](/ADSplitCHWRes.md) and
[`ADSplitCHParsed`](/ADSplitCHParsed.md)).







### BarrierFunctionMaterial


Two phase free energy phase transformation barrier term.
With the `g_order` parameter set to `SIMPLE` the function is defined as

\begin{equation}
g(\eta) = \eta^2(1-\eta)^2
\end{equation}

and with the  `g_order` parameter set to `LOW` it is defined as

\begin{equation}
g(\eta) = \eta(1-\eta)
\end{equation}

and with the  `g_order` parameter set to `HIGH` it is defined as

\begin{equation}
g(\eta) = \eta^2(1-\eta^2)^2
\end{equation}






### ComputeGBMisorientationType

ComputeGBMisorientationType uses an EBSDReader object and a Grain Tracker object to calculate the grain boundary (GB) type based on the misorientation angle. There are two kind of GB type: Low Angle GB (LAGB) and High Angle GB (HAGB). When the misorientation angle is smaller than the critical angle, 15˚, the GB type is defined as LAGB, and it is defined as HAGB for higher misorientation angles. The critical angle can be modified with the [!param](/Materials/ComputeGBMisorientationType/angle_threshold) parameter. 

#### Description and Syntax








### CoupledValueFunctionFreeEnergy


CoupledValueFunctionFreeEnergy evaluates MOOSE Functions with a set of up to
four coupled variable values `v` as its input parameters. The coupled variable
values are substituted for the `x`,`y`,`z`, and `t` function variables in that
order.

Functions for the free energy (optional) and the chemical potentials for the
coupled variables can be supplied. Derivatives of the chemical potentials are
computed automatically using the `gradient` and `timeDerivative` methods of the
`MooseFunction` class.

One example application is the use of
[`PiecewiseMultilinear`](PiecewiseMultilinear.md) functions with data files
containing pretabulations of Gibbs energy and chemical potentials as a function
of up to four primary variable values.




### CrossTermBarrierFunctionMaterial


The material provides a function $g(\vec\eta)$ that is parameterized by all
phase order parameters $\eta$. It calculates a phase transformation barrier energy
that contains contributions for pairs of order parameters.

With the `g_order` parameter set to `SIMPLE` the function is defined as

\begin{equation}
g(\vec\eta) = 16\sum_i\sum_{j>i} W_{ij} \eta_i^2\eta_j^2
\end{equation}

and with the  `g_order` parameter set to `LOW` it is defined as

\begin{equation}
g(\vec\eta) = 16\sum_i\sum_{j>i} W_{ij} \eta_i\eta_j
\end{equation}

The $W_{ij}$ is a matrix of all coefficients for the pair terms.








### DerivativeTwoPhaseMaterial


The simplified +two-phase model+ uses a single order parameter to switch between the two phases. A global free energy is constructed using a meta material class that combines the phase free energies.

For two phase models the `DerivativeTwoPhaseMaterial` can be used to combine two phase
free energies into a global free energy (which the [`AllenCahn`](/AllenCahn.md)
and [`Cahn-Hilliard`](/CahnHilliard.md) kernels use to evolve the system) as

\begin{equation}
F = \left(1-h(\eta)\right) F_a + h(\eta)F_b + Wg(\eta)
\end{equation}



Note that the phase free energies usually have single well character. The global free energy
landscape will however have a double well character in the examples above.


### DiscreteNucleation


The nucleation material computes a local free energy density contribution

\begin{equation}
F_{nuc} = \gamma\sum_i (c_i-c_{0,i})^2.
\end{equation}

The `DiscreteNucleation` material is part of the [Discrete Nucleation system](Nucleation/DiscreteNucleation.md).




### ElasticEnergyMaterial


This material generates an elastic free energy contribution consistent with the
TensorMechanics stress divergence kernels. This allows for proper coupling of
the phase field problem and the mechanics problem. The contribution of the
`ElasticEnergyMaterial` and the chemical free energy (possibly defined using a
`DerivativeParsedMaterial`) are then summed up using a `DerivativeSumMaterial`
to form a _total free energy_ which is passed to the phase field kernels.

The `ElasticEnergyMaterial` applies a _linear_ elasticity model. It couples in
the strain $\epsilon$ and the elasticity tensor $C_{ijkl}$ to compute the elastic
energy

\begin{equation}
E = \frac12 C_{ijkl} \epsilon_{ij} \epsilon_{kl}.
\end{equation}

The material utilizes the derivatives of $C$ and $\epsilon$ to provide the
derivatives of $E$, which are required by the phase field equations.

```yaml
[Materials]
  # material subblocks that define stress and elasticity tensor properties
  # (and necessary derivatives) are omitted

  [./elasticenergy]
    type = ElasticEnergyMaterial
    args = 'c'
  [../]
[]
```




### ElectrochemicalDefectMaterial

The ElectrochemicalDefectMaterial defines the susceptibility $\chi$ and defect densities $n^s, n^v$
in the solid and void phases for a defect species
in the electrochemical sintering model. One instantiation of this material must be included for
each defect species. Other material properties for this model are calculated by the
ElectrochemicalSinteringMaterial, which also must be included.

There are two energy models that can be used for the solid phase: parabolic
($f_s = \frac12k_s(c_s-c_s^{eq})^2$) and dilute ($f_s = \frac{E_f}{V_a}+\frac{k_BT}{V_a}(c \ln c - c)$).
The void phase uses a parabolic free energy. There is also a contribution to the grand potential
from the electric potential of the form $\frac12 \epsilon | \nabla V|^2$.

The equilibrium solid-phase vacancy concentrations for defect species are determined in separate
materials and need to be supplied to this one.
This is done to maximize the flexibility of the sintering model to include effects
such as GB vacancy segregation and stoichiometry effects.





### ElectrochemicalSinteringMaterial

Defines switching functions and thermodynamic parameters for the electrochemical grand potential
sintering model. In this model, an arbitrary number of charged defect species can exist.
The ElectrochemicalSinteringMaterial defines switching functions for void and solid
phases as well as switching functions for solid and grain boundary regions.
It also defines the grand potential densities, and the phase field free energy terms
$m$, $\kappa$, and $\gamma$.
For each defect species, an ElectrochemicalDefectMaterial object must also be included to
calculate the susceptibility and densities in each phase.

There are two energy models that can be used for the solid phase: parabolic
($f_s = \frac12k_s(c_s-c_s^{eq})^2$) and dilute ($f_s = \frac{E_f}{V_a}+\frac{k_BT}{V_a}(c \ln c - c)$).
The void phase uses a parabolic free energy. There is also a contribution to the grand potential
from the electric potential of the form $\frac12 \epsilon | \nabla V|^2$.

The equilibrium solid-phase vacancy concentrations for defect species are determined in separate
materials and need to be supplied to this one.
This is done to maximize the flexibility of the sintering model to include effects
such as GB vacancy segregation and stoichiometry effects.









### GasFreeEnergyBase

$n_Q$ is the _quantum concentration_ defined by

\begin{equation}
n_Q = \left(\frac{2\pi m k_B T}{h^2}\right)^\frac32.
\end{equation}

Here $m$ (`m`) is the gas atom mass, which by default us specified in atomic mass
units $u$ (this can be customized using the `mass_unit_conversion`). $T$ (`T`) is
the coupled temperature, $n$ is defined as

\begin{equation}
n= \frac NV = \frac c\Omega,
\end{equation}

where $c$ (`c`) is the coupled concentration and $\Omega$ (`omega`) is the lattice
site volume.







### GBEvolution


#### Overview

This material calculates the order parameter mobility $L$, the free energy prefactor $\mu$, and the gradient multiplier $\kappa$ for the grain growth model from [!cite](moelans_quantitative_2008), assuming isotropic grain boundary (GB) properties and a symmetric interfacial profile ($\gamma=1.5$). The parameters are calculated based on the GB energy $\sigma$, the GB mobility $M_{GB}$, and the phase field interfacial width $w_{GB}$ according to

\begin{equation}
L = \frac{4}{3} \frac{M_{GB}}{w_{GB}}
\end{equation}
\begin{equation}
\mu = 6 \frac{\sigma}{w_{GB}}
\end{equation}
\begin{equation}
\kappa = \frac{3}{4} \sigma w_{GB}.
\end{equation}

The GB mobility can be defined in terms of the temperature $T$ using an Arrhenius expression

\begin{equation}
  M_{GB} = M_0 \exp\left( -\frac{Q}{k_b T} \right),
\end{equation}
where $M_0$ is the mobility prefactor, $Q$ is the activation energy, and $k_b$ is the Boltzmann constant.

#### Example Input File Syntax









### GrandPotentialInterface


The multiphase Grand Potential model is parameterized using a bulk free energy
coefficient $\mu$, a gradient interface coefficient $\kappa$, and a set of
interface pair coefficients $\gamma_{\alpha i \beta j}$ [!cite](AagesenGP2018).
Note that this model is a multi phase / poly crystal model and the indices
$\alpha$ and $\beta$ represent phases and $i$ and $j$ represent grains.

This material class provides the above mentioned parameters and calculates them
using the physical parameters of the free energy area density $\sigma_{\alpha i
\beta j}$ (`sigma`) for the interface between each pair of phases, and an
interface width $l$ (`width`).

To compute the parameters first either the median of all $\sigma_{\alpha i \beta
j}$ is chosen or, if supplied by the user, the $\sigma_{\alpha i \beta j}$ entry
with the index `sigma_index` is chosen (overriding the median computation).  The
chosen $\sigma_{\alpha i \beta j}$ is assigned a value $\gamma_{\alpha i \beta
j}=1.5$. For this gamma value a set of analytical expressions holds

\begin{equation}
\begin{aligned}
\kappa &= \frac 34 \sigma_{\alpha i \beta j} l_{\alpha i \beta j}\\
\mu &= \frac{6 \sigma_{\alpha i \beta j}} {l_{\alpha i \beta j}}.
\end{aligned}
\end{equation}

Note that the interface with $l$ (`width`) is only guaranteed for the interface
with either the median $\sigma_{\alpha i \beta j}$ or - if provided - the index
supplied in `sigma_index`. All other interface widths are a function of their
respective interfacial free energies.

With $\kappa$ and $\mu$ determined the remaining $\gamma_{\alpha i \beta j}$ can
be computed using the fitted relation [!cite](MoelansWeb)

\begin{equation}
\begin{aligned}
g_{\alpha i \beta j} &= \frac{\sigma_{\alpha i \beta j}}{\sqrt{\mu\kappa}}  \\
\gamma_{\alpha i \beta j} &= \left( -5.288 g_{\alpha i \beta j}^8 -0.09364 g_{\alpha i \beta j}^6 + 9.965 g_{\alpha i \beta j}^4 -8.183 g_{\alpha i \beta j}^2 + 2.007 \right)^{-1}.
\end{aligned}
\end{equation}

The material propertied provided by this class are directly used by the
[`ACGrGrMulti`](/ACGrGrMulti.md) and [`ACInterface`](/ACInterface.md) objects
and indirectly used by the
[GrandPotentialKernelAction](/actions/GrandPotentialKernelAction.md).





### GrandPotentialSinteringMaterial

Defines switching functions and thermodynamic parameters for the grand potential
sintering model.
The GrandPotentialSinteringMaterial defines switching functions for void and solid
phases as well as switching functions for solid and grain boundary regions.
It also defines the susceptibility, vacancy densities and concentrations, potential
densities, and the phase field free energy terms $m$, $\kappa$, and $\gamma$.

There are three energy models that can be used for the solid-phase: parabolic
($f_s = \frac12k_s(c_s-c_s^{eq})^2$), dilute ($f_s = \frac{E_f}{V_a}+\frac{k_BT}{V_a}(c \ln c - c)$),
and ideal ($f_s = c\frac{E_f}{V_a} + \frac{k_BT}{V_a}[c\ln c + (1-c)\ln(1-c)]$).

The equilibrium solid-phase vacancy concentration is determined in a separate
material and referenced by this one.
This is done to maximize the flexibility of the sintering model to include effects
such as GB vacancy segregation and stoichiometry effects.

Additional option for strict mass conservation formulation can be defined using 'mass_conservation' flag set to "true", which generates the coefficients for void and solid phases.





### GrandPotentialTensorMaterial

Mobility calculations for the grand potential model using a tensor vacancy mobility.
GrandPotentialTensorMaterial calculates the vacancy mobility tensor $\mathbf{M}=\chi \mathbf{D}$
and the solid and void phase order parameter mobilities $L=\frac43 \frac{M}l$.

This material uses the diffusion tensor defined in ```DiffMtrxBase``` for the vacancy
diffusivity.





### IdealGasFreeEnergy


This material defines the Helmholtz free energy density $f$ of an ideal Boltzmann gas.

\begin{equation}
f = \frac FV = \frac 1V(U - TS) = -nk_BT\left(1+\ln\frac {n_Q}n\right)
\end{equation}

where




### InterfaceOrientationMaterial


Material to compute the angular orientation of order parameter interfaces.
See Kobayashi [!cite](Kobayashi1993), final (non-numbered) equation
on p. 412. doi:10.1016/0167-2789(93)90120-P





### InterfaceOrientationMultiphaseMaterial


This Material accounts for the orientation dependence of interfacial energy for multi-phase multi-order parameter phase-field model. It is assumed interface parameter $\kappa$ is a function of gradients of order parameters.




### KKSPhaseConcentrationDerivatives

Kim-Kim-Suzuki (KKS) nested solve material (part 2 of 2). KKSPhaseConcentrationDerivatives computes the partial derivatives of phase concentrations w.r.t global concentrations and phase parameters, for example, $\frac{\partial c_a}{\partial c}$, where $c$ is the global concentration and $c_a$ is the phase concentration of species $c$ in phase $a$. Another example is $\frac{\partial c_b}{\eta}$ where $\eta$ is one of the two phase parameters in the model and $c_b$ is the phase concentration of species $c$ in phase $b$. These partial derivatives are used in KKS kernels as chain rule terms in the residual and Jacobian. The expressions for the derivatives were presented in [!cite](kim_phase-field_1999)

#### Example input:


#### Class Description





### KKSPhaseConcentrationMaterial

Kim-Kim-Suzuki (KKS) nested solve material (part 1 of 2). KKSPhaseConcentrationMaterial implements a nested Newton iteration to solve the KKS constraint equations for the phase concentrations $c_a$ and $c_b$ as material properties (instead of non-linear variables as in the traditional solve in MOOSE). The constraint equations are the mass conservation equation for each global concentration ($c$):

\begin{equation}
c=\left(1-h(\eta)\right)c_a + h(\eta)c_b,
\end{equation}

and the pointwise equality of the phase chemical potentials:

\begin{equation}
\frac{\partial f_a}{\partial c_a} = \frac{\partial f_b}{\partial c_b}.
\end{equation}

The parameters Fa_material and Fb_material must have [!param](/Materials/KKSPhaseConcentrationMaterial/compute) set to `false`. This material also passes the phase free energies and their partial derivatives w.r.t phase concentrations to the KKS kernels (NestKKSACBulkC, NestKKSACBulkF, NestKKSSplitCHCRes).

#### Example input:

##### Without damping

Parabolic free energies have valid values for any real number, and therefore don't require damping to ensure the solution is inside a trust region.


##### With damping

Log free energies are only valid when the component phase mole fractions are within 0 to 1. We add a material `C` that checks if the nested solve guess is within this trust region. Similar to the free energy, `C` must have [!param](/Materials/KKSPhaseConcentrationMaterial/compute) set to `false`. The nested solve then requires damping to ensure the solution is inside the trust region.


#### Class Description





### KKSPhaseConcentrationMultiPhaseDerivatives

Kim-Kim-Suzuki (KKS) nested solve material for multiphase models (part 2 of 2). KKSPhaseConcentrationMultiPhaseDerivatives computes the partial derivatives of phase concentrations w.r.t global concentrations and phase parameters, for example, $\frac{\partial c_{i,p}}{\partial c_i}$, where $c_i$ is the global concentration and $c_{i,p}$ is the phase concentration of species $i$ in phase $p$. Another example is $\frac{\partial c_{i,p}}{\eta_p}$ where $\eta_p$ is a phase parameter in the model. These partial derivatives are used in KKS kernels as chain rule terms in the residual and Jacobian. The expressions for the derivatives were presented in [!cite](kim_phase-field_1999).

#### Example input:


#### Class Description





### KKSPhaseConcentrationMultiPhaseMaterial

Kim-Kim-Suzuki (KKS) nested solve material for multiphase models (part 1 of 2). KKSPhaseConcentrationMultiPhaseMaterial implements a nested Newton iteration to solve the KKS constraint equations for the phase concentrations $c_{i,p}$ as material properties (instead of non-linear variables as in the traditional solve in MOOSE), where $i$ is the component species and $p$ is the phase. For a model with N phases, the constraint equations are the mass conservation equation for each global concentration ($c_i$):

\begin{equation}
c_i=\sum_{p=1}^N h(\eta_p)c_{i,p},
\end{equation}

and the pointwise equality of the phase chemical potentials:

\begin{equation}
\frac{\partial f_a}{\partial c_{i,a}} = \frac{\partial f_b}{\partial c_{i,b}}.
\end{equation}

The free energies in Fj_materials must have [!param](/Materials/KKSPhaseConcentrationMultiPhaseMaterial/compute) set to `false`. This material also passes the phase free energies and their partial derivatives w.r.t phase concentrations to the KKS kernels (NestKKSMultiACBulkC, NestKKSMultiACBulkF, NestKKSSplitCHCRes).

#### Example input:

##### Without damping

Parabolic free energies have valid values for any real number, and therefore don't require damping to ensure the solution is inside a trust region.


##### With damping

Log free energies are only valid when the component phase mole fractions are within 0 to 1. We add a material `C` that checks if the nested solve guess is within this trust region. Similar to the free energy, `C` must have [!param](/Materials/KKSPhaseConcentrationMaterial/compute) set to `false`. The nested solve then requires damping to ensure the solution is inside the trust region.



#### Class Description







### LinearizedInterfaceFunction


#### Overview

       caption=Figure 1: Example of order parameter values ($\phi_1$, $\phi_2$) and the linear preconditioning transformed variables ($\psi_1$, $\psi_2$),

This material defines the linearized interface substitution defined in [!cite](glasner2001nonlinear). This substitution converts the profile from a nonlinear shape to a linear shape, as shown in Fig. 1, requiring fewer elements across the interface to accurately resolve.

The transformation implemented in this material is defined as

\begin{equation}
    \phi_i = \frac{1}{2} \left[ 1 + \tanh\left( \frac{\psi_i}{\sqrt{2}} \right) \right],
\end{equation}

where $\phi_i$ is the order parameter and $\psi_i$ is the transformed variable. The function is implemented using the [ExpressionBuilder](/ExpressionBuilder.md) capability in MOOSE, such that all the derivatives of the function are calculated analytically.

#### Example Input File Syntax

The material is used via the syntax shown below:


This material is also generated as part of the automated syntax implemented in [GrainGrowthLinearizedInterfaceAction](/GrainGrowthLinearizedInterfaceAction.md).





### MathCTDFreeEnergy


Implements the bulk free energy density

f_\text{bulk}(c) = \frac14(1-c)^2(1+c)^2

using the [CompileTimeDerivatives](/CompileTimeDerivatives.md) system, where $c$ (`c`) is
a coupled concentration. The minima of this free energy density lie at $c=1$ and
$c=-1$. See also [`MathEBFreeEnergy`](/MathEBFreeEnergy.md).




### MathEBFreeEnergy


Implements the bulk free energy density

f_\text{bulk}(c) = \frac14(1-c)^2(1+c)^2

using the [ExpressionBuilder](/ExpressionBuilder.md) system, where $c$ (`c`) is
a coupled concentration. The minima of this free energy density lie at $c=1$ and
$c=-1$. See also [`SplitCHMath`](/SplitCHMath.md).




### MathFreeEnergy

This material implements an analytical double well free energy

\begin{equation}
F = \frac14(1 + c)^2(1 - c)^2
\end{equation}

and its up to third order derivatives.





### MixedSwitchingFunctionMaterial


##### Order `MIX234`

Computes a switching function represented by 234-order polynomial, which is the
general form with an adjustable parameter $k$ ($0<k<1$).

\begin{equation}
k(3\eta^2-2\eta^3)+(1-k)(4\eta^3-3\eta^4)
\end{equation}

##### Order `MIX246`

Computes a switching function represented by 246-order polynomial, which is the
general form with an adjustable parameter $k$ ($0<k<1$).

\begin{equation}
k(2\eta^2-\eta^4)+(1-k)(3\eta^4-2\eta^6)
\end{equation}




### MultiBarrierFunctionMaterial


The material provides a function $g(\vec\eta)$ that is parameterized by all
phase order parameters $\eta$. It calculates a phase transformation barrier
energy that contains double well contributions for each single order parameter.

Currently the `g_order` only supports the `SIMPLE` setting and the function is
defined as

\begin{equation}
g(\vec\eta) = \sum_i \eta_i^2(1-\eta_i)^2.
\end{equation}










### PhaseNormalTensor


Computes the second order tensor $P$ (with a property name given by `normal_tensor_name`)

P = \frac{\nabla v \otimes \nabla v}{|\nabla v|^2}

where $\otimes$ is the outer product of two vectors. The resulting tensor has a
major axis that is parallel to the gradient of the coupled variable $v$
(`phase`), a norm of 1, and minor axis of zero.




### PolycrystalDiffusivity


The `PolycrystalDiffusivity` material builds a diffusivity function that distinguishes between
the solid and void phases, grain boundaries, and free surfaces, thus allowing different diffusion
rates in those regions.
The final diffusion function is expressed as:

$D = D_m \, h_m \, I_m + D_v \, h_v \, I_v + 30 \, D_s \, c^2 \, (1-c)^2 \, I_s + 9 \, D_{GB}\, I_{GB} \sum_i \sum_{j \neq i} \eta_{i}^2 \eta_{j}^2$.

Here, $D_m$ is the bulk diffusion coefficient in the matrix/solid phase, $D_v$ is the diffusion coefficient within the void/pore/bubble phase, $D_s$ is the coefficient for the surface diffusion,
and $D_{GB}$ is the coefficient of diffusion along the grain boundaries. The prefactors for the diffusion along various interfaces are chosen such that, $\int_0^1{ D_i f(\eta_i) \, d\eta_i} \approx D_i$, where $D_i$ denotes the diffusivity along the interface (i.e., $D_s$ or $D_{GB}$). $I_m$, $I_v$, $I_s$, $I_{GB}$ are the indices to activate different diffusion mechanisms. When the diffusion values in different regions are unknown, replace those with weighted bulk diffusion coefficients.






### PolycrystalDiffusivityTensorBase

The PolycrystalDiffusivityTensorBase material builds a diffusivity tensor that distinguishes between
the bulk, grain boundaries, and free surfaces, thus allowing different diffusion
rates in those regions.
The bulk diffusion is calculated using the standard Arrhenius Equation
$D_B = D_0 \exp\left(\frac{-E_m}{k_B T}\right)$.
The grain boundary and bulk diffusions are approximated as multiples of the bulk
diffusion $D_{GB} = w_{GB}D_B$, $D_S = w_s D_B$.
Once the diffusivity tensor is calculated, it can be used to calculate a mobility
tensor in your model.








### RegularSolutionFreeEnergy


This material defines the Helmholtz free energy density $f$ of a binary regular solution.

\begin{equation}
f = \frac14 \omega c(1 - c) + k_bT (c\log c + (1 - c)\log(1 - c))
\end{equation}

where $\omega$ ([!param](/Materials/RegularSolutionFreeEnergy/omega)) is the regular solution parameter.














### TimeStepMaterial


The material sets up material properties for the current time step size `dt`,
the current time `t`, and the current time step number `time_step`. These
material properties can for example be used in [parsed materials](/ParsedMaterial.md).




### VanDerWaalsFreeEnergy


This material defines the Helmholtz free energy density $f$ of a Van der Waals gas.

\begin{equation}
f = \frac FV = \frac 1V(U - TS) = -nk_BT\left(1+\ln n_Q\left(\frac1n-b\right)\right)-n^2a
\end{equation}

where $a$ (`a`) and $b$ (`b`) are the Van der Waals coefficients, and




### VariableGradientMaterial


The material creates a material property with the name given by the parameter
`prop` that contains the L2 norm of the gradient of a coupled `variable`.




## mesh

### EBSDMesh


The mesh is generated from the EBSD information, to get an optimal reconstruction of the data. This
is accomplished in the mesh block using the EBSDMesh type. The same data file used with the EBSD
reader is used in the EBSDReader UserObject.  The mesh is created with one node per data point in the
EBSD data file. If you wish to use mesh adaptivity and allow the mesh to get coarser during the
simulation, the "uniform_refine" parameter is used to set how many times the mesh can be
coarsened. For this to work the number of elements along _each_ dimension has to be divisible by
$2^u$ where $u$ is the value of the ```uniform_refine``` parameter.

Contrary to other mesh objects the "uniform_refine" parameter will not affect the resolution of the
final mesh. It sets the levels of coarsening that can be applied to the EBSD data.




## meshgenerators

### EBSDMeshGenerator


The mesh is generated from the EBSD information, to get an optimal reconstruction of the data. This
is accomplished in the mesh block using the EBSDMeshGenerator type. The same data file used with the EBSD
reader is used in the EBSDReader UserObject.  The mesh is created with one node per data point in the
EBSD data file. If you wish to use mesh adaptivity and allow the mesh to get coarser during the
simulation, the [!param](/Mesh/uniform_refine) parameter is used to set how many times the mesh can be
coarsened. For this to work the number of elements along _each_ dimension has to be divisible by
$2^u$ where $u$ is the value of the [!param](/Mesh/EBSDMeshGenerator/uniform_refine) parameter.

Contrary to other mesh objects the [!param](/Mesh/EBSDMeshGenerator/uniform_refine) parameter will not affect the resolution of the
final mesh. It sets the levels of coarsening that can be applied to the EBSD data.




### SphereSurfaceMeshGenerator


This object generates a 2D mesh approximating the surface of a sphere in 3D space
using TRI3 triangle elements. Both center and radius of the sphere may be specified.

       caption=Targeted mesh refinement prior to nucleus insertion.

The mesh is constructed by iterative refinement of an initial icosahedron (depth 0)
for a number of steps specified using the `depth` parameter. After each refinement step
all nodes are snapped to the sphere surface defined by `radius` and `center`.
Each refinement step multiplies the number of mesh elements by a factor of four.





## postprocessors



### DiscreteNucleationData


The data to be extracted from the
[DiscreteNucleationInserter](/DiscreteNucleationInserter.md) is selected using
the `value` parameter, which has the following options:

|`value`|Output|
|-|-|
| `COUNT` | Number of currently active nucleation sites maintained by the inserter |
| `UPDATE` | Boolean (0/1) value denoting if at least one new nucleus was inserted or removed (i.e. its hold time expired) for the current timestep |
| `RATE` | Total nucleation rate per unit time for the entire domain |
| `INSERTIONS` | Number of new nucleation points added to the inserter's list |
| `DELETIONS` | Number of nucleation points that were removed due to their hold time having expired |

The `DiscreteNucleationData` postprocessor is part of the
[Discrete Nucleation system](Nucleation/DiscreteNucleation.md).





### DiscreteNucleationTimeStep


Supply this postprocessor to an [IterationAdaptiveDT](/IterationAdaptiveDT.md)
via the `timestep_limiting_postprocessor` parameter.

The timestep limit computed by this postprocessor is computed according to two
different criteria.

#### Time step limit at nucleus insertion

If a nucleus has just been added to the nucleus list by the
[DiscreteNucleationInserter](/DiscreteNucleationInserter.md) the timestep limit
is set to the value supplied using the `dt_max` parameter for one timestep. In
conjunction with IterationAdaptiveDT this causes the time step to be cut to
`dt_max` from which it will slowly have to grow back.

#### Nucleation rate based timestep limit

Between nucleation event onsets the timestep is limited based on the user
supplied upper bound on the probability $p_{2nuc}$  (`p2nucleus`) to have
_more than two_ nucleation events to occur during a single timestep.
This probability is calculated as

\begin{equation}
\label{eq-p2nuc}
p_{2nuc} = 1-(1+\lambda_{2nuc})e^{-\lambda_{2nuc}},
\end{equation}

where $\lambda_{2nuc}$ is the total nucleation rate over the whole simulation
cell that results in the probability $p_{2nuc}$. To obtain $\lambda_{2nuc}$ for
a given $p_{2nuc}$ equation [eq-p2nuc] is numerically inverted. $\lambda_{2nuc}$
is then divided by the integrated nucleation rate per unit time to obtain the
largest possible time step that keeps the probability for two or more nuclei to
form below the user specified upper bound.

       caption=Timestep (dt) in a nucleation simulation with a DiscreteNucleationTimeStep
       limited time step. The green curve (dtnuc) shows the time step limit.
       The envelope of that curve is determined by the upper bound on the two or more
       nucleus probability. The sharp downward spikes are the time step cut-backs
       during nucleation events.

This addresses two issues with poisson statistics sampling. At every sampling
point in the domain the rate is sufficiently low to stay in the rare event
regime (i.e where either zero or one event are happening). At higher rates the
time resolution is insufficient to capture all possible nucleation events.
Controlling the probability of multiple nuclei forming also reduces the chance
of overlapping nuclei to form.

The `DiscreteNucleationTimeStep` postprocessor is part of the
[Discrete Nucleation system](Nucleation/DiscreteNucleation.md).







### FeatureFloodCount

The FeatureFloodCount object is a utility that inspects solution fields looking for [Connected Components](https://en.wikipedia.org/wiki/Connected_component_(graph_theory)) or "topologically connected regions of a solution field sharing a similar characteristic". Typically, this means a region where the solution value is higher than some threshold. This object is designed to work efficiently on a partitioned unstructured mesh with hundreds to thousands of processors.






<br/>
The algorithm for identifying portions of connected components begins by running a [Flood Fill](https://en.wikipedia.org/wiki/Flood_fill) algorithm on each processor that recursively visits neighboring elements on the unstructured mesh while the connecting criteria is met. [unstructured1] illustrates the identification of a new region on a processor. The dark shaded element represents an element that was identified whose variable value exceeds a given threshold. The lightly shaded elements surrounding the dark element represent the current "halo" markings of the region. These halo markings always extend one neighbor beyond the currently shaded region. They are used for both the connected component algorithm and for identifying potential collisions among disjoint regions.





<br/>
Several pieces of information are recorded on each processor including all of the marked elements, a minimum ID for a partition independent stable ordering and "overlapping elements" for stitching. [grain_stitch_split] shows a regular mesh partitioned among three processors with several regions of interest. The alpha characters represent a possible local ordering of the features. The subscript represents the processor ID. Portions of the feature data structure is serialized and sent to the rank 0 process where connection information is used to discover the global picture [grain_stitch].










### GrainTracker

The Grain Tracker is a utility that may be used in phase-field simulations to reduce the number of
order parameters needed to model a large polycrystal system. The GrainTracker utilizes the
[FeatureFloodCount](/FeatureFloodCount.md) object for identifying and extracting individual grains
from a solution field. Once the FeatureFloodCount object has identified all grains, the GrainTracker
does two things:

- Match up grains from the current timestep with grains from the previous timestep.
- Remap grains that are "close" to coming into contact.

#### Grain Tracking

The ability to track features over time is of interest for many simulation types. Here we present an
algorithm for tracking arbitrary features on an unstructured mesh over time. The tracking stage is
responsible for maintaining consistent and unique identification for an arbitrary number of moving
and interacting features over time. The tracking stage is the only stage in the algorithm which
requires stateful data between time steps. This is important from an implementation perspective as it
can have an affect on the ability of a simulation to checkpoint, terminate, and successfully
restart. Restart capabilities are useful for handling hardware faults or spreading out a long running
simulation over several execution windows common in high performance computing environments.

During the first invocation of the feature tracking stage there is no previous feature data to
compare against so no tracking is performed. Instead a set of IDs must be assigned to each identified
feature. These IDs may be supplied externally if desired. In fact there are no restrictions on the
IDs if supplied externally. The IDs need not be contiguous nor must they be unique. However, if
separate features are assigned duplicate IDs and those features come into contact during a
simulation, the data will be coalesced, which may or may not result in a correct simulation.  If an
external assignment is not desired, the feature tracking algorithm will assign a set of contiguous
and unique IDs to each individual feature. This is accomplished by first sorting the identified
features by the min element ID stored in each feature's data structure and assigning a number based
on the sorted position. This strategy ensures a stable sorting insusceptible to different mesh
partitionings.

On subsequent invocations, the feature information from the previous time step is compared against
all of the features from the current time step and organized such that the best matches for all
features is determined correctly. The comparison criterion is to globally minimize the centroid
distances of all features simultaneously. The centroid is calculated by averaging the element
centroids making up each feature. As we iterate over the new list of features, we select the feature
in the previous list that is closest by centroid distance. This pairing is saved into a "best match"
data structure while the remaining features are being processed.

It's possible for features to compete for the same "best match" feature on the previous time
step. This indicates that a feature has been absorbed or has otherwise disappeared on the current
step and that its corresponding feature from the previous step is incorrectly identifying an
unrelated feature as the best match. This case is handled by marking the feature with the greater
centroid distance mismatch as inactive.

When all pairs have been compared, all of the features in the best match data structure are marked
("matched") and the IDs from the previous time step are saved into the corresponding matches in the
current time step. Unmatched features from both the new list and previous lists are then handled.
The features in the previous list that are unmatched are marked as inactive. The unmatched features
in the current list are "new", meaning that they haven't been previously identified. The former case
occurs when there are exactly zero features in the current list, meaning any feature in the previous
list will remain unmatched. The latter case can occur when a feature splits or when a new feature is
created.


#### Grain Remapping

       id=remap_red_conflict
       caption=Red feature bounding boxes intersecting (fast check).

       id=remap_red_halo
       caption=Red feature halos intersecting (complete check).

Grain remapping is implemented using a recursive backtracking algorithm capable of performing several
variable swaps to transform the improperly colored grain graph into a proper one. This backtracking
algorithm runs only on the root process which is the only processor that contains the complete global
grain graph.  When a pair of grains are located that are in close proximity [remap_red_conflict] and
[remap_red_halo], one of them is arbitrarily chosen and designated as the "target" grain indicating
that we seek to remap its defining variable values to a different solution variable. Depending on the
number of neighbors a graph has and the variables representing each of those neighbors, it may or may
not be possible to create a valid graph by remapping only the target grain. In this case a
depth-limited, depth-first search is performed seeking a series of neighbor swaps to leave the graph
in a valid state.

To begin, an array of lists of size $m$ is built and populated, where $m$ is the number of variables
(colors) in use. For each variable the nearest grain represented by that variable (as determined by
the bounding box distance) is located and its distance is stored in the list at the corresponding
array position along with the grain ID itself. In cases where the nearest bounding boxes for a given
variable overlap the target grain, we maintain a negative count representing the total number of
overlaps and the ID of each grain which overlaps. Otherwise we store the closest bounding box edge to
bounding box edge distance for the given variable. We don't bother to calculate or store any
information for grains with matching variable indices, or for grains that live on a reserved order
parameter since those variables are ineligible for remapping. If there are any empty order parameters
(an order parameter representing zero grains), a distance of infinity ($\infty$) is entered into the
corresponding position prioritizing those variables for remapping. This ``color distance'' array is
then sorted in reverse order putting the grains furthest away near the front and leaving those with
several overlaps near the back.

       id=remap_red_yellow
       caption=Distance check against "B" Features.

       id=remap_red_green
       caption=Distance check against "C" Features.


       id=remap_red_blue
       caption=Distance check against "D" Features.

| Variable | Distance |
|----------|----------|
| A        | $\varnothing$ |
| B        | -2.0     |
| C        | -1.0     |
| D        | -3.0     |

A case with all negative distances is illustrated in [large_red]. In this example, the target grain
is chosen as the large grain labeled $A$, centered on the right side of the image. All of the other
colors have at least one bounding box that overlaps the large $A$ grain: 2 for $B$, 1 for $C$, and 3
for $D$.  The empty list ($\varnothing$) is used for the variable represented by the target grain to
ensure that the same variable is never considered as a possible remapping option.

       id=remap_green_red
       caption=Distance check against "A" Features.

       id=remap_green_yellow
       caption=Distance check against "B" Features.

       id=remap_green_blue
       caption=Distance check against "D" Features.

| Variable | Distance |
|----------|----------|
| A        | 52.6     |
| B        | 4.2      |
| C        | $\varnothing$ |
| D        | -1.0     |

We iterate over the array of distances looking for available variables suitable for remapping the
target grain. If a positive value is encountered, the grain can be immediately remapped and the
algorithm returns "success". If however a negative value is encountered, we must first perform a
fine-level check on each of the corresponding grain halos to see if these grains actually overlap. If
they do not, we can immediately remap the target grain and return "success". If we encounter a case
where there is only a single truly overlapping grain (bounding boxes and halos intersect), the
algorithm tentatively marks the target grain with the other grain's variable effectively simulating a
remapping operation. It then recurses on the other neighboring grain making it the new target. If the
algorithm is able to find a successful remap in the recursive call, the returned "success" value
indicates to the caller that the tentative mark can be removed. The "success" value can then be
propagated on up the call stack. If all items in the "color distance" array are exhausted without
finding a successful swap or set of swaps, the algorithm returns "fail". If we are in a recursive
call, the tentative mark is removed and the next value in the array is inspected. We find that
limiting the depth-first search to a relatively small depth (2 or 3) works reasonably well to fail
out of impossibly tightly colored graphs faster. This also helps avoid the huge runtime penalty and
exponential growth rate possible with an unlimited backtracking algorithm. Note: Tentative markings
are indicated by turning on the `DIRTY` status flag in the feature's data structure. The `DIRTY`
status uses an independent bit so it can exist simultaneously with another status.

       id=remap_to_red_pre
       caption=Ready to remap.

       id=remap_to_red
       caption=Remap to "A".

       id=remap_to_green
       caption=Remap to "C".

#### 3D Halo Images

       id=3D_start
       caption=6000 grains in 3D

       id=3D_end
       caption=grain structure after several simulation steps.

#### Description and Syntax









### WeightedVariableAverage


Compute the ratio $a$ of volume integrals
\begin{equation}
a=\frac{\int_Omega w\cdot v dr}{\int_Omega w dr},
\end{equation}
where $v$ (`v`) is a coupled variable and $w$ (`weight`) a material property.

For constant weight values $w$ this object is equivalent to
[ElementAverageValue](/ElementAverageValue.md).





## userobjects





### ConservedMaskedNormalNoise


#### See also

- [ConservedLangevinNoise](/ConservedLangevinNoise.md)
- [fluctuation based nucleation](Nucleation/LangevinNoise.md)




### ConservedMaskedUniformNoise


#### See also

- [ConservedLangevinNoise](/ConservedLangevinNoise.md)
- [fluctuation based nucleation](Nucleation/LangevinNoise.md)




### ConservedNormalNoise


#### See also

- [ConservedLangevinNoise](/ConservedLangevinNoise.md)
- [fluctuation based nucleation](Nucleation/LangevinNoise.md)




### ConservedUniformNoise


#### See also

- [ConservedLangevinNoise](/ConservedLangevinNoise.md)
- [fluctuation based nucleation](Nucleation/LangevinNoise.md)






### DiscreteNucleationFromFile


This inserter can be used for verification and test cases. Instead of
stochastic nucleus insertion via a probability calculated in
[`DiscreteNucleationInserter`](/DiscreteNucleationInserter.md), this object reads
a CSV file with columns for nucleus insertion time (`time`) and the coordinates
of the insertion point (`x`, `y`, `z`).  The nuclei inserted can be of a fixed
radius or have a variable radius.  If the parameter `radius`, which must be greater than 0, is specified, a fixed radius will be used.  If
the radius is not fixed, an additional column must be supplied in the CSV file,
such that the columns supply (`time`, `x`, `y`, `z`, `r`).  Note that the radius can be supplied in the CSV file and overridden by supplying a value for `radius`.

The `DiscreteNucleationFromFile` is part of the [Discrete Nucleation system](Nucleation/DiscreteNucleation.md).




### DiscreteNucleationInserter


The inserter manages the global list of currently active nucleus stabilization sites. The inserter object keeps track if any changes to the nucleus list occurred in the current timestep.


This user object takes two required parameters

- `hold_time` - the duration in time for which a stabilization site remains active
- `probability` - a material property containing a nucleation rate density. This material property can be calculated using classical nucleation theory for example.

In addition, the user has the option of specifying whether this nuclei with a fixed
radius will be inserted, or whether the radius can vary based on an internal calculation. A
constant radius can be supplied via the input file to the `radius` parameter, while a variable
radius can be used by providing a material property name to `radius` (a default name is provided).

The final parameter, `time_dependent_statistics`, is a boolean that defaults to true.  This
parameter indicates whether time-dependent nucleation statistics are used or not.  
The default of true indicates that time-dependent statistics are used, i.e., that the nucleation
probability depends on time step size. A value of false indicates time-independent
nucleation statistics.  This might be used in a situation in which the physics driving
nucleus formation occur at much faster time scales than the other physics in microstructure
evolution.  For example, grain boundary motion during recrystallization is much slower
than dislocation motion to organize into cells or the nuclei of new grains.  As a result,
time-independent statistics can be applied.

The `DiscreteNucleationInserter` is part of the [Discrete Nucleation system](Nucleation/DiscreteNucleation.md).




### DiscreteNucleationMap


The map objects builds a smooth map of nucleation sites in the simulation
domain, expanding the (time, x, y, z, radius) description from the
[`DiscreteNucleationInserter`](/DiscreteNucleationInserter.md) to a description
in which nucleation sites have a finite size and a smooth interface. This object
takes two parameters,

- ```periodic``` - a variable to take the periodicity information of the simulation domain
- ```inserter``` - the ```DiscreteNucleationInserter``` object that maintains the nucleus list

The map object only updates the map if during a timestep the nucleus list was changed.

The `DiscreteNucleationMap` is part of the [Discrete Nucleation system](Nucleation/DiscreteNucleation.md).




### EBSDReader


The EBSDReader user object reads in data from [electron backscatter diffraction (EBSD)](https://en.wikipedia.org/wiki/Electron_backscatter_diffraction)
to set initial conditions for phase field simulations. EBSD identifies the grain and
phase structure of a sample, as well as the crystal structure and the crystal orientation.
The `EBSDReader` reads in this information from a specially formatted data file and
reconstructs the microstructure. It accomplishes this by setting the initial conditions
for all the phase field variables. In addition, it stores the crystal structure and
orientation information by use by the phase field and mechanics models.

**Note that the EBSDReader does not mesh the microstructure**, but rather sets phase
field variable initial conditions. To reconstruct a mesh of the microstructure,
we recommend using [OOF](http://www.ctcms.nist.gov/oof/).

##### Average orientation of a grain

Euler angles are not the best for representing the orientation of a grain because they suffer from gimbal lock. Therefore, we use quaternions to compute the average orientation of the grain. Firstly, the Euler angles are converted to quaternions. Next, we segregate the quaternions into different bins with the parameter "bins" specifying the number of bins. We then perform a weighted average of the quaternions with weights of each quaternion corresponds
to size of the bin in which it resides. The average quaternion is then converted to Euler angle representation.

Various weighted averages can be performed by raising power of the weights corresponding to each quaternion. The parameter "L_norm" allows us to
raise the power of the weights according to the positive integer assigned to it. By default, the value of "L_norm" is set to 1, computing the simple weighted average of the quaternions.


### EBSD Data File Format

The `EBSDReader` user object reads in a data file taken from EBSD data. The file
should have the following format:

```
### Header:    Marmot Input File

### Date:      19-Jul-2013 00:23:55

### 
### Column 1:  Euler angle "phi1" (in radians)

### Column 2:  Euler angle "PHI" (in radians)

### Column 3:  Euler angle "phi2" (in radians)

### Column 4:  x-coordinate (in microns)

### Column 5:  y-coordinate (in microns)

### Column 6:  z-coordinate (in microns)

### Column 7:  grain number (integer)

### Column 8:  phase number (integer)

### Column 9:  symmetry class (from TSL)

### 
### Phase 1:   Nickel (symmetry class = 43)

### Number of Grains in Phase 1:  111

### 
### X_Min:      0.000000

### X_Max:      32.000000

### X_step:     0.250000

### X_Dim:      128

### 
### Y_Min:      0.000000

### Y_Max:      32.000000

### Y_step:     0.250000

### Y_Dim:      128

### 
### Z_Min:      0.000000

### Z_Max:      0.000000

### Z_step:     0.000000

### Z_Dim:      0

### 
2.48663 1.84098 5.50548 0.12500 0.12500 0.00000 0 1 43
2.48663 1.84098 5.50548 0.12500 0.37500 0.00000 0 1 43
.
.
.
```

The open source code [Dream3D](http://dream3d.bluequartz.net/) has the option to
output in this format using the _"Write INL File"_ filter. Note that the data must
be on a square grid rather than a hex grid.

The `EBSDReader` supports additional custom data columns.





### FauxPolycrystalVoronoi

This is a special case of [PolycrystalVoronoi](PolycrystalVoronoi.md) when
the number of grains equal to the number of order parameters. In this case,
expensive [FeatureFloodCount](postprocessors/FeatureFloodCount.md) is avoided.


#### Description and Syntax









### PolycrystalCircles

PolycrystalCircles generates several touching circle particles from centers and radii either from the input file or from a separate file. This object is useful for generating ICs suitable for sintering simulations. Each particle can be assigned an order parameter from the reduced set.

See [Polycrystal Initial Conditions](ICs/PolycrystalICs.md) for more information.

#### Description and Syntax





### PolycrystalEBSD

PolycrystalEBSD uses an EBSDReader object and utilizes the algorithms in [Polycrystal Initial Conditions](/ICs/PolycrystalICs.md) to generate a reduced order parameter model from electron backscatter data. More information about this capability can be found in the [EBSD](ICs/EBSD.md) object description.

#### Description and Syntax





### PolycrystalHex

The PolycrystalHex object generates a set of points in 2D space such that hexagonal patterns are generated from a resulting Voronoi Tesselation. The number of grains must be chosen such that the $\sqrt[dim=2]{n}$ root is an even integer. Furthermore, a suitable number must be chosen that is supported by the mesh resolution and grain boundary width. At present, the object is supported for generating hexagons in 2D and hexagonal prisms in 3D with the `columnar_3D` option. It works with periodic boundary conditions. Once the grain structure has been generated, a coloring algorithm is used to assign order parameters to grains so that a reduced number of order parameters may be used. Typical numbers are given here:

| Dimension | Recommended OPs |
|-----------|-----------------|
| 2D        | 8               |

See [Polycrystal Initial Conditions](ICs/PolycrystalICs.md) for more information.

#### Typical usage in an input file:




#### Description and Syntax

### PolycrystalHex





### PolycrystalVoronoi

The PolycrystalVoronoi UserObject either generates a set of random points or
reads a set of grain centroids from a file and performs a Voronoi tessellation to
produce a grain structure. The number of grains may be set by the user but a
suitable number must be chosen that is supported by the mesh resolution and
grain boundary width. Once the grain structure has been generated, a coloring
algorithm is used to assign order parameters to grains so that a reduced number
of order parameters may be used. Typical numbers are given here:

| Dimension | Recommended OPs |
|-----------|-----------------|
| 2D        | 8               |
| 3D        | 25              |

See [Polycrystal Initial Conditions](ICs/PolycrystalICs.md) for more information.

To reduce the computational cost associated with setting up a polycrystal structure with a large number of grains, an alternative option is to use the `KDTree` approach. In this case, a search tree is built a-priori such that the time to search nearest points and neighboring grains is optimized. To leverage this approach for an initial condition with diffused interfaces, it is recommended that users determine what is the minimum `grain_patch_size` required for their problem (the default value is `grain_patch_size = 10`).

#### Typical usage in an input file:



An example of activating `KDTree` is provided below:



#### Description and Syntax







### SolutionRasterizer


Mesoscale microstructure simulations using the phase field method can be utilized to generate initial structures for large scale molecular dynamics simulations. One application is the construction of nano-foam atomistic samples from simulations of spinodal decomposition.


MOOSE provides a built in system to template an atomic coordinate file in the `.xyz` format from the simulation result in a given mesh file. The workflow is as follows

1. Set up a phase field simulation and output a finite element mesh file
2. Create a bulk `.xyz` input file with the desired underlying lattice and crystal structure
3. Use the minimal input file shown below to load the mesh and `.xyz` input

MOOSE will load the `.xyz` input and finite element mesh superpose both and use thresholding to carve out _rejected_ atoms while retaining _accepted_ atoms. Finally a new `.xyz` output is written containing only the _accepted_ atoms, generating a porous microstructure.

The `SolutionRasterizer` user object is derived from the [`SolutionUserObject`](/wiki/MooseSystems/UserObjects/SolutionUserObject) and inherits its input parameters. It takes the following additional input parameters:

|Input Parameter | Description|
|----------------|------------|
| `xyz_input`     | An `.xyz` file as an input file. This input file should contain an atomistic simulation cell completely filled with atoms of a chosen crystal structure (a polycrystalline sample can be supplied). |
| `xyz_output`    | Output `.xyz` file containing the filtered (or mapped) atomic coordinate file. |
| `raster_mode = FILTER`  | In `FILTER` mode the `SolutionRasterizer` uses thresholding on a specified non-linear variable to reject or accept atom from the input file to pass to the output `.xyz` file. |
| `raster_mode = MAP`     | In `MAP` mode the `SolutionRasterizer` takes the atoms from the input file and add an additional column to the data set containing the value of a specified non-linear variable. |
| `threshold`    | Value of the selected non-linear variable to use in `FILTER` mode used to _accept_ or _reject_ atoms from the `xyz_input` file. |

##### Minimal working input file

The following input can be executed with the MOOSE Phase Field module executable and will

- load the mesh file `diffuse_out.e`
- load the atomic coordinate file `in.xyz`
- accept all atoms at the coordinates where the value of the non-linear variable `c` is above a value of `0.5`
- write out the atomic coordinate file `out.xyz`





## vectorpostprocessors



### FeatureVolumeVectorPostprocessor

This VectorPostprocessor is designed to pull data from a [FeatureFloodCount](FeatureFloodCount.md) or one of its
derived classes. In particular, the FeatureFloodCount object stores information
about each connected component that it discovers: volumes, whether or not that component intersects a
boundary, and the variable number.

If this VPP is used with a GrainTracker or derived object, the row number represents the unique identifier of each
feature. This value is stable between time steps meaning that row number 5 would always represent the grain with an
ID of 5 (zero-based indexing). This also means that information from inactive grains is output and should be ignored.
Inactive grains are identified with `var_num == -1`.

When using this VPP with a FeatureFloodCount object, there is no implied ordering of the features.

- var_num - The index of which coupled variable represents this feature [0..n).
- feature_volume - The volume of the feature, computed as an integral of the solution over each element representing this feature.
- intersects_bounds - A Boolean indicating whether this feature intersects any boundary.
- centroid_<x, y, z> (optional) - The coordinates of each feature centroid (Currently only supported when no periodic boundaries are used).

#### Typical Output


#### Centroid Output

This VectorPosptrocessor can also output centroid information when the simulation is not using periodic boundary conditions. To enable
centroid output, add `output_centroids = true` to the VPP block in your input file.

#### Usage

To use this VPP, you simply need to specify the name of a FeatureFloodCount or derived object in
the input file.


#### Advanced Parameter(s)

The `single_feature_per_element` parameter is a crude attempt at total volume conservation. When you set this Boolean to true, the volume of every element
will be added only to the most dominant feature. In this manner, the loss of an element in one feature results in the addition of an element to another feature.
There is no loss of volume to grain boundaries or anything else using this assumption.

#### Class Description










# PorousFlow module

       style=width:80%;margin-left:10px
       autoplay=True
       loop=True
       caption=CO$_2$ injection and dissolution in [complex geometry](porous_flow/fluidflower.md)
       id=fluidflower

The PorousFlow module is a library of physics for fluid and heat flow in porous
media. It is formulated in an extremely general manner, so is capable of solving
problems with an arbitrary number of phases (gas, liquid, etc) and fluid components (species present in
each fluid phase), using any set of primary variables.

By simply adding pieces of physics together in an input file, the PorousFlow
module enables the user to model problems with any combination of fluid, heat
and geomechanics.


### Module overview class=center style=font-weight:200;

- [Governing equations](porous_flow/governing_equations.md)
- [Material laws](porous_flow/material_laws.md)
- [Fluid equations of state](porous_flow/fluids.md)
- [Boundaries](porous_flow/boundaries.md)
- [Point and line sources and sinks](porous_flow/sinks.md)
- [Flow models](porous_flow/flow_models.md)
- [Additional objects (actions, postprocessors, etc)](porous_flow/additional_objects.md)
- [Full system documentation](porous_flow/systems.md)
- [A to Z Index](porous_flow/contents.md)



### Tutorial and examples class=center style=font-weight:200;




### Implementation details class=center style=font-weight:200;

- [PorousFlowDictator](porous_flow/dictator.md)
- [Numerical stabilization](porous_flow/stabilization.md)
- [Preconditioning and solvers](porous_flow/solvers.md)
- [Convergence criteria](porous_flow/convergence.md)
- [Nonlinear convergence problems](porous_flow/nonlinear_convergence_problems.md)
- [Persistent variables](porous_flow/persistent_variables.md)
- [Time derivative](porous_flow/time_derivative.md)
- [Lagrangian coordinates](porous_flow/lagrangian_eulerian.md)
- [Compositional flash](porous_flow/compositional_flash.md)


## Become a developer

The PorousFlow module is being developed by users at national laboratories
and universities around the world. Learn how to get in touch with the developers
on the [help/contact_us.md optional=True] page.

All users of PorousFlow are encouraged to assist in the development of this module. There are
a large number of possible enhancements that can be implemented, and better documentation that could
be contributed, so consider becoming a developer yourself. Follow the MOOSE standards for [contributing code](framework/contributing.md).

## actions

### PorousFlowAddBCAction

This action creates `PorousFlow`-specific boundary conditions. It allow developers to create
user friendly syntax for adding more complicated boundary conditions using the following structure:

```
[PorousFlow]
  [BCs]
    [my_bc]
      type = MyUserFriendlyBC
      parameters
    []
  []
[]
```

To create a syntax like this, developers have to build a proxy class called `MyUserFriendlyBC`.
This class inherits from `MooseObject` and will register its own parameters as usual.

Then, in `PorousFlowAddBCAction::act()` developers check the type of a constructed object and if
it matches their type, they build the underlying boundary conditions objects using the MOOSE C++
interface.

An example of this approach can be seen in (PorousFlowSinkBC)[PorousFlowSinkBC.md] which is
the user-friendly proxy class and the way it is setup can be seen in `PorousFlowAddBCAction.C`.

### PorousFlowAddMaterialAction





### PorousFlowAddMaterialJoiner





### PorousFlowBasicTHM

This Action allows simple simulation of fully-saturated, single-phase, single-component simulations.  It is mainly used in *poro-elastic* and *thermo-poro-elastic* simulations.  The fluid flow may be optionally coupled
to mechanics and/or heat flow using the `coupling_type` flag.

This Action offers simplified physics compared with the [PorousFlowFullySaturated](PorousFlowFullySaturated.md) and [PorousFlowUnsaturated](PorousFlowUnsaturated.md) Actions.

#### Fluid flow

The fluid equation is a simplified form of the full [PorousFlow fluid equation](/porous_flow/governing_equations.md) (see [PorousFlowFullySaturatedMassTimeDerivative](/PorousFlowFullySaturatedMassTimeDerivative.md) and [PorousFlowFullySaturatedDarcyBase](/PorousFlowFullySaturatedDarcyBase.md) for the derivation):
\begin{equation}
\label{eq:basicthm}
0 = (\rho)\left(\frac{\dot{P}}{M} + \alpha_{B}\dot{\epsilon}_{v} - A\dot{T}\right) -
\nabla_{i}\left((\rho) k_{ij}\left(\nabla_{j}P - \rho g_{j}\right)/\mu\right)
\ .
\end{equation}
In this equation, the fluid density, $\rho$, appears in parentheses, because the user has the option of including it or not using the `multiply_by_density` flag.  Note that the fluid-mass time derivative is close to linear, and is perfectly linear if `multiply_by_density=false`, and this also almost linearises the flow term.  Extremely good nonlinear convergence should therefore be expected, but there are some knock-on effects that are documented in [PorousFlowFullySaturatedMassTimeDerivative](/PorousFlowFullySaturatedMassTimeDerivative.md).

The term $\alpha_{B}\dot{\epsilon}_{v}$ only appears if the `coupling_type` includes "Mechanical".  The term $A\dot{T}$ only appears if the `coupling_type` includes "Thermo".

To simulate [eq:basicthm] the `PorousFlowBasicTHM` Action employs the following Kernels:

- [PorousFlowFullySaturatedMassTimeDerivative](/PorousFlowFullySaturatedMassTimeDerivative.md), if the simulation is of Transient type.
- [PorousFlowFullySaturatedDarcyBase](/PorousFlowFullySaturatedDarcyBase.md)

For isothermal simulations, the fluid properties may still depend on temperature, so the `temperature` input parameter may be set to any real number, or to an AuxVariable if desired.

[Upwinding](/porous_flow/upwinding.md) and [mass lumping](/porous_flow/mass_lumping.md) are not used by these Kernels.  These numerical schemes are typically unnecessary in fully-saturated, single-phase simulations, but the lack of stabilization means the results from `PorousFlowBasicTHM` will typically be slightly different to the remainder of PorousFlow.

Even though there is only one fluid phase in this fully saturated action, some objects may require a relative permeability material to work. Examples include [PorousFlowDarcyVelocityComponent](PorousFlowDarcyVelocityComponent.md) `AuxKernels` which requires relative permeability, or [PorousFlowPeacemanBorehole](PorousFlowPeacemanBorehole.md) wells. By default, this action adds a constant relative permeability of one, so that the fluid is perfectly mobile. 

#### Heat flow

For anisothermal simulations, the energy equation reads
\begin{equation}
0 = \frac{\partial}{\partial t}\left((1-\phi)\rho_{R}C_{R}T + \phi\rho\mathcal{E}\right) - \nabla\cdot (\rho h k(\nabla P - \rho \mathbf{g})/\mu) - \nabla\cdot(\lambda \nabla T) + \left((1-\phi)\rho_{R}C_{R}T + \phi\rho\mathcal{E}\right)\nabla\cdot v_{s} \ ,
\end{equation}
where the final term is only used if coupling with mechanics is also desired.  To simulate this DE, `PorousFlowBasicTHM` uses the following kernels:

- [PorousFlowEnergyTimeDerivative](/PorousFlowEnergyTimeDerivative.md) if the simulation is of Transient type
- [PorousFlowFullySaturatedHeatAdvection](/PorousFlowFullySaturatedHeatAdvection.md) with `multiply_by_density=true` (irrespective of the setting of this flag in the `PorousFlowBasicTHM` Action)
- [PorousFlowHeatConduction](/PorousFlowHeatConduction.md)
- [PorousFlowHeatVolumetricExpansion](/PorousFlowHeatVolumetricExpansion.md) if coupling with temperature and mechanics is desired, and if the simulation is of Transient type

#### Solid Mechanics

For simulations that couple fluid flow to mechanics, the equations are already written in [governing equations](/porous_flow/governing_equations.md), and `PorousFlowBasicTHM` implements these by using the following kernels:

- [StressDivergenceTensors](/StressDivergenceTensors.md)
- [Gravity](/Gravity.md)
- [PorousFlowEffectiveStressCoupling](/PorousFlowEffectiveStressCoupling.md)

#### Required Materials

`PorousFlowBasicTHM` adds many Materials automatically, however, to run a simulation you will need to provide more Materials for each mesh block, depending on your simulation type, viz:

- One of the `PorousFlowPermeability` classes, eg [PorousFlowPermeabilityConst](PorousFlowPermeabilityConst.md)
- [PorousFlowConstantBiotModulus](/PorousFlowConstantBiotModulus.md)
- [PorousFlowConstantThermalExpansionCoefficient](/PorousFlowConstantThermalExpansionCoefficient.md)
- [PorousFlowPorosity](/PorousFlowPorosity.md)
- [PorousFlowMatrixInternalEnergy](/PorousFlowMatrixInternalEnergy.md)
- A thermal conductivity calculator, eg [PorousFlowThermalConductivityIdeal](/PorousFlowThermalConductivityIdeal.md)
- An elasticity tensor, eg, [ComputeIsotropicElasticityTensor](/ComputeIsotropicElasticityTensor.md)
- A strain calculator, eg, [ComputeSmallStrain](/ComputeSmallStrain.md)
- A thermal expansion eigenstrain calculator, eg, [ComputeThermalExpansionEigenstrain](/ComputeThermalExpansionEigenstrain.md)
- A stress calculator, eg [ComputeLinearElasticStress](/ComputeLinearElasticStress.md)

Before choosing non-standard `pressure_unit` or `time_unit`, you should read the essay on these non-standard choices [here](PorousFlowSingleComponentFluid.md)


#### Examples

A simple example of using `PorousFlowBasicTHM` is documented in the [PorousFlow tutorial](/porous_flow/tutorial_01.md) with input file:


A TH example that uses `PorousFlowBasicTHM` is also documented in the [PorousFlow tutorial](/porous_flow/tutorial_03.md) with input file:


A THM example that uses `PorousFlowBasicTHM` is also documented in the [PorousFlow tutorial](/porous_flow/tutorial_04.md) with input file:



### PorousFlowFullySaturated


For a worked example, see [tutorial page 6](/tutorial_06.md).

#### Dictator

This `Action` automatically adds an appropriately-parameterized [PorousFlowDictator](PorousFlowDictator.md) with name given by the `dictator_name` input.

#### Fluid equations

##### Order of unknowns

The unknowns for the fluid equations are
\begin{equation}
\{\chi^{0}, \chi^{1}, \ldots, \chi^{N_{f}-2}, P\}
\end{equation}
Here $N_{f}$ is the number of fluid components, $\chi^{i}$ is a fluid component, and $P$ is the porepressure.  For example:

- For single-component fluids ($N_{f} = 1$) such as pure water, $P$ is the only variable
- For brine, whose fluid components are NaCl and H$_{2}$O, the variables are $\{\chi^{0}, P\} = \{\chi^{\mathrm{NaCl}}, P\}$
- For an acidic brine, whose basis species are Na$^{+}$, Cl$^{-}$, H$^{+}$ and H$_{2}$O (with $N_{f} = 4$), the variables are $\{\chi^{0}, \chi^{1}, \chi^{2}, P\} = \{\chi^{\mathrm{Na+}}, \chi^{\mathrm{Cl-}}, \chi^{\mathrm{H+}}, P\}$

Note that this `Action` associates the final mass-fraction with the porepressure variable.  Ordering your mass-fraction variables so that the final variable has the greatest mass-fraction will usually improve convergence speed because the Jacobian is more diagonally dominant.  For instance, for the brine situation, it is usually much more computationally efficient to choose $\chi^{0} = \chi^{\mathrm{NaCl}}$ rather than $\chi^{0} = \chi^{\mathrm{H2O}}$ even though the final answers will be identical.

Since the final mass-fraction, $1 - \sum_{\kappa = 0}^{N_{f} - 2}\chi^{\kappa}$, is associated with the porepressure variable, `BCs` and other objects associated with the porepressure variable will be "acting on" the final mass-fraction.  See [tutorial page 6](/tutorial_06.md) for examples.

##### Fluid-flow equations

This `Action` simulates the $N_{f}$ [fluid equations](porous_flow/governing_equations.md)
\begin{equation}
\label{eq:full_sat}
0 = \frac{\partial}{\partial t} \phi(\rho) \chi^{\kappa} + \phi(\rho) \chi^{\kappa}\nabla\cdot \mathrm{v}_{s} - \nabla_{i} \left(\chi^{\kappa}(\rho)\frac{k_{ij}}{\mu}(\nabla P_{j} - \rho g_{j}) \right) \ .
\end{equation}
In this equation, the fluid density, $\rho$, appears in parentheses, because the user has the option of including it or not using the `multiply_by_density` flag.

Think carefully before you use `multiply_by_density = false`.  When not multiply by density, in many situations the sum of [eq:full_sat] will imply a Laplace equation such $0 = \nabla (k(\nabla P - \rho g))$, that is a steady-state distribution for the porepressure.  In addition, care must be taken when using other parts of PorousFlow, for instance, the [`PorousFlowMass`](PorousFlowFluidMass.md) Postprocessor is coded to record fluid mass, not fluid volume.  New users should set `multiply_by_density = true` to avoid confusion, even at the expense of extra computational cost.

##### Kernels added

To represent the $\frac{\partial}{\partial t} \phi(\rho) \chi^{\kappa}$ term (which only appears in `transient` simulations) the `Action` adds a [PorousFlowMassTimeDerivative](PorousFlowMassTimeDerivative.md) Kernel for each fluid component.  These Kernels lump the fluid-component mass to the nodes to ensure superior [numerical stabilization](stabilization.md).

To represent the $\phi(\rho) \chi^{\kappa}\nabla\cdot \mathrm{v}_{s}$ term (which only appears in `transient` simulations with mechanical `coupling_type`) the `Action` adds a [PorousFlowMassVolumetricExpansion](PorousFlowMassVolumetricExpansion.md) Kernel for each fluid component.  These Kernels lump the fluid-component mass to the nodes to ensure superior [numerical stabilization](stabilization.md).

To represent the $\nabla_{i} \left(\chi^{\kappa}(\rho)\frac{k_{ij}}{\mu}(\nabla P_{j} - \rho g_{j}) \right)$ the `Action` adds Kernels and possibly UserObjects depending on the `stabilization` parameter:

- In the case of no-upwinding, a [PorousFlowFullySaturatedDarcyFlow](PorousFlowFullySaturatedDarcyFlow.md) Kernel for each fluid component.
- For full upwinding, a [PorousFlowFullySaturatedAdvectiveFlux](PorousFlowFullySaturatedAdvectiveFlux.md) Kernel for each fluid component.
- For [KT stabilization](kt.md), a [PorousFlowFluxLimitedTVDAdvection](PorousFlowFluxLimitedTVDAdvection.md) Kernel and a [PorousFlowAdvectiveFluxCalculatorSaturatedMultiComponent](PorousFlowAdvectiveFluxCalculatorSaturatedMultiComponent.md) UserObject for each fluid component (or a [PorousFlowAdvectiveFluxCalculatorSaturated](PorousFlowAdvectiveFluxCalculatorSaturated.md) in the case of just one fluid component).

##### Advanced additions: diffusion and dispersion, radioactive decay, chemistry

The `Action` does *not* add Kernels to model the following effects

- Dispersion: if dispersion is important, the user must manually add a set of [PorousFlowDispersiveFlux](PorousFlowDispersiveFlux.md) Kernels.
- Radioactive decay: if this is important, the user must manually add some [PorousFlowMassRadioactiveDecay](PorousFlowMassRadioactiveDecay.md) Kernels.
- Chemistry: if chemistry is of importance, then appropriate Kernels must be manually added, such as [PorousFlowPreDis](PorousFlowPreDis.md), [PorousFlowDesorpedMassTimeDerivative](PorousFlowDesorpedMassTimeDerivative.md) and [PorousFlowDesorpedMassVolumetricExpansion](PorousFlowDesorpedMassVolumetricExpansion.md).  A simple example is discussed in the [tutorial 07 page](tutorial_07.md).  Alternatively, MOOSE's Geochemistry module may be employed.


#### Heat equation

The [heat equation](porous_flow/governing_equations.md) is associated with the temperature variable, and is only included if the `coupling_type` includes "Thermo".
\begin{equation}
\label{eq:heat_cons}
0 = \frac{\partial}{\partial t}\left( (1 - \phi)\rho_{R}C_{R}T + \phi\rho\mathcal{E} \right) + \left( (1 - \phi)\rho_{R}C_{R}T + \phi\rho\mathcal{E} \right)\nabla\cdot{\mathbf
  v}_{s} -\lambda \nabla^{2}T - \nabla_{i}\left(h\rho \frac{k_{ij}}{\mu} (\nabla_{j}P - \rho g_{j}) \right)
\end{equation}
Note that multiplication by fluid density $\rho$ occurs, irrespective of the `multiply_by_density` flag.

To represent the term $\frac{\partial}{\partial t}\left( (1 - \phi)\rho_{R}C_{R}T + \phi\rho\mathcal{E} \right)$ (which only appears in `transient` simulations) the `Action` adds a [PorousFlowEnergyTimeDerivative](PorousFlowEnergyTimeDerivative.md) Kernel.  This Kernel lumps the heat energy-density to the nodes.

To represent the term $\left( (1 - \phi)\rho_{R}C_{R}T + \phi\rho\mathcal{E} \right)\nabla\cdot{\mathbf v}_{s}$ (which only appears in `transient` simulations with `coupling_type = ThermoHydroMechanical`), the `Action` adds a [PorousFlowHeatVolumetricExpansion](PorousFlowHeatVolumetricExpansion.md) Kernel.

To represent the term $\lambda \nabla^{2}T$, the `Action` adds a [PorousFlowHeatConduction](PorousFlowHeatConduction.md) Kernel

To represent the term $\nabla_{i}\left(h\rho \frac{k_{ij}}{\mu} (\nabla_{j}P - \rho g_{j}) \right)$, the `Action` adds the following Kernels and possibly UserObjects, depending on the `stabilization` parameters:

- In the case of no-upwinding, a [PorousFlowFullySaturatedHeatAdvection](PorousFlowFullySaturatedHeatAdvection.md) Kernel with `multiply_by_density = true`.
- For full upwinding, a [PorousFlowFullySaturatedUpwindHeatAdvection](PorousFlowFullySaturatedUpwindHeatAdvection.md) Kernel.
- For [KT stabilization](kt.md), a [PorousFlowFluxLimitedTVDAdvection](PorousFlowFluxLimitedTVDAdvection.md) Kernel and a [PorousFlowAdvectiveFluxCalculatorSaturatedHeat](PorousFlowAdvectiveFluxCalculatorSaturatedHeat.md) UserObject with `multiply_by_density = true`.

#### Solid-mechanics equations

The [static conservation of momentum equation](porous_flow/governing_equations.md) is associated with the displacement variables, and is only included if the `coupling_type` includes "Mechanical":
\begin{equation}
\label{eq:cons_mom}
0 = \nabla_{i}\sigma_{ij}^{\mathrm{eff}} - \alpha_{B}\nabla_{j} P - \rho_{\mathrm{undrained}} g_{j} \ .
\end{equation}
These equations are represented by a set of `StressDivergenceTensors` Kernels (or `StressDivergenceRZTensors` Kernels in the case of RZ coordinates), including thermal-eigenstrain coupling if `coupling_type = HydroThermoMechanical`, and `Gravity` Kernels.  These Kernels are added automatically and are part of the Tensor-Mechanics module.  The $\alpha_{B}\nabla_{j}P_{f}$ term is represented by a [PorousFlowEffectiveStressCoupling](PorousFlowEffectiveStressCoupling.md) Kernel.

It is assumed that the *effective stress not the total stress* enters into the
constitutive law (as above), and any plasticity, and any insitu stresses, and
almost everywhere else.  One exception is specifying Neumann boundary conditions
for the displacements where the total stresses are being specified, as can be
seen from [eq:cons_mom].  Therefore, MOOSE uses effective stress, and not total stress, internally.  If one needs to input or output total stress, one must subtract $\alpha_{B}P$ from MOOSE's stress.

#### Sources and boundary conditions

Source terms may be added to the above equations by the user by including appropriate `Kernels` or `DiracKernels` (such as those listed [here](porous_flow/systems.md) and described [here](porous_flow/sinks.md)).  [Boundary conditions](porous_flow/boundaries.md) can also be suppled.  Sources and boundary conditions are not automatically included by the `Action`.

#### Materials added

If required by the Kernels, the following Materials are added.  For each case, derivatives of the Material Properties are also created: these are with respect to mass fractions and porepressure, and, in the case of appropriate `coupling_type`, temperature and displacements.

[PorousFlow1PhaseFullySaturated](PorousFlow1PhaseFullySaturated.md) which creates `Material` versions of the porepressure and its spatial derivatives, saturation (which is always 1.0 in this case) and its spatial derivatives.

[PorousFlowTemperature](PorousFlowTemperature.md) which creates `Material` versions of the temperature and its spatial derivatives.

[PorousFlowMassFraction](PorousFlowMassFraction.md) which creates `Material` versions of the mass-fraction variables and their spatial derivatives

[PorousFlowSingleComponentFluid](PorousFlowSingleComponentFluid.md) or [PorousFlowBrine](PorousFlowBrine.md) or, in the case of `custom_fluid_properties`, a user-supplied Material to compute the fluid properties.  These properties are the fluid density and viscosity, as well as internal energy and enthalpy if required.

Using non-standard `pressure_unit` or `time_unit` is only possible with `PorousFlowSingleComponentFluid`, not `PorousFlowBrine`.  You need to read the essay on these non-standard unit systems [here](PorousFlowSingleComponentFluid.md)

[PorousFlowEffectiveFluidPressure](PorousFlowEffectiveFluidPressure.md) which creates an effective fluid pressure, equal to the porepressure, for use in mechanically-coupled models.

[PorousFlowVolumetricStrain](PorousFlowVolumetricStrain.md) which creates a volumetric strain rate, for use in mechanically-coupled models.

[PorousFlowNearestQp](PorousFlowNearestQp.md) which records the nearest quadpoint to each node in each element.

Even though there is only one fluid phase in this fully saturated action, some objects may require a relative permeability material to work. Examples include [PorousFlowDarcyVelocityComponent](PorousFlowDarcyVelocityComponent.md) `AuxKernels` which requires relative permeability, or [PorousFlowPeacemanBorehole](PorousFlowPeacemanBorehole.md) wells. By default, this action adds a constant relative permeability of one, so that the fluid is perfectly mobile.

#### Materials not added

Various important `Materials` are not added by this Action, so must be added by the user in the `[Materials]` block.  The reason these are not added by default is that they are usually subdomain-dependent.

- One of the [PorousFlowPorosity](/porous_flow/porosity.md) options
- One of the [PorousFlowPermeability](permeability.md) options
- [PorousFlowMatrixInternalEnergy](PorousFlowMatrixInternalEnergy.md)
- Thermal conductivity, such as [PorousFlowThermalConductivityIdeal](PorousFlowThermalConductivityIdeal.md)
- A definition of the elasticity tensor (eg [ComputeIsotropicElasticityTensor](/ComputeIsotropicElasticityTensor.md)) a strain calculator (eg [ComputeSmallStrain](/ComputeSmallStrain.md)) a thermal expansion eigenstrain calculator, (eg [ComputeThermalExpansionEigenstrain](/ComputeThermalExpansionEigenstrain.md)) and a stress calculator (eg [ComputeLinearElasticStress](/ComputeLinearElasticStress.md))
- Materials associated with chemistry, such as [PorousFlowAqueousPreDisChemistry](PorousFlowAqueousPreDisChemistry.md) and [PorousFlowAqueousPreDisMineral](PorousFlowAqueousPreDisMineral.md): see [tutorial 07](tutorial_07.md) for a worked example.

#### AuxVariables

- If `add_darcy_aux = true` then the `Action` adds `constant monomial` auxiliary variables with the names `darcy_vel_x`, `darcy_vel_y` and `darcy_vel_z` that record the Darcy velocity by using [PorousFlowDarcyVelocityComponent](PorousFlowDarcyVelocityComponent.md) AuxKernels.

- If `add_stress_aux = true` and the `coupling_type` includes "Mechanical", then the `Action` adds `constant monomial` auxiliary variables with the name `stress_xx`, `stress_xy`, `stress_xz`, `stress_yx`, `stress_yy`, `stress_yz`, `stress_zx`, `stress_zy` and `stress_zz` that record the effective stress using a `RankTwoAux`.  As mentioned above, this is the effective stress: if you require total stress you need to subtract $\alpha_{B}P$, as in $\sigma_{ij}^{\mathrm{total}} = \sigma^{\mathrm{eff}}_{ij} - \delta_{ij}\alpha_{B}P$







### PorousFlowUnsaturated


For discussion and a worked example, see [tutorial page 8](/tutorial_08.md).



## auxkernels

### PorousFlowDarcyVelocityComponent


This `AuxKernel` calculates the *x*, *y*, or *z* component of the Darcy velocity
\begin{equation*}
  -\frac{k\,k_{\mathrm{r,}\beta}}{\mu_{\beta}}(\nabla P_{\beta} - \rho_{\beta} \mathbf{g})
\end{equation*}
for fluid phase $\beta$. All parameters are defined in the [nomenclature](/nomenclature.md).

As this `AuxKernel` uses material properties, only elemental (`Monomial`) `AuxVariables`
can be used.




### PorousFlowDarcyVelocityComponentLowerDimensional


This `AuxKernel` records the Darcy velocity within a lower-dimensional element living in a
higher-dimensional mesh.  For instance, to study flow within a fractured material, you might have
created a 3D mesh with its own 3D subdomains (blocks of elements representing different aquifers and
aquitards, for example) and within that 3D mesh you might have included 2D elements to represent the
fractures.  Those 2D elements must share nodes with the 3D elements for the MOOSE model to make
sense.  The 2D elements belong to a different set of subdomains, and those subdomains typically have
different Material properties assigned to them (for example, high permeability and porosity).  If you
want to measure Darcy velocity within those lower-dimensional subdomains, then use this `AuxKernel`.

This `AuxKernel` calculates the *x*, *y*, or *z* component of the Darcy velocity
\begin{equation*}
  -\frac{k\,k_{\mathrm{r,}\beta}}{a\mu_{\beta}}(\nabla P_{\beta} - \rho_{\beta} \mathbf{g})
\end{equation*}
for fluid phase $\beta$, where $\nabla P_{\beta}$ and $\mathbf{g}$ are projected onto the tangent
direction of the lower-dimensional element.  All parameters are defined in the
[nomenclature](/nomenclature.md).

Notice that the denominator of this expression includes $a$, which is the fracture aperture.  If the
user doesn't want to divide by $a$, the default value of $a=1$ should be used.  However, it is likely
that when using this `AuxKernel` the dimensions of permeability will be m$^{3}$, because of a
pre-multiplication by the fracture aperture.  The denominator includes $a$ so that the unconventional
units of permeability may be accounted for if desired.

As this `AuxKernel` uses material properties, only elemental (`Monomial`) `AuxVariables` can be used.
The `AuxVariables` must be defined on the lower-dimensional subdomain only.

For the result to make sense, the permeability tensor, $k$, must not rotate tangential vectors to
non-tangential vectors.  For instance, an isotropic permeability tensor is sensible.




### PorousFlowElementLength

This `AuxKernel` calculates a notion of element "length" along a given direction.  A plane is constructed through the element's centroid, with normal equal to the [!param](/AuxKernels/PorousFlowElementLength/direction).  The average of the distance of the nodal positions to this plane is the "length" returned.  An example is shown in [ele_l_fig].


Only elemental (`Monomial`) `AuxVariables` can be used with this `AuxKernel`




### PorousFlowElementNormal

This `AuxKernel` calculates the element normal, and returns the *x*, *y*, or *z* component.  This is mostly designed for 2D elements living in 3D space, however, the 1D and 3D cases are handled as special cases using the [!param](/AuxKernels/PorousFlowElementNormal/1D_perp) and [!param](/AuxKernels/PorousFlowElementNormal/3D_default) inputs.

For 2D elements, the normal is calculated by:

1. Construct the vector $(n_{2} - n_{1})\times (n_{0} - n_{1})$, where $\times$ is the cross-product, and $n_{i}$ is the position of the $i^{\mathrm{th}}$ node.
2. Construct the vector $(n_{3} - n_{2})\times (n_{1} - n_{2})$
3. $\ldots$
3. Construct the vector $(n_{N-1} - n_{N-2})\times (n_{N-3} - n_{N-2})$, where $N$ is the number of nodes in the element.  Hence, for triangular linear Lagrange elements ($N=3$) only 1 vector is constructed, for quadrilateral linear Lagrange elements ($N=4$) 2 vectors are constructed
4. Sum these vectors, normalise, and return the result

For 1D elements, the normal is calculated by:

1. Construct the vector $v\times (n_{1} - n_{0})$, where $v$ is the [!param](/AuxKernels/PorousFlowElementNormal/1D_perp) vector supplied by the user
2. Construct the vector $v\times (n_{2} - n_{1})$
3. $\ldots$
3. Construct the vector $v\times (n_{N-1} - n_{N-2})$, where $N$ is the number of nodes in the element.  Hence, for bar linear Lagrange elements ($N=2$) only 1 vector is constructed
4. Sum these vectors, normalise, and return the result

For 3D elements, the [!param](/AuxKernels/PorousFlowElementNormal/3D_default) is returned.


Only elemental (`Monomial`) `AuxVariables` can be used with this `AuxKernel`




### PorousFlowPropertyAux


This `AuxKernel` provides simplified access to fluid and material properties. The
following properties are available using the `property` input parameter:

- `pressure`
- `saturation`
- `temperature`
- `density`
- `viscosity`
- `mass_fraction`
- `relperm`
- `capillary_pressure`
- `enthalpy`
- `internal_energy`
- `secondary_concentration` (m$^{3}$(secondary species)/m$^{3}$(fluid))
- `mineral_concentration` (m$^{3}$(secondary species)/m$^{3}$(porous material))
- `mineral_reaction_rate` (m$^{3}$(secondary species).m$^{-3}$(porous material).s$^{-1}$))
- `porosity`
- `permeability`
- `hystersis_order`
- `hysteresis_saturation_turning_point`
- `hysteretic_info` --- see [PorousFlowHystereticInfo](PorousFlowHystereticInfo.md)

The fluid phase and fluid component are specified in the `phase` and
`fluid_component` input parameters, respectively.  For properties
related to chemical reactions, the `secondary_species` and
`mineral_species` parameters are relevant.  For `hysteresis_saturation_turning_point` the `hysteresis_turning_point` number is relevant.

As this `AuxKernel` uses material properties, only elemental (`Monomial`) `AuxVariables`
can be used.




## bcs

### PorousFlowEnthalpySink

`PorousFlowEnthalpySink` implements a sink that adds heat energy corresponding to
adding fluid at a mass flux rate (computed by a function) at a specified temperature.

This object should be used in conjunction with (PorousFlowSink)[PorousFlowSink.md]
that uses the same `flux_function`, so that the correct amount of fluid is injected into the system.
Users are encouraged to utilize the (PorousFlowSinkBC)[PorousFlowSinkBC.md] to avoid making subtle mistakes.

Note that the fluid property object used by this boundary condition should be the same one that is
used in the computational domain where this object is located.

This BC can be used to model two situations.

- If [!param](/BCs/PorousFlowEnthalpySink/fluid_phase) is provided, then the injected enthalpy is calculated using the porepressure within the porous medium, and [!param](/BCs/PorousFlowEnthalpySink/T_in).  This corresponds to injecting at a specified rate and specified temperature which could potentially lead to changes in the porepressure (assuming the appropriate (PorousFlowSink)[PorousFlowSink.md] is also added).
- If [!param](/BCs/PorousFlowEnthalpySink/porepressure_var) is provided, then the injected enthalpy is calculated using this pressure (which may be an AuxVariable, for instance) and [!param](/BCs/PorousFlowEnthalpySink/T_in).  This corresponds to injecting a fluid at a specified rate, specified pressure and specified temperature.

For instance:





### PorousFlowHalfCubicSink


The basic sink $f(x,t)$ is scaled by a cubic flux multiplier of the pressure
of a fluid phase *or* the temperature.  Label the pressure or temperature by $v$.  Then the sink strength is
\begin{equation*}
  s = f(t, x) \times g(v) \ .
\end{equation*}

The function $g$ interpolates smoothly between $g(v_{\mathrm{cutoff}} + v_{\mathrm{center}}) = 0$ and $g(v_{\mathrm{center}}) = g_{\mathrm{max}}$.  Since a cubic interpolation is used, the function $g$ is continuous and its derivative is continuous everywhere.  Explicitly:
\begin{equation*}
  g(v) =
  \begin{cases}
    g_{\mathrm{max}} & \text{if}\ v > v_{\mathrm{center}} \\
    \frac{g_{\mathrm{max}} \left(2[v - v_{\mathrm{center}}] + v_{\mathrm{cutoff}}\right) (v - v_{\mathrm{center}} - v_{\mathrm{cutoff}})^2}{v_{\mathrm{cutoff}}^3},  & v_{\mathrm{cutoff}} + v_{\mathrm{center}} \leq v \leq v_{\mathrm{center}} \\
    0 & \text{if}\ v < v_{\mathrm{cutoff}} + v_{\mathrm{center}} \\
  \end{cases}
\end{equation*}
Here the units of $f\times g$ are kg.m$^{-2}$.s$^{-1}$ (for fluids) or
J.m$^{-1}$.s$^{-1}$ (for heat). The parameters $g_{\mathrm{max}}$, $v_{\mathrm{center}}$ and $v_{\mathrm{cutoff}}$ are given in the input file using the `max`, `center` and `cutoff` options, respectively.

This sink is often used in groundwater modelling of evapotranspiration, where:

- $v_{\mathrm{center}} = 0$, since evapotranspiration is maximum when the groundwater table is at or above the topography;
- $v_{\mathrm{cutoff}} = -10^{4}d$, where $d$ is the root depth at which there is no evapotranspiration from the groundwater system;
- $g_{\mathrm{max}}$ is the value of the pan evaporation, in kg.m$^{-2}$.s$^{-1}$.

If $f>0$ then the boundary condition will act as a sink, while if $f<0$ the boundary condition acts as a source.  If applied to a fluid-component equation, the function $f$ has units kg.m$^{-2}$.s$^{-1}$.  If applied to the heat equation, the function $f$ has units J.m$^{-2}$.s$^{-1}$.  These units are potentially modified if the extra building blocks enumerated below are used.

In addition, the sink may be multiplied by any or all of the following
quantities through the `optional parameters` list.

- Fluid relative permeability
- Fluid mobility ($k_{ij}n_{i}n_{j}k_{r} \rho / \nu$, where $n$ is the normal vector to the boundary)
- Fluid mass fraction
- Fluid internal energy
- Thermal conductivity

See [boundary conditions](boundaries.md) for many more details and discussion.




### PorousFlowHalfGaussianSink


The basic sink $f(x,t)$ is scaled by a Gaussian flux multiplier of the pressure
of a fluid phase *or* the temperature $g(v)$:
\begin{equation*}
  s = f(t, x) \times g(v) \,
\end{equation*}
where
\begin{equation*}
  g(v) =
  \begin{cases}
    g_{\mathrm{max}} \exp((-0.5 (v - v_{\mathrm{center}}) / sd)^2), & \text{if}\ v < v_{\mathrm{center}} \\
    g_{\mathrm{max}},  & \text{otherwise}
  \end{cases}
\end{equation*}
Here the units of $f\times g$ are kg.m$^{-2}$.s$^{-1}$ (for fluids) or
J.m$^{-1}$.s$^{-1}$ (for heat). The parameters $g_{\mathrm{max}}$, $v_{\mathrm{center}}$ and $sd$ are given in the input file using the `max`, `center` and `sd` options, respectively.

If $f>0$ then the boundary condition will act as a sink, while if $f<0$ the boundary condition acts as a source.  If applied to a fluid-component equation, the function $f$ has units kg.m$^{-2}$.s$^{-1}$.  If applied to the heat equation, the function $f$ has units J.m$^{-2}$.s$^{-1}$.  These units are potentially modified if the extra building blocks enumerated below are used.

In addition, the sink may be multiplied by any or all of the following
quantities through the `optional parameters` list.

- Fluid relative permeability
- Fluid mobility ($k_{ij}n_{i}n_{j}k_{r} \rho / \nu$, where $n$ is the normal vector to the boundary)
- Fluid mass fraction
- Fluid internal energy
- Thermal conductivity

See [boundary conditions](boundaries.md) for many more details and discussion.




### PorousFlowOutflowBC

This adds the following term to the residual
\begin{equation}
\int_{\partial\Omega}\psi {\mathbf n}\cdot \mathbf{F}
\end{equation}
Various forms for $\mathbf{F}$ may be chosen, as discussed next, so that this BC removes fluid species or heat energy through $\partial\Omega$ at exactly the rate specified by the multi-component, multi-phase Darcy-Richards equation, or the heat equation.  Therefore, this BC can be used to represent a "free" boundary through which fluid or heat can freely flow: the boundary is "invisible" to the simulation.  Alternate PorousFlow boundary conditions, such as those allowing boundary fluxes to be prescribed, are discussed [here](boundaries.md).

Ensure your normal vector points *out* of the model, otherwise your fluxes will have the wrong sign

`PorousFlowOutflowBC` does not model the interface of the model with "empty space".  Imagine a model of a porous-media pipe containing water.  `PorousFlowOutflowBC` does *not* model the situation where the pipe has an end through which the water flows into empty space.  Instead, `PorousFlowOutflowBC` allows only part of the pipe to be modelled: when water exits the model it continues freely into the unmodelled section of the pipe.  In this sense, the model's boundary is "invisible" to the simulation.  This has a further consequence: if there is a sink in the modelled section, `PorousFlowOutflowBC` will allow water to flow from the unmodelled section into the modelled section.

The rate of outflow is limited by the permeability, the viscosity of the fluid, etc, in exactly the same way that the Darcy velocity is limited by these quantities.  This means, for instance, if you inject a lot of fluid or heat into the model, it will take the `PorousFlowOutflowBC` some time to "suck" it all out.

Worked examples of this boundary condition may be found in the [boundaries documentation](boundaries.md).

This BC is fully upwinded, so can be used in conjunction with the [PorousFlowAdvectiveFlux](PorousFlowAdvectiveFlux.md), [PorousFlowHeatAdvection](PorousFlowHeatAdvection.md) and [PorousFlowHeatConduction](PorousFlowHeatConduction.md) Kernels.

##### Fluid flow

To allow a fluid species, $\kappa$, to flow freely out of the model, the [governing equations](porous_flow/governing_equations.md) imply that
\begin{equation}
\mathbf{F} = \sum_{\beta}\chi_{\beta}^{\kappa}\mathbf{F}_{\beta}^{\mathrm{advective}} + \mathbf{F}^{\kappa}_{\mathrm{diffusion+dispersion}} \ ,
\end{equation}
where the standard [Porous Flow nomenclature](/porous_flow/nomenclature.md) has been used.  Many PorousFlow simulations do not involve diffusion and dispersion, so the latter term is not included in `PorousFlowOutflowBC`: $\mathbf{F}$ is simply
\begin{equation}
\mathbf{F} = \sum_{\beta}\chi_{\beta}^{\kappa}\mathbf{F}_{\beta}^{\mathrm{advective}} = -\sum_{\beta}\chi_{\beta}^{\kappa}\rho_{\beta}\frac{k\,k_{\mathrm{r,}\beta}}{\mu_{\beta}}(\nabla
P_{\beta} - \rho_{\beta} \mathbf{g}) \ .
\end{equation}

Input-file syntax for this type of boundary condition requires specifying:

- `flux_type = fluid` (the default);
- the `mass_fraction_component` $\kappa$;
- the flag `include_relperm`, which should only be set `false` in fully-saturated situations where there is no notion of relative permeability;
- the flag `multiply_by_density`, which means the above expression is *not* premultiplied by $\rho_{\beta}$.  This allows the `PorousFlowOutflowBC` to be used with other objects that do not multiply by density in simulations based on fluid volume instead of fluid mass.

##### Heat flow

To allow heat energy to flow freely out of the model, the [governing equations](porous_flow/governing_equations.md) imply that
\begin{equation}
\mathbf{F} = -\lambda \nabla T + \sum_{\beta}h_{\beta}\mathbf{F}_{\beta} = -\lambda \nabla T - \sum_{\beta}h_{\beta}\rho_{\beta}\frac{k\,k_{\mathrm{r,}\beta}}{\mu_{\beta}}(\nabla
P_{\beta} - \rho_{\beta} \mathbf{g}) \ .
\end{equation}

Input-file syntax for this type of boundary condition requires specifying:

- `flux_type = heat`;
- the flag `include_relperm`, which should only be set `false` in fully-saturated situations where there is no notion of relative permeability.

In this case, `multiply_by_density` is set to `true` irrespective of the choice set by the user, since it is an error not to multiply by density.  Any `mass_fraction_component` specified is ignored.


##### Example: single-phase, single-component fluid-flow through a boundary

The most basic usage of [PorousFlowOutflowBC](PorousFlowOutflowBC.md) is illustrated in the following:


In this input-file, all boundaries are of the "outflow" type, and the total flow rate (kg.s$^{-1}$) is recorded into the `outflow_kg_per_s` using a [NodalSum](NodalSum.md) postprocessor.


##### Example: heat flow through a boundary

A [PorousFlowOutflowBC](PorousFlowOutflowBC.md) with `flux_type = heat` will allow heat to flow through a boundary.  To record the total heat-energy flowing through the boundary a [NodalSum](NodalSum.md) postprocessor should be used:



#### A multicomponent example

A fully-saturated 2-component modelled on a 1D line segment, $0\leq x \leq 1$:


The model initializes with the porous material fully filled with component = 1 (that is, `frac = 0`) and with a porepressure gradient that will move fluid from negative $x$ to positive $x$:
\begin{equation}
p(t=0) = 1 - x \ \ \ \mathrm{and}\ \ \ \chi^{0}(t=0) = 0 \ .
\end{equation}



For $t>0$, fluid component $0$ (the `frac` variable) is introduced on the material's left
side ($x=0$), by applying the fixed boundary conditions:
\begin{equation}
p(x=0) = 1 \ \ \ \mathrm{and}\ \ \ \chi^{0}(x=0) = 1 \ .
\end{equation}
The right-hand side, at $x=1$, has fixed porepressure
\begin{equation}
p(x=1) = 0 \ .
\end{equation}
while the fluid component $0$ (the `frac` variable) is allowed to freely exit the domain when it arrives there.

- Porepressure is held at `pp = 1` at $x=0$.  (Physically this adds or removes component = 1 to ensure that porepressure is fixed.)
- Porepressure is held at `pp = 0` at $x=1$.  (Physically this adds or removes component = 1 to ensure that porepressure is fixed.)  These two BCs ensure the porepressure gradient is maintained.
- The zeroth mass fraction is held at `frac = 1` at $x=0$.
- The zeroth mass fraction is allowed to freely exit the model at $x=1$.

The former 3 are implemented using [DirichletBC](DirichletBC.md), while the latter is the `PorousFlowOutflowBC`.  It acts on `mass_fraction_component = 0` because that is the mass-fraction associated to the `frac` variable by the [PorousFlowFullySaturated Action](PorousFlowFullySaturated.md):


The results are shown in [s13] where it can be seen the fluid component freely exits the right-hand boundary.

	style=width:60%;margin:auto;padding-top:2.5%;
	id=s13
	caption=Advection and diffusion of a fluid component from left to right along a porepressure gradient.  The fluid component is free to exit the right-hand boundary due to the PorousFlowOutflowBC there.

Further description of this result and further examples may be found in the [boundaries documentation](boundaries.md) and [sinks tests documentation](sinks_tests.md).





### PorousFlowPiecewiseLinearSink


The basic sink $f(x,t)$ is multiplied by a piecewise linear MOOSE Function of the pressure
of a fluid phase $g(P^{\beta}-P_{\mathrm{e}})$ *or* the temperature $g(T-T_{\mathrm{e}})$:
\begin{equation*}
s = f(t, x) \times g(P^{\beta}-P_{\mathrm{e}}) \ \ \ \textrm{or}\ \ \ s = f(t, x)
\times g(T-T_{\mathrm{e}}) \ .
\end{equation*}
Here the units of $f\times g$ are kg.m$^{-2}$.s$^{-1}$ (for fluids) or
J.m$^{-1}$.s$^{-1}$ (for heat).

If $f>0$ then the boundary condition will act as a sink, while if $f<0$ the boundary condition acts as a source.  If applied to a fluid-component equation, the function $f$ has units kg.m$^{-2}$.s$^{-1}$.  If applied to the heat equation, the function $f$ has units J.m$^{-2}$.s$^{-1}$.  These units are potentially modified if the extra building blocks enumerated below are used.

In addition, the sink may be multiplied by any or all of the following
quantities through the `optional parameters` list.

- Fluid relative permeability
- Fluid mobility ($k_{ij}n_{i}n_{j}k_{r} \rho / \nu$, where $n$ is the normal vector to the boundary)
- Fluid mass fraction
- Fluid internal energy
- Thermal conductivity

See [boundary conditions](boundaries.md) for many more details and discussion.




### PorousFlowSink


This sink is
\begin{equation*}
s = f(t, x) \ ,
\end{equation*}
where $f$ is a MOOSE Function of time and position on the boundary.

If $f>0$ then the boundary condition will act as a sink, while if $f<0$ the boundary condition acts as a source.  If applied to a fluid-component equation, the function $f$ has units kg.m$^{-2}$.s$^{-1}$.  If applied to the heat equation, the function $f$ has units J.m$^{-2}$.s$^{-1}$.  These units are potentially modified if the extra building blocks enumerated below are used.

In addition, the sink may be multiplied by any or all of the following
quantities through the `optional parameters` list.

- Fluid relative permeability
- Fluid mobility ($k_{ij}n_{i}n_{j}k_{r} \rho / \nu$, where $n$ is the normal vector to the boundary)
- Fluid mass fraction
- Fluid internal energy
- Thermal conductivity

See [boundary conditions](boundaries.md) for many more details and discussion.




### PorousFlowSinkBC

This class adds a (PorousFlowSink)[PorousFlowSink.md] and a (PorousFlowEnthalpySink)[PorousFlowEnthalpySink.md] to model adding fluid at a mass flux rate at a specified temperature.

Users are required to specify:

- `boundary` - The list of boundary IDs from the mesh where this boundary condition applies
- either `fluid_phase` (the fluid phase whose porepressure is used to compute the injected enthalpy) or `porepressure_var` (an AuxVariable representing fluid pressure at which to compute the injected enthalpy)
- `T_in` - Inlet temperature
- `fp` - The name of the user object for fluid properties
- `flux_function` - The flux out of the medium


## dirackernels

### PorousFlowPeacemanBorehole

A `PorousFlowPeacemanBorehole` is a special case of the general line sink in which a polyline (represented by a sequence of points) acts as a sink or source in the model.  Please see [sinks](sinks.md) for an extended discussion and examples.

The function given by [!param](/DiracKernels/PorousFlowPeacemanBorehole/bottom_p_or_t) is evaluated at the well bottom.  If a file is read in using [!param](/DiracKernels/PorousFlowPeacemanBorehole/point_file) to define the coordinates and weights of the PorousFlowPeacemanBorehole, the well bottom is assumed to be the last entry in this file and [!param](/DiracKernels/PorousFlowPeacemanBorehole/bottom_p_or_t) will be evaluated at the z-coordinate of the last entry in [!param](/DiracKernels/PorousFlowPeacemanBorehole/point_file).  It is an error if the first entry in the [!param](/DiracKernels/PorousFlowPeacemanBorehole/point_file) has a smaller z-coordinate than the last entry.




### PorousFlowPointEnthalpySourceFromPostprocessor

`PorousFlowPointEnthalpySourceFromPostprocessor` implements a point source that adds heat energy
corresponding to adding fluid at a mass flux rate (computed by a postprocessor) at a specified
temperature (computed by a postprocessor).

This object should be used in conjunction with (PorousFlowPointSourceFromPostprocessor)[PorousFlowPointSourceFromPostprocessor.md]
that uses the same `mass_flux` Postprocessor, so that the correct amount of fluid is injected into the system.

Note that the fluid property object used by this Dirac kernel should be the same one that used in
the computational domain where this object is located.

Parameter [!param](/DiracKernels/PorousFlowPointEnthalpySourceFromPostprocessor/pressure)
(along with [!param](/DiracKernels/PorousFlowPointEnthalpySourceFromPostprocessor/T_in)) is used to calculate
the injected fluid enthalpy. Most frequently, it is the PorousFlow pressure variable (the porepressure
in the porous medium). This models the situation where fluid is injected at a specified rate and
temperature (using this DiracKernel and a PorousFlowPointSourceFromPostprocessor) which potentially
leads to changes in the porepressure. Alternately, it may be the pressure of the injected fluid, as
fixed by an external agent (such as a pump) which is stored in an AuxVariable.

For instance:


Note that the ```execute_on``` parameter is set to ```timestep_begin``` so that the correct
value is being used within the timestep.






### PorousFlowPointSourceFromPostprocessor

`PorousFlowPointSourceFromPostprocessor`
implements a mass point source that adds (or removes) fluid at a
mass flux rate that was computed by a postprocessor.

For instance:


Note that the ```execute_on``` parameter is set to ```timestep_begin``` so that the correct
value is being used within the timestep.





### PorousFlowPolyLineSink

A `PorousFlowPolyLineSink` is a special case of the general line sink in which a polyline (represented by a sequence of points) acts as a sink or source in the model.  Please see [sinks](sinks.md) for an extended discussion and examples.




### PorousFlowSquarePulsePointSource

`PorousFlowSquarePulsePointSource`
implements a constant mass point source that adds (removes) fluid at a constant
mass flux rate for times between the specified start and end times. If
no start and end times are specified, the source (sink) starts at the
start of the simulation and continues to act indefinitely. 
For instance:





## functions

### MovingPlanarFront





## fvbcs

### FVPorousFlowAdvectiveFluxBC


This boundary condition implements the strong form of
\begin{equation*}
  -\nabla\cdot \sum_{\beta}\chi_{\beta}^{\kappa} \rho_{\beta}\frac{k\,k_{\mathrm{r,}\beta}}{\mu_{\beta}}(\nabla P_{\beta} - \rho_{\beta} \mathbf{g})
\end{equation*}
on the boundary where all parameters are defined in the [nomenclature](/nomenclature.md).




## fvkernels

### FVPorousFlowAdvectiveFlux


This `FVKernel` implements the strong form of
\begin{equation*}
  -\nabla\cdot \sum_{\beta}\chi_{\beta}^{\kappa} \rho_{\beta}\frac{k\,k_{\mathrm{r,}\beta}}{\mu_{\beta}}(\nabla P_{\beta} - \rho_{\beta} \mathbf{g})
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).




### FVPorousFlowDispersiveFlux


This `FVKernel` implements the strong form of
\begin{equation*}
  -\nabla\cdot \sum_{\beta}\rho_{\beta}{\mathcal{D}}_{\beta}^{\kappa}\nabla \chi_{\beta}^{\kappa}
\end{equation*}
where the hydrodynamic dispersion tensor is
\begin{equation*}
{\mathcal{D}}_{\beta}^{\kappa} = D_{\beta,T}^{\kappa}{\mathcal{I}} +
\frac{D_{\beta,L}^{\kappa} - D_{\beta,
    T}^{\kappa}}{\mathbf{v}_{\beta}^{2}}\mathbf{v}_{\beta}\mathbf{v}_{\beta}
\ ,
\end{equation*}
where
\begin{equation*}
\begin{aligned}
D_{\beta,L}^{\kappa} & = \phi\tau_{0}\tau_{\beta}d_{\beta}^{\kappa} + \alpha_{\beta, L}\left|\mathbf{v}\right|_{\beta} \ , \\
D_{\beta,T}^{\kappa} & = \phi\tau_{0}\tau_{\beta}d_{\beta}^{\kappa} + \alpha_{\beta, T}\left|\mathbf{v}\right|_{\beta} \ .
\end{aligned}
\end{equation*}
All parameters are defined in the [nomenclature](/nomenclature.md).




### FVPorousFlowEnergyTimeDerivative


This `FVKernel` implements the strong form of
\begin{equation*}
  \frac{\partial}{\partial t}\left((1-\phi)\rho_{R}C_{R}T + \phi\sum_{\beta}S_{\beta}\rho_{\beta}\mathcal{E}_{\beta}\right)
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).

Presently, a first-order accurate implicit Euler time derivative is hard-coded.




### FVPorousFlowHeatAdvection


This `FVKernel` implements the strong form of
\begin{equation*}
  -\nabla\cdot \sum_{\beta}h_{\beta} \rho_{\beta}\frac{k\,k_{\mathrm{r,}\beta}}{\mu_{\beta}}(\nabla P_{\beta} - \rho_{\beta} \mathbf{g})
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).




### FVPorousFlowHeatConduction


This `FVKernel` implements the strong form of
\begin{equation*}
  -\nabla\cdot \left(\lambda \nabla T\right)
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).




### FVPorousFlowMassTimeDerivative


This `FVKernel` implements the strong form of
\begin{equation*}
  \frac{\partial}{\partial t}\left(\phi\sum_{\beta}S_{\beta}\rho_{\beta}\chi_{\beta}^{\kappa}\right)
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).

Presently, a first-order accurate implicit Euler time derivative is hard-coded.




## ics

### PorousFlowFluidPropertyIC


This initial condition provides a straightforward way to specify an initial value for a
fluid property using pressure and temperature as the inputs.

A valid [Fluid Properties](/fluid_properties/index.md) UserObject is required.

The FluidProperties UserObject expects temperature in Kelvin. If the simulation uses temperature in Celsius, `temperature_units = celsius` must be used.




### PorousFlowFluidStateIC


This initial condition provides a straightforward way to specify an initial gas saturation for models using the persistent variable fluid states that describe miscible multicomponent, multiphase flow.




## kernels

### FluxLimitedTVDAdvection


This `Kernel` implements the weak form of
\begin{equation}
\nabla\cdot(\mathbf{v}u) \ .
\end{equation}
It employs Kuzmin-Turek [!citep](KuzminTurek2004) stabilization, so needs a corresponding [AdvectiveFluxCalculatorConstantVelocity](AdvectiveFluxCalculatorConstantVelocity.md) UserObject.  This sort of stabilization is described in detail in [A worked example of Kuzmin-Turek stabilization](kt_worked.md).  Also see [numerical diffusion](numerical_diffusion.md) for example of how the Kuzmin-Turek scheme compares with other numerical schemes.




### PorousFlowAdvectiveFlux


This `Kernel` implements the weak form of
\begin{equation*}
  -\nabla\cdot \sum_{\beta}\chi_{\beta}^{\kappa} \rho_{\beta}\frac{k\,k_{\mathrm{r,}\beta}}{\mu_{\beta}}(\nabla P_{\beta} - \rho_{\beta} \mathbf{g})
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).

A fully-upwinded version is implemented, where the mobility of the upstream nodes is used.

See [upwinding](/upwinding.md) for details.  Other Kernels implement [Kuzmin-Turek TVD stabilization](kt.md).




### PorousFlowBasicAdvection


This Kernel implements the differential expression
\begin{equation}
\nabla\cdot(\mathbf{v}_{\beta} u) \ ,
\end{equation}
where $\mathbf{v}_{\beta}$ is Darcy velocity of fluid phase $\beta$.  That is, the advection of a variable $u$.  The Darcy velocity is defined to be
\begin{equation}
\mathbf{v}_{\beta} = -\frac{k k_{\mathrm{r,}\ \beta}}{\mu_{\beta}}(\nabla P_{\beta} - \rho_{\beta}\mathbf{g}) \ ,
\end{equation}
where $k$ is the permeability tensor, $k_{\mathrm{r,}\ \beta}$ is the relative permeability, $\mu$ is the viscosity, $P$ is the porepressure, $\rho$ is the density and $\mathbf{g}$ is the gravitational acceleration.

This Kernel is designed to be used with tracers or other similar variables that are not described by the mass fraction variables of PorousFlow.  It requires the use of the [`PorousFlowDarcyVelocityMaterial`](PorousFlowDarcyVelocityMaterial.md) material.

The most naive implementation of advection is used.  You will almost definitely see spurious overshoots and undershoots as well as numerical diffusion when using this `Kernel`.  It is usually better to use the [`PorousFlowAdvectiveFlux`](PorousFlowAdvectiveFlux.md) if possible.

The typical usage of this `Kernel` is to model the advection equation $\dot{u}+\nabla (vu) = 0$, which is implemented by the following:





### PorousFlowDesorpedMassTimeDerivative


This `Kernel` implements the weak form of
\begin{equation*}
  \frac{\partial}{\partial t}\left((1 - \phi)C^{\kappa}\right)
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).




### PorousFlowDesorpedMassVolumetricExpansion


This `Kernel` implements the weak form of
\begin{equation*}
  \left((1 - \phi)C^{\kappa}\right)\nabla\cdot\mathbf{v}_{s}
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).




### PorousFlowDispersiveFlux


This `Kernel` implements the weak form of
\begin{equation*}
  -\nabla\cdot \sum_{\beta}\rho_{\beta}{\mathcal{D}}_{\beta}^{\kappa}\nabla \chi_{\beta}^{\kappa}
\end{equation*}
where the hydrodynamic dispersion tensor is
\begin{equation*}
{\mathcal{D}}_{\beta}^{\kappa} = D_{\beta,T}^{\kappa}{\mathcal{I}} +
\frac{D_{\beta,L}^{\kappa} - D_{\beta,
    T}^{\kappa}}{\mathbf{v}_{\beta}^{2}}\mathbf{v}_{\beta}\mathbf{v}_{\beta}
\ ,
\end{equation*}
where
\begin{equation*}
\begin{aligned}
D_{\beta,L}^{\kappa} & = \phi\tau_{0}\tau_{\beta}d_{\beta}^{\kappa} + \alpha_{\beta, L}\left|\mathbf{v}\right|_{\beta} \ , \\
D_{\beta,T}^{\kappa} & = \phi\tau_{0}\tau_{\beta}d_{\beta}^{\kappa} + \alpha_{\beta, T}\left|\mathbf{v}\right|_{\beta} \ .
\end{aligned}
\end{equation*}
All parameters are defined in the [nomenclature](/nomenclature.md).




### PorousFlowEffectiveStressCoupling





### PorousFlowEnergyTimeDerivative


This `Kernel` implements the weak form of
\begin{equation*}
  \frac{\partial}{\partial t}\left((1-\phi)\rho_{R}C_{R}T + \phi\sum_{\beta}S_{\beta}\rho_{\beta}\mathcal{E}_{\beta}\right)
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).

An energy-lumped version is implemented.

See [mass lumping](/mass_lumping.md) for details.

For mechanically-coupled simulations (where the mesh deforms) the numerical implementation of this Kernel involves the old value of the volumetric strain.  Further information can be found [here](porous_flow/time_derivative.md).  This is assumed to be calculated by a SolidMechanics strain calculator, for instance [ComputeSmallStrain](ComputeSmallStrain.md), with a given `base_name`.  Hence, you should usually employ the same `base_name` for this Kernel as used by your strain calculator.  However, if you wish to include mechanical deformations, but not couple them to the porous flow, simply enter a `base_name` that doesn't exist (eg `base_name = non_existent`) and the volumetric strain won't be included in this Kernel.  (Note: if you want a fully-coupled simulation but accidentally make a typo in your `base_name`, then PorousFlow will assume you don't want to include the volumetric strain!)

Because it contains volumetric strain, this Kernel always sets `use_displaced_mesh = false` and the parameter cannot be altered by the user.  Further information can be found [here](porous_flow/time_derivative.md)




### PorousFlowExponentialDecay

`!syntax description /Kernels/PorousFlowExponentialDecay`

#### Description

The residual computed by `PorousFlowExponentialDecay` is
\begin{equation}
\mathrm{residual} = r(u - u_{\mathrm{ref}})
\end{equation}
where $u$ is the variable, and $r$ and $u_{\mathrm{ref}}$ are `AuxVariables` (or real values).  Combined with a `TimeDerivative` `Kernel`, this is useful for simulating exponential decay of $u$.  One example is simulating heat loss using the Lauwerier  model.

`!syntax parameters /Kernels/PorousFlowExponentialDecay`

`!syntax inputs /Kernels/PorousFlowExponentialDecay`

`!syntax children /Kernels/PorousFlowExponentialDecay`

### PorousFlowFluxLimitedTVDAdvection

This `Kernel` implements the advective flux
\begin{equation}
\nabla\cdot(\mathbf{v}u) \ ,
\end{equation}
where $u$ and $\mathbf{v}$ are defined via one of the `PorousFlowAdvectiveFluxCalculator` UserObjects.  See the [PorousFlow Kuzmin-Turek page](kt.md) for details of to use this Kernel in PorousFlow simulations.




### PorousFlowFullySaturatedAdvectiveFlux


Describes the differential term
\begin{equation}
-\nabla\cdot ((\rho)\chi^{\kappa} k(\nabla P - \rho \mathbf{g})/\mu) \ .
\end{equation}
The nomenclature is described [here](nomenclature.md).  This is fully-saturated, multi-component, single-phase Darcy flow for fluid component $\kappa$.

The factor $(\rho)$ appears in parentheses because it is optional and controlled by the `multiply_by_density` flag.  If `multiply_by_density = false` is chosen then the problem becomes more linear (and hence converges faster) but care must be taken with other PorousFlow objects (such as [PorousFlowFluidMass](PorousFlowFluidMass.md)) since all fluxes become *volume fluxes* (with SI units m$^{3}$.m$^{-3}$.s$^{-1}$) instead of the usual mass fluxes (with SI units kg.m$^{-3}$.s$^{-1}$)

[Full upwinding](upwinding.md) is used in this Kernel.  See the [numerical stabilization lead page](stabilization.md) page for more details.

This Kernel may be added automatically by the [PorousFlowFullySaturated](PorousFlowFullySaturated.md) Action: see more discussion on that page.





### PorousFlowFullySaturatedDarcyBase


Describes the differential term
\begin{equation}
-\nabla\cdot ((\rho)k(\nabla P - \rho \mathbf{g})/\mu) \ .
\end{equation}
The nomenclature is described [here](nomenclature.md).  This is fully-saturated, single-component, single-phase Darcy flow.

The multiplication by $\rho$ is optional: this is indicated by the parentheses.  The reason for this is that the time-derivative part described by [PorousFlowFullySaturatedMassTimeDerivative](PorousFlowFullySaturatedMassTimeDerivative.md) linearises if the total differential equation is not multiplied by density.  Please see that page for a full description of the effects of not multiplying by density.

No [upwinding](upwinding.md) is performed, which means many [nodal Material properties](tutorial_09.md) are not needed and [numerical diffusion](numerical_diffusion.md) is reduced.  However, the numerics are less well controlled: the whole point of full upwinding is to prevent over-shoots and under-shoots.    Other Kernels implement [Kuzmin-Turek TVD stabilization](kt.md).





### PorousFlowFullySaturatedDarcyFlow


Describes the differential term
\begin{equation}
-\nabla\cdot ((\rho)\chi^{\kappa} k(\nabla P - \rho \mathbf{g})/\mu) \ .
\end{equation}
The nomenclature is described [here](nomenclature.md).  This is fully-saturated, multi-component, single-phase Darcy flow for fluid component $\kappa$.

Although the multiplication by $\rho$ is optional, you should almost always set `multiply_by_density=true`

No [upwinding](upwinding.md) is performed, which means many [nodal Material properties](tutorial_09.md) are not needed and [numerical diffusion](numerical_diffusion.md) is reduced.  However, the numerics are less well controlled: the whole point of full upwinding is to prevent over-shoots and under-shoots in the mass fraction, etc.  Other Kernels implement [Kuzmin-Turek TVD stabilization](kt.md).





### PorousFlowFullySaturatedHeatAdvection


Describes the differential term
\begin{equation}
-\nabla\cdot ((\rho)h k(\nabla P - \rho \mathbf{g})/\mu) \ .
\end{equation}
The nomenclature is described [here](nomenclature.md).  This describes heat advection via Darcy flow in fully-saturated, multi-component, single-phase cases.

Although the multiplication by $\rho$ is optional, you should almost always set `multiply_by_density=true`

No [upwinding](upwinding.md) is performed, which means many [nodal Material properties](tutorial_09.md) are not needed and [numerical diffusion](numerical_diffusion.md) is reduced.  However, the numerics are less well controlled: the whole point of full upwinding is to prevent over-shoots and under-shoots in the temperature, etc.

If you desire full upwinding, use [PorousFlowFullySaturatedUpwindHeatAdvection](PorousFlowFullySaturatedUpwindHeatAdvection.md) instead.  If you desire [Kuzmin-Turek TVD stabilization](kt.md), use [PorousFlowFluxLimitedTVDAdvection](PorousFlowFluxLimitedTVDAdvection.md).






### PorousFlowFullySaturatedMassTimeDerivative


Consider a fully-saturated, single-phase, single-component fluid in a
THM simulation.  The time-derivative terms from the [fluid governing equation](porous_flow/governing_equations.md) are
\begin{equation}
\frac{\partial}{\partial t} \phi \rho + \phi\rho\dot{\epsilon}_{v} \ ,
\end{equation}
where $\dot{\epsilon}_{v} = \nabla\cdot {\mathbf v}_{s}$ and all other nomenclature is described [here](nomenclature.md).  Using the
[THM evolution of porosity](/porous_flow/porosity.md), along with the
assumption that the fluid bulk modulus, $K_{f}$, and its volumetric
thermal expansion coefficient, $\alpha_{f}$, are constant, and the fluid density is given by
\begin{equation}
\rho = \rho_{0}\exp(P/K_{f} - \alpha_{f} T) \ ,
\end{equation}
the time derivative terms may be written as
\begin{equation}
\label{poromecheq}
\rho \left( \frac{1}{M}\dot{P} + \alpha_{B}\dot{\epsilon}_{v} -
A\dot{T} \right) \ .
\end{equation}
Here $M$ is the so-called Biot Modulus:
\begin{equation}
\label{biotmoddef}
\frac{1}{M} = \frac{\phi}{K_{f}} + \frac{(1 - \alpha_{B})(\alpha_{B} -
  \phi)}{K} \ ,
\end{equation}
and $A$ is an effective volumetric thermal expansion coefficient:
\begin{equation}
\label{constthermexpdef}
A = (\alpha_{B} - \phi)\alpha_{T} + \phi\alpha_{f} \ .
\end{equation}
Notice that disregarding the premultiplication by $\rho$, the above
time-derivative terms in [poromecheq] would be linear in the variables $P$,
displacement, and $T$, if $M$ and $A$ were constant.

In standard poro-mechanics it is usual to calculate $M$ and $A$ at the
initial stage of simulation, and keep them fixed forever afterwards.
Of course this is an approximation since $M$ and $A$ were derived
using the explicit assumption of a porosity that depended on $P$,
$\epsilon_{v}$, and $T$, but it makes finding analytical solutions
much easier.  Therefore, PorousFlow offers the following Materials and
Kernels.  Using these Materials and Kernel allows immediate and precise
comparison with analytical and numerical solutions of poro-mechanics.

1. [PorousFlowConstantBiotModulus](PorousFlowConstantBiotModulus.md) Material, which computes $M$ given by [biotmoddef] during the initial stage of simulation, and keeps it fixed thereafter.  It requires a Porosity Material, but that Material's Property is only used during the initial computation.

2. [PorousFlowConstantThermalExpansionCoefficient](PorousFlowConstantThermalExpansionCoefficient.md) Material, which computes $A$ given by [constthermexpdef] during the initial stage of simulation, and keeps it fixed thereafter.  It requires a Porosity Material, but that Material's Property is only used during the initial computation.

3. The `PorousFlowFullySaturatedMassTimeDerivative` Kernel, which computes one of the following contributions, depending upon the `coupling_type` flag:

- $(\rho) \dot{P}/M$ for fluid-flow-only problems;
- $(\rho)(\dot{P}/M - A\dot{T})$ for TH problems;
- $(\rho)(\dot{P}/M + \alpha_{B}\dot{\epsilon}_{v})$ for HM problems;
- $(\rho)(\dot{P}/M + \alpha_{B}\dot{\epsilon}_{v} - A\dot{T})$ for THM problems.

The `PorousFlowFullySaturatedMassTimeDerivative` Kernel does not employ lumping, which is largely unnecessary in this single-phase, single-component situation.  This means only ``quad-point'' Materials are needed.  In fact, when using all the FullySaturated flow Kernels (see [governing equations](porous_flow/governing_equations.md)) standard Materials evaluated at the quadpoints are needed, which saves on computation time and input-file length.

In each case, the initial pre-multiplication by $\rho$ is optional
(indicated by the parentheses around $\rho$).

When the Kernel is pre-multiplied by $\rho$, which is the default,
it is computing the time derivative of fluid mass.  This allows
the Kernel to be easily used with the remainder of PorousFlow: the
BCs, the Postprocessors, the AuxKernels, and the DiracKernels are all
based on mass.

When the pre-multiplication is not performed, this Kernel is computing the
time derivative of fluid volume.  This has two great advantages:

- the time-derivatives are linearised, resulting in excellent nonlinear convergence;
- comparing with results from poro-mechanics theory is straightforward.

However, this means additional care must be taken.

- The flow Kernel [PorousFlowFullySaturatedDarcyBase](PorousFlowFullySaturatedDarcyBase.md) should also not pre-multiply by density.
- The BCs, Postprocessors, AuxKernels, and DiracKernels must be written in such a way to operate in the fluid-volume scenario rather than the default fluid-mass scenario.
- The flag `consistent_with_displaced_mesh` should be set `false` in the [PorousFlowVolumetricStrain](PorousFlowVolumetricStrain.md) Material.








### PorousFlowFullySaturatedUpwindHeatAdvection


This `Kernel` implements the weak form of
\begin{equation*}
  -\nabla\cdot h \rho\frac{k}{\mu}(\nabla P - \rho \mathbf{g})
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).  This is only relevant for situations involving a single-phase fluid: if you have a multi-phase scenario you will want to use [PorousFlowHeatAdvection](PorousFlowHeatAdvection.md).

This `Kernel` is usually added by the [PorousFlowFullySaturated](PorousFlowFullySaturated.md) Action (and more discussion is included on that page).

A fully-upwinded version is implemented, where the mobility of the upstream nodes is used.

See [upwinding](/upwinding.md) for details.  If you desire no upwinding, use [PorousFlowFullySaturatedHeatAdvection](PorousFlowFullySaturatedHeatAdvection.md) instead.  If you desire [Kuzmin-Turek TVD stabilization](kt.md), use [PorousFlowFluxLimitedTVDAdvection](PorousFlowFluxLimitedTVDAdvection.md).




### PorousFlowHeatAdvection


This `Kernel` implements the weak form of
\begin{equation*}
  -\nabla\cdot \sum_{\beta}h_{\beta} \rho_{\beta}\frac{k\,k_{\mathrm{r,}\beta}}{\mu_{\beta}}(\nabla P_{\beta} - \rho_{\beta} \mathbf{g})
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).

A fully-upwinded version is implemented, where the mobility of the upstream nodes is used.

See [upwinding](/upwinding.md) for details.  Other Kernels implement [Kuzmin-Turek TVD stabilization](kt.md).




### PorousFlowHeatConduction


This `Kernel` implements the weak form of
\begin{equation*}
  -\nabla\cdot \left(\lambda \nabla T\right)
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).




### PorousFlowHeatMassTransfer


This `Kernel` implements the weak form of
\begin{equation*}
  C(u-v)
\end{equation*}
where $u$ and $v$ are `Variables` such as pressure, temperature or mass fraction. The kernel's `Variable` is $u$, while $v$ is the coupled `Variable`. $C$ is the transfer coefficient which defines the transfer from $v$ to $u$. Note, this `Kernel` does no mass lumping, which might effect the numerical stabilization.




### PorousFlowHeatVolumetricExpansion


This `Kernel` implements the weak form of
\begin{equation*}
  \mathcal{E}\nabla\cdot\mathbf{v}_{s}
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).

Because it contains volumetric strain, this Kernel always sets `use_displaced_mesh = false` and the parameter cannot be altered by the user.  Further information can be found [here](porous_flow/time_derivative.md)




### PorousFlowMassRadioactiveDecay


This `Kernel` implements the weak form of
\begin{equation*}
  \Lambda \phi\sum_{\beta}S_{\beta}\rho_{\beta}\chi_{\beta}^{\kappa}
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).




### PorousFlowMassTimeDerivative


This `Kernel` implements the weak form of
\begin{equation*}
  \frac{\partial}{\partial t}\left(\phi\sum_{\beta}S_{\beta}\rho_{\beta}\chi_{\beta}^{\kappa}\right)
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).

A mass-lumped version is implemented.

See [mass lumping](/mass_lumping.md) for details.

The multiplication by $\rho_{\beta}$ is optional and is controlled by the `multiply_by_density` flag.  It is sometimes advantageous to use this flag because the problem becomes more linear.  However, this sometimes changes the nature of the physical problem modelled (consider, for instance, a fully-saturated multicomponent system, where `multiply_by_density = false` implies the steady-state Laplace equation for the porepressure), and care must be taken when using other PorousFlow objects (that intrinsically have `multiply_by_density = true`, such as [PorousFlowFluidMass](PorousFlowFluidMass.md)) so new users are encouraged to use the default `multiply_by_density = true` flag until they gain familiarity with PorousFlow.

For mechanically-coupled simulations (where the mesh deforms) the numerical implementation of this Kernel involves the old value of the volumetric strain.  Further information can be found [here](porous_flow/time_derivative.md).  This is assumed to be calculated by a SolidMechanics strain calculator, for instance [ComputeSmallStrain](ComputeSmallStrain.md), with a given `base_name`.  Hence, you should usually employ the same `base_name` for this Kernel as used by your strain calculator.  However, if you wish to include mechanical deformations, but not couple them to the porous flow, simply enter a `base_name` that doesn't exist (eg `base_name = non_existent`) and the volumetric strain won't be included in this Kernel.  (Note: if you want a fully-coupled simulation but accidentally make a typo in your `base_name`, then PorousFlow will assume you don't want to include the volumetric strain!)

Because it contains volumetric strain, this Kernel always sets `use_displaced_mesh = false` and the parameter cannot be altered by the user.  Further information can be found [here](porous_flow/time_derivative.md)




### PorousFlowMassVolumetricExpansion


This `Kernel` implements the weak form of
\begin{equation*}
  \phi\sum_{\beta}S_{\beta}\rho_{\beta}\chi_{\beta}^{\kappa}\nabla\cdot\mathbf{v}_{s}
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).

A mass-lumped version is implemented.

See [mass lumping](/mass_lumping.md) for details.

Because it contains volumetric strain, this Kernel always sets `use_displaced_mesh = false` and the parameter cannot be altered by the user.  Further information can be found [here](porous_flow/time_derivative.md)

The multiplication by $\rho_{\beta}$ is optional and is controlled by the `multiply_by_density` flag.  It is sometimes advantageous to use this flag because the problem becomes more linear.  However, this sometimes changes the nature of the physical problem modelled, and care must be taken when using other PorousFlow objects (that intrinsically have `multiply_by_density = true`, such as [PorousFlowFluidMass](PorousFlowFluidMass.md)) so new users are encouraged to use the default `multiply_by_density = true` flag until they gain familiarity with PorousFlow.




### PorousFlowPlasticHeatEnergy


This `Kernel` implements the weak form of
\begin{equation*}
  -\nu (1-\phi)\sigma^{\mathrm{eff}}_{ij}\frac{\partial}{\partial t}\epsilon_{ij}^{\mathrm{plastic}}
\end{equation*}
where all parameters are defined in the [nomenclature](/nomenclature.md).  Hence, this Kernel models the heating produced by inelastic deformation of the porous skeleton.

Some examples may be found in [the test descriptions](porous_flow/tests/plastic_heating/plastic_heating_tests.md)




### PorousFlow PreDis


This `Kernel` implements the residual
\begin{equation*}
  \phi_{\mathrm{old}} S_{\mathrm{aq}} \sum_{m}\nu_{m}\rho_{m}I_{m} \ .
\end{equation*}
In this equation, $\phi$ is the porosity (only the *old* value is used), $S_{\mathrm{aq}}$ is the aqueous saturation, the sum over $m$ is a sum
over all the precipitated-or-dissolved (`PreDis`) mineral species,
$\nu_{m}$ are stoichiometric coefficients, $\rho_{m}$ is the density
of a solid lump of the mineral, and $I_{m}$ is the mineral
reaction rate (m$^{3}$(precipitate)/m$^{3}$(solution).s$^{-1}$) which is computed by
[PorousFlowAqueousPreDisChemistry](PorousFlowAqueousPreDisChemistry.md).

Details concerning precipitation-dissolution kinetic chemistry may be found in the
[`chemical reactions`](/chemical_reactions/index.md) module.

The numerical implementation of the chemical-reactions part of `PorousFlow` is quite simplistic, with
very few guards against strange numerical behavior that might arise during the non-linear iterative
process that MOOSE uses to find the solution.  Therefore, care must be taken to define your chemical
reactions so that the primary species concentrations remain small, but nonzero, and that
mineralisation does not cause porosity to become negative or exceed unity.

This `Kernel` is usually added to a
[PorousFlowMassTimeDerivative](PorousFlowMassTimeDerivative.md)
`Kernel` to simulate precipitation-dissolution of a mineral from some primary chemical species.  For
instance in the case of just one precipitation-dissolution kinetic reaction
\begin{equation}
a + b  \rightleftharpoons  \mathrm{mineral}
\end{equation}
and including diffusion and dispersion, the `Kernels` block looks like


Appropriate stoichiometric coefficients must be supplied to this `Kernel`.  Consider the reaction
system
\begin{equation}
\begin{array}{rcl}
 1a + 2b - 3c & \rightleftharpoons & \mathrm{mineral0} \\
4a -5b + 6c   & \rightleftharpoons & \mathrm{mineral1} \ .
\end{array}
\end{equation}

Then the stoichiometric coefficients for the `PorousFlowPreDis` Kernels would be:

 - `stoichiometry = '1 4'` for Variable `a`
 - `stoichiometry = '2 -5'` for Variable `b`
 - `stoichiometry = '-3 6'` for Variable `c`

This `Kernel` lumps the mineral masses to the nodes.  It also only uses the *old* values of porosity,
which is an approximation: see [porosity](/porous_flow/porosity.md) for a discussion.

See [mass lumping](/porous_flow/mass_lumping.md) for details.




## materials

### PorousFlow1PhaseFullySaturated





### PorousFlow1PhaseHysP

This Material computes saturation given porepressure in single-phase, partially-saturated, hysteretic situations, assuming a van Genuchten relationship.  Detailed documentation about hysteresis and the van Genuchten relationship can be found on the [hysteresis page](hysteresis.md).  It is the hysteretic cousin of [PorousFlow1PhaseP](PorousFlow1PhaseP.md)

This Material requires a [PorousFlowHysteresisOrder](PorousFlowHysteresisOrder.md) Material, which will compute the hysteresis order.  `PorousFlow1PhaseHysP` then uses the hysteresis order along with the single-phase porepressure to compute the saturation.

A simple example usage is:


Note the following features:

- The [PorousFlowHysteresisOrder](PorousFlowHysteresisOrder.md) Material appears alongside the `PorousFlow1PhaseHysP` Material:


- Saturation and hysteresis order may be recorded into `AuxVariables` using a [PorousFlowPropertyAux](PorousFlowPropertyAux.md) 


To improve numerical convergence, it is recommended that you use a `low_extension` and a `high_extension` along with values of `Pc_max` and `S_lr` that are appropriate for your situation.  See the [hysteresis page](hysteresis.md) for more details.






### PorousFlow1PhaseMD_Gaussian





### PorousFlow1PhaseP


Given the porepressure, this Material computes the saturation for 1-phase fluid simulations.  See [capillary pressure](porous_flow/capillary_pressure.md) for further details.




### PorousFlow2PhaseHysPP

This Material computes the liquid and gas saturations given their porepressures for 2-phase hysteretic situations, assuming a van Genuchten relationship.  Detailed documentation about hysteresis and the van Genuchten relationship can be found on the [hysteresis page](hysteresis.md).  `PorousFlow2PhaseHysPP` is the hysteretic cousin of [PorousFlow2PhasePP](PorousFlow2PhasePP.md)

This Material requires a [PorousFlowHysteresisOrder](PorousFlowHysteresisOrder.md) Material, which will compute the hysteresis order.  `PorousFlow2PhaseHysPP` then uses the hysteresis order along with the two porepressures to compute the saturation.

A simple example usage is:


Note the following features:

- The [PorousFlowHysteresisOrder](PorousFlowHysteresisOrder.md) Material appears alongside the `PorousFlow2PhaseHysPP` Material:


- Saturations and hysteresis order may be recorded into `AuxVariables` using a [PorousFlowPropertyAux](PorousFlowPropertyAux.md) 


To improve numerical convergence, it is recommended that you use a `low_extension` and a `high_extension` along with values of `Pc_max` and `S_lr` that are appropriate for your situation.  See the [hysteresis page](hysteresis.md) for more details.





### PorousFlow2PhaseHysPS

This Material computes the liquid saturation and gas porepressure, given the gas saturation and the liquid porepressure, for 2-phase hysteretic situations, assuming a van Genuchten relationship.  Detailed documentation about hysteresis and the van Genuchten relationship can be found on the [hysteresis page](hysteresis.md).  `PorousFlow2PhaseHysPS` is the hysteretic cousin of [PorousFlow2PhasePS](PorousFlow2PhasePS.md)

This Material requires a [PorousFlowHysteresisOrder](PorousFlowHysteresisOrder.md) Material, which will compute the hysteresis order.  `PorousFlow2PhaseHysPS` then uses the hysteresis order along with the two porepressures to compute the saturation.

A simple example usage is:


Note the following features:

- The [PorousFlowHysteresisOrder](PorousFlowHysteresisOrder.md) Material appears alongside the `PorousFlow2PhaseHysPS` Material:


- Saturations and hysteresis order may be recorded into `AuxVariables` using a [PorousFlowPropertyAux](PorousFlowPropertyAux.md) 


To improve numerical convergence, it is recommended that you use a `low_extension` and a `high_extension` along with values of `Pc_max` and `S_lr` that are appropriate for your situation.  See the [hysteresis page](hysteresis.md) for more details.





### PorousFlow2PhasePP


Given the liquid and gas porepressures, this Material computes the liquid and gas saturations for 2-phase fluid simulations.  See [capillary pressure](porous_flow/capillary_pressure.md) for further details.




### PorousFlow2PhasePS





### PorousFlow Aqueous PreDis Chemistry


This computes reaction rates resulting from a precipitation-dissolution (`PreDis`) kinetic reaction
system.

The numerical implementation of the chemical-reactions part of `PorousFlow` is quite simplistic, with
very few guards against strange numerical behavior that might arise during the non-linear iterative
process that MOOSE uses to find the solution.  Therefore, care must be taken to define your chemical
reactions so that the primary species concentrations remain small, but nonzero, and that
mineralisation doesn't cause porosity to become negative or exceed unity.

Details concerning precipitation-dissolution kinetic chemistry may be found in the
[`chemical reactions`](/chemical_reactions/index.md) module.  There are two main differences
between the `chemical reactions` module and `PorousFlow`.  These are:

- The molar volumes must be specified in `PorousFlow`.  This is so that the concentrations may be
  measured in $m^{3}/m^{3}$ rather than mol.m$^{-3}$.
- Unlike the `chemical reactions` module, users of `PorousFlow` must specify the stoichiometric
  coefficients themselves.  In each reaction, the primary concentrations (variables) must be brought
  to the left-hand-side.  The right-hand-sides are the minerals, by definition.  For instance,
  consider a 2-reaction system consisting of 3 primary variables, $a$, $b$ and $c$.  The reactions
  are
  \begin{equation}
  \begin{array}{rcl}
  1a + 2b - 3c & \rightleftharpoons & \mathrm{mineral0} \\
  4a -5b + 6c   & \rightleftharpoons & \mathrm{mineral1}
  \end{array}
  \end{equation}

  Then the `reactions` input is `1 2 -3 4 -5 6`.

If the equilibrium constants are AuxVariables that depend on temperature (or other Variables) the computed Jacobian will not be exact and you may experience poor nonlinear convergence.  If this becomes frustrating, please contact the [MOOSE Discussion forum](https://github.com/idaholab/moose/discussions).




### PorousFlow Aqueous PreDis Mineral


This computes mineral concentrations that result from a precipitation-dissolution (`PreDis`) kinetic
reaction system.  The Material Property may be saved in an `AuxVariable` using the
[PorousFlowPropertyAux](PorousFlowPropertyAux.md) `AuxKernel`.  The mineral concentration computed
has units m$^{3}$(precipitate)/m$^{3}$(porous material).

The numerical implementation of the chemical-reactions part of `PorousFlow` is quite simplistic, with
very few guards against strange numerical behavior that might arise during the non-linear iterative
process that MOOSE uses to find the solution.  Therefore, care must be taken to define your chemical
reactions so that the primary species concentrations remain small, but nonzero, and that
mineralisation doesn't cause porosity to become negative or exceed unity.

The computation uses a *lagged* approach for porosity to calculate the mineral concentration, $C$:
\begin{equation}
C = C_{\mathrm{old}} + \phi_{\mathrm{old}} I S_{\mathrm{aq}} \mathrm{d}t \ ,
\end{equation}
where $I$ is the reaction rate (dependent on primary concentrations,
etc) and $S_{\mathrm{aq}}$ is the saturation of the aqueous phase.
Notice the use of the *old* value for porosity.  This is an
approximation.  It breaks the cyclic dependency between mineral
concentration and porosity: see [Porosity](/porous_flow/porosity.md)
for more details.




### PorousFlowBrine





### PorousFlowConstantBiotModulus


The Biot Modulus is defined to be
\begin{equation}
\label{biotmoddef}
\frac{1}{M} = \frac{\phi}{K_{f}} + \frac{(1 - \alpha_{B})(\alpha_{B} -
  \phi)}{K} \ ,
\end{equation}
where $\phi$ is the porosity, $K_{f}$ is the fluid bulk modulus, $\alpha_{B}$ is the Biot coefficient and $K$ is the drained bulk modulus of the porous skeleton.

This Material is designed to work with the [PorousFlowFullySaturatedMassTimeDerivative](PorousFlowFullySaturatedMassTimeDerivative.md) Kernel.

This quantity is computed during the initial stage of the simulation and is kept fixed thereafter.




### PorousFlowConstantThermalExpansionCoefficient


This Material computes
\begin{equation}
\label{constthermexpdef}
A = (\alpha_{B} - \phi)\alpha_{T} + \phi\alpha_{f} \ ,
\end{equation}
where $\alpha_{B}$ is the Biot Modulus, $\phi$ is the porosity, $\alpha_{T}$ is the drained volumetric thermal expansion coefficient, and $\alpha_{f}$ is the fluid thermal volumetric expansion coefficient.

This Material is designed to work with the [PorousFlowFullySaturatedMassTimeDerivative](PorousFlowFullySaturatedMassTimeDerivative.md) Kernel.

This quantity is computed during the initial stage of the simulation and is kept fixed thereafter.




### PorousFlowDarcyVelocityMaterial


This `Material` computes the Darcy velocity of all phases in the PorousFlow system.  The Material properties are evaluated at the quadpoints (`at_nodes = false`).  The Darcy velocity of a phase $\beta$ is:
\begin{equation}
\mathbf{v}_{\beta} = -\frac{k k_{\mathrm{r,}\ \beta}}{\mu_{\beta}}(\nabla P_{\beta} - \rho_{\beta}\mathbf{g}) \ ,
\end{equation}
where $k$ is the permeability tensor, $k_{\mathrm{r,}\ \beta}$ is the relative permeability, $\mu$ is the viscosity, $P$ is the porepressure, $\rho$ is the density and $\mathbf{g}$ is the gravitational acceleration.
Hence, this `Material` requires many other `Materials`: permeability, relative permeabilities, etc.

An example of the syntax is:


The declaration of the Material name is:


This `Material` also computes the derivatives of the Darcy velocities with respect to all the PorousFlow variables, for use by Kernels, etc, to construct the Jacobian.







### PorousFlowDiffusivityConst


Tortuosity is defined as the ratio of the shortest path to the effective path,
such that $0 < \tau \leq 1$.




### PorousFlowDiffusivityMillingtonQuirk


A saturation dependent model where the diffusion coefficients are constant but the tortuosity is
\begin{equation}
  \tau_0 \tau_{\beta}(S_{\beta}) = \phi^{1/3} S_{\beta}^{10/3}.
\end{equation}




### PorousFlowEffectiveFluidPressure





### PorousFlowFluidState


Material that provides all thermophysical properties of the system given a set
of nonlinear variables using the formulation provided by one of the fluid state
UserObjects.




### PorousFlowFluidStateSingleComponent


Material that provides all thermophysical properties of the system given a set
of nonlinear variables using the formulation provided by one of the single component
fluid state UserObjects.




### PorousFlowHysteresisOrder

This Material is used in simulations involving [hysteresis](porous_flow/hysteresis.md).

This Material computes the "order" for simulations involving hysteretic capillary-pressure and/or relative-permeability functions.  It also records the liquid saturation at each turning point.  The meaning of "order" is illustrated in [hysteretic_order_fig].
The order and the turning points may be recorded into AuxVariables using a [PorousFlowPropertyAux](PorousFlowPropertyAux.md).

Since the hysteretic capillary-pressure and relative-permeability functions are only defined up to third order, the order computed by `PorousFlowHysteresisOrder` never exceeds 3 (hard coded in `PorousFlowConstants.h`).






### PorousFlowHystereticCapillaryPressure

This is a base class that enables computation of capillary pressure, saturations and porepressures in models with [hysteresis](hysteresis.md).  It should not usually appear in MOOSE input files.  Its derived classes, which should be employed in MOOSE input files, are:

- [PorousFlow1PhaseHysP](PorousFlow1PhaseHysP.md) which computes the saturation given the porepressure in partially-saturated 1-phase systems
- [PorousFlowHystereticInfo](PorousFlowHystereticInfo.md) which computes the capillary pressure, and other quantities, given the saturation.





### PorousFlowHystereticInfo

This Material computes quantities relevant to [hysteretic capillary pressure](hysteresis.md).  The quantity computed is written into the `PorousFlow_hysteretic_info_qp` or `PorousFlow_hysteretic_nodal` Property (depending on the `at_nodes` parameter).

This Material does not compute porepressures or saturations, so cannot be used in usual PorousFlow simulations.  Instead, it enables preliminary exploration of hysteresis in models before hysteretic PorousFlow simulations are run: informative plots may be generated using this Material.

The quantity computed depends on the `info_required` parameter, which may be one of the following.

- `pc` capillary pressure, given the saturation
- `sat` saturation.  The saturation is provided as an input, the capillary pressure is computed, and then the saturation is computed using the inverse relationship.  This is useful when exploring the non-invertibility of the hysteretic relationships
- `sat_given_pc` saturation, given the capillary pressure
- various derivative information, such as the numerical error in $dP_{c}/dS$, etc.

An example input file containing `PorousFlowHystereticInfo` is


In this input file, saturation is an AuxVariable which is varied with time through a `FunctionAux`.  The `PorousFlowHystereticInfo` Material computes capillary pressure, which is written into an AuxVariable using the [PorousFlowPropertyAux](PorousFlowPropertyAux.md) AuxKernel.  By choosing different `FunctionAux`, various capillary-pressure curves may be generated such as the one shown below.







### PorousFlowHystereticRelativePermeabilityGas

This Material computes the gas relative permeability using the van Genuchten formulation.  The relative permeability is assumed to be hysteretic.  This Material may be used in two-phase situations only.

Along the drying curve, the relative permeability is
\begin{equation}
k_{r, g} = k_{r, g}^{max}\left(1 - \bar{S}_{l}\right)^{\gamma} \left( 1- \bar{S}_{l}^{1/m} \right)^{2m}
\end{equation}
where
\begin{equation}
\bar{S}_{l} = \frac{S_{l} - S_{l, r}}{1 - S_{l, r}}
\end{equation}
In these formulae:

- $S_{l}$ is the liquid saturation
- $S_{l, r}$ is the liquid residual saturation
- $k_{r, g}^{max}$ is the value of the gas relative permeability for $S_{l} \leq S_{l, r}$
- $m$ is the van Genuchten exponent
- $\gamma$ is another exponent

See the [hysteresis page](hysteresis.md) for more details concerning extending the formulation in the low-saturation region ($S_{l} < S_{l, r}$) and for a definition of the wetting relative permeability.

To use this Material, it is necessary to include a [PorousFlowHysteresisOrder](PorousFlowHysteresisOrder.md) Material, which computes and records information regarding the hysteresis order and the saturation turning points.




### PorousFlowHystereticRelativePermeabilityLiquid

This Material computes the liquid relative permeability using the van Genuchten formulation.  The relative permeability is assumed to be hysteretic.  This Material may be used in single-phase or two-phase situations only.

Along the drying curve, the relative permeability is
\begin{equation}
k_{r, l} = \sqrt{\bar{S}_{l}}\left[ 1 - \left( 1- \bar{S}_{l}^{1/m} \right)^{m} \right]^{2}
\end{equation}
where
\begin{equation}
\bar{S}_{l} = \frac{S_{l} - S_{l, r}}{1 - S_{l, r}}
\end{equation}
In these formulae:

- $S_{l}$ is the liquid saturation
- $S_{l, r}$ is the liquid residual saturation: for $S_{l} \leq S_{l, r}$ the relative permeability is zero
- $m$ is the van Genuchten exponent

See the [hysteresis page](hysteresis.md) for details concerning the wetting relative permeability.

To use this Material, it is necessary to include a [PorousFlowHysteresisOrder](PorousFlowHysteresisOrder.md) Material, which computes and records information regarding the hysteresis order and the saturation turning points.




### PorousFlowJoiner


This material is added automatically by the action system, so should
not need to be included by the user.




### PorousFlowMassFraction


The `mass_fraction_vars` is a list of mass fractions, $\chi_{\beta}^{\kappa}$, of fluid component $\kappa$ in phase $\beta$:
\begin{equation}
\chi_{0}^{0},\ 
\chi_{0}^{1},\ 
\chi_{0}^{2},\ \ldots
\chi_{0}^{N-2},\ 
\chi_{1}^{0},\ 
\chi_{1}^{1},\ 
\chi_{1}^{2},\ \ldots
\chi_{1}^{N-2},\
\ldots
\chi_{P-1}^{0},\ 
\chi_{P-1}^{1},\ 
\chi_{P-1}^{2},\ \ldots
\chi_{P-1}^{N-2}
\end{equation}
There are $P$ phases and $N$ fluid components.  Notice that $\chi_{\beta}^{N-1}$ need not be specified for any phase, since
\begin{equation}
\chi_{\beta}^{N-1} = 1 - \sum_{\kappa = 0}^{N-2}\chi_{\beta}^{\kappa} \ .
\end{equation}
Examples are:

- with a single component fluid in a single-phase system, `mass_fraction_vars` should be left empty since the mass-fraction is always 1.0.
- with 3 fluid components in a single-phase system, `mass_fraction_vars = f0 f1`, where `f0` is the mass fraction of the zeroth component, and `f1` is the mass fraction of the first component (these will be AuxVariables or Variables, depending on your model).  The second component does not need to be specified since `f2 = 1 - f0 - f1`.
- with 2 fluid components in a 2-phase system, `mass_fraction_vars = f00 f10` where `f00` is the mass fraction of the zeroth component in the zeroth phase, and `f10` is the mass fraction of the zeroth component in the first phase.





### PorousFlow Mass Fraction Aqueous Equilibrium Chemistry


This forms `PorousFlow` mass-fractions appropriate for an aqueous equilibrium chemistry simulation.
The first $N-1$ of these are the total concentrations of the primary species of the chemical reaction
system, while the last one is the mass-fraction of the remaining component, which is assumed to be
pure water.  See [PorousFlowMassFraction](PorousFlowMassFraction.md) for the non-chemistry version.

The numerical implementation of the chemical-reactions part of `PorousFlow` is quite simplistic, with
very few guards against strange numerical behavior that might arise during the non-linear iterative
process that MOOSE uses to find the solution.  Therefore, care must be taken to define your chemical
reactions so that the primary species concentrations remain small, but nonzero.

Details concerning aqueous equilibrium chemistry may be found in the
[`chemical reactions`](/chemical_reactions/index.md) module.  The
`PorousFlowMassFractionAqueousEquilibriumChemistry` computes the secondary concentrations, and adds
them appropriately to the primary concentrations to form the mass-fractions.  There are two main
differences between the `chemical reactions` module and `PorousFlow`.  These are:

- The molar volumes must be specified in `PorousFlow`.  This is so that the concentrations may be
  measured in $m^{3}/m^{3}$ rather than mol.m$^{-3}$.

- Unlike the `chemical reactions` module, users of `PorousFlow` must specify the stoichiometric
  coefficients themselves.  In each reaction, the primary concentrations (variables) must be brought
  to the left-hand-side.  The right-hand-sides are the secondary species, by definition.  For
  instance, consider a 2-reaction system consisting of 3 primary variables, $a$, $b$ and $c$.  The
  reactions are
  \begin{equation}
  \begin{array}{rcl}
  1a + 2b - 3c & \rightleftharpoons & \mathrm{secondary0} \\
  4a -5b + 6c   & \rightleftharpoons & \mathrm{secondary1}
  \end{array}
  \end{equation}
  Then the `reactions` input is `1 2 -3 4 -5 6`.

If the equilibrium constants are AuxVariables that depend on temperature (or other Variables) the computed Jacobian will not be exact and you may experience poor nonlinear convergence.  If this becomes frustrating, please contact the [MOOSE Discussion forum](https://github.com/idaholab/moose/discussions).





### PorousFlowMatrixInternalEnergy





### PorousFlowMultiComponentFluid


#### Recommended choice of units

Most of MOOSE is independent of the choice of units, but the units must be kept consistent throughout the input file.

- For instance, time can be measured in seconds, nano-seconds, years, etc, providing this choice is used everywhere.

- For instance, you must specify fluid bulk modulus and solid Young's modulus using the same units (for example, both in GPa).

PorousFlow does not check the consistency of units in the input file.

However, the [FluidProperties module](fluid_properties/index.md) assumes that the pressure units are Pascals, the time units are seconds, temperature is measured in Kelvin, distance is measured in metres, mass in kilograms and energy in Joules.  Therefore, when using this module, users are ordinarily restricted to using these standard SI units.  Almost all PorousFlow input files use the FluidProperties module.  Therefore it is recommended to use these standard SI units everywhere in your input file.

#### Alternate unit choices

`PorousFlowMultiComponentFluid` allows different units to be employed: it modifies the input and output of the FluidProperties module to reflect the choice of units.

- For instance, suppose you choose to measure temperature in Celsius.  Then `PorousFlowMultiComponentFluid` will add 273.15 to your temperature before feeding it to the FluidProperties module.  No other alterations to the FluidProperties input/output are needed.

- For instance, suppose you choose to measure pressure in MPa.  Then `PorousFlowMultiComponentFluid` will multiply your pressure by $10^6$ before feeding it to the FluidProperties module.  Since the viscosity returned by the FluidProperties module has units Pa.s, it needs to be converted to MPa.s before using it in the remainder of PorousFlow, so the FluidProperties viscosity is multiplied by $10^{-6}$.

If you choose non-default SI units, you must ensure that all the other parameters in your input file use these non-default units.  For instance, if you choose to measure pressure in MPa, then your solid-mechanical stresses, Young's moduli, strengths, etc, must also be specified in MPa.  That is, `PorousFlowMultiComponentFluid` only interfaces with the FluidProperties module: it doesn't also change your pressure boundary conditions, end time, gravity, etc: all these must be specified by you in the units you choose. See [PorousFlowSingleComponentFluid](PorousFlowSingleComponentFluid.md) for more details.



#### Available unit systems

`PorousFlowMultiComponentFluid` includes the following choices for unit systems

##### Default: Pascals, seconds and Kelvin

No changes to the input or output of the FluidProperties module are required

##### Temperature in Celsius

Choosing the temperature unit to be Celsius means that 273.15 is added to all PorousFlow temperatures before feeding them to the FluidProperties module.

Other input-file objects that may need to be specified in Celsius are boundary conditions, initial conditions, [PorousFlowSinks](PorousFlowSink.md), etc.

All objects in the input file need to be specified in Celsius, except the FluidProperties objects.

##### Pressure (and stress) in MPa

Choosing the pressure unit to be MPa means that the PorousFlow pressures are multiplied by $10^{6}$ before feeding them to the FluidProperties module.  The viscosity returned by the FluidProperties module is multiplied by $10^{-6}$ (and any quantity from choosing non-default time units) before handing back to the remainder of PorousFlow.

In addition, you must remember that solid mechanical stresses should be measured in MPa, so moduli and strengths need to be specified in MPa.  Similarly, boundary tractions or pressures need to be specified in MPa.

Remember that the FluidProperties module always uses Pa, m, s and J.

##### Alternate time units

Choosing the time unit to be hours means no change is made to the inputs to the FluidProperties module.

You must remember that fluid and heat sources must be measured in kg.m$^{-3}$.time$^{-1}$ and J.m$^{-3}$.time$^{-1}$, respectively (where "time" is "hours", "days" or "years" depending on your specific choice).  Remember too that the thermal conductivity of the solid skeleton must be measured in J.m$^{-1}$.K$^{-1}$.time$^{-1}$.  Velocities, radioactive decay rates, chemical precipitation and reaction rates, dispersion tensors and diffusion coefficients are similarly impacted.

Remember that the FluidProperties module always uses Pa, m, s and J. 

###### Hours

The viscosity returned by the FluidProperties module is multiplied by $1/3600$ (and any quantity from choosing non-default pressure units) before handing back to the remainder of PorousFlow.

###### Days

The viscosity returned by the FluidProperties module is multiplied by $1/(3600\times 24)$ (and any quantity from choosing non-default pressure units) before handing back to the remainder of PorousFlow.

###### Julian years

The viscosity returned by the FluidProperties module is multiplied by $1/(3600\times 24\times 365.25)$ (and any quantity from choosing non-default pressure units) before handing back to the remainder of PorousFlow.





### PorousFlowNearestQp





### PorousFlowPermeabilityConst





### PorousFlowPermeabilityConstFromVar





### PorousFlowPermeabilityExponential


A simple porosity-permeability model where
\begin{equation*}
k_{ij} = B k_{ij}^{0} e^{A \phi},
\end{equation*}
where $\phi$ is the porosity, and $A$ and $B$ are user-defined constant.

Input can be entered in any of three forms depending on the value of `poroperm_function`

| `poroperm_function` | input format |
| --- | --- |
| `log_k` | $\log k = A \phi + B$ |
| `\ln k` | $\ln k = A \phi + B$  |
| `k`     | $k = B \exp(A \phi)$  |

The parameters $A$ and $B$ are then converted to the correct form internally.




### PorousFlowPermeabilityKozenyCarman


Permeability is calculated from porosity using
\begin{equation}
k_{ij} = A k_{ij}^{0} \frac{\phi^{n}}{(1 - \phi)^{m}},
\end{equation}
where $n$ and $m$ are user-defined constants.

Input can be entered in one of two forms depending on the value of `poroperm_function`

| `poroperm_function` | input format |
| --- | --- |
| `kozeny_carman_fd2` | $A = f d^2$ |
| `kozeny_carman_fd2` | $A = k_0 (1 - \phi)^m / \phi^n$  |

The parameters $A$ and $B$ are then converted to the correct form internally.




### PorousFlowPermeabilityTensorFromVar


Permeability is calculated from a tensor multiplied by
a scalar variable.




### PorousFlowPorosity


This Material computes porosity (at the nodes or quadpoints, depending on the `at_nodes` flag):
\begin{equation}
\label{eq:poro_evolve}
\phi + M = \alpha_{B} + (\phi_{0} + M_{\mathrm{ref}} - \alpha_{B})\times \exp \left( \frac{\alpha_{B}'
  - 1}{K}(P_{f} - P_{f}^{\mathrm{ref}}) - \epsilon^{\mathrm{total}}_{ii} + \alpha_{T}(T - T^{\mathrm{ref}}) \right) \ ,
\end{equation}
A full description is provided in the [porosity documentation](/porous_flow/porosity.md)

Flags provided to `PorousFlowPorosity` control its evolution.

- If `mechanical = true` then the porosity will depend on $\epsilon^{\mathrm{total}}_{ii}$.
  Otherwise that term in [eq:poro_evolve] is ignored.

- If `fluid = true` then the porosity will depend on $(P_{f} - P_{f}^{\mathrm{ref}})$.  Otherwise
  that term in [eq:poro_evolve] is ignored.

- If `thermal = true` then the porosity will depend on $(T - T^{\mathrm{ref}})$.  Otherwise that term
  in [eq:poro_evolve] is ignored.

- If `chemical = true` then porosity will depend on $M$.  Otherwise that term in
  [eq:poro_evolve] is ignored.




### PorousFlowPorosityConst


A single value of porosity can be specified in the input file, or a spatially
varying porosity `AuxVariable` can be coupled to define a heterogeneous
porosity distribution.




### PorousFlowPorosityHMBiotModulus





### PorousFlowPorosityLinear

This Material computes porosity (at the nodes or quadpoints, depending on the `at_nodes` flag) according to

\begin{equation}
\label{eq:poro_evolve_linear}
\phi = \phi_{\mathrm{ref}} + A(P_{f} - P_{f\ \mathrm{ref}}) + B(T - T_{\mathrm{ref}}) + C(\epsilon^{\mathrm{total}}_{ii} - \epsilon^{\mathrm{total}}_{ii\ \mathrm{ref}}) \ .
\end{equation}

Here:

- $\phi_{\mathrm{ref}}$ is the reference porosity, which is a constant-monomial variable or a real number
- $A$, $B$ and $C$ are real-valued coefficients
- $P_{f}$ is the [effective fluid pressure](PorousFlowEffectiveFluidPressure.md)
- $P_{f\ \mathrm{ref}}$ is the reference effective fluid pressure, which is a coupled variable (usually linear-Lagrange) or a real number
- $T$ is the [temperature](PorousFlowTemperature.md)
- $T_{\mathrm{ref}}$ is the reference temperature, which is a coupled variable (usually linear-Lagrange) or a real number
- $\epsilon^{\mathrm{total}}_{ii}$ is the [total volumetric strain](PorousFlowVolumetricStrain.md)
- $\epsilon^{\mathrm{total}}_{ii\ \mathrm{ref}}$ is the reference total volumetric strain, which is a constant monomial coupled variable or a real number.

In addition, it is possible to place a lower bound on porosity: $\phi \geq \phi_{\mathrm{min}}$.  This can be physically useful, but can also be numerically important because during Newton-Raphson iterations, the linear relationship can sometimes yield small, or even negative, values of $\phi$.

Descriptions of other porosity classes can be found in the [porosity documentation](/porous_flow/porosity.md)




### PorousFlowRelativePermeabilityBC


The [!cite](brookscorey1966) relative permeability model is an extension of the previous  [!cite](corey1954) formulation where the relative permeability of the wetting phase is given by
\begin{equation*}
k_{\mathrm{r, w}} = \left(S_{\mathrm{eff}}\right)^{(2 + 3 \lambda)/\lambda},
\end{equation*}
and the relative permeability of the non-wetting phase is
\begin{equation*}
k_{\mathrm{r, nw}} = (1 - S_{\mathrm{eff}})^2 \left[1 - \left(S_{\mathrm{eff}}\right)^{(2 + \lambda)/\lambda}\right],
\end{equation*}
where the effective saturation is
\begin{equation*}
S_{\mathrm{eff}}(S) = \frac{S - S_{\mathrm{res}}^{\beta}}{1 -
  \sum_{\beta'}S_{\mathrm{res}}^{\beta'}},
\end{equation*}
and $\lambda$ is a user-defined exponent.







### PorousFlowRelativePermeabilityBW


The relative permeability of the phase is
\begin{equation*}
k_{\mathrm{r}} = K_{n} + \frac{K_{s} - K_{n}}{(c - 1)(c -
  S_{\mathrm{eff}})}S_{\mathrm{eff}}^{2},
\end{equation*}
where the effective saturation is
\begin{equation*}
S_{\mathrm{eff}}(S) = \frac{S - S_{\mathrm{res}}^{\beta}}{1 -
  \sum_{\beta'}S_{\mathrm{res}}^{\beta'}}.
\end{equation*}




### PorousFlowRelativePermeabilityConst





### PorousFlowRelativePermeabilityCorey


The relative permeability of the phase is
\begin{equation*}
k_{\mathrm{r}} = S_{\mathrm{eff}}^{n},
\end{equation*}
where the effective saturation is
\begin{equation*}
S_{\mathrm{eff}}(S) = \frac{S - S_{\mathrm{res}}^{\beta}}{1 -
  \sum_{\beta'}S_{\mathrm{res}}^{\beta'}}.
\end{equation*}




### PorousFlowRelativePermeabilityFLAC


The relative permeability of the phase is
\begin{equation*}
k_{\mathrm{r}} = (m + 1)S_{\mathrm{eff}}^{m} - m S_{\mathrm{eff}}^{m + 1},
\end{equation*}
where the effective saturation is
\begin{equation*}
S_{\mathrm{eff}}(S) = \frac{S - S_{\mathrm{res}}^{\beta}}{1 -
  \sum_{\beta'}S_{\mathrm{res}}^{\beta'}}.
\end{equation*}




### PorousFlowRelativePermeabilityVG


The relative permeability of the phase is
\begin{equation*}
k_{\mathrm{r}} = \sqrt{S_{\mathrm{eff}}} \left(1 - (1 -
S_{\mathrm{eff}}^{1/m})^{m} \right)^{2},
\end{equation*}
where the effective saturation is
\begin{equation*}
S_{\mathrm{eff}}(S) = \frac{S - S_{\mathrm{res}}^{\beta}}{1 -
  \sum_{\beta'}S_{\mathrm{res}}^{\beta'}}.
\end{equation*}

A *cut* version of the van Genuchten expression is also offered, which is
almost definitely indistinguishable experimentally from the original expression:
\begin{equation*}
k_{\mathrm{r}} =
\begin{cases}
\textrm{van Genuchten} & \textrm{for } S_{\mathrm{eff}} < S_{c} \\
\textrm{cubic} & \textrm{for } S_{\mathrm{eff}} \geq S_{c}.
\end{cases}
\end{equation*}
Here the cubic is chosen so that its value and derivative match the
van Genuchten expression at $S=S_{c}$, and so that it is unity at
$S_{\mathrm{eff}}=1$.




### PorousFlowSingleComponentFluid


#### Recommended choice of units

Most of MOOSE is independent of the choice of units, but the units must be kept consistent throughout the input file.

- For instance, time can be measured in seconds, nano-seconds, years, etc, providing this choice is used everywhere.

- For instance, you must specify fluid bulk modulus and solid Young's modulus using the same units (for example, both in GPa).

PorousFlow does not check the consistency of units in the input file.

However, the [FluidProperties module](fluid_properties/index.md) assumes that the pressure units are Pascals, the time units are seconds, temperature is measured in Kelvin, distance is measured in metres, mass in kilograms and energy in Joules.  Therefore, when using this module, users are ordinarily restricted to using these standard SI units.  Almost all PorousFlow input files use the FluidProperties module.  Therefore it is recommended to use these standard SI units everywhere in your input file.

#### Alternate unit choices

`PorousFlowSingleComponentFluid` allows different units to be employed: it modifies the input and output of the FluidProperties module to reflect the choice of units.

- For instance, suppose you choose to measure temperature in Celsius.  Then `PorousFlowSingleComponentFluid` will add 273.15 to your temperature before feeding it to the FluidProperties module.  No other alterations to the FluidProperties input/output are needed.

- For instance, suppose you choose to measure pressure in MPa.  Then `PorousFlowSingleComponentFluid` will multiply your pressure by $10^6$ before feeding it to the FluidProperties module.  Since the viscosity returned by the FluidProperties module has units Pa.s, it needs to be converted to MPa.s before using it in the remainder of PorousFlow, so the FluidProperties viscosity is multiplied by $10^{-6}$.

If you choose non-default SI units, you must ensure that all the other parameters in your input file use these non-default units.  For instance, if you choose to measure pressure in MPa, then your solid-mechanical stresses, Young's moduli, strengths, etc, must also be specified in MPa.  That is, `PorousFlowSingleComponentFluid` only interfaces with the FluidProperties module: it doesn't also change your pressure boundary conditions, end time, gravity, etc: all these must be specified by you in the units you choose.

#### An essay on Pascals, kilograms and densities

In most PorousFlow simulations, it is convenient to use the unit system: pressure, distance, time, and energy.  Note that mass is not included since
\begin{equation}
\mathrm{kg} = \mathrm{Pa.m.s}^{2} \ .
\end{equation}
Using Pascals rather than kilograms is a different convention to most other physics, and means that, strictly, masses and densities should be thought of in terms of Pascals.

This is quite annoying, however, for if something has a mass of 10$\,$kg, and you want to employ MPa instead of Pa, strictly you should write the mass as 10$^{-5}\,$MPa.m.s$^{2}$.  Similar remarks hold for density (kg.m$^{-3}$), enthalpy and internal energy (J.kg$^{-1}$), heat capacity (J.kg$^{-1}$.K$^{-1}$), and mass fluxes (kg.m$^{-3}$.s$^{-1}$).  Everything gets changed!

Fortunately, density appears as a multiplicative factor almost everywhere, so scaling it by a constant amount (eg, multiplying by 10$^{-6}$ when using MPa instead of Pa) leads to the same equations.  For consider the fluid equations:
\begin{equation}
0 = \frac{\partial}{\partial t}\phi S \rho  + \phi S \rho \nabla\cdot \mathbf{v}_{\mathrm{s}} + \nabla \cdot \rho \mathbf{v}_{\mathrm{Darcy}} + \nabla\cdot \rho D \nabla \chi - q \ .
\end{equation}
Obviously, scaling $\rho$ will lead to the same equation.  The only thing to be careful of is the $\rho g$ inside the Darcy velocity, which is discussed below.  The heat equation is
\begin{equation}
0 = \frac{\partial}{\partial t}\phi S \rho \mathcal{E}  + \phi S \rho\mathcal{E} \nabla\cdot \mathbf{v}_{\mathrm{s}} + \nabla \cdot \rho h \mathbf{v}_{\mathrm{Darcy}} - \nabla\cdot \lambda \nabla T - q^{\mathrm{T}} \ .
\end{equation}
Since $\rho$ scales inversely to $\mathcal{E}$ (with respect to mass and pressure) the quotient $\rho\mathcal{E}$ is independent of the mass unit (it has units energy.distance$^{-3}$).  The same remark holds for $\rho h$.  The solid-mechanics conservation of momentum reads
\begin{equation}
\rho_{\mathrm{mat}}\frac{\partial v_{\mathrm{s}}}{\partial t} = \nabla \sigma^{\mathrm{tot}} + \rho_{\mathrm{mat}} b \ .
\end{equation}
Here, the $\rho_{\mathrm{mat}}$ on the left-hand side must be measured in the "Pascals" units described above.  The $\rho_{\mathrm{mat}}$ on the right-hand side should be too, although often the body force is due to gravity, so may be treated as described below.

##### Suggested approach

Continue to think in terms of kilograms:

- specify fluid density in kg.m$^{-3}$

- specify enthalpy and internal energy in J.kg$^{-1}$

- specify mass fluxes in kg.m$^{-3}$.s$^{-1}$

- specify heat capacity in J.kg$^{-1}$.K$^{-1}$

but modify gravity and the acceleration terms in the solid-mechanics equations, as described below.

This is the approach used by `PorousFlowSingleComponentFluid`.  That is, when you use non-default units, `PorousFlowSingleComponentFluid` does not modify the fluid density, fluid enthalpy and fluid internal energy returned by the FluidProperties module.

##### Addressing the issue of gravity in the Darcy velocity and solid-mechanics body force

The product $\rho g$ appears in the Darcy velocity.  The product $\rho_{\mathrm{mat}} b$ appears in the solid-mechanics equation.  Strictly, we should measure $\rho$ in units pressure.time$^{2}$.distance$^{-2}$ (eg, Pa.s$^{2}$.m$^{-2}$) in each of these, but we have found that to be inconvenient, so we modify the accelerations $g$ and $b$ instead, in order to achieve the correct result for the products $\rho g$ and $\rho_{\mathrm{mat}} b$.  [tab:grav] should help.

| Value | Units used |
| - | - |
| $g = 9.81$ | m.s$^{-2}$ |
| $9.81$ | Pascals (Pa) |
| $9.81\times 10^{-6}$ | MPa |
| $9.81\times 10^{-9}$ | GPa |


##### Addressing the issue of the solid-mechanics acceleration

If you use time-dependent solid mechanics, with the term
\begin{equation}
\rho_{\mathrm{mat}}\frac{\partial v_{\mathrm{s}}}{\partial t} \ ,
\end{equation}
you must measure $\rho_{\mathrm{mat}}$ in units of pressure.time$^{2}$.distance$^{-2}$.  [tab:rhomat] should help.

| Value | Units used |
| - | - |
| $\rho_{\mathrm{mat}} = 1234$ | kg.m$^{-3}$ |
| $1234$ | Pascals (Pa), seconds |
| $1234\times 10^{-6}$ | MPa, seconds |
| $9.522\times 10^{-5}$ | Pa, hours |
| $9.522\times 10^{-11}$ | MPa, hours |
| $1.653\times 10^{-7}$ | Pa, days |
| $1.653\times 10^{-13}$ | MPa, days |
| $1.241\times 10^{-12}$ | MPa, years |
| $1.241\times 10^{-18}$ | MPa, years |


#### Available unit systems

`PorousFlowSingleComponentFluid` includes the following choices for unit systems

##### Default: Pascals, seconds and Kelvin

No changes to the input or output of the FluidProperties module are required

##### Temperature in Celsius

Choosing the temperature unit to be Celsius means that 273.15 is added to all PorousFlow temperatures before feeding them to the FluidProperties module.

Other input-file objects that may need to be specified in Celsius are boundary conditions, initial conditions, [PorousFlowSinks](PorousFlowSink.md), etc.

All objects in the input file need to be specified in Celsius, except the FluidProperties objects.  For example, if using the [SimpleFluidProperties](SimpleFluidProperties.md), then you must remember the $T$ seen by SimpleFluidProperties will be measured in Kelvin.

##### Pressure (and stress) in MPa

Choosing the pressure unit to be MPa means that the PorousFlow pressures are multiplied by $10^{6}$ before feeding them to the FluidProperties module.  The viscosity returned by the FluidProperties module is multiplied by $10^{-6}$ (and any quantity from choosing non-default time units) before handing back to the remainder of PorousFlow.

In addition, you must remember that solid mechanical stresses should be measured in MPa, so moduli and strengths need to be specified in MPa.  Similarly, boundary tractions or pressures need to be specified in MPa.

Remember that the FluidProperties module always uses Pa, m, s and J.  Therefore, when using [SimpleFluidProperties](SimpleFluidProperties.md) you must specify the bulk modulus and viscosity in these units, not using MPa.

##### Alternate time units

Choosing the time unit to be hours means no change is made to the inputs to the FluidProperties module.

You must remember that fluid and heat sources must be measured in kg.m$^{-3}$.time$^{-1}$ and J.m$^{-3}$.time$^{-1}$, respectively (where "time" is "hours", "days" or "years" depending on your specific choice).  Remember too that the thermal conductivity of the solid skeleton must be measured in J.m$^{-1}$.K$^{-1}$.time$^{-1}$.  Velocities, radioactive decay rates, chemical precipitation and reaction rates, dispersion tensors and diffusion coefficients are similarly impacted.

Remember that the FluidProperties module always uses Pa, m, s and J.  Therefore, when using [SimpleFluidProperties](SimpleFluidProperties.md) you must specify the fluid thermal conductivity and viscosity in these units, not using hours, days or years.

###### Hours

The viscosity returned by the FluidProperties module is multiplied by $1/3600$ (and any quantity from choosing non-default pressure units) before handing back to the remainder of PorousFlow.

###### Days

The viscosity returned by the FluidProperties module is multiplied by $1/(3600\times 24)$ (and any quantity from choosing non-default pressure units) before handing back to the remainder of PorousFlow.

###### Julian years

The viscosity returned by the FluidProperties module is multiplied by $1/(3600\times 24\times 365.25)$ (and any quantity from choosing non-default pressure units) before handing back to the remainder of PorousFlow.





### PorousFlowTemperature





### PorousFlowThermalConductivityFromPorosity





### PorousFlowThermalConductivityIdeal





### PorousFlowTotalGravitationalDensityFullySaturatedFromPorosity





### PorousFlowVolumetricStrain

This Material computes volumetric strain and volumetric strain rate.  It requires a SolidMechanics strain calculator, which will usually be [ComputeSmallStrain](ComputeSmallStrain.md), to compute the Material property `total_strain`.  It then calculates

- `PorousFlow_total_volumetric_strain_qp` which is $\sum_{i}\epsilon_{ii}$, where $\epsilon$ is `total_strain`
- `PorousFlow_volumetric_strain_rate_qp` which is $\sum_{i}(\epsilon_{ii} - \epsilon_{ii}^{\mathrm{old}})/\mathrm{d}t$.

It also calculates derivatives of these with respect to the PorousFlow variables.

If your SolidMechanics strain calculator uses `base_name` then you must ensure that you supply the same `base_name` to this material.  [This page](porous_flow/time_derivative.md) contains more information.

The derivatives calculated assume Cartesian small strain.  Therefore, if you use a finite-strain calculator, or if you're using other coordinate systems, such as RZ coordinates, the Jacobian won't be exact, which will lead to slightly poorer convergence

This Material provides the time-derivative of the volumetric strain to the [PorousFlowMassVolumetricExpansion](PorousFlowMassVolumetricExpansion.md) and [PorousFlowHeatVolumetricExpansion](PorousFlowHeatVolumetricExpansion.md).  Related information can be found [here](porous_flow/time_derivative.md).





## postprocessors

### FVPorousFlowFluidMass


This finite volume specific `Postprocessor` calculates the mass of a fluid component $\kappa$ using
\begin{equation*}
M^{\kappa} = \phi \sum_{\beta} \chi^{\kappa}_{\beta} \rho_{\beta} S_{\beta},
\end{equation*}
where all variables are defined in [`nomenclature`](/nomenclature.md).

The fluid component $\kappa$ is specified in the input parameter [!param](/Postprocessors/FVPorousFlowFluidMass/fluid_component). By default, the mass of fluid component $\kappa$ is summed over all fluid phases. The
sum can be restricted to only a subset of fluid phases by entering the phase indexes
in the [!param](/Postprocessors/FVPorousFlowFluidMass/phase) input parameter.

This `Postprocessor` also provides the option to only calculate fluid mass below a
certain saturation, which can be invoked using the [!param](/Postprocessors/FVPorousFlowFluidMass/saturation_threshold) parameter.

The flag `use_displaced_mesh = false` is set internally by this Postprocessor, and the parameter cannot be altered by the user, even for simulations with solid-mechanical deformation.  The reason is that this Postprocessor uses the strain calculated by SolidMechanics to automatically compensate for deformed meshes.  Further information may be found [here](porous_flow/time_derivative.md).  Therefore:

- For mechanically-coupled simulations, you must provide a [!param](/Postprocessors/FVPorousFlowFluidMass/base_name) parameter that is identical to that used by the SolidMechanics strain calculator, so that this Postprocessor can retrieve the correct strain.  The most common use-case is that you provide no `base_name` to the SolidMechanics strain calculator and hence no `base_name` to this Postprocessor.
- For non-mechanically-coupled simulations, you must not provide a `base_name` that is used in any SolidMechanics strain calculators.  The most common use-case is that you have no SolidMechanics strain calculators, so you needn't worry about providing any `base_name` to this Postprocessor.  However, there is a possibility that you have a SolidMechanics strain calculator but you don't want to couple mechanics to PorousFlow.  In that case, supply `base_name = non_existent`, or similar, so that this Postprocessor doesn't retrieve any strain.




### PorousFlowFluidMass


This `Postprocessor` calculates the mass of a fluid component $\kappa$ using
\begin{equation*}
M^{\kappa} = \phi \sum_{\beta} \chi^{\kappa}_{\beta} \rho_{\beta} S_{\beta},
\end{equation*}
where all variables are defined in [`nomenclature`](/nomenclature.md).

The fluid component $\kappa$ is specified in the input parameter `fluid_component`.
By default, the mass of fluid component $\kappa$ is summed over all fluid phases. The
sum can be restricted to only a subset of fluid phases by entering the phase indexes
in the `phase` input parameter.

This `Postprocessor` also provides the option to only calculate fluid mass below a
certain saturation, which can be invoked using the `saturation_threshold` parameter.

The flag `use_displaced_mesh = false` is set internally by this Postprocessor, and the parameter cannot be altered by the user, even for simulations with solid-mechanical deformation.  The reason is that this postprocessor uses the strain calculated by SolidMechanics to automatically compensate for deformed meshes.  Further information may be found [here](porous_flow/time_derivative.md).  Therefore:

- For mechanically-coupled simulations, you must provide a `base_name` that is identical to that used by the SolidMechanics strain calculator, so that this Postprocessor can retrieve the correct strain.  The most common use-case is that you provide no `base_name` to the SolidMechanics strain calculator and hence no `base_name` to this Postprocessor.
- For non-mechanically-coupled simulations, you must not provide a `base_name` that is used in any SolidMechanics strain calculators.  The most common use-case is that you have no SolidMechanics strain calculators, so you needn't worry about providing any `base_name` to this postprocessor.  However, there is a possibility that you have a SolidMechanics strain calculator but you don't want to couple mechanics to PorousFlow.  In that case, supply `base_name = non_existent`, or similar, so that this Postprocessor doesn't retrieve any strain.




### PorousFlowHeatEnergy


This `Postprocessor` calculates the heat energy of fluid phase(s) $\beta$ using
\begin{equation*}
\mathcal{E} = \phi\sum_{\beta}S_{\beta}\rho_{\beta}\mathcal{E}_{\beta},
\end{equation*}
where all variables are defined in [`nomenclature`](/nomenclature.md).

The phases that the heat energy is summed over can be entered in the `phase` input
parameter. Multiple indices can be entered.

By default, the additional heat energy due to the porous material
\begin{equation*}
(1-\phi)\rho_{R}C_{R}T
\end{equation*}
is added to the heat energy of the fluid phase(s). This contribution can be ignored
by setting `include_porous_skeleton = false`.

The flag `use_displaced_mesh = false` is set internally by this Postprocessor, and the parameter cannot be altered by the user, even for simulations with solid-mechanical deformation.  The reason is that this postprocessor uses the strain calculated by SolidMechanics to automatically compensate for deformed meshes.  Further information may be found [here](porous_flow/time_derivative.md).  Therefore:

- For mechanically-coupled simulations, you must provide a `base_name` that is identical to that used by the SolidMechanics strain calculator, so that this Postprocessor can retrieve the correct strain.  The most common use-case is that you provide no `base_name` to the SolidMechanics strain calculator and hence no `base_name` to this Postprocessor.
- For non-mechanically-coupled simulations, you must not provide a `base_name` that is used in any SolidMechanics strain calculators.  The most common use-case is that you have no SolidMechanics strain calculators, so you needn't worry about providing any `base_name` to this postprocessor.  However, there is a possibility that you have a SolidMechanics strain calculator but you don't want to couple mechanics to PorousFlow.  In that case, supply `base_name = non_existent`, or similar, so that this Postprocessor doesn't retrieve any strain.




### PorousFlowPlotQuantity

This is used to record the total fluid (kg) or heat (J) flux that is produced by a PorousFlow DiracKernel in a time step.  See [polyline sinks](sinks.md) for an extended discussion.




## userobjects

### AdvectiveFluxCalculatorConstantVelocity

The `AdvectiveFluxCalculatorConstantVelocity` computes $K$, $R^{+}$ and $R^{-}$ that are used in the Kuzmin-Turek [!citep](KuzminTurek2004) numerical stabilization scheme, when the velocity is constant and uniform over the mesh.  $K$ is a measure of advective flux between neighbouring nodes, while $R^{+}$ and $R^{-}$ quantify how much antidiffusion to allow around the nodes.  See [A worked example of Kuzmin-Turek stabilization](kt_worked.md) for many explicit details, and [numerical diffusion](numerical_diffusion.md) for example of how the Kuzmin-Turek scheme compares with other numerical schemes.




### PorousFlowAdvectiveFluxCalculatorSaturated

This `UserObject` implements the [Kuzmin-Turek stabilization scheme](kt.md) in the case of one-phase, one-component, fully-saturated Darcy flow.  Specifically, it computes $u$ and $\mathbf{v}$ and $u$ given by
\begin{equation}
u = \rho / \mu \ ,
\end{equation}
and
\begin{equation}
v_{i} = -k_{ij}(\nabla_{j}P - \rho g_{j}) \ ,
\end{equation}
where $k_{ij}$ is the permeability tensor, $P$ is the porepressure, $\rho$ is the fluid density, and $g_{j}$ is the acceleration due to gravity, and $\mu$ is the fluid viscosity.  Derivatives of these quantities with respect to the PorousFlow Variables (defined in the [PorousFlowDictator](PorousFlowDictator.md)) are also computed.

The computed $u$ and $\mathbf{v}$ may then be used by the [PorousFlowFluxLimitedTVDAdvection](PorousFlowFluxLimitedTVDAdvection.md) Kernel.




### PorousFlowAdvectiveFluxCalculatorSaturatedHeat

This `UserObject` implements the [Kuzmin-Turek stabilization scheme](kt.md) for heat advection in the case of single-phase porous flow.  Specifically, it computes $u$ and $\mathbf{v}$ and $u$ given by
\begin{equation}
u = h \rho / \mu \ ,
\end{equation}
and
\begin{equation}
v_{i} = -k_{ij}(\nabla_{j}P - \rho g_{j}) \ ,
\end{equation}
where $k_{ij}$ is the permeability tensor, $P$ is the porepressure, $\rho$ is the fluid density, and $g_{j}$ is the acceleration due to gravity, $h$ is the fluid enthalpy, and $\mu$ is the fluid viscosity.  Derivatives of these quantities with respect to the PorousFlow Variables (defined in the [PorousFlowDictator](PorousFlowDictator.md)) are also computed.

The computed $u$ and $\mathbf{v}$ may then be used by the [PorousFlowFluxLimitedTVDAdvection](PorousFlowFluxLimitedTVDAdvection.md) Kernel to simulate heat flow.  See details on the [Kuzmin-Turek stabilization scheme](kt.md) page.




### PorousFlowAdvectiveFluxCalculatorSaturatedMultiComponent

This `UserObject` implements the [Kuzmin-Turek stabilization scheme](kt.md) in the case of one-phase, multi-component, fully-saturated Darcy flow.  Specifically, it computes $u$ and $\mathbf{v}$ and $u$ given by
\begin{equation}
u = \chi \rho / \mu \ ,
\end{equation}
and
\begin{equation}
v_{i} = -k_{ij}(\nabla_{j}P - \rho g_{j}) \ ,
\end{equation}
where $k_{ij}$ is the permeability tensor, $P$ is the porepressure, $\rho$ is the fluid density, and $g_{j}$ is the acceleration due to gravity, $\chi$ is the appropriate mass fraction, and $\mu$ is the fluid viscosity.  Derivatives of these quantities with respect to the PorousFlow Variables (defined in the [PorousFlowDictator](PorousFlowDictator.md)) are also computed.

The computed $u$ and $\mathbf{v}$ may then be used by the [PorousFlowFluxLimitedTVDAdvection](PorousFlowFluxLimitedTVDAdvection.md) Kernel.




### PorousFlowAdvectiveFluxCalculatorUnsaturated

This `UserObject` implements the [Kuzmin-Turek stabilization scheme](kt.md) in the case of one-phase, one-component, unsaturated Darcy-Richards flow.  Specifically, it computes $u$ and $\mathbf{v}$ and $u$ given by
\begin{equation}
u = k_{r} \rho / \mu \ ,
\end{equation}
and
\begin{equation}
v_{i} = -k_{ij}(\nabla_{j}P - \rho g_{j}) \ ,
\end{equation}
where $k_{ij}$ is the permeability tensor, $P$ is the porepressure, $\rho$ is the fluid density, and $g_{j}$ is the acceleration due to gravity, $k_{r}$ is the relative permeability, and $\mu$ is the fluid viscosity.  Derivatives of these quantities with respect to the PorousFlow Variables (defined in the [PorousFlowDictator](PorousFlowDictator.md)) are also computed.

This `UserObject` may also be used for multi-phase, multi-component porous-flow, if each mass fraction exists in one phase only (so that the mass fractions are just 1 or 0).

The computed $u$ and $\mathbf{v}$ may then be used by the [PorousFlowFluxLimitedTVDAdvection](PorousFlowFluxLimitedTVDAdvection.md) Kernel.




### PorousFlowAdvectiveFluxCalculatorUnsaturatedHeat

This `UserObject` implements the [Kuzmin-Turek stabilization scheme](kt.md) for heat advection in the case of multi-phase porous flow.  Specifically, it computes $u$ and $\mathbf{v}$ and $u$ given by
\begin{equation}
u = h k_{r} \rho / \mu \ ,
\end{equation}
and
\begin{equation}
v_{i} = -k_{ij}(\nabla_{j}P - \rho g_{j}) \ ,
\end{equation}
where $k_{ij}$ is the permeability tensor, $P$ is the porepressure of the phase, $\rho$ is the fluid density of the phase, and $g_{j}$ is the acceleration due to gravity, $h$ is the fluid enthalpy of the phase, $k_{r}$ is the relative permeability of the phase, and $\mu$ is the fluid viscosity of the phase.  Derivatives of these quantities with respect to the PorousFlow Variables (defined in the [PorousFlowDictator](PorousFlowDictator.md)) are also computed.

The computed $u$ and $\mathbf{v}$ may then be used by the [PorousFlowFluxLimitedTVDAdvection](PorousFlowFluxLimitedTVDAdvection.md) Kernel to simulate heat flow.  Typically $N_{\beta}$ (number of fluid phases) of such Kernel-UserObject pairs would contribute to the Residual for the temperature variable, corresponding to heat being transferred by each of the fluid phases.  See details on the [Kuzmin-Turek stabilization scheme](kt.md) page.




### PorousFlowAdvectiveFluxCalculatorUnsaturatedMultiComponent

This `UserObject` implements the [Kuzmin-Turek stabilization scheme](kt.md) in the case of multi-phase, multi-component porous flow.  Specifically, it computes $u$ and $\mathbf{v}$ and $u$ given by
\begin{equation}
u = \chi k_{r} \rho / \mu \ ,
\end{equation}
and
\begin{equation}
v_{i} = -k_{ij}(\nabla_{j}P - \rho g_{j}) \ ,
\end{equation}
where $k_{ij}$ is the permeability tensor, $P$ is the porepressure of the phase, $\rho$ is the fluid density of the phase, and $g_{j}$ is the acceleration due to gravity, $k_{r}$ is the relative permeability of the phase, $\chi$ is the mass fraction of the component in the phase, and $\mu$ is the fluid viscosity of the phase.  Derivatives of these quantities with respect to the PorousFlow Variables (defined in the [PorousFlowDictator](PorousFlowDictator.md)) are also computed.

The computed $u$ and $\mathbf{v}$ may then be used by the [PorousFlowFluxLimitedTVDAdvection](PorousFlowFluxLimitedTVDAdvection.md) Kernel.  $N_{\beta}$ (the number of fluid phases) of these `UserObjects` typically contribute to the residual for a single variable: see details on the [Kuzmin-Turek stabilization scheme](kt.md) page.




### PorousFlowBrineCO2


A high precision equation of state for brine and CO$_2$, including the mutual solubility of
CO$_2$ into the liquid brine and water vapor into the CO$_2$-rich gas phase using the accurate
fugacity-based formulation of [!cite](spycher2003) and [!cite](spycher2005).

This model is suitable for simulations of geological storage of CO$_2$ in saline aquifers.

For more details, see the documentation of the [brine and CO$_2$](brineco2.md) equation of state.





### PorousFlowCapillaryPressureBC


The Brooks-Corey capillary-pressure relationship is [!citep](brookscorey1966)

\begin{equation}
S_{\mathrm{eff}} = \left( \frac{P_c}{P_e} \right)^{-\lambda},
\end{equation}
or
\begin{equation}
P_c = P_e S_{\mathrm{eff}}^{-1/\lambda},
\end{equation}
where $P_e$, the threshold entry pressure, and $\lambda$, the exponent, are required
parameters.







### PorousFlowCapillaryPressureBW


The Broadbridge-White capillarity relationship valid for small $K_{n}$ is [!citep](broadbridge1988)
\begin{equation}
S_{\mathrm{eff}} = S_{n} + (S_{s} - S_{n}) \frac{c}{1 + L(x)} \ .
\end{equation}
where
\begin{equation}
x = (c - 1) e^{c - 1 - c P/\lambda} \ ,
\end{equation}
and $L(x)$ is the Lambert W-function that satisfies $L(z)e^{L(z)}=z$.  This is of limited use in real
simulations, and is only used in the Porous Flow module for comparison with the analytical solutions
of [!cite](broadbridge1988) and [!cite](warrick1990) for multi-phase infiltration and drainage
problems.

Only effective saturation as a function of capillary pressure is available





### PorousFlowCapillaryPressureConst


This UserObject provides a constant capillary pressure
\begin{equation}
  P_c = c.
\end{equation}
This formulation is useful for testing purposes.





### PorousFlowCapillaryPressureRSC


The Rogers-Stallybrass-Clements capillary relationship is [!citep](rsc1983)
\begin{equation}
S_{\mathrm{eff}} = \frac{1}{\sqrt{1 + \exp((P_{c} - A)/B)}} \ ,
\end{equation}
when the oil viscosity is exactly twice the water viscosity.  This is
of limited use in real simulations, and is only used in the Porous
Flow module for comparison with the analytical solutions offered by
the authors for multi-phase infiltration and drainage problems.

Only effective saturation as a function of capillary pressure is available.






### PorousFlowCapillaryPressureVG


van Genuchten's capillary-pressure relationship [!citep](vangenuchten1980)

\begin{equation}
S_{\mathrm{eff}} =
\begin{cases}
1 & \textrm{if } P \geq 0 \ , \\
(1 + (-\alpha P)^{1/(1-m)})^{-m} & \textrm{if } P < 0 \ .
\end{cases}
\end{equation}
or
\begin{equation}
P_{c} =
\begin{cases}
0 & \textrm{if } S_{\mathrm{eff}} >= 1.0 \ , \\
\frac{1}{\alpha} (S_{\mathrm{eff}}^{-1/m} - 1)^{1 - m} & \textrm{if } S_{\mathrm{eff}} < 1
\end{cases}
\end{equation}

The effective saturation has been denoted by $S_{\mathrm{eff}}$ and
$P$ is the porepressure, which is the *negative* of the capillary
pressure: $P = -P_{c}$.  Here $\alpha$ and $m$ are user-defined parameters.  The
parameter $m$ must satisfy
\begin{equation}
0 < m < 1 \ .
\end{equation}

By default, a logarithmic extension for low liquid phase saturations is implemented.
This can be disabled by setting `log_extension = false`.






### PorousFlowDictator


The `PorousFlowDictator` provides information about the valid PorousFlow
variables, as well as the number of fluid components and fluid phases to other
PorousFlow objects in a simulation.

This +must+ be present in all simulations!




### PorousFlowSumQuantity

This is used to record the total fluid (kg) or heat (J) flux that is produced by a PorousFlow DiracKernel in a time step.  See [`polyline sinks`](sinks.md) for an extended discussion.




### PorousFlowWaterNCG





### PorousFlowWaterVapor





# Ray Tracing Module

The ray tracing module traces rays through the finite element mesh. Notable features include:

- Supports tracing in meshes with planar sides (2D and 3D)
- Supports mesh adaptivity
- Supports contribution to residuals and Jacobians (with full coupling support) along ray segments
- Supports ray interaction with internal and external boundaries
- Supports storage and manipulation of data unique to each ray
- Supports ray interaction with field variables
- Highly parallelizable: tested to 20k MPI ranks

       id=cone-ray-study-u
       caption=Example of [flashlight_source.md] within a diffusion-reaction problem.

      id=cone-ray-study-rays
      caption=Overlay of the rays that were traced for the problem in [cone-ray-study-u].

## Examples

- [line_integrals.md] - Integration of a field along a line
- [line_sources.md] - Body force term along a line
- [flashlight_source.md] - Anisotropic point sources that emit in a cone of directions

## Object Overview

- [Ray.md] - Basic data structure that represents a single ray that traverses the mesh
- [RayTracingStudy.md] - [UserObject](UserObjects/index.md) that generates and executes the [Rays](Ray.md)
- [RayBCs/index.md] - Manipulates [Rays](Ray.md) on boundaries, both internal and external
- [RayKernels/index.md] - Manipulates [Rays](Ray.md) on segments within an element along a [Ray.md] trajectory

## actions

### AddRayBCAction


For more information, see [RayBCs/index.md].

A [RayBC](RayBCs/index.md) requires a [RayTracingStudy.md] to be associated with it. This is provided with the [!param](/RayBCs/KillRayBC/study) parameter. If the [!param](/RayBCs/KillRayBC/study) parameter is not provided, the associated [RayTracingStudy.md] will be the one study object that exists. If multiple studies exist, the [!param](/RayBCs/KillRayBC/study) parameter must be provided.


### AddRayKernelAction


For more information, see [RayBCs/index.md].

A [RayKernels/index.md](RayKernel) requires a [RayTracingStudy.md] to be associated with it. This is provided with the [!param](/RayKernels/NullRayKernel/study) parameter. If the [!param](/RayKernels/NullRayKernel/study) parameter not provided, the associated [RayTracingStudy.md] will be the one study object that exists. If multiple studies exist, the [!param](/RayKernels/NullRayKernel/study) parameter must be provided.


## outputs

### RayTracingExodus


For more information, see [RayTracingMeshOutput.md].




### RayTracingMeshOutput

`RayTracingMeshOutput` is the base class for the output of rays traced with the [ray_tracing/index.md] as 1D elements in a mesh format. Exodus and Nemesis mesh formats are currently supported and are found in [RayTracingExodus.md] and [RayTracingNemesis.md], respectively. The information that follows pertains to both Exodus and Nemesis output---the only difference is the format in which the mesh is output. In order to output traced rays, you must enable the caching of the trace information in the [RayTracingStudy.md] (see [#trace-caching]).

Each segment of the [Ray.md] (the portion of the trace within an element) is represented as a 1D, edge element. This enables the overlaying of the traced rays on the actual mesh with ease using visualization software such as Paraview.


#### Ray Information Output

Information on each segment can also be output. In the most general form, the information is output as a constant value on the Ray segment. The supported output for information on a [Ray.md] is as follows:

- All of the data on the [Ray](Ray.md), enabled by [!param](/Outputs/RayTracingExodus/output_data).
- All of the auxiliary data on the [Ray](Ray.md), enabled by [!param](/Outputs/RayTracingExodus/output_aux_data).
- The [Ray.md] ID, enabled by appending `ray_id` to the [!param](/Outputs/RayTracingExodus/output_properties) parameter.
- The number of intersections the [Ray.md] has encountered up to a segment, enabled by appending `intersections` to the [!param](/Outputs/RayTracingExodus/output_properties) parameter.
- The processor ID that the segment was executed on, enabled by appending `pid` to the [!param](/Outputs/RayTracingExodus/output_properties) parameter.
- The number of processor crossings that the [Ray.md] has encountered up to a segment, enabled by appending `processor_crossings` to the [!param](/Outputs/RayTracingExodus/output_properties) parameter.
- The number of trajectory changes that the [Ray.md] has encountered up to a segment, enabled by appending `trajectory_changes` to the [!param](/Outputs/RayTracingExodus/output_properties) parameter.

Note that the representation of data on a [Ray.md] segment as a constant value is an approximation. When this data is a represented as a constant value, the data is sampled at the furthest point of the trace after [RayKernels/index.md] and [RayBCs/index.md] are executed on it. Another form of approximation available is the output of this data in a nodal sense, where the data are sampled at both points on the segments and represented linearly. This is enabled by the
[!param](/Outputs/RayTracingExodus/output_data_nodal) parameter.

#### Trace Caching

`RayTracingMeshOutput` uses cached information about the traces to produce this output. By default, this caching is not enabled in the [RayTracingStudy.md].

The default method in [RayTracingStudy.md] makes use of the [!param](/UserObjects/RepeatableRayStudy/always_cache_traces) parameter, which enables the caching of all traces. In addition, if you wish to output [Ray.md] data or auxiliary data, you must set true the [!param](/UserObjects/RepeatableRayStudy/data_on_cache_traces) and [!param](/UserObjects/RepeatableRayStudy/aux_data_on_cache_traces) parameters, respectively.

In simulations in which many rays are traced, storing and outputting each segment could be constrained by memory or could be computationally expensive. With this, there is also an option to represent the traces with as little information as possible. This option stores the cached information about the traces only when the [Ray.md] trajectory has changed or when the [Ray.md] has crossed a processor. This functionality is enabled by the [!param](/UserObjects/RepeatableRayStudy/segments_on_cache_traces) parameter in the [RayTracingStudy.md].

#### Example

As an example, we are going to output the segment-wise accumulated integral for the simple diffusion variable integral example described in [ray_tracing/examples/line_integrals.md].

To recap, we begin with the "simple diffusion" problem:


A [RepeatableRayStudy.md] is utilized that computes the integral of the variable $u$ from $(0, 0)$ to $(5, 5)$ and from $(5, 0)$ to $(5, 5)$:


Take note that we must enable the commented out parameters [!param](/UserObjects/RepeatableRayStudy/always_cache_traces) and [!param](/UserObjects/RepeatableRayStudy/data_on_cache_traces) in order to enable the caching of information needed for the output.

Lastly, we are going to add a [RayTracingExodus.md] output object that will output the traces in Exodus format. For Nemesis format, simply use [RayTracingNemesis.md].


In order to enable this output, we will set [!param](/UserObjects/RepeatableRayStudy/execute_on) to `TIMESTEP_END` as per the comment.

##### Running the Example

First, we will run the example with constant data for the integrated value on each segment:

```
./ray_tracing-opt -i test/tests/raykernels/variable_integral_ray_kernel/simple_diffusion_line_integral.i UserObjects/study/always_cache_traces=true UserObjects/study/data_on_cache_traces=true Outputs/rays/output_data=true Outputs/rays/execute_on=TIMESTEP_END
```

Overlaying the standard output of the problem, `simple_diffusion_line_integral_out.e`, with the ray output, `simple_diffusion_line_integral_rays.e` and visualizing the `u_integral_value` variable on the ray output mesh, we obtain the result below in [constant].


Second, we will instead plot the ray data in a nodal sense, in which the value on a segment is represented in a linear fashion with its start and end point values. This is done by enabling enabling [!param](/Outputs/RayTracingExodus/output_data_nodal), as:

```
./ray_tracing-opt -i test/tests/raykernels/variable_integral_ray_kernel/simple_diffusion_line_integral.iUserObjects/study/always_cache_traces=true UserObjects/study/data_on_cache_traces=true Outputs/rays/output_data_nodal=true Outputs/rays/execute_on=TIMESTEP_END
```

Again, overlaying the ray mesh result on the problem result we obtain the result below in [nodal].


### RayTracingNemesis


For more information, see [RayTracingMeshOutput.md].




## postprocessors

### RayDataValue


A [Ray.md] in the [ray_tracing/index.md] has the ability to locally store information that can be modified along the trace. This object enables convenient access to said data after the trace has completed.




### RayIntegralValue


For more information and example use, see [line_integrals.md].




### RayTracingStudyResult





## raybcs

### GeneralRayBC

#### Description

`GeneralRayBC` is the base class for general objects that wish to operate on a [Ray.md] as it intersects a boundary.

For more information, see [RayBCs/index.md].

### KillRayBC


The ray is killed by setting the Ray to not be continued:




### NullRayBC





### RayBoundaryConditionBase

#### Description

`RayBoundaryConditionBase` is the base object for [RayBCs/index.md]. For more information, see [RayBCs/index.md].

### ReflectRayBC


It can properly handle reflections at domain corners/edges that are reflecting on all boundaries at the corner/edge (see [syntax/RayBCs/index.md#hitting-multiple-boundaries] for more information).

It achieves the reflection by changing the direction of the [Ray.md]:


Per the specularly reflected direction (static and available for other [RayBCs/index.md] to use):




## raykernels

### ADRayKernel

#### Description

`ADRayKernel` is the base class for the objects that calculate residual vector contributions of non-linear scalar field variables that use [automatic_differentiation/index.md] along a [Ray.md]. See also [RayKernel.md] for the non-AD version of this object.

The use of a `ADRayKernel` is the same of a standard [Kernel](Kernels/index.md). In an `ADRayKernel` subclass the `computeQpResidual()` function must be overridden. This is where you implement your PDE weak form terms.

Inside your `ADRayKernel` class, you have access to several member variables for computing the residual:

- `_i`, `_j`: indices for the current test and trial shape functions respectively.
- `_qp`: current quadrature point index.
- `_u`, `_grad_u`: value and gradient of the variable this Kernel operates on;
  indexed by `_qp` (i.e. `_u[_qp]`).
- `_test`, `_grad_test`: value ($\psi$) and gradient ($\nabla \psi$) of the
  test functions at the q-points; indexed by `_i` and then `_qp` (i.e., `_test[_i][_qp]`).
- `_phi`, `_grad_phi`: value ($\phi$) and gradient ($\nabla \phi$) of the
    trial functions at the q-points; indexed by `_j` and then `_qp` (i.e., `_phi[_j][_qp]`).
- `_q_point`: XYZ coordinates of the current quadrature point.
- `_current_elem`: pointer to the current element being operated on.

Also available for override is `precalculateResidual()`,
which is an insertion point immediately before computing the residual. This can be useful when computing cached values that are valid for all quadrature points.

Many other useful member variables exist that describe the [Ray.md] segment. For more information, see [syntax/RayKernels/index.md#using-a-raykernel].

`RZ` and `RSPHERICAL` coordinate changes are not valid for a `RayKernel`. This is because said coordinate systems have no way to represent a line source---one would end up with a plane/surface source or a volumetric source, respectively. This is why `_coord[_qp]` is not utilized in `RayKernel`.

### AuxRayKernel

#### Description

`AuxRayKernel` is the base class for contributing to an [AuxVariable](syntax/AuxVariables/index.md) (of type `CONSTANT MONOMIAL` only) from a [Ray.md] segment. An example is [RayDistanceAux.md], which accumulates the distance traversed by each [Ray.md] segment into an `AuxVariable` for the element that the segment is in.

To use, override the `onSegment()` method and use the `addValue()` method to add to the [AuxVariable](syntax/AuxVariables/index.md). Many useful member variables exist that describe the [Ray.md] segment - see [Using a RayKernel](syntax/RayKernels/index.md#using-a-raykernel).

### FunctionIntegralRayKernel


The integration performed for the function $f(r)$ is

\int_L f(r)~dr, \quad L = \{\vec{r}_1 + t\vec{r}_2 \mid t \in [0, 1]\}\,,

which is achieved by overriding `computeQpIntegral()` as:


The resulting integrated value can be obtained using a [RayIntegralValue.md] postprocessor.




### GeneralRayKernel

`GeneralRayKernel` is the base class for general objects that wish to operate on a [Ray.md] as it intersects a boundary.

For more information, see [RayKernels/index.md].

### GenericRayKernel

Acts as a switch between the AD/non-AD base class for [RayKernels/index.md] that calculate residual contributions along the trace of a [Ray.md].

This effectively allows a class to either inherit from [RayKernel.md] for the non-AD case or [ADRayKernel.md] for the AD case via the boolean `<is_ad>`. For en example, see [LineSourceRayKernel.md].

### IntegralRayKernel

#### Description

`IntegralRayKernel` is the base class for integrating a quantity $f(r)$ along a [Ray.md] and accumulating the integral into a data member on the [Ray.md]. The integral computed is:

\int_L f(r)~dr, \quad L = \{\vec{r}_1 + t\vec{r}_2 \mid t \in [0, 1]\}\,,

where $f(r)$ is integrated from $\vec{r}_1$ to $\vec{r}_2$.

`IntegralRayKernel` is *not* to be used for contributing to a residual or Jacobian along a [Ray.md]. For this case, you should derive from [RayKernel.md] or [ADRayKernel.md].

For examples, see:

- [VariableIntegralRayKernel.md] for integrating a [Variable](Variables/index.md) or an [AuxVariable](AuxVariables/index.md)
- [MaterialIntegralRayKernel.md] for integrating a [Material](Materials/index.md)
- [FunctionIntegralRayKernel.md] for integrating a [Function](Functions/index.md)

To integrate along a desired quantity, inherit from IntegralRayKernel and override the `computeQpIntegral()` method in which `_qp` is the current quadrature point index. For example:


Many other useful member variables exist that describe the [Ray.md] segment. For more information, see [Using a RayKernel](syntax/RayKernels/index.md#using-a-raykernel).

The integrated value produced by a class that derives from this should be obtained using the [RayIntegralValue.md] postprocessor. For example:


### IntegralRayKernelBase

#### Description

`IntegralRayKernelBase` is the base class for computing an integral along a [Ray.md] segment. It is used as a parent for classes like [IntegralRayKernel.md], [RayKernel.md], and [ADRayKernel.md].

It makes available the standard [Assembly.md] members like `_q_point` for the current quadrature points and `_JxW` for the current weights. It overrides the standard `onSegment()` behavior of a [RayKernel](RayKernels/index.md) and replaces it with a `computeIntegral()` method to be overridden to compute the integral on a segment.

### KillRayKernel





### LineSourceRayKernel


While this summary describes the non-AD form available in `LineSourceRayKernel`, an AD-form is also available as the `ADLineSourceRayKernel`.

The strong form, given the line

L = \{\vec{r}_1 + t\vec{r}_2 \mid t \in [0, 1]\}\,

is defined as

\underbrace{-f(r')}_{\text{LineSourceRayKernel}} + \sum_{i=1}^n \beta_i(u,r) = 0\,,\quad r\in\Omega\,,\quad r'\in L

where $f$ is the source term (negative if a sink) along $L$ and the second term on the left hand side represents the strong forms of other kernels and boundary conditions. The `LineSourceRayKernel` weak form, in inner-product notation, is defined as

R_i(u_h) = (\psi_i, -f)_L \quad \forall ~ \psi_i,

where the $\psi_i$ are the test functions, and $u_h$ are the trial solutions in the finite dimensional space $\mathcal{S}^h$ for the unknown ($u$).

The Jacobian term for this kernel is zero: $\frac{\partial R_i(u_h)}{\partial u_j} = 0$, since it is assumed that $f$ +is not+ a function of the unknown $u$.

The force is constructed through a user supplied constant $c$, [function](/Functions/index.md) value evaluated at the current time and quadrature point $f$, [postprocessor](/Postprocessors/index.md) value $p$, and/or [Ray.md] data $r$. The constant $c$, supplied through the parameter [!param](/RayKernels/LineSourceRayKernel/value), may also be controlled over the course of a transient simulation with a [`Controls`](/Controls/index.md) block.  $c$, $f$, $p$ are supplied through the input parameters [!param](/RayKernels/LineSourceRayKernel/value), [!param](/RayKernels/LineSourceRayKernel/function), and [!param](/RayKernels/LineSourceRayKernel/postprocessor) respectively. $r$ is supplied through the input parameters [!param](/RayKernels/LineSourceRayKernel/ray_data_factor_names) and [!param](/RayKernels/LineSourceRayKernel/ray_aux_data_factor_names) as the product of the ray data with the given names. Not supplying $c$, $f$, $p$, or $r$ through its corresponding parameter is equivalent to setting its value to unity.




### MaterialIntegralRayKernel

#### Description


The integral performed for the material $u$ is

\int_L u~dr, \quad L = \{\vec{r}_1 + t\vec{r}_2 \mid t \in [0, 1]\}\,,

where $u$ is the material property, which is achieved by overriding `computeQpIntegral` as:


The resulting integrated value can be obtained using a [RayIntegralValue.md] postprocessor.




### NullRayKernel





### RayDistanceAux


The accumulation is achieved by overriding `onSegment` and appending into the `AuxVariable` via `addValue()`, as:




### RayKernel

#### Description

`RayKernel` is the base class for the objects that calculate residual vector contributions of non-linear scalar field variables along a [Ray.md]. See also [ADRayKernel.md] for the AD version of this object. The most simple form of a `RayKernel` is a [LineSourceRayKernel.md], which implements a line source along a [Ray.md]. 

The use of a `RayKernel` is the same of a standard [Kernel](Kernels/index.md). In a `RayKernel` subclass the `computeQpResidual()` function must be overridden. This is where you implement your PDE weak form terms. For non-AD objects the following member functions can optionally be overridden:

- `computeQpJacobian()`
- `computeQpOffDiagJacobian()`

These two methods provide extra information that can help the numerical solver(s) converge faster and better.

Inside your `RayKernel` class, you have access to several member variables for computing the residual and Jacobian values in the above mentioned functions:

- `_i`, `_j`: indices for the current test and trial shape functions respectively.
- `_qp`: current quadrature point index.
- `_u`, `_grad_u`: value and gradient of the variable this Kernel operates on;
  indexed by `_qp` (i.e. `_u[_qp]`).
- `_test`, `_grad_test`: value ($\psi$) and gradient ($\nabla \psi$) of the
  test functions at the q-points; indexed by `_i` and then `_qp` (i.e., `_test[_i][_qp]`).
- `_phi`, `_grad_phi`: value ($\phi$) and gradient ($\nabla \phi$) of the
    trial functions at the q-points; indexed by `_j` and then `_qp` (i.e., `_phi[_j][_qp]`).
- `_q_point`: XYZ coordinates of the current quadrature point.
- `_current_elem`: pointer to the current element being operated on.

Also available for override are:

- `precalculateResidual()`
- `precalculateJacobian()`
- `precalculateOffDiagJacobian()`

which are insertion points immediately before computing residuals and Jacobians. These methods can be useful when computing cached values that are valid for all quadrature points.

Many other useful member variables exist that describe the [Ray.md] segment. For more information, see [Using a RayKernel](syntax/RayKernels/index.md#using-a-raykernel).

RZ and RSPHERICAL coordinate changes are not valid for a `RayKernel`. This is because said coordinate systems have no way to represent a line source - one would end up with a plane/surface source or a volumetric source, respectively. This is why `_coord[_qp]` is not utilized in `RayKernel`.

### RayKernelBase

RayKernelBase is the base object for [RayKernels/index.md].

For more information, see [RayKernels/index.md]. For the majority of use cases, you should inherit from one of the mentioned objects in [RayKernels/index.md].

### VariableIntegralRayKernel


The integral performed along the value $u$ is

\int_L u~dr, \quad L = \{\vec{r}_1 + t\vec{r}_2 \mid t \in [0, 1]\}\,,

which is achieved by overriding `computeQpIntegral`, as:


The resulting integrated value can be obtained using a [RayIntegralValue.md] postprocessor.




## raytracing

### ElemExtrema

#### Description

`ElemExtrema` is a helper struct for identifying if a [Ray.md] has intersected the "extrema" of an element during tracing. In 2D, an element extrema is defined as a vertex. In 3D, an element extrema is defined as a vertex or an edge.

The intersected element extrema is available in [RayKernels/index.md] and [RayBCs/index.md] during a trace as the `_current_intersected_extrema` member variable.

The methods of interest for use during tracing on `ElemExtrema` are:

- `atExtrema()` - Whether or not the intersection is at an extrema.
- `atVertex()` - Whether or not the intersection is at a vertex.
- `atEdge()` - Whether or not the intersection is at an edge.
- `vertex()` - The local vertex index that was intersected.
- `vertexPoint()` - The point of the vertex that was intersected.
- `edgeVertices()` - The vertices that define the edge that was intersected.
- `buildEdge()` - Builds an `Elem` that is the edge that was intersected.

### Ray

A `Ray` is the data structure that represents a single ray in the [ray_tracing/index.md] that is generated and traced by a [RayTracingStudy.md]. It can store data and auxiliary data that can modified along the trace via [RayKernels/index.md] and [RayBCs/index.md].

The discussion of how to use and interact with a `Ray` is summarized into the following sections:

- [Defining a Ray Trajectory](#defining-a-ray-trajectory): How to define a `Ray` trajectory for it to be traced using a [RayTracingStudy.md].
- [Modifying a Ray Trajectory](#modifying-a-ray-trajectory): How to modify a `Ray` trajectory while it is being traced via [RayKernels/index.md] and [RayBCs/index.md].
- [Using Ray Data](#using-ray-data): How to best access and use the data stored on the `Ray`.
- [Getting a Ray](#getting-a-ray): How to obtain a `Ray` to be used for tracing.

Useful member variables available on the `Ray` are:

- `currentPoint()` - The current point of the `Ray`. Before being traced, this is the starting point. While being traced, this is the furthest point that the `Ray` has travelled (during RayKernel execution, this is the end of the segment). After being traced, this is the point where the `Ray` was killed.
- `currentElem()` - The current element that the `Ray` is in. Before being traced, this is the starting element of the `Ray`. During tracing during [RayKernel](RayKernels/index.md) execution, this is the element that the segment is in. During tracing during [RayBC](RayBCs/index.md) execution, this is the element that the [RayBC](RayBCs/index.md) is being applied to. At the end of tracing, this is the element that the `Ray` died in.
- `currentIncomingSide()` - The current incoming side on `currentElem()` that the `Ray` was incoming on. Before being traced, this is the side that the `Ray` will begin on (if any). During tracing, this is only valid when [RayKernels/index.md] are being executed. After tracing, this is not valid.
- `direction()` - The current direction of the `Ray` trajectory.
- `data()` - Access into the data stored on the `Ray`.
- `auxData()` - Access into the auxiliary data stored on the `Ray`.
- `distance()` - The total distance the `Ray` has traveled thus far.
- `maxDistance()` - The user-set maximum distance that this `Ray` can travel. When a user defines the `Ray` trajectory using `setStartingEndPoint()`, this is set internally to the straight-line distance from the start point to the user-set end point.
- `endSet()` - Whether or not the user defined the trajectory using the `setStartingEndPoint()` method. This identifies whether or not `maxDistance()` was set internally to ensure that the `Ray` ends at the user-defined end point.
- `endPoint()` - The user-set end point if it was set via `setStartingEndPoint()`.
- `shouldContinue()` - Whether or not the `Ray` should continue to be traced after [RayKernels/index.md] and [RayBCs/index.md] are executed.
- `setShouldContinue()` - Makes it possible to set a `Ray` to be killed after [RayKernels/index.md] and [RayBCs/index.md] are executed.
- `getInfo()` - Helper method for creating a `std::string` with useful information about the `Ray`.

#### Defining a Ray Trajectory

A `Ray`'s trajectory defines where it is going to be traced by the [RayTracingStudy.md]. This description is *only* for defining a `Ray`'s trajectory before it is being traced.
To change a `Ray`'s trajectory mid-trace, see [Modifying a Ray Trajectory](#modifying-a-ray-trajectory).

First, you must define the starting point for the `Ray`. This is achieved via the `setStart()` method, which takes as arguments a starting point, an optional starting element, and an optional incoming side.

A starting element is required for a `Ray` to be traced, but there exist cases in which you will not initially set the starting element. For example, the [RepeatableRayStudyBase.md] will internally determine both the starting element and starting incoming side (if any) for a `Ray` via a claiming process.

Next, you must define where the `Ray` is to travel from its starting point. This is achieved by one of the following methods:

- `setStartingEndPoint()` - Takes as an argument the desired end point for the `Ray`. It will be traced until it hits said end point within the mesh (but it can be killed by [RayKernels/index.md] or [RayBCs/index.md] along the way). Internally, this is handled by setting `maxDistance()` to the straight-line distance from the start point to the end point. `Ray`s initialized using this method that have end points on the boundary will not have [RayBCs/index.md] executed on them on the boundary. They will be killed internally before the execution of [RayBCs/index.md].
- `setStartingDirection()` - Takes as an argument the desired direction for the `Ray` to travel. `Ray`s initialized by this method must be killed by either [RayKernels/index.md], by a [RayBCs/index.md], by the maximum distance `maxDistance()`, or by the [RayTracingStudy.md] maximum distance parameter `ray_max_distance`. If a `Ray` in this situation hits a boundary and is not killed, an error will be generated.
- `setStationary()` - Sets the Ray to be stationary. That is, it will end as soon as it started. Can be useful for unit testing or for Rays that represent stationary particles.

If you utilize the `setStartingDirection()` method, you may also utilize `setMaxDistance()` to set the maximum distance that the `Ray` is allowed to travel. If it reaches this distance, it will be killed after execution of [RayKernels/index.md]. If the `Ray` was initialized using the `setStartingEndPoint()` method, you cannot set the maximum distance for said `Ray` because it was set internally to the straight-line distance from the start to the user-set end.

The generation of rays can easily become a very complicated task. When a `Ray` is added to the buffer to be traced, it must be on the processor that its starting element is on, or if on a processor boundary, on a neighboring processor to the starting element. It is recommended that you first see if the [RepeatableRayStudy.md] is sufficient for the generation of Rays for your use case.

#### Modifying a Ray Trajectory

It is possible to modify the trajectory of a `Ray` while it is being traced via [RayKernels/index.md] and [RayBCs/index.md]:

To modify the trajectory of a `Ray` mid trace, see:

- [RayKernels/index.md#changing-the-ray-trajectory] for changing a `Ray`'s trajectory in a [RayKernel](RayKernels/index.md)
- [RayBCs/index.md#changing-the-ray-trajectory] for changing a `Ray`'s trajectory in a [RayBC](RayBCs/index.md)

#### Using Ray Data

In its simplest form, `Ray` data is a vector of arbitrarily sized data and auxiliary data that lives on the `Ray` and remains until it is changed.

In order to ensure that said data is sized appropriately for the use case, a system exists to register the need for data in the [RayTracingStudy.md].
This guarantees that [RayTracingStudy.md] objects, all [RayBC](RayBCs/index.md) objects, and all [RayKernel](RayKernels/index.md) objects will have access to the data that they need on all `Ray`s that are traced. This registration devises an index into the `Ray` data and auxiliary data. For more information, see [RayTracingStudy.md#ray-data-registration].

With a specific data or auxiliary data index, the data are accessed using the `data()` and `auxData()` member variables on the `Ray`.

#### Getting a Ray

The [RayTracingStudy.md] has a "pool" of `Ray` objects available for use. This pool allows for previously-allocated `Ray` objects that are no longer in use to be reset and re-used without deallocating and allocating memory again. This pool is the *only* way to construct new `Ray` objects.

For more information on the pool, see [RayTracingStudy.md#ray-pool].

## userobjects

### ConeRayStudy


Rays are generated in directions by a product angular quadrature, in which the azimuthal directions are produced by Chebyshev quadrature and the polar directions are produced by Gauss-Legendre quadrature. In the 2D case, the full 3D quadrature is produced and projected into the 2D plane.

For example use and a further description, see [flashlight_source.md].




### RayTracingStudy

The `RayTracingStudy` is the base object for generating and tracing of [Rays](Ray.md) with the [Ray Tracing Module](ray_tracing/index.md). For information about the manipulation of [Rays](Ray.md) once they have began tracing, see [RayKernels/index.md] and [RayBCs/index.md].

The majority of the information presented here is for +advanced+ users only. The use of this module for simple cases like line sources (see [line_sources.md]) and line integrals (see [line_integrals.md]) utilize the [RepeatableRayStudy.md]. Please see [RepeatableRayStudy.md] first for a more general understanding. If the [RepeatableRayStudy.md] is not sufficient for your use case, please then reference the [RepeatableRayStudyBase.md] instead.

#### Execution Phases

The execution of the  `RayTracingStudy` is split up into two phases:

- [#generation] - The [Rays](Ray.md) to be traced are defined and moved into the buffer to be traced
- [#propagation] - The [Rays](Ray.md) are traced until completion

##### Generation

To use the `RayTracingStudy`, you are to derive from it and override the `generateRays()` method. Within `generateRays()`, you are to create [Rays](Ray.md) (using the [#ray-pool]), set their trajectories (for more information, see [Ray.md#defining-a-ray-trajectory]), set their data (if any, see [Ray.md#using-ray-data] for more information), and move them into the buffer to be traced with `moveRayToBuffer()` or `moveRaysToBuffer()`.

If you know in advance the number of [Rays](Ray.md) that you are adding to the buffer to be traced during generation, it is advised call `reserveRayBuffer()` with the number of [Rays](Ray.md) to be moved to the buffer +before+ moving them into the buffer.

##### Propagation

The Ray propagation phase traces the [Rays](Ray.md) that were added to the buffer to be traced. This is done internally by the `propagateRays()` method.

Note that additional [Ray.md] objects may be added to be traced during the propagation phase via [RayKernels/index.md] and [RayBCs/index.md]. For more information, see [RayKernels/index.md#creating-additional-rays] for creating a [Ray.md] within [RayKernels/index.md] and [RayBCs/index.md#creating-a-new-ray] for creating a [Ray.md] within [RayBCs/index.md].

#### Specialization

There are many methods that can be overridden in your derived class. A summary of such methods follows:

- `generateRays()` - +MUST+ override to define and move the [Rays](Ray.md) into the buffer to be traced (see [#generation])
- `preExecuteStudy()` - Called before [#generation]
- `postExecuteStudy()` - Called after [#propagation]
- `postOnSegment()` - Called after each segment of a [Ray.md]
- `onCompleteRay()` - Called when the trace of a [Ray.md] has ended
- `buildSegmentQuadrature()` Called to generate the 1D quadrature across a [Ray.md] segment

#### Helper Systems

The `RayTracingStudy` contains many systems that aid in the generation and manipulation of [Rays](Ray.md):

- [Ray Data Registration](#ray-data-registration): Registers indices into data and auxiliary data to be stored on each [Ray.md]
- [Ray Registration](#ray-registration): Registers names to be associated with each [Ray.md] and requires [RayBCs/index.md] and [RayKernels/index.md] to provide which [Rays](Ray.md) they are applied to
- [Ray Banking](#ray-banking): Banks [Rays](Ray.md) once they end to be accessed after tracing
- [Ray Pool](#ray-pool): A shared pool of [Rays](Ray.md) that allows for their reuse after they are called to be destructed
- [Side Normal Caching](#side-normal-caching): Generates and caches (for future use) outward normals for an element

##### Ray Data Registration

The data and auxiliary data associated with a [Ray.md] is stored on the [Ray.md] itself in the form of two `std::vector<RayData>` (`RayData` is typically a `Real`), which are accessed via `Ray::data()` and `Ray::auxData()`. A data registration system exists that allows for the study, [RayKernels/index.md], and [RayBCs/index.md] to request the data and auxiliary data that they need upon construction.

To register value(s), use the methods `registerRayData()` and `registerRayAuxData()`, which return either a single index or a vector of indices into the `Ray::data()` and `Ray::auxData()` vectors that you should utilize. If the same value is registered (uses the same name) within multiple objects, the same index will be returned.

For example, the [IntegralRayKernel.md] is the base object for [RayKernels/index.md] that integrate a field across a line (variables, materials, etc). In order to accumulate the integrated value, these kernels need a data value on the [Ray.md]. As such, they register the need for [Ray.md] data in the constructor and store the index for access:



While you can acquire [Rays](Ray.md) that do not necessarily have the data size set according to the registration using the [#ray-pool], any time the data is accessed on a [Ray.md] (via `Ray::data()` and `Ray::auxData()`), if it is not sized properly as required by the registration, it will be resized to the registered size with zeros.

##### Ray Registration

For cases in which only a few [Rays](Ray.md) are generated, it is beneficial to have a registration system that allows for the user to access a specific [Ray](Ray.md) by name instead of an ID. Specific examples are line sources (see [line_sources.md]) and line integrals (see [line_integrals.md]), which utilize the [RepeatableRayStudy.md].

The enabling and disabling of ray registration is handled by the `_use_ray_registration` private parameter, for which the default is true. When ray registration is enabled, all [RayKernels/index.md] and [RayBCs/index.md] +must+ have the parameter [!param](/RayKernels/NullRayKernel/rays) set, which identifies the [Rays](Ray.md) by name that said objects are executed on. When ray registration is disabled, the [!param](/RayKernels/NullRayKernel/rays) parameter cannot be used and [RayKernels/index.md] and [RayBCs/index.md] will be executed for +all+ [Rays](Ray.md).

When using [Ray.md] registration, each [Ray.md] must be constructed within the study using the `acquireRegisteredRay()` method, which takes as an argument the name for the [Ray.md]. For more information, see [#ray-pool].

The public methods `registeredRayID()` and `registeredRayName()` can be utilized to map a registered [Ray.md] name to its ID and an ID to its registered name, respectively.

##### Ray Banking

It is often useful to examine a [Ray.md] after it has completed tracing. An example use case is for obtaining the accumulated integral for a [Ray.md] that is integrating a field along a line (see [line_integrals.md] and [IntegralRayKernel.md]). Within line integrals, the [Ray.md] banks will be accessed to obtain the final accumulated value in a [Ray.md].

With the `_bank_rays_on_completion` private parameter set to true, all [Rays](Ray.md) that complete on a given processor are stored in the private member variable `_ray_bank`. This bank can be accessed through the `rayBank()` method or via `getBankedRay()`, which will return the [Ray.md] with the requested ID on the processor that ended the [Ray.md].

In addition, the methods `getBankedRayData()` and `getBankedRayAuxData()` are available to get a single data value from a [Ray.md] from the banks after it has completed. For these methods, the resulting value is replicated across all processors.

##### Ray Pool

For simulations with the [ray_tracing/index.md] that generate a significant number of [Ray.md] objects, it becomes advantageous to minimize the construction of new [Ray.md] objects. This is more important whenever the size of the data on the [Ray.md] is significant.

Because of this, construction [Ray.md] objects is handled via a shared pool. The pool ensures that, internally, any [Rays](Ray.md) that are no-longer used can be reset and used again without extraneous allocation. The construction of new [Rays](Ray.md) can only occur in three places:

- Within `generateRays()` in a study, to create [Rays](Ray.md) to be inserted into the buffer for tracing, via the `acquireRay{}()` methods (more discussion follows).
- Within `onSegment()` in [RayKernels/index.md], via the `acquireRay()` method.
- Within `onBoundary()` in [RayBCs/index.md], via the `acquireRay()` method.

Multiple methods exist for acquiring rays within the study, which are:

- `acquireRay()` - Acquires a [Ray.md] with a generated unique ID and with data sized according to the [#ray-registration].
- `acquireUnsizedRay()` - Acquires a [Ray.md] with a generated unique ID and data sized to zero. Note, whenever the unsized data is accessed within the [Ray.md], it will be automatically resized to ensure data consistency.
- `acquireReplicatedRay()` - Acquires a [Ray.md] with an ID that is replicated across all processors and with data sized according to the [#ray-registration]. This must be called on all processors at the same time.
- `acquireRegisteredRay()` - Acquires a [Ray.md] that is replicated across all processors with a given name and utilizes the [#ray-registration]. For example use, see [RepeatableRayStudy.md].
- `acquireCopiedRay()` - Acquires a [Ray.md] that is initialized from another [Ray.md]. This is the only acquire method that does not generate a new ID. For example use, see [RepeatableRayStudyBase.md].

[Ray.md] storage is wrapped as a `std::shared_ptr<Ray>`. The significance of using a `shared_ptr` is that the destructor is called when the use count reaches zero, that is, when nobody is holding onto the [Ray.md]. The internal tracing algorithm will decrease the use count for a traced [Ray.md] after it has completed tracing. That is, if no other shared ownership of the [Ray.md] exists, the use count will reach zero. This is why [#ray-banking] exists---the [Ray.md] bank will increase the use count of the [Ray.md] so that it is available for use after tracing and is not destructed.

As all [Rays](Ray.md) must be constructed using the shared pool, whenever the use count for a [Ray.md] goes to zero, the [Ray.md] will be returned to the pool for future use.

##### Side Normal Caching

There is often a need to obtain the outward normal for an element's side for many use cases of the [ray_tracing/index.md].

The `RayTracingStudy` can provide outward side normals for an element on the fly. It also caches the generated normal for future requests for the same side normal. This is accessed through the `getSideNormal()` method.

Note that the side normals obtained through this caching are evaluated at the side centroid. Therefore, if the element side is non-planar, the returned normal will be an approximation.

### RepeatableRayStudy


The `RepeatableRayStudy` is meant to be the primary [RayTracingStudy.md] to be used for the majority of use cases and is not meant to be derived from! It is "repeatable" because it works with adaptivity and multiple executions (transients, on residual/Jacobian evaluations, etc). It does not require the user to have any knowledge of how to generate rays or determine on which processor and element element rays need to start depending on their starting point.

#### Defining the Rays

The following parameters must first be set:

- [!param](/UserObjects/RepeatableRayStudy/names): A list of unique names to identify the rays being generated.
- [!param](/UserObjects/RepeatableRayStudy/start_points): A list of points that the rays should start from.

When using [RayKernels/index.md] and [RayBCs/index.md] with the `RepeatableRayStudy`, you must specify which rays the [RayKernels/index.md]/[RayBCs/index.md] are applied to via their own [!param](/UserObjects/RepeatableRayStudy/names) parameter. The names supplied to the [RayKernels/index.md] and [RayBCs/index.md] are the same as the names specified in your `RepeatableRayStudy`.

After setting these parameters, you must decide if you want to define the remainder of the trajectory by end points or by directions. +This decision is significant.+

Defining a Ray trajectory by end points (set with the [!param](/UserObjects/RepeatableRayStudy/end_points) parameter) is the recommended method for non-advanced cases. The rays will be traced until they reach the user-set end point. Example use cases of setting [Ray.md] trajectories via end points are line sources and line integrals, for which examples are found in [line_sources.md] and [line_integrals.md], respectively.

##### Defining By End Points

To define the remainder of the trajectory by end points, provide the points at which you want the rays to end in the [!param](/UserObjects/RepeatableRayStudy/end_points) parameter. When the [Ray.md] end points are set, internally the tracer will set the max distance of each [Ray.md] individually such that they all end at the straight-line distance between the provided start point and the provided end point.

[RayKernels/index.md] and [RayBCs/index.md] can still end the rays earlier along their trajectory, but they are guaranteed to end once they hit either their end point or possibly sooner if the study's global maximum ray distance (the [!param](/UserObjects/RepeatableRayStudy/ray_distance) parameter) is less than the distance from the start to end point.

Rays that are killed due to reaching their max distance (which is the case when they reach their end point) are killed before the execution of [RayBCs/index.md]. For example, if a [Ray.md] reaches its end point and said end point is on a boundary with [RayBCs/index.md], the [RayBCs/index.md] will not be executed on the [Ray.md].

Rays that have had their trajectory set via end points are not allowed to have their trajectories modified mid-trace via [RayKernels/index.md] or [RayBCs](RayBCs/index.md). For example, these rays cannot be reflected on boundaries via the [ReflectRayBC](ReflectRayBC.md). You must instead define rays by the [!param](/UserObjects/RepeatableRayStudy/directions) parameter if you want them to be able to have their trajectories changed mid-trace.

##### Defining By Directions (Advanced Use)

The definition of [Ray.md] trajectory is considered advanced use because the user is responsible for ending the [Ray.md] by one of the following four methods:

- Killing it with a [RayBC](RayBCs/index.md) (example: [KillRayBC.md]).
- Killing it with a [RayKernel](RayKernels/index.md).
- Setting a maximum distance that it is allowed to travel via the [!param](/UserObjects/RepeatableRayStudy/max_distances) parameter.
- Setting a maximum distance that all rays are allowed to travel via the [!param](/UserObjects/RepeatableRayStudy/ray_distance) parameter.

To define the trajectory by directions, provide the directions at which you want the rays to travel in the [!param](/UserObjects/RepeatableRayStudy/directions) parameter. These directions do not need to be normalized.

If the [Ray.md] intersects an external boundary and is not set to be killed and its trajectory is not changed, the tracer will error.

#### Setting Ray Data

For more advanced use, one can also register [Ray.md] data/auxiliary data and initialize it as desired. It is important that this is not necessary when using [RayKernels/index.md] that contribute to residuals or integrate along lines, as the [Ray.md] data management in those cases is handled under the hood.

  visible=Required Trajectory


### RepeatableRayStudyBase

The `RepeatableRayStudyBase` is a specialized [RayTracingStudy.md] that simplifies the [Ray.md] generation process. To describe how exactly it simplifies this process, we will describe the difficulties of [Ray.md] generation and how this study overcomes many of those issues.

The use of the `RepeatableRayStudyBase` is considered an +advanced+ use of the [ray_tracing/index.md]. Please consider the [RepeatableRayStudy.md] before using this object.

##### Finding a Ray's Starting Element

The [ray_tracing/index.md] requires that a [Ray.md] be on the processor that contains the element that it starts in when it is moved into the buffer to be traced. If one wants to only specify a set of starting points for rays, it becomes necessary to determine which elements said points are contained in and then to communicate ahead of time the [Ray.md] to the processor that owns each element.

The `RepeatableRayStudyBase` has an option that only requires the defined rays to have their starting points set. Internally, the rays will be "claimed" and communicated to the processor that owns their starting element based on the user-set starting points. In addition, the incoming side on said starting elements will be set (if any).

The "claiming" of rays after they are defined is controlled by the `_claim_after_define_rays` private parameter. An example of a study that uses this claiming is the [RepeatableRayStudy.md].

##### Tracing After Mesh Changes

In the case of mesh changes (for example, mesh adaptivity steps), the element that a [Ray.md] starts in may change, which may also result in a change of the processor that a [Ray.md] starts on.

The `RepeatableRayStudyBase` keeps a copy of the user-generated rays such that at any time the mesh changes, the information is available to trace rays with the same information (start point, direction, data, etc). Internally, when the mesh changes the `RepeatableRayStudyBase` will re-claim the users' rays to ensure that they are again on the correct processor with the correct starting elements.

#### Process

The process by which the `RepeatableRayStudyBase` generates rays follows:

1. [Define Rays](#define-rays) - Only done on the first execution of the study.
2. [Claim Rays](#claim-rays) - Done on the first execution of the study and after all mesh changes.
3. [Copy Rays](#copy-rays) - Done on every execution of the study.

##### Define Rays

The user-derived object will overload the `defineRays()` method. Upon first execution of the study, this method will be called. Within `defineRays()`, you are to create rays (see [Ray.md#defining-a-ray-trajectory]) and move them into the `_rays` member variable. This action by default is only performed once, when `generateRays()` is first called.

If you are defining rays that need to be "claimed", that is they are being defined with only their start points (and not starting elements or starting incoming sides), ensure that the `_claim_after_define_rays` parameter is set to `true`. When this parameter is `true`, it is assumed that the starting elements and starting incoming sides have not been set and that the rays need to be "claimed". After claiming, internally they will be placed on the correct processors with a starting element that contains their starting points.

If you are defining rays that:

- have their starting point set,
- have their starting element set (which contains the starting point),
- have their starting incoming sides set (if any - the rays can also start within an element),
- are filled into `_rays` on the processor that contains their respective starting elements,

then it is not necessary to utilize claiming. You would set the `_claim_after_define_rays` parameter to false.

Any [Ray.md] data or auxiliary data that is set at this point will also be used in any further executions of this study.

The other important parameter that can be changed is the `_define_rays_replicated` private parameter. If this parameter is true, the rays that are filled into `_rays` during `defineRays()` are replicated. That is, the same rays were filled into `_rays` across all processors. If `_claim_after_define_rays == false`, the `_define_rays_replicated` parameter is set to false regardless of the user's setting because it is not possible for rays that are on their correct processors with their correct starting elements to be replicated.

###### Example

For an example of the define process, see [RepeatableRayStudy.md]:


In this case, the rays defined during `defineRays()` are replicated across all processors. Their start points are set but the starting elements and starting incoming sides are not set, therefore claiming is required.

##### Claim Rays

Note that the actions that follow in this section are performed on the first execution of the study and thereafter only after each mesh change, because claiming afterwards is only needed when the mesh changes.

If the private parameter `_claim_after_define_rays == true`, the rays within `_rays` do not have their starting elements set and are not necessarily on the correct starting processor. The `_rays` are passed to the `ClaimRays` object and the result is `_local_rays` being filled with the rays that can be started in the local processor. This claiming is only performed in the first call of `generateRays()` and thereafter is only called after each mesh change to re-determine the starting elements and starting processors.

If the private parameter `_claim_after_define_rays == false`, the rays within `_rays` are already on their starting processor with the starting elements set. The `_rays` are then simply copied into `_local_rays`. Because all of the [Ray.md] objects are actually shared pointers (`std::shared_ptr<Ray>`), this copying process does not actually "copy" the rays, it just points to the same objects that are in `_rays`. This "copying" is seen as:


##### Copy Rays

In every execution of the study, all of the rays in `_local_rays` are copied and inserted into the buffer to be traced. An actual copy takes place here - we want the rays within `_local_rays` to always be valid so that on later executions of the study, we can produce repeatable behavior in terms of the rays that are being traced.


## utils

### BoundingBoxIntersectionHelper

The `BoundingBoxIntersectionHelper` is a helper utility that computes the intersection of a line segment defined by a point and a direction and a `BoundingBox`.

### RayTracingAngularQuadrature


## vectorpostprocessors

### PerProcessorRayTracingResultsVectorPostprocessor


This object is particularly useful for quantifying load balance between processors when
using the [ray_tracing/index.md]. It pairs well with a [VectorPostprocessorVisualizationAux.md]
for visualization.

The non-advanced results that are available are as follows:

- `rays_started`: The number of rays started on a processor
- `rays_finished`: The number of rays finished (rays that end) on a processor
- `rays_received`: The number of rays received on a processor
- `rays_sent`: The number of rays sent from a processor
- `intersections`: The number of intersections encountered by all rays on a processor
- `generation_time`: The time spent in `generateRays()` on a processor
- `propagation_time`: The time spent in `propagateRays()` on a processor
- `ray_pool_created`: The number of rays created in the [RayTracingStudy.md#ray-pool] on a processor
- `face_hit`: The number of trace hits on faces on a processor
- `vertex_hit`: The number of trace hits on vertices on a processor
- `edge_hit`: The number of trace hits on edges on a processor
- `moved_through_neighbors`: The number of times a trace moves through neighbors on a processor
- `intersection_calls`: The number of times a trace has attempted to find an intersection on an element, on a processor
- `vertex_neighbor_builds`: The number of times the neighbor map for a vertex has been built on a processor
- `vertex_neighbor_lookups`: The number of times the neighbor map for a vertex has been looked up on a processor
- `edge_neighbor_builds`: The number of times the neighbor map for an edge has been built on a processor
- `edge_neighbor_lookups`: The number of times the neighbor map for an edge has been looked up on a processor
- `point_neighbor_builds`: The number of times a point neighbor lookup has been performed on a processor
- `failed_traces`: The number of allowed trace failures that have occurred on a processor




# rDG Module

The MOOSE rDG module is a library for the implementation of simulation tools that solve
convection-dominated problems using the class of so-called reconstructed discontinuous Galerkin (rDG)
methods. The specific rDG method implemented in this module is rDG(P0P1), which is equivalent to the
second-order cell-centered finite volume method (FVM). Cell-centered FVMs are regarded as a subset of
rDG methods in the case when the baseline polynomial solution in each element is a constant
monomial. The FVMs are the most widely used numerical methods in areas such as computational fluid
dynamics (CFD) and heat transfer, computational acoustics, and magnetohydrodynamics (MHD). This
module provides a systematic solution for implementing all required components in a second-order FVM
such as slope reconstruction, slope limiting, numerical flux, and proper boundary conditions.

To avoid ambiguity, the term "rDG" should be understood as "cell-centered FVM" in this module, and
these two terms are used interchangeably in the following text.

## The Advection Equation

To best help developers and/or users better understand the rDG method so that they can try to develop
new applications or use existing rDG-based codes, we use the advection equation (the simplest
convection-dominated system that we can think of) as an example to describe the implementation of
cell-centered FVM in MOOSE.

The advection equation for a conserved quantity described by a scalar field $\psi$ is expressed
mathematically by a continuity equation as

\begin{equation}
\label{eq:advection_equation}
\frac{\partial \psi}{\partial t} + \nabla\cdot(\psi{\bf v}) = 0,
\end{equation}
where $\nabla\cdot$ is the divergence operator, and ${\bf v}$ is the velocity field. If the flow is assumed to be incompressible, that is, the velocity field satisfies
\begin{equation}
\nabla\cdot{\bf v} = 0,
\end{equation}
the above equation can be rewritten as

\begin{equation}
\frac{\partial \psi}{\partial t} + {\bf v}\cdot\nabla(\psi) = 0.
\end{equation}

## Finite Volume Method

[eq:advection_equation] can be discretized in space using a cell-centered FVM. In an FVM,
the computational domain $\Omega$ is divided by a set of non-overlapping control volumes $\Omega_i$,
which can be one or a combination of the most common element types, e.g. line segment in 1D,
triangles and quadrilaterals in 2D, and tetrahedra, prisms, pyramids, and hexahedra in 3D. On each
control volume, the integral form of the governing equations is required to be satisfied,
\begin{equation}
\label{eq:fvm_integral}
  \int_{\Omega_i}\frac{\partial\psi}{\partial t}~{\rm d}V
+ \int_{\Omega_i}\nabla\cdot(\psi{\bf v})~{\rm d}V
= 0.
\end{equation}
The cell-averaged conservative variable, $\psi_i$, is taken to be the unknown and defined by
\begin{equation}
\psi_i = \frac{1}{V_i}\int_{\Omega_i}\psi~{\rm d}V
\end{equation}
where $V_i$ is the volume of the control volume $\Omega_i$. The following equation can then be
derived using the divergence theorem,
\begin{equation}
\label{eq:fvm_divergence_theorem_bc}
  V_i\frac{{\rm d}\psi_i}{{\rm d}t}
+ \sum_{j \in N_i}\int_{\Gamma_{ij}}(\psi_{ij}{\bf v}_{ij})\cdot{\bf n}_{ij}~{\rm d}S
+ \sum_{\Gamma_{ib} \in \partial\Omega}\int_{\Gamma_{ib}}(\psi_{ib}{\bf v}_{ib})\cdot{\bf n}_{ib}~{\rm d}S
= 0,
\end{equation}
where $\Gamma_{ij}=\partial\Omega_i\cap\partial\Omega_j$ denotes an interior common face between cell
$\Omega_i$ and $\Omega_j$, $\Gamma_{ib}=\partial\Omega_i\cap\partial\Omega$ denotes a face on the
boundary of domain $\Omega$; and ${\bf n}_{ij}$ and ${\bf n}_{ib}$ are the unit vectors normal to
face $\Gamma_{ij}$ and $\Gamma_{ib}$, respectively.  For each cell $\Omega_i$, $N_i$ represents a set
of neighboring cells, $\Omega_j$, sharing a common face, $\Gamma_{ij}$.

Because the numerical solution is discontinuous between cell interfaces, the interface fluxes are not
uniquely defined.  The flux, $(\psi_{ij}{\bf v}_{ij})\cdot{\bf n}_{ij}$, appearing in the second term
of [eq:fvm_divergence_theorem_bc] should be replaced by a numerical flux function
$\mathcal{H}(\psi_{ij}, \psi_{ji}, {\bf n}_{ij})$, i.e.,
\begin{equation}
\mathcal{H}(\psi_{ij}, \psi_{ji}, {\bf n}_{ij}) \approx (\psi_{ij}{\bf v}_{ij})\cdot{\bf n}_{ij},
\end{equation}
where $\psi_{ij}$ and $\psi_{ji}$ are the conservative variable at the "left" and "right" side of the
cell interface ($i < j$).  In the case of first-order FVM, the solution in each cell is assumed to be
constant in space.  Then on any interior face, $\Gamma_{ij}$, the two states are simply $\psi_{ij} =
\psi_i$ and $\psi_{ji} = \psi_j$.  In order to guarantee consistency and conservation,
$\mathcal{H}(\psi_{ij}, \psi_{ji}, {\bf n}_{ij})$ is required to satisfy

\begin{equation}
\mathcal{H}(\psi_{ij}, \psi_{ij}, {\bf n}_{ij}) = ({\bf v}_{ij}\cdot{\bf n}_{ij})\psi_{ij}
\end{equation}
and
\begin{equation}
\mathcal{H}(\psi_{ij}, \psi_{ji}, {\bf n}_{ij}) = -\mathcal{H}(\psi_{ji}, \psi_{ij}, {\bf n}_{ij}).
\end{equation}

Similarly, the flux function on the domain boundary, $(\psi_{ib}{\bf v}_{ib})\cdot{\bf n}_{ib}$,
should be determined by $\mathcal{H}(\psi_{ib}, \psi_b, {\bf n}_{ib})$, i.e.,
\begin{equation}
\mathcal{H}(\psi_{ib}, \psi_b, {\bf n}_{ib}) \approx (\psi_{ib}{\bf v}_{ib})\cdot{\bf n}_{ib},
\end{equation}
with the use of appropriate boundary conditions satisfying the characteristic theory.

Finally, the boundary integration in [eq:fvm_divergence_theorem_bc] is approximated using
one point quadrature at the midpoint of the face, and the semi-discrete form of the equations may be
written as
\begin{equation}
\label{eq:fvm_semi_discrete}
  V_i\frac{{\rm d}{\psi_i}}{{\rm d}t}
+ \sum_{j \in N_i}\mathcal{H}(\psi_{ij}, \psi_{ji}, {\bf n}_{ij})S_{ij}
+ \sum_{\Gamma_{ib} \in \partial\Omega}\mathcal{H}_b(\psi_{ib}, \psi_b, {\bf n}_{ib})S_{ib}
= 0,
\end{equation}
where $S_{ij}$ is the length of cell edge in 2D, and area of cell face in 3D.

By assembling all the elemental contributions, a system of ordinary differential equations
governing the evolution of the discrete solution in time can be written as
\begin{equation}
{\bf{\it M}}\frac{{\rm d}\psi}{{\rm d}t} = -{\bf R}(\psi),
\end{equation}
where $\bf{\it M}$ denotes the mass matrix, $\bf W$ is the global vector of the degrees of freedom,
and ${\bf R}(\psi)$ is the residual vector.  $\bf{\it M}$ has a block diagonal structure that couples
the degrees of freedom of the unknown vector associated to $\psi_i$ only within $\Omega_i$.  As a
result, the inverse of $\bf{\it M}$ can be easily computed in advance considering one cell at a time.

## Numerical Flux Scheme

In the example of advection equation, the flux function is approximated using the upwind scheme, i.e.,
\begin{equation}
\mathcal{H}(\psi_{ij}, \psi_{ji}, {\bf n}_{ij}) = a^+\psi_i + a^-\psi_j,
\end{equation}
where
\begin{equation}
a^+ = \frac{1}{2}(v^{\perp}_{ij} + |v^{\perp}_{ij}|)
\end{equation}
and
\begin{equation}
a^- = \frac{1}{2}(v^{\perp}_{ji} - |v^{\perp}_{ji}|),
\end{equation}
where
\begin{equation}
v^{\perp}_{ij} = {\bf v}_{ij}\cdot{\bf n}_{ij}
\end{equation}
and
\begin{equation}
v^{\perp}_{ji} = {\bf v}_{ji}\cdot{\bf n}_{ij}.
\end{equation}

## TVD Slope Limiters

First-order FVMs are in general stable on arbitrary grids.  However, second-order FVMs based on
piecewise linear reconstruction suffer from non-physical oscillations in the vicinity of strong
discontinuities for convection-dominant flows.  One common approach to address this issue is an
appropriate slope limiter.  Slope limiters are widely used in FVMs to modify the piecewise linearly
reconstructed gradients of solution variables, and thus to satisfy the total-variational diminishing
(TVD) condition.

In MOOSE, implementation of the TVD slope limiters is possible on 1D unstructured grids, because it
is trivial to know the indices of the "left" and "right" neighboring elements of the $i$-th element,
i.e., $i-1$ and $i+1$, during a loop over the elements.  The three classical slope limiters
implemented in the example of advection equation are described below.

### Minmod Slope Limiter

One choice of slope that gives second-order accuracy for smooth solutions while still satisfying the TVD property is the *minmod slope*
\begin{equation}
\phi_i = {\rm minmod}
\left(
\frac{\psi_i-\psi_{i-1}}{\Delta x},
\frac{\psi_{i+1}-\psi_i}{\Delta x}
\right)
\end{equation}
where the minmod function of two arguments is defined by
\begin{equation}
{\rm minmod}(a, b) =
\begin{cases}
a & \text{ if } |a| < |b| \text{ and } ab>0,\\
b & \text{ if } |b| < |a| \text{ and } ab>0,\\
0 & \text{ if } ab \le 0.
\end{cases}
\end{equation}
If $a$ and $b$ have the same sign, then this selects the one that is smaller in modulus, else it
returns zero.

Rather than defining the slope on the $i$-th cell by always using the downwind difference (which
would give the Lax-Wendroff method), or by always using the upwind difference (which would give the
Beam-Warming method), the minmod method compares the two slopes and chooses the one that is smaller
in magnitude. If the two slopes have different sign, then the value $\psi_i$ must be a local maximum
or minimum, and it is easy to check in this case that we must set $\phi_i = 0$ in order to satisfy
the TVD condition. The minmod method does a fairly good job of maintaining good accuracy in the
smooth hump and also sharp discontinuities in the square wave, with no oscillations. Sharper
resolution of discontinuities can be achieved with other limiters that do not reduce the slope as
severely as minmod near a discontinuity.

### Superbee Slope Limiter

One choice of limiter that gives the sharper reconstruction, while still giving second order accuracy
for smooth solutions, is the so-called *superbee* limiter introduced by [!cite](roe1985some):
\begin{equation}
\label{eq:superbee-limiter}
\phi_i={\rm maxmod}(\phi^{(1)}_i,\phi^{(2)}_i),
\end{equation}
where
\begin{equation}
\phi^{(1)}_i = {\rm minmod}
\left(
\frac{\psi_{i+1}-\psi_i}{\Delta x},
2\frac{\psi_i-\psi_{i-1}}{\Delta x}
\right)
\end{equation}
and
\begin{equation}
\phi^{(2)}_i = {\rm minmod}
\left(
2\frac{Q_{i+1}-Q_i}{\Delta x},
\frac{Q_i-Q_{i-1}}{\Delta x}
\right).
\begin{equation}
Each one-sided slope is compared with twice the opposite one-sided slope.  Then the maxmod function
in [eq:superbee-limiter] selects the argument with larger modulus.  In regions where the
solution is smooth this will tend to return the larger of the two one-sided slopes, but will still be
giving an approximation, and hence we expect second-order accuracy.  The superbee limiter is also TVD
in general.

With the superbee method, the discontinuity stays considerably sharper than with the minmod
method. On the other hand, there is a tendency of the smooth hump to become steeper and squared
off. This is sometimes a problem with superbee --- by choosing the larger of the neighboring slopes
it tends to steepen smooth transitions near inflection points.

### MC Slope Limiter

Another popular choice is the *monotonized central-difference limiter* (MC limiter), which was proposed by [!cite](van1977towards):
\begin{equation}
\label{eq:mc-limiter}
\phi_i = {\rm minmod}
\left(
\left(\frac{Q_{i+1}-Q_{i-1}}{2\Delta x}\right),
2\left(\frac{Q_i-Q_{i-1}}{\Delta x}\right),
2\left(\frac{Q_{i+1}-Q_i}{\Delta x}\right)
\right).
\end{equation}
This compares the central difference of Fromm method with twice the one-sided slope to either
side. In smooth regions this reduces to the centered slope of Fromm method and hence does not tend to
artificially steepen smooth slopes to the extent that superbee does. The MC limiter appears to be a
good default choice for a wide class of problems.

## Example Problem id=example

### Problem Description

In a test case validating the rDG implementation of the advection equation, the three slope limiters
introduced above are used for simulating a right-going square-shaped wave in 1D.  The initial
condition (I.C.) at $t=0$ contains contact discontinuities at $x=0.1$ and $x=0.6$.  For simplicity,
the wave speed is set to $1$.

       id=square_wave
       style=width:50%;margin-left:20px;float:right;
       caption=Time evolution of rDG solution for simulating a right-going square-shaped wave in 1D.g

### Numerical Results

To demonstrate the oscillation-free solution quality during wave propagation, an animation is
presented below.  In addition, the numerical results at $t=0.2$ are presented in [square_wave].

### Input File

The content of some input file blocks is described in detail for clarity.

#### GlobalParams

1. It is mandatory to declare `order = CONSTANT` and `family = MONOMIAL`, which specifies the
   piecewise cell-average solution variable for the cell-centered finite volume method.
2. It is convenient to provide some parameters for rDG-related objects used in an input file, such as
   `slope_reconstruction = rslope` and `slope_limiting = lslope` for *slope reconstruction* and
   *slope limiting*.
3. If an explicit time integration method is used, it is convenient to declare `implicit = false`
   here, so that Jacobian matrices will not be computed.


[GlobalParams]
order = CONSTANT
  family = MONOMIAL
  u = u
  slope_limiting = lslope
  implicit = false
[]


#### Mesh

[Mesh]
type = GeneratedMesh
  dim = 1
  xmin = 0
  xmax = 1
  nx = 100
[]


Notes:

1. A one-dimensional computational domain ranging between $x=0$ and $x=1$ is defined, with 100
   elements equally distributed in the domain.

#### Functions

[Functions]
[./ic_u]
    type = PiecewiseConstant
    axis = x
    direction = right
    xy_data = '0.1 0.5
               0.6 1.0
               1.0 0.5'
  [../]
[]


Notes:

1. In this case, a piecewise constant function is used to specify the initial condition of the
   square-shaped wave profile.

#### UserObjects

[UserObjects]
[./lslope]
    type = AEFVSlopeLimitingOneD
    execute_on = 'linear'
    scheme = 'none' #none | minmod | mc | superbee
  [../]

  [./internal_side_flux]
    type = AEFVUpwindInternalSideFlux
    execute_on = 'linear'
  [../]

  [./free_outflow_bc]
    type = AEFVFreeOutflowBoundaryFlux
    execute_on = 'linear'
  [../]
[]


Notes:

1. The prefix `AEFV` represents "Advection Equation Finite Volume" --- an abbreviation to uniquely
   name these classes.
2. `AEFVSlopeReconstructionOneD` does not do any work, but has to be in place for code
   consistency. In 1D the slope reconstruction and limiting can be accomplished in one user object.
3. `AEFVSlopeLimitingOneD` calculates the limited slope for each element in 1D.
4. `AEFVUpwindInternalSideFlux` calculates the internal side flux using a simple upwind scheme.
5. `AEFVFreeOutflowBoundaryFlux` calculates the boundary side flux using a free outflow BC.

#### Variables

[Variables]
[./u]
  [../]
[]


Notes:

1. Declare the nonlinear variable as `u`. The type and family of the variable have been declared in
  `GlobalParams` for convenience.

#### Kernels

[Kernels]
[./time_u]
    implicit = true
    type = TimeDerivative
    variable = u
  [../]
[]


Notes:

1. Always set `implicit = true` for time derivative kernels when using explicit time integration.
2. In FVMs, there is no volumetric integration for flux terms.
3. Other possible kernels in this block include source terms. In this example, we do not have any.

#### DGKernels

[DGKernels]
[./concentration]
    type = AEFVKernel
    variable = u
    component = 'concentration'
    flux = internal_side_flux
  [../]
[]


Notes:

1. Internal side flux terms should be declared in this block.

#### BCs

[BCs]
[./concentration]
    type = AEFVBC
    boundary = 'left right'
    variable = u
    component = 'concentration'
    flux = free_outflow_bc
  [../]
[]


Notes:

1. Boundary side flux terms should be declared in this block.

#### Materials

[Materials]
[./aefv]
    type = AEFVMaterial
    block = 0
  [../]
[]


Notes:

1. This block does not calculate actual material properties. It is used to trigger the calculation of slopes in every element, and then interpolate variable values at side centers.

## Reference


## bcs

### AEFVBC





## dgkernels

### AEFVKernel





## materials

### AEFVMaterial





## postprocessors

### RDGBoundaryFluxPostprocessor


This post-processor is used to query flux vectors that are computed via
objects derived from `BoundaryFluxBase` (in the RDG module). It computes the side integral of the
specified entry of the flux at a specified boundary.

This post-processor is useful for conservation tests because the inflow and
outflow fluxes for a domain can be integrated. Note that in this case, one still
needs to integrate the post-processor over time; this is done with the
[TimeIntegratedPostprocessor](/TimeIntegratedPostprocessor.md) post-processor.




## userobjects

### AEFVFreeOutflowBoundaryFlux





### AEFVSlopeLimitingOneD





### AEFVUpwindInternalSideFlux





# Reactor Module

## Overview

This `reactor` module aims to add advanced meshing capabilities to MOOSE so that users can create complex-geometry meshes that are related to reactors without turning to external meshing software.

This module consists of a series of new mesh generators to enable meshing of reactor cores including both hexagonal and Cartesian geometries. The functionalities of these mesh generators cover:

- Creating unit hexagon meshes as basic components for the core (other polygon meshes can also be created);
- Stitching the unit hexagon meshes and adding appropriate peripheral regions to form hexagon assembly regions;
- Creating unit hexagon meshes with adaptive external boundaries that are stitch-able with assembly meshes;
- Stitching the assembly meshes and adaptive-boundary unit hexagon meshes to form a core mesh;
- Modifying unit hexagon meshes to create azimuthal section blocks to enable static simulation of rotational control drum;
- Adding reporting IDs (extra element integers) to mesh elements to identify pins, assemblies regions;
- Adding a peripheral region to a given input mesh to produce a mesh with a circular external boundary.

Aside from the mesh generators, this `reactor` module also includes a Function object to enable dynamic simulation of rotational control drums in a reactor core mesh.

## Tutorial

This module is demonstrated in detail in the [MOOSE Reactor Module Meshing Tutorial](https://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial04_meshing/index.html).

## Objects and Syntax


## functions

### MultiControlDrumFunction


#### Overview

`MultiControlDrumFunction` is a Function object that assigns values for the absorber volume fraction. This is useful for simulating control drums rotation during power transients. It must be used with a mesh generated by [`PatternedHexMeshGenerator`](/PatternedHexMeshGenerator.md) so as to get access to the essential `MeshMetaData`. This `MultiControlDrumFunction` is capable of handling multiple control drums within a single mesh.

#### Principles

A control drum is a common reactivity control approach. It usually has a cylindrical geometry with an outer ring containing both absorber (yellow) and reflector (blue) sections (see [Figure 1](#control_drum)). Using this `MultiControlDrumFunction` object, the rotation of the absorber section can be simulated. The entire ring needs to be a single block, while this Function object creates a time and space dependent function to represent the volume percentage of the absorber in this ring block. The function is supposed to work with either [`FunctionAux`](/FunctionAux.md) to assign value to an elemental auxiliary variable, or [`GenericFunctionMaterial`](/GenericFunctionMaterial.md) to assign value to a material property. There are three possible scenarios:

- If the entire mesh element is within the absorber section, the function value is 100 (percent absorber);
- If the entire mesh element is within the reflector section, the function value is 0 (percent absorber);
- If the mesh element is intercepted by the absorber-reflector boundary, the function value is between 0 and 100 and equal to the volume percentage of the absorber part in that mesh element.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=schematic
      caption=A schematic drawing showing a typical control drum structure and important parameters of this `MultiControlDrumFunction` object.

#### Key Parameters

To simulate the rotation of the control drums, a set of parameters are needed for each control drum (see [Figure 1](#control_drum)):

- [!param](/Functions/MultiControlDrumFunction/start_angles): the azimuthal angles of the starting positions of the absorber sections at the beginning of rotation;
- [!param](/Functions/MultiControlDrumFunction/angle_ranges): the azimuthal angle ranges of the absorber sections;
- [!param](/Functions/MultiControlDrumFunction/angular_speeds): the rotation speeds of the control drums in degree per second (positive values mean counterclockwise rotation; negative values mean clockwise rotation.)

By default, rotation of the control drums starts at t = 0 and never ends. Optionally, users can set up [!param](/Functions/MultiControlDrumFunction/rotation_start_time) and [!param](/Functions/MultiControlDrumFunction/rotation_end_time) to customize the control drums rotation time.

When [!param](/Functions/MultiControlDrumFunction/use_control_drum_id) is true, this `MultiControlDrumFunction` can also use the element extra integer `control_drum_id` in the mesh to determine the domain of each control drum. Please refer to [`PatternedHexMeshGenerator`](/PatternedHexMeshGenerator.md) for details on how `control_drum_id`'s are assigned. If [!param](/Functions/MultiControlDrumFunction/use_control_drum_id) is false, the domain of each control drum is determined based on the nearest control drum position.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=multi_drums
      caption=An example of control drums simulated by this `MultiControlDrumFunction` object (see [input file](modules/reactor/test/tests/functions/multi_control_drum_function/multi_cd.i) here).

#### Example Syntax





## meshdivisions

### HexagonalGridDivision


Points that lie outside the hexagonal grid may be assigned to the grid outer bins
using the [!param](/MeshDivisions/HexagonalGridDivision/assign_domain_outside_grid_to_border)
parameter. This is the current treatment for background/duct regions around hexagonal pins in
an assembly.

Using a [Positions](syntax/Positions/index.md) object as the [!param](/MeshDivisions/HexagonalGridDivision/center_positions)
parameter, multiple hexagonal grids can be created around each position computed by that object. The division index
of a point is then:

\text{division index} = (i - 1) N_{\text{single division}} + \text{division index in hexagonal grid centered around position i}

with $i$ the index in the `Positions` object of the position nearest from the point and $N_{\text{single division}}$ the number of divisions for a single hexagonal grid, based on the number of rings and axial discretization specified.

For points lying within the standard tolerance of an internal boundary of the hexagonal grid, this object
will output a warning. If you do not mind the indetermination on which bins they belong to but do mind
that a warning is output, please reach out to a MOOSE (or any MOOSE app) developer.




## meshgenerators

### AdvancedConcentricCircleGenerator


#### Overview

`AdvancedConcentricCircleGenerator` generates concentric circular meshes that are similar to the output of [`PolygonConcentricCircleMeshGenerator`](PolygonConcentricCircleMeshGenerator.md) but without background and duct regions. While all the features of `PolygonConcentricCircleMeshGenerator` involving the concentric circular "ring" regions are preserved, this mesh generator has some unique features because of the absence of the polygon outer regions. The mesh generator can generate meshes with either linear or quadratic elements, which is controlled by the [!param](/Mesh/AdvancedConcentricCircleGenerator/tri_element_type) and [!param](/Mesh/AdvancedConcentricCircleGenerator/quad_element_type) parameters.

##### Azimuthal Mesh Density

By default, the azimuthal intervals are uniform and a single parameter [!param](/Mesh/AdvancedConcentricCircleGenerator/num_sectors) is used to define the total number of the azimuthal intervals.

Users can alternatively provide a list of ascending azimuthal angles between 0 to 360$^{\circ}$ through [!param](/Mesh/AdvancedConcentricCircleGenerator/customized_azimuthal_angles), which correspond to node angular positions of the generated mesh. Any azimuthal interval widths less than 120$^{\circ}$ are supported.

Due to the extra flexibility in azimuthal mesh density, the central elements have to be triangular.

#### Example Syntax


      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=accg_uniform
      caption=An example output of `AdvancedConcentricCircleGenerator` with (8) uniform azimuthal sectors.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=accg_azi
      caption=An example output of `AdvancedConcentricCircleGenerator` with (8) customized azimuthal sectors.




### AssemblyMeshGenerator


#### Overview

This object is designed to be used in the Reactor MeshGenerator workflow, which also consists of [`ReactorMeshParams`](ReactorMeshParams.md), [`PinMeshGenerator`](PinMeshGenerator.md), [`ControlDrumMeshGenerator`](ControlDrumMeshGenerator.md), and [`CoreMeshGenerator`](CoreMeshGenerator.md).

The `AssemblyMeshGenerator` object generates assembly reactor geometry structures in either square or hexagonal geometries using component pin cell meshes from the [`PinMeshGenerator`](PinMeshGenerator.md) in [!param](/Mesh/AssemblyMeshGenerator/inputs). The component pin cell meshes are tagged with pin cell `reporting ID` values according to their location in the assembly grid. Any newly created regions such as ducts are given block ID assignments.

This object automates the use and functionality of the [`PatternedCartesianMeshGenerator`](PatternedCartesianMeshGenerator.md) for cartesian  reactor geometry, [`PatternedHexMeshGenerator`](PatternedHexMeshGenerator.md) for hexagonal reactor geometry and, if extruding to three dimensions, the [`AdvancedExtruderGenerator'](AdvancedExtruderGenerator.md) through the use of the `MeshSubgenerator` functionality and supporting functionality from [`RenameBoundaryGenerator`](RenameBoundaryGenerator.md) and [`PlaneIDMeshGenerator'](PlaneIDMeshGenerator.md). In addition to the functionality of the `MeshGenerators` used, this object also automates block ID assignment for background and duct regions and boundary ID and name assignment.

The `AssemblyMeshGenerator` object adopts much of the existing input structure of patterned MeshGenerators but uses parameters that are more typical for reactor design. Since `AssemblyMeshGenerator` requires an input lattice structure to be defined, users that require homogenized assembly definitions or assemblies with single pins should define this structure with [`PinMeshGenerator'](PinMeshGenerator.md) and set [!param](/Mesh/PinMeshGenerator/use_as_assembly) to true. The resulting mesh will be tagged with the extra element IDs, block names, and outer boundaries in a similar manner to `AssemblyMeshGenerator`, and can be inputted directly to [`CoreMeshGenerator'](CoreMeshGenerator.md)`.

#### Region ID, Block ID, and Block Name Information

The [!param](/Mesh/AssemblyMeshGenerator/background_region_id) and [!param](/Mesh/AssemblyMeshGenerator/duct_region_ids) parameters are used to identify regions within the assembly around the lattice of fuel pins. This functionality is intended for easy identification of regions within the mesh that will have the same properties, such as material assignments, and this region ID will be assigned as an extra element integer.

The user defined ID assignment using [!param](/Mesh/AssemblyMeshGenerator/background_region_id) is given as a 1-D vector of size `A`, where `A` is the number of axial levels. This vector defines the background block IDs (single value per axial layer) starting from the bottom axial layer and ending with the top axial layer. Similarly, [!param](/Mesh/AssemblyMeshGenerator/duct_region_ids) is given as an `A` by `D` vector, where `D` is the number of duct intervals per axial layer. This vector assignment starts from the innermost duct region of the bottom axial layer, and extends out first radially and then axially.

For ease of use, block ids are generated automatically by the mesh generator, and for users who require element identification by block name, the optional parameters [!param](/Mesh/AssemblyMeshGenerator/background_block_name) and [!param](/Mesh/AssemblyMeshGenerator/duct_block_names) can be defined to set block names for the assembly background and duct regions respectively. In that case, each block name will be prepended with the prefix `RGMB_ASSEMBLY<assembly_type_id>_`, where `<assembly_type_id>` is the assembly ID provided by the user through [!param](/Mesh/AssemblyMeshGenerator/assembly_type). If not specified, the block names will be assigned automatically as `RGMB_ASSEMBLY<assembly_type_id>` by default. If [ReactorMeshParams](ReactorMeshParams.md)/[!param](/Mesh/ReactorMeshParams/region_id_as_block_name) is set to `true`, the resulting elements will have the block name `RGMB_ASSEMBLY<assembly_type_id>_REG<region_id>`, where `<region_id>` is the region ID of the element. Note that [!param](/Mesh/ReactorMeshParams/region_id_as_block_name) should not be used in conjunction with [!param](/Mesh/AssemblyMeshGenerator/background_block_name) or [!param](/Mesh/AssemblyMeshGenerator/duct_block_names).

#### Reporting ID Information

As mentioned above, the `AssemblyMeshGenerator` object will tag all elements (that do not belong to one of the constituent pins) with the extra integer reporting ID named "region_id" with the value equal to the assembly region ID.

The `AssemblyMeshGenerator` object also automatically tags all elements in the mesh with the [!param](/Mesh/AssemblyMeshGenerator/assembly_type) using the extra_integer name "assembly_type_id" and, if extruded, elements in each axial layer are tagged the axial layers using the name "plane_id". The pins composing the assembly are also tagged via [`PatternedCartesianMeshGenerator`](PatternedCartesianMeshGenerator.md) or [`PatternedHexMeshGenerator`](PatternedHexMeshGenerator.md), using the "cell" assignment type, with the extra integer name "pin_id".

#### Depletion ID Information

The `AssemblyMeshGenerator` object can optionally assign a depletion ID, with the extra integer name "depletion_id", only if they are the final mesh generator.
The depletion ID generation option can be enabled by setting the  [!param](/Mesh/AssemblyMeshGenerator/generate_depletion_id) to true.
The level of detail needed for depletion zones is specified in the input parameter [!param](/Mesh/AssemblyMeshGenerator/depletion_id_type).
[!param](/Mesh/AssemblyMeshGenerator/depletion_id_type) can be either `pin` and `pin_type`.
All pins in the assembly have separate depletion ID values by setting [!param](/Mesh/AssemblyMeshGenerator/depletion_id_type) to `pin`.
By setting that option to `pin_type`, unique ID values are assigned to individual pin types in assemblies.

#### Exterior Boundary ID Information

The `AssemblyMeshGenerator` objects automatically assigns boundary information derived from the [!param](/Mesh/AssemblyMeshGenerator/assembly_type) parameter. The exterior assembly boundary is assigned the ID equal to 2000 + the assembly type ID and is named "outer_assembly_<assembly_type_id>" (for example an assembly with an assembly type ID of 1 will have a boundary ID of 2001 and boundary name of "outer_assembly_1").

If the assembly is extruded to three dimensions the top-most boundary ID must be assigned using [!param](/Mesh/ReactorMeshParams/top_boundary_id) and will have the name "top", while the bottom-most boundary must be assigned using [!param](/Mesh/ReactorMeshParams/bottom_boundary_id) and will have the name "bottom".

#### Metadata Information

Users may be interested in defining additional metadata to represent the reactor geometry and region IDs assigned to each geometry zone, which may be useful to users who want mesh geometry and composition information without having to inspect the generated mesh itself. The following metadata is defined on the assembly mesh:

- `assembly_type`: Value of type_id associated with assembly, equivalent to the input parameter [!param](/Mesh/AssemblyMeshGenerator/assembly_type)
- `pitch`: Assembly pitch, equivalent to the input parameter [!param](/Mesh/ReactorMeshParams/assembly_pitch)
- `is_single_pin`: Whether or not assembly mesh is represented by a single pin region or a lattice of pins, equivalent to the input parameter [!param](/Mesh/PinMeshGenerator/use_as_assembly).
- `duct_halfpitches`: Length of apothems defining the duct locations, equivalent to the input parameter [`AssemblyMeshGenerator`](AssemblyMeshGenerator.md)/[!param](/Mesh/AssemblyMeshGenerator/duct_halfpitch)
- `background_region_id`: 1-D vector of region_ids corresponding to axial zones of background regions of assembly mesh, equivalent to the input parameter [!param](/Mesh/AssemblyMeshGenerator/background_region_id).
- `duct_region_ids`: 2-D vector of region ids corresponding to radial and axial zones within duct regions of assembly mesh, equivalent to the input parameter [!param](/Mesh/AssemblyMeshGenerator/duct_region_ids). Inner indexing is radial zones, while outer index is axial zones.

If the assembly is represented as a single pin, the following metadata is also defined:

- `ring_radii`: Length of ring radii comprising of assembly region, equivalent to [`PinMeshGenerator`](PinMeshGenerator.md)/[!param](/Mesh/PinMeshGenerator/ring_radii).
- `ring_region_ids`: 2-D vector of region ids corresponding to radial and axial zones within ring regions of assembly mesh, corresponding to the ring-related region ids of the input parameter [`PinMeshGenerator`](PinMeshGenerator.md)/[!param](/Mesh/PinMeshGenerator/region_ids). Inner indexing is radial zones, while outer index is axial zones.
- `is_homogenized`: Whether or not assembly mesh is homogenized, equivalent to the input parameter [`PinMeshGenerator`](PinMeshGenerator.md)/[!param](/Mesh/PinMeshGenerator/homogenized)

If instead the assembly is represented as a lattice of pins, the following metadata is defined:

- `pin_names`: List of mesh generator names of constituent pins in lattice.
- `pin_lattice`: 2-D lattice of pins in assembly, where each location represents the 0-based index of the pin in the list of names under the `pin_names` metadata entry.

For each of the pins listed in `pin_names`, the pin-level metadata is also displayed when [!param](/Mesh/AssemblyMeshGenerator/show_rgmb_metadata) is set to true. A list of pin-level metadata that is defined on the assembly mesh can be found in [PinMeshGenerator](PinMeshGenerator.md).

In addition, the value of the `reactor_params_name` metadata can be used to retrieve global metadata defined by [ReactorMeshParams](ReactorMeshParams.md). Please refer to [ReactorMeshParams](ReactorMeshParams.md) to see a list of metadata defined by this mesh generator.

For applications where an output mesh does not need to be created and meshing routines can consist entirely of defining reactor-based metadata, the parameter `[Mesh]`/[!param](/Mesh/MeshGeneratorMesh/data_driven_generator) can be set to the mesh generator that would generate an output mesh from RGMB metadata.

#### Example Syntax


This is the resulting mesh block layout, where by default a single block is assigned to the triangular elements and another block is assigned to the quadrilateral elements:


This is the resulting "region_id" extra element integer layout, which was chosen by setting the region IDs for each of the constituent pins:





### AzimuthalBlockSplitGenerator


#### Overview

The `AzimuthalBlockSplitGenerator` object is used to modify a mesh generated by either [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md) or [`HexagonConcentricCircleAdaptiveBoundaryMeshGenerator`](/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator.md). The input mesh can consist of either linear elements or quadratic elements. This object divides each selected radial block in the original mesh into two azimuthal sections and moves the nodes to the exact azimuthal positions.

Multiple radial blocks, which are defined by [!param](/Mesh/AzimuthalBlockSplitGenerator/old_blocks), can be modified simultaneously. The azimuthal range of the new blocks is defined by [!param](/Mesh/AzimuthalBlockSplitGenerator/start_angle) and [!param](/Mesh/AzimuthalBlockSplitGenerator/angle_range) in degrees. The algorithm finds the nodes that have azimuthal angles closest to the given azimuthal range and moves them to the exact azimuthal positions. If the external block (i.e., the block that contains the external boundary of the mesh) is not selected to be modified, the nodes on the external boundary are not altered by this object to facilitate mesh stitching. On the other hand, if the external block is selected, the nodes on the external boundary are moved as well. See [Figure 1](#schematic) for more details.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=schematic
      caption=A schematic drawing showing the functionalities of this `AzimuthalBlockSplitGenerator` object.

As moving nodes in the azimuthal direction changes the volumes of the circular blocks, the volume preservation radius correction is made if [!param](/Mesh/AzimuthalBlockSplitGenerator/preserve_volumes) is set as true.

If the [!param](/Mesh/AzimuthalBlockSplitGenerator/input) mesh is generated by [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md) with [!param](/Mesh/PolygonConcentricCircleMeshGenerator/quad_center_elements) set as true, and if the block that contains these quadrilateral central elements is selected in [!param](/Mesh/AzimuthalBlockSplitGenerator/old_blocks), an error message is issued because no nodes in that block should be moved. The central pattern of quad elements is not designed to be arbitrarily modified to align its nodes with azimuthal sectors.

#### Example Syntax





### CartesianConcentricCircleAdaptiveBoundaryMeshGenerator


#### Overview

The `CartesianConcentricCircleAdaptiveBoundaryMeshGenerator` object generates a 2D mesh for concentric circles with a square enclosure with or without external ducts. It is similar to [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md) and the majority of the parameters and functionalities of this object are described in the documentation of [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md). The major unique feature of this object is that the [!param](/Mesh/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator/num_sectors_per_side) parameter will be overridden to enable stitching to another square mesh (provided via [!param](/Mesh/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator/meshes_to_adapt_to) to this object). This object therefore creates square meshes that can be directly stitched with square meshes generated by [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md) and [`PatternedCartesianMeshGenerator`](/PatternedCartesianMeshGenerator.md). This object only works for squares instead of general polygons.

##### More Information

In order to adapt the external boundary to match input meshes (typically generated by [`PatternedCartesianMeshGenerator`](/PatternedCartesianMeshGenerator.md)), two extra input parameters must be provided:

- [!param](/Mesh/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator/sides_to_adapt): a vector parameter that can include up to four elements which lists the reference square side numbers to adaptively mesh. These entries must be non-repeating integers from 0 to 3 (see [Figure 1](#schematic)). The square sides are indexed counterclockwise starting from the top side.
- [!param](/Mesh/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator/meshes_to_adapt_to): a vector parameter that includes the same number of elements as [!param](/Mesh/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator/sides_to_adapt). These elements are input square meshes whose boundary nodes will be queried and used to adaptively mesh a side of the square mesh being created. The input square meshes are generated by [`PatternedCartesianMeshGenerator`](/PatternedCartesianMeshGenerator.md) or [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md). Multiple meshes may be input, each one corresponding to the side index value specified in [!param](/Mesh/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator/sides_to_adapt). The same input mesh may be repeated multiple times.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=schematic
      caption=A schematic drawing showing the square side indices in `CartesianConcentricCircleAdaptiveBoundaryMeshGenerator` object.

The [!param](/Mesh/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator/square_size) provided here must be consistent with the [!param](/Mesh/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator/square_size) values of all the [!param](/Mesh/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator/meshes_to_adapt_to) generators.

The mesh generator can generate meshes with either linear or quadratic elements, which is controlled by the [!param](/Mesh/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator/tri_element_type) and [!param](/Mesh/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator/quad_element_type) parameters. The [!param](/Mesh/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator/meshes_to_adapt_to) must have the consistent element types for compatibility.

One major application of this object is to generate meshes for control drums. In that case, [!param](/Mesh/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator/is_control_drum) can be set as true so that corresponding `MeshMetaData` can be generated for future use with control drum related objects.

#### Example Syntax


Here, a simple square mesh stored in an Exodus file is used as the input of `CartesianConcentricCircleAdaptiveBoundaryMeshGenerator`. Only Side 0 of the generated mesh is set to adapt the input mesh (i.e., Side 2 of the input mesh), as shown in [Figure 2](#cart_adapt). Note that only Side 0 of the generated mesh matches the input mesh (Side 2).

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=cart_adapt
      caption=A schematic drawing showing the input and generated meshes of the example case.




### CartesianIDPatternedMeshGenerator


#### Overview

The `CartesianIDPatternedMeshGenerator` object generates a 2D Cartesian lattice mesh with `reporting ID` assignments.
This object inherits the functionality of the lattice mesh generator named [`PatternedMeshGenerator`](PatternedMeshGenerator.md) that stitches together Cartesian cells, and adds additional functionality to assign reporting IDs to lattice cells.
The object can be used successively on its own output mesh to add IDs on the pin and assembly levels, for example.

#### Reporting ID Information

The `CartesianIDPatternedMeshGenerator` object adopts the existing input structures of [`PatternedMeshGenerator`](PatternedMeshGenerator.md) for geometry building and uses additional keywords to control the reporting ID assignment.

A user can select an ID assignment scheme using [!param](/Mesh/CartesianIDPatternedMeshGenerator/assign_type), and the following schemes are currently available:

- `cell` (default):  Assign unique  IDs for each component in the lattice in sequential order.

- `pattern`:  Assign IDs based on the ID of the input tiles.

- `manual`: Assign IDs based on user-defined mapping defined in [!param](/Mesh/CartesianIDPatternedMeshGenerator/id_pattern).

The default numbering scheme starts at 0 in the upper left hand corner of the grid and increments by 1 as the grid is traversed left to right, top to bottom.
The name of the reporting ID is provided through [!param](/Mesh/CartesianIDPatternedMeshGenerator/id_name) depending on the hierarchical level of component.
For example, the reporting IDs for individual pins (`pin_id`) can be assigned when assemblies are built, because the IDs for pin level are uniquely determined from the pin arrangement within each assembly type.
The ID values themselves are stored as extra element integers on the mesh.
Similarly, the assembly reporting IDs (`assembly_id`) are assigned in the core construction process.


Certain regions can be excluded from being labeled with an ID, for example dummy regions that will later be deleted.
This can be accommodated by listing mesh objects in the [!param](/Mesh/CartesianIDPatternedMeshGenerator/exclude_id) input parameter.
IDs will not be assigned to these mesh objects.
Usage of this parameter is helpful to retain sequential numbering when dummy region are later deleted, or to only label areas of interest.

#### Example Syntax

In this example, the `CartesianIDPatternedMeshGenerator` is used to generate
a Cartesian assembly with pin reporting IDs (`pin_id`).






### CartesianMeshTrimmer


#### Overview

The `CartesianMeshTrimmer` object takes the square mesh generated by [`PatternedCartesianMeshGenerator`](/PatternedCartesianMeshGenerator.md) as [!param](/Mesh/CartesianMeshTrimmer/input) and trims off part of the mesh. The input mesh can also be `PatternedCartesianMeshGenerator`'s output processed by [`PeripheralRingMeshGenerator`](/PeripheralRingMeshGenerator.md) or [`PatternedCartesianPeripheralModifier`](/PatternedCartesianPeripheralModifier.md).

Two types of trimming can be performed by `CartesianMeshTrimmer`: +Peripheral Trimming+ and +Through-the-Center Trimming+, which will be introduced separately as follows.

      style=display: block;margin-left:auto;margin-right:auto;width:60%;
      id=cart_trimmer
      caption=A schematic drawing showing different trimming schemes for a cartesian mesh.

##### Peripheral Trimming

Peripheral trimming trims off peripheral region(s) of one or multiple sides of the input square assembly mesh. To be specific, for each side, half of the unit pin meshes are trimmed off, as shown by the purple lines in [cart_trimmer]. Each side of the square assembly is assigned an index as illustrated in [cart_trimmer]. Users can use [!param](/Mesh/CartesianMeshTrimmer/trim_peripheral_region) to set which sides need to be trimmed off (`1`) and which need to be retained (`0`). The setting [!param](/Mesh/CartesianMeshTrimmer/trim_peripheral_region) = "1 1 1 1"  trims off all the sides (full peripheral trimming) to create a square assembly mesh with half-pins on each of the external 4 boundaries. Partial peripheral trimming may be employed for practical applications to create peripheral assemblies in a core whose normal interior assembly units contain half-pins on the boundary. The mesh metadata generated by `PatternedCartesianMeshGenerator` are retained, with `pattern_pitch_meta` updated to take trimming into consideration. The output of this object can be assembled into a patterned lattice using  `PatternedCartesianMeshGenerator`.

##### Center Trimming

Center trimming removes azimuthal sectors from the input square assembly or core mesh. The mesh may be trimmed along lines of symmetry in the input mesh. Only certain square meshes are eligible to be trimmed by this object due to imposed symmetries (see Trimmability). Valid square input meshes may be trimmed at eight possible center trimming lines, indexed from 0 to 7 as the blue lines shown in [cart_trimmer]. Each unit azimuthal sector is 45$^{\circ}$. A practical application of center trimming is to reduce the domain size (and simulation scale) by leveraging symmetry through reflected boundary conditions. Therefore the largest possible output mesh after center trimming contains four consecutive azimuthal sectors (i.e., half of the input mesh), while the smallest possible output mesh has only one azimuthal sector (i.e., one eighth of the input mesh). This mesh trimmer object RETAINS any sectors which are included between the trimming line defined by [!param](/Mesh/CartesianMeshTrimmer/center_trim_starting_index) to the trimming line defined by [!param](/Mesh/CartesianMeshTrimmer/center_trim_ending_index) swept out in a counterclockwise direction. Other sectors are discarded.

#### Trimmability

In general, `CartesianMeshTrimmer` trims meshes generated by `PatternedCartesianMeshGenerator`. An assembly mesh consisting of patterned pin meshes has both peripheral and center trimmability; whereas a core mesh consisting of patterned assembly meshes only has center trimmability.  Two mesh metadata entries (`peripheral_trimmability` and `center_trimmability`) are created by `PatternedCartesianMeshGenerator` to tell `CartesianMeshTrimmer` which trimming options are valid. In the absence of these two meta data, `CartesianMeshTrimmer` will throw an incompatible error message.

In addition, `PeripheralRingMeshGenerator`, which applies quadrilateral peripheral cylinder mesh around an assembly or core, retain these two mesh meta data from the input mesh so that valid meshes generated by `PeripheralRingMeshGenerator` may also be trimmed. Similarly, assembly meshes modified by `PatternedCartesianPeripheralModifier` also have these meta data retained and are thus able to be trimmed by this generator.

#### Degenerate Quadrilateral Elements

When trimming a mesh, some elements may be located across the trimming line and thus need to be processed to ensure a smooth trimming boundary. Generic tools such as [`PlaneDeletionGenerator`](/PlaneDeletionGenerator.md) is capable of trimming meshes but leaves a zigzag trimming boundary in the presence of across-trimming-line elements.

To avoid this zig-zag boundary, `CartesianMeshTrimmer` adopts a post-trimming processing algorithm to smooth the trimming boundary. The algorithm moves the nodes of the across-trimming-line elements in the normal direction of the trimming line onto the trimming line. During this procedure, some elements may become zero volume and will be removed. More importantly, after node moving, some quadrilateral elements may have three co-linear vertices on the trimming line, which make the element degenerate. To fix this issue, these degenerate quadrilateral elements are converted into triangular elements. As triangular elements and quadrilateral elements cannot share a single subdomain id/name, new subdomains are created for any affected quadrilateral element subdomains. The subdomain ids of the new subdomains are decided by shifting the original subdomain ids by [!param](/Mesh/CartesianMeshTrimmer/tri_elem_subdomain_shift) (default shift value is the maximum subdomain id of the mesh), while the subdomain names of the new subdomains are created by appending [!param](/Mesh/CartesianMeshTrimmer/tri_elem_subdomain_name_suffix) after the original subdomain names.

#### Boundary Assignment

For peripheral trimming, the new boundary formed by the trimming operation is the new external boundary. Therefore, the boundary id defined by [!param](/Mesh/CartesianMeshTrimmer/external_boundary) is assigned to the new boundary. On the other hand, for center trimming, the new boundary formed by the trimming operation is a mirror boundary instead of an external boundary. Hence, the boundary id defined by [!param](/Mesh/CartesianMeshTrimmer/external_boundary) is NOT assigned to the new boundaries.

In addition, users can optionally use [!param](/Mesh/CartesianMeshTrimmer/peripheral_trimming_section_boundary) and [!param](/Mesh/CartesianMeshTrimmer/center_trimming_section_boundary) to assign additional boundary names to the new boundary.

#### Example Syntax





### CoarseMeshExtraElementIDGenerator


#### Overview

This mesh generator adds an extra element integer to an input mesh based on a coarse mesh.
The extra element integer of an element on the input mesh is assigned with the element ID of the coarse element containing the centroid of the fine element by default.
Users can use the [!param](/Mesh/CoarseMeshExtraElementIDGenerator/coarse_mesh_extra_element_id) parameter to use an extra element ID on the coarse mesh for the assignment instead of the default coarse element ID.
A reserved name *subdomain_id* can be used for [!param](/Mesh/CoarseMeshExtraElementIDGenerator/coarse_mesh_extra_element_id) for using the subdomain ID on the coarse mesh.
Users can optionally check if the fine mesh is embedded in the coarse mesh using the [!param](/Mesh/CoarseMeshExtraElementIDGenerator/enforce_mesh_embedding) parameter, i.e. every element on the fine mesh must be contained
within one and only one coarse element or a region by [!param](/Mesh/CoarseMeshExtraElementIDGenerator/coarse_mesh_extra_element_id) of the coarse mesh.
The extra element ID assignment can be restricted to subdomains in the fine mesh by specifying [!param](/Mesh/CoarseMeshExtraElementIDGenerator/subdomains). With this parameter, this mesh generator can be called multiple times with different coarse meshes. After the first assignment, subsequent IDs will be offset by the maximum ID found from previous calls.




### ControlDrumMeshGenerator


#### Overview

This object is designed to be used in the Reactor MeshGenerator workflow, which also consists of [ReactorMeshParams](ReactorMeshParams.md), [PinMeshGenerator](PinMeshGenerator.md), [AssemblyMeshGenerator](AssemblyMeshGenerator.md), and [CoreMeshGenerator](CoreMeshGenerator.md).

This object creates the target mesh by automating the use and functionality of the [AdvancedConcentricCircleGenerator](AdvancedConcentricCircleGenerator.md) and [FlexiblePatternGenerator](FlexiblePatternGenerator.md) mesh generators to build the 2-D geometry of the control drum region and, if extruding to three dimensions, the [AdvancedExtruderGenerator](AdvancedExtruderGenerator.md) through the use of the `MeshSubgenerator` functionality and supporting functionality from [PlaneIDMeshGenerator](PlaneIDMeshGenerator.md). In addition to the functionality of the `MeshGenerators` used, this object also automates block ID, boundary ID, and boundary name assignment for the output control drum mesh.

The `ControlDrumMeshGenerator` object generates control drum reactor geometry structures in either square or hexagonal geometries. These drum structures are created by defining two concentric rings, which creates an annular area that will be referred to as the 'drum region'. The area within the inner radius will be referred to as the 'inner drum' region, while the area outside of the outer radius will be regarded as the 'background' region. Optionally, the drum region can be sub-divided into two azimuthal sectors to distinguish the placement of the 'drum pad' region, which is commonly used in microreactor-type designs as a control mechanism to regulate the neutron absorption rate within the reactor core. A figure showing the relevant regions defined in `ControlDrumMeshGenerator` is shown in [cd_regions], where the left diagram represents the case with a drum pad explicitly defined, while the right diagram represents the case without a drum pad (i.e., the control drum is defined as a single region).


The inner and outer radius of the drum region are defined by setting [!param](/Mesh/ControlDrumMeshGenerator/drum_inner_radius) and [!param](/Mesh/ControlDrumMeshGenerator/drum_outer_radius), respectively. [!param](/Mesh/ControlDrumMeshGenerator/drum_inner_intervals) controls the number of radial mesh sub-intervals in the inner drum region, while [!param](/Mesh/ControlDrumMeshGenerator/drum_intervals) sets the number of radial mesh sub-intervals in the drum region. [!param](/Mesh/ControlDrumMeshGenerator/num_azimuthal_sectors) is used to define the number of azimuthal sectors to subdivide the drum region into, while [!param](/Mesh/ControlDrumMeshGenerator/pad_start_angle) and [!param](/Mesh/ControlDrumMeshGenerator/pad_end_angle) are used to set the start and end angles of the drum pad region, respectively. Here, angles start in the positive y direction and rotate clockwise, and the difference between the end and start angles cannot exceed 360 degrees. Additionally, the start angle needs to be defined between 0 and 360 degrees, and the end angle cannot exceed 720 degrees. Additionally, if the pad angles do not line up with the azimuthal discretization of the drum region, additional azimuthal nodes are defined to ensure that the pad region as defined by the pad start and end angles lines up exactly with the azimuthal discretization of the drum region.

In order to facilitate stitching of `ControlDrumMeshGenerator` objects in downstream core lattice patterning with [CoreMeshGenerator](CoreMeshGenerator.md), users must set [ReactorMeshParams](ReactorMeshParams.md)/[!param](/Mesh/ReactorMeshParams/flexible_assembly_stitching) to true to ensure that a fixed number of sectors are created at the boundary surfaces of the control drum mesh. The resulting mesh will be tagged with the extra element IDs, block names, and outer boundaries in a similar manner to `AssemblyMeshGenerator`, and can be inputted directly to [CoreMeshGenerator](CoreMeshGenerator.md).

#### Region ID, Block ID, and Block Name Information

The parameter [!param](/Mesh/ControlDrumMeshGenerator/region_ids) is used to identify regions within the control drum, and this functionality is intended for easy identification of regions within the mesh that will have the same properties, such as material assignments, and this region ID will be assigned as an extra element integer.

[!param](/Mesh/ControlDrumMeshGenerator/region_ids) is given as an `A` (inner) by `R` (outer) vector, where `A` is the number of axial layer (equal to 1 for 2-D meshes) and `R` is the number of radial intervals per axial layer. Here, `R` is equal to 4 for control drum meshes with explicit drum pads defined, where the radial region ID ordering follows (drum inner, drum pad, drum ex-pad, background) according to the left image in [cd_regions]. Similarly, when the drum pad angles are not defined, `R` equals 3 and follows the ordering (drum inner, drum, background), based on the right image in [cd_regions].

For ease of use, block ids are generated automatically by the mesh generator, and for users who require element identification by block name, the optional parameter [!param](/Mesh/ControlDrumMeshGenerator/block_names) can be defined to set block names for the control drum regions. In this case, the ordering and size of the block names should match those of [!param](/Mesh/ControlDrumMeshGenerator/region_ids), and each block name will be prepended with the prefix `RGMB_DRUM<assembly_type_id>_`, where `<assembly_type_id>` is the assembly ID provided by the user through [!param](/Mesh/ControlDrumMeshGenerator/assembly_type). If not specified, the block names will be assigned automatically as `RGMB_DRUM<assembly_type_id>` by default. If [ReactorMeshParams](ReactorMeshParams.md)/[!param](/Mesh/ReactorMeshParams/region_id_as_block_name) is set to `true`, the resulting elements will have the block name `RGMB_DRUM<assembly_type_id>_REG<region_id>`, where `<region_id>` is the region ID of the element. Note that [!param](/Mesh/ReactorMeshParams/region_id_as_block_name) should not be used in conjunction with [!param](/Mesh/ControlDrumMeshGenerator/block_names). Regardless of whether block names are provided or not, the suffix `_TRI` is automatically added to the block name for all triangular elements in the central pin mesh elements when "quad_center_elements" is set to false.

#### Reporting ID Information

As mentioned above, the `ControlDrumMeshGenerator` object will tag all elements (that do not belong to one of the constituent pins) with the extra integer reporting ID named "region_id" with the value equal to the drum region ID.

The `ControlDrumMeshGenerator` object also automatically tags all elements in the mesh with the [!param](/Mesh/ControlDrumMeshGenerator/assembly_type) using the extra_integer name "assembly_type_id" and, if extruded, elements in each axial layer are tagged the axial layers using the name "plane_id".

#### Depletion ID Information

The `ControlDrumMeshGenerator` object can optionally assign a depletion ID, with the extra integer name "depletion_id", only if it is the final mesh generator.
The depletion ID generation option can be enabled by setting the  [!param](/Mesh/ControlDrumMeshGenerator/generate_depletion_id) to true.
The level of detail needed for depletion zones is specified in the input parameter [!param](/Mesh/ControlDrumMeshGenerator/depletion_id_type) and must be set to `pin_type`, which will assign a unique depletion ID for each radial and axial zone of the drum.

#### Exterior Boundary ID Information

The `ControlDrumMeshGenerator` objects automatically assigns boundary information derived from the [!param](/Mesh/ControlDrumMeshGenerator/assembly_type) parameter. The exterior assembly boundary is assigned the ID equal to


+ the assembly type ID and is named "outer_assembly_<assembly_type_id>" (for example a control drum with an assembly type ID of 1 will have a boundary ID of 2001 and boundary name of "outer_assembly_1").

If the assembly is extruded to three dimensions the top-most boundary ID must be assigned using [!param](/Mesh/ReactorMeshParams/top_boundary_id) and will have the name "top", while the bottom-most boundary must be assigned using [!param](/Mesh/ReactorMeshParams/bottom_boundary_id) and will have the name "bottom".

#### Metadata Information

Users may be interested in defining additional metadata to represent the reactor geometry and region IDs assigned to each geometry zone, which may be useful to users who want mesh geometry and composition information without having to inspect the generated mesh itself. The following metadata is defined on the control drum mesh:

- `assembly_type`: Value of type_id associated with control drum, equivalent to the input parameter [!param](/Mesh/ControlDrumMeshGenerator/assembly_type)
- `pitch`: Assembly pitch, equivalent to the input parameter [!param](/Mesh/ReactorMeshParams/assembly_pitch)
- `is_control_drum`: Whether or not this mesh is a control drum, equal to true for all structures created by `ControlDrumMeshGenerator`.
- `drum_radii`: Vector of length two corresponding to the inner and outer radii of the drum region, controlled by [!param](/Mesh/ControlDrumMeshGenerator/drum_inner_radius) and [!param](/Mesh/ControlDrumMeshGenerator/drum_outer_radius), respectively.
- `drum_region_ids`: 2-D vector of region ids corresponding to radial and axial zones within control drum regions of assembly mesh, equivalent to the input parameter [!param](/Mesh/ControlDrumMeshGenerator/region_ids). Inner indexing is radial zones, while outer index is axial zones.

In addition, the value of the `reactor_params_name` metadata can be used to retrieve global metadata defined by [ReactorMeshParams](ReactorMeshParams.md). Please refer to [ReactorMeshParams](ReactorMeshParams.md) to see a list of metadata defined by this mesh generator.

For applications where an output mesh does not need to be created and meshing routines can consist entirely of defining reactor-based metadata, the parameter `[Mesh]`/[!param](/Mesh/MeshGeneratorMesh/data_driven_generator) can be set to the mesh generator that would generate an output mesh from RGMB metadata.

#### Example Syntax


If [!param](/Mesh/ControlDrumMeshGenerator/pad_start_angle) and [!param](/Mesh/ControlDrumMeshGenerator/pad_end_angle) are not provided, the drum region is discretized with the same region ID applied to all azimuthal drum elements. In this case, only 3 values per axial level should be provided in [!param](/Mesh/ControlDrumMeshGenerator/region_ids) (drum inner, drum, background). In order to calculate the volume fraction of the pad region, [`MultiControlDrumFunction`](/MultiControlDrumFunction.md) can be used.




### CoreMeshGenerator


#### Overview

This object is designed to be used in the Reactor MeshGenerator workflow, which also consists of [`ReactorMeshParams`](ReactorMeshParams.md), [`PinMeshGenerator`](PinMeshGenerator.md), [`AssemblyMeshGenerator`](AssemblyMeshGenerator.md), and [`ControlDrumMeshGenerator`](ControlDrumMeshGenerator.md).

The `CoreMeshGenerator` object generates core-like reactor geometry structures in either square or hexagonal geometries with block ID assignments and reporting (extra integer) IDs, as described in [`PatternedCartesianMeshGenerator`](PatternedCartesianMeshGenerator.md) and [`PatternedHexMeshGenerator`](PatternedHexMeshGenerator.md). There is expected to only be a single `CoreMeshGenerator` in a Mesh definition.

This object automates the use and functionality of the [`PatternedCartesianMeshGenerator`](PatternedCartesianMeshGenerator.md) for cartesian  reactor geometry, [`PatternedHexMeshGenerator`](PatternedHexMeshGenerator.md) for hexagonal reactor geometry and, if extruding to three dimensions, the [`AdvancedExtruderGenerator'](AdvancedExtruderGenerator.md) through the use of the `MeshSubgenerator` functionality and supporting functionality from [`RenameBoundaryGenerator`](RenameBoundaryGenerator.md) and [`PlaneIDMeshGenerator'](PlaneIDMeshGenerator.md). In addition to the functionality of the `MeshGenerators` used, this object also automates boundary ID and name assignment.

In addition to the functionality of [`PatternedCartesianMeshGenerator`](PatternedCartesianMeshGenerator.md) or [`PatternedHexMeshGenerator`](PatternedHexMeshGenerator.md), this object allows for the definition of "empty" lattice locations using `MeshSubgenerators`. This is achieved through the use of creating "dummy" assembly meshes via [`CartesianMeshGenerator`](CartesianMeshGenerator.md) or [`HexagonConcentricCircleAdaptiveBoundaryMeshGenerator`](HexagonConcentricCircleAdaptiveBoundaryMeshGenerator.md) respectively. These assemblies are then removed after the core mesh creation via [`BlockDeletionGenerator`](BlockDeletionGenerator.md). If assembly homogenization is leveraged by setting both [!param](/Mesh/PinMeshGenerator/use_as_assembly) and [!param](/Mesh/PinMeshGenerator/homogenized) to true, then all assemblies inputted to `CoreMeshGenerator` must be homogenized. Mixtures of heterogeneous and homogeneous assembly inputs to `CoreMeshGenerator` are not currently supported.

The `CoreMeshGenerator` object adopts much of the existing input structure of patterned MeshGenerators but also adapts to use parameters that are more accessible for reactor design.

#### Reporting ID Information

The `CoreMeshGenerator` object automatically tags the mesh, if three dimensional, with the axial layers using the extra integer name "plane_id". The assemblies composing the core are also tagged via [`PatternedCartesianMeshGenerator`](PatternedCartesianMeshGenerator.md) or [`PatternedHexMeshGenerator`](PatternedHexMeshGenerator.md), using the "cell" assignment type, with the extra integer name "assembly_id" and any "dummy" assembly (identified via the [!param](/Mesh/CoreMeshGenerator/dummy_assembly_name) parameter) locations excluded.

#### Depletion ID Information

The `CoreMeshGenerator` object can optionally assign a depletion ID, with the extra integer name "depletion_id".
The depletion ID generation option can be enabled by setting the  [!param](/Mesh/CoreMeshGenerator/generate_depletion_id) to true.
The level of detail needed for depletion zones is specified in the input parameter [!param](/Mesh/CoreMeshGenerator/depletion_id_type).
For a core with heterogeneous assemblies, [!param](/Mesh/CoreMeshGenerator/depletion_id_type) can be either `pin` and `pin_type`.
All pins in the core have separate depletion ID values by setting [!param](/Mesh/CoreMeshGenerator/depletion_id_type) to `pin`.
By setting that option to `pin_type`, unique ID values are assigned to individual pin types in assemblies.
However, pins in different assemblies have different depletion IDs even if they have the same type.
For a core with homogenized assemblies (no explicit pins), [!param](/Mesh/CoreMeshGenerator/depletion_id_type) can be either `assembly` and `assembly_type`, which assign unique ID values to individual assemblies or to individual assembly types, respectively.

#### Exterior Boundary ID Information

The `CoreMeshGenerator` objects automatically assigns boundary information. The exterior core boundary ID is assigned with the parameter [!param](/Mesh/ReactorMeshParams/radial_boundary_id) and will have the name "outer_core".

If the core is extruded to three dimensions the top-most boundary ID must be assigned using [!param](/Mesh/ReactorMeshParams/top_boundary_id) and will have the name "top", while the bottom-most boundary must be assigned using [!param](/Mesh/ReactorMeshParams/bottom_boundary_id) and will have the name "bottom".

#### Flexible Assembly Stitching

By default, `CoreMeshGenerator` will stitch assemblies created by [`AssemblyMeshGenerator`](AssemblyMeshGenerator.md) together without regard for the number and location of nodes at the exterior boundaries of the assemblies. This works if very similar assemblies are being stitched together. However, this will lead to an output core mesh with hanging nodes if dissimilar assemblies are being stitched together. The following situations are identified as scenarios where such hanging nodes can occur between stitched assemblies:

1. Two assemblies have the same constituent pin geometry but vary in total number of pins in the pin lattice
2. Two assemblies have the same pin lattice structure and geometry, but the constituent pins of each assembly are subdivided into a different number of sectors per side.
3. One assembly is defined as a heterogeneous mesh (contains one or more pins), and the other assembly is homogenized.

`CoreMeshGenerator` will throw a warning if it detects that assembly stitching may lead to hanging nodes. If this happens, the user can regenerate the core mesh by setting [ReactorMeshParams](ReactorMeshParams.md)/[!param](/Mesh/ReactorMeshParams/flexible_assembly_stitching) to `true` to enable flexible assembly stitching. This flexible assembly stitching algorithm deletes the outermost mesh interval and replaces it with a triangulated region using [`FlexiblePatternGenerator`](FlexiblePatternGenerator.md). For a homogeneous assembly, the entire assembly region is triangulated. By doing so, the number of nodes at the outer boundary of each input assembly will be identical and positioned at the same locations, thus enabling stitching of dissimilar assemblies. In order to control the number of sectors at the outer assembly boundary after the triangulation step, the user can set this parameter using [ReactorMeshParams](ReactorMeshParams.md)/[!param](/Mesh/ReactorMeshParams/num_sectors_at_flexible_boundary). If the core lattice consists of any structures created with [ControlDrumMeshGenerator](ControlDrumMeshGenerator.md), then [ReactorMeshParams](ReactorMeshParams.md)/[!param](/Mesh/ReactorMeshParams/flexible_assembly_stitching) must be set to `true`. The following three images describe how flexible assembly patterning can be used to address the issue of hanging nodes for the three cases listed above:




#### Metadata Information

Users may be interested in defining metadata to represent the reactor geometry and region IDs assigned to each geometry zone, which may be useful to users who want mesh geometry and composition information without having to inspect the generated mesh itself. At the core level, the following metadata is defined on the output mesh:

- `assembly_names`: Mesh generator names of input assemblies in lattice, similar to input parameter (/Mesh/CoreMeshGenerator/inputs) but with the dummy assembly name excluded
- `lattice`: 2-D lattice of assemblies in core, where each location represents the 0-based index of the assembly in the list of names under the `assembly_names` metadata entry. A -1 entry represents a dummy assembly.

For each of the assemblies listed in `assembly_names`, the assembly-level metadata is also displayed. In addition, if any of these assemblies are comprised of pins in a lattice, the pin-level metadata of these constituent pins is also displayed. A list of assembly-level and pin-level metadata defined on the core mesh can be found in [AssemblyMeshGenerator](AssemblyMeshGenerator.md) and [PinMeshGenerator](PinMeshGenerator.md) respectively.

For meshes where a core periphery is defined, the following metadata is also defined:

- `peripheral_ring_radius`: Outer radius of core periphery, equivalent to the input parameter [`CoreMeshGenerator`](CoreMeshGenerator.md)/[!param](/Mesh/CoreMeshGenerator/outer_circle_radius).
- `peripheral_ring_region_id`: Region ID associated with core periphery, equivalent to the input parameter [`CoreMeshGenerator`](CoreMeshGenerator.md)/[!param](/Mesh/CoreMeshGenerator/periphery_region_id).

In addition, the value of the metadata `reactor_params_name` can be used to retrieve global metadata defined by [ReactorMeshParams](ReactorMeshParams.md). Please refer to [ReactorMeshParams](ReactorMeshParams.md) to see a list of metadata defined by this mesh generator.

For applications where an output mesh does not need to be created and meshing routines can consist entirely of defining reactor-based metadata, the parameter `[Mesh]`/[!param](/Mesh/MeshGeneratorMesh/data_driven_generator) can be set to the mesh generator that would generate an output mesh from RGMB metadata.

#### Example Syntax


This is the resulting mesh block layout, where by default a single block is assigned to all of the quadrilateral elements in the mesh:


This is the resulting "region_id" extra element integer layout, which was chosen by setting the region IDs for each of the constituent pins and assemblies:


#### Periphery Mesh Generation

The `CoreMeshGenerator` includes support for meshing a circular reactor periphery surrounding the core. This integration supports using either [`PeripheralTriangleMeshGenerator`](PeripheralTriangleMeshGenerator.md) (PTMG) or [`PeripheralRingMeshGenerator`](PeripheralRingMeshGenerator.md) (PRMG), selected using the [!param](/Mesh/CoreMeshGenerator/periphery_generator) input option by specifying either `triangle` or `quad_ring`, respectively. The input options for these mesh generators are provided below, but more details on their meaning and usage can be found in their respective documentation pages. The generated periphery region is given the block name [!param](/Mesh/CoreMeshGenerator/periphery_block_name) (default `RGMB_CORE`) and extra integer reporting ID `region_id` [!param](/Mesh/CoreMeshGenerator/periphery_region_id), along with outer boundary name "outside_periphery". If [ReactorMeshParams](ReactorMeshParams.md)/[!param](/Mesh/ReactorMeshParams/region_id_as_block_name) is set to `true`, the resulting element will have the block name `RGMB_CORE_REG<region_id>`, where `<region_id>` is the region ID of the element. Note that [!param](/Mesh/ReactorMeshParams/region_id_as_block_name) should not be used in conjunction with [!param](/Mesh/CoreMeshGenerator/periphery_block_name).

#### Example Core Periphery Syntax


This is the resulting mesh block layout:





### DepletionIDGenerator


#### Overview

`DepletionIDGenerator` object generates and assigns depletion IDs (extra element integers) on a mesh by finding unique combinations of reporting and material IDs.
For a pin-level depletion case, the individual pins can be identified by the pin and assembly IDs, and the detailed depletion regions within a pin can be further divided by material IDs.
For assembly-wise depletion, the user can set up the depletion IDs by combining the assembly and material IDs.
Once the detailed depletion regions are determined, depletion IDs are uniquely assigned to those resulting regions.

#### Depletion ID Control

[!param](/Mesh/DepletionIDGenerator/id_name) lists extra element integer ID names used for setting up the depletion zones.
Note that the material ID does not need to be defined in the list because it is included by default.
A depletion zone (elements with the same depletion id) is always covered by one material region (elements with the same material id).
The level of details in depletion zones can be controlled by the extra element integer IDs defined in [!param](/Mesh/DepletionIDGenerator/id_name).
Any different combination of extra element integer IDs is considered a unique depletion zone.

For example, one can set up pin-by-pin and axial layer-by-layer arrangement of depletion zone by specifying those three reporting IDs: pin, assembly and plane IDs.

An alternative extra element integer ID name for the material ID can be optionally specified in [!param](/Mesh/DepletionIDGenerator/material_id_name). Its default value is set to  material_id.

A list of extra element integer ID can be provided in [!param](/Mesh/DepletionIDGenerator/exclude_id_name) and [!param](/Mesh/DepletionIDGenerator/exclude_id_value) to exclude certain domains from being assigned depletion IDs.
For those domains specified in [!param](/Mesh/DepletionIDGenerator/exclude_id_name) and [!param](/Mesh/DepletionIDGenerator/exclude_id_value), the depletion ID is set to zero because the depletion ID must be assigned for every mesh element even if not used in the actual depletion calculation.

#### Example Syntax





### ExtraElementIDCopyGenerator


#### Overview

The `ExtraElementIDCopyGenerator` is used to copy an extra element ID to other extra element IDs.
If the target extra element IDs do not exist in the input mesh, they will be added by this mesh generator before copying.
The extra element ID name *subdomain_id* is reserved for the subdomain ID and can be used as the name of the source extra element ID, but not as the target extra element ID.
The extra element ID name *element_id* is reserved for the element ID and can be used as the name of the source extra element ID, but not as the target extra element ID.




### FlexiblePatternGenerator


#### Overview

`FlexiblePatternGenerator` enhances the capabilities provided in [`PatternedHexMeshGenerator`](PatternedHexMeshGenerator.md) and [`PatternedCartesianMeshGenerator`](PatternedCartesianMeshGenerator.md) by providing more flexibility in both patterning and background shape. It can be used when the background shape is not a hexagon or square and/or when the pin pattern does not follow a hexagonal or cartesian grid.

#### Background Shape

Instead of the fixed hexagonal and cartesian background shapes provided respectively by `PatternedHexMeshGenerator` and `PatternedCartesianMeshGenerator`, `FlexiblePatternGenerator` allows adoption of a closed curve of any type, provided by [!param](/Mesh/FlexiblePatternGenerator/boundary_mesh), to be used as the external boundary of the background region, with [!param](/Mesh/FlexiblePatternGenerator/boundary_type) set as `CUSTOM`. The [!param](/Mesh/FlexiblePatternGenerator/boundary_mesh) needs to be a mesh containing a single closed curve that resides in the XY plane and consists of only `EDGE2` elements. Examples of such curve meshes include polygon curves generated by [`PolyLineMeshGenerator`](PolyLineMeshGenerator.md), more generalized curves generated by [`ParsedCurveGenerator`](ParsedCurveGenerator.md), and even externally generated curves through [`FileMeshGenerator`](FileMeshGenerator.md).

If a hexagonal, Cartesian, or circular external boundary are desired, [!param](/Mesh/FlexiblePatternGenerator/boundary_type) should be set as as `HEXAGON`, `CARTESIAN`, and `CIRCLE`, respectively. In that case, [!param](/Mesh/FlexiblePatternGenerator/boundary_size) and [!param](/Mesh/FlexiblePatternGenerator/boundary_sectors) also need to be specified. Users can also define a custom id and name for the external boundary by using [!param](/Mesh/FlexiblePatternGenerator/external_boundary_id) and [!param](/Mesh/FlexiblePatternGenerator/external_boundary_name), respectively. By default, the external boundary will be assigned the following ID to be compatible with other Reactor Module tools:


The background region is meshed by [`XYDelaunayGenerator`](XYDelaunayGenerator.md) through MOOSE's sub-meshgenerator capability. Some key parameters of `XYDelaunayGenerator` (e.g., [!param](/Mesh/FlexiblePatternGenerator/desired_area), [!param](/Mesh/FlexiblePatternGenerator/desired_area_func), [!param](/Mesh/FlexiblePatternGenerator/verify_holes), [!param](/Mesh/XYDelaunayGenerator/use_auto_area_func), [!param](/Mesh/XYDelaunayGenerator/auto_area_func_default_size), [!param](/Mesh/XYDelaunayGenerator/auto_area_func_default_size_dist), [!param](/Mesh/XYDelaunayGenerator/auto_area_function_num_points), and [!param](/Mesh/XYDelaunayGenerator/auto_area_function_power)) can be set here and then directly passed to `XYDelaunayGenerator`. The block id and names can be optionally specified through [!param](/Mesh/FlexiblePatternGenerator/background_subdomain_id) and [!param](/Mesh/FlexiblePatternGenerator/background_subdomain_name).

#### Patterning

Within the interior region defined by [!param](/Mesh/FlexiblePatternGenerator/boundary_mesh), `FlexiblePatternGenerator` can place single or multiple patterns of input unit meshes provided by [!param](/Mesh/FlexiblePatternGenerator/inputs). Supporting patterning mode includes hexagonal, rectangular, and circular geometry. In addition, free-style patterning is supported by directly providing positions of unit meshes. Styles of patterns can be combined as well when using multiple patterns.
The details are discussed as follows.

##### Hexagonal Patterning

One or several hexagonal patterns of input unit meshes can be generated. These patterns are provided by a triple-indexed input parameter [!param](/Mesh/FlexiblePatternGenerator/hex_patterns). Each element of [!param](/Mesh/FlexiblePatternGenerator/hex_patterns) follows the same format as the [!param](/Mesh/PatternedHexMeshGenerator/pattern) parameter in [`PatternedHexMeshGenerator`](PatternedHexMeshGenerator.md). The origin position of each pattern is defined through [!param](/Mesh/FlexiblePatternGenerator/hex_origins), while the patterning pitches are provided by [!param](/Mesh/FlexiblePatternGenerator/hex_pitches). Each hexagonal pattern can be rotated around its own origin independently, as directed by [!param](/Mesh/FlexiblePatternGenerator/hex_rotations). Here, a `zero` rotation angle leads to a hexagonal pattern with its flat side parallel to x-axis (so that patterns in [!param](/Mesh/FlexiblePatternGenerator/hex_patterns) are intuitive).

         block=Mesh/fpg
         id=hex_pattern
         caption=Input example of hexagonal patterning.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=double_hex_pattern
      caption=Output example of hexagonal patterning.

##### Rectangular Patterning

One or several rectangular patterns of input unit meshes can be generated. These patterns are provided by a triple-indexed input parameter [!param](/Mesh/FlexiblePatternGenerator/rect_patterns). Each element of [!param](/Mesh/FlexiblePatternGenerator/rect_patterns) follows the same format as the [!param](/Mesh/PatternedCartesianMeshGenerator/pattern) parameter in [`PatternedCartesianMeshGenerator`](PatternedCartesianMeshGenerator.md) but allows general rectangular patterning instead of restricted square patterning. The origin position of each pattern is defined through [!param](/Mesh/FlexiblePatternGenerator/rect_origins), while the patterning pitches in both directions are provided by [!param](/Mesh/FlexiblePatternGenerator/rect_pitches_x) and [!param](/Mesh/FlexiblePatternGenerator/rect_pitches_y), respectively. Each rectangular pattern can be rotated around its own origin independently, as directed by [!param](/Mesh/FlexiblePatternGenerator/rect_rotations).

         block=Mesh/fpg
         id=rect_pattern
         caption=Input example of rectangular patterning.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=single_rect_pattern
      caption=Output example of rectangular patterning.

##### Circular Patterning

One or several circular patterns of input unit meshes can be generated. The patterns are provided by a double-indexed input parameter [!param](/Mesh/FlexiblePatternGenerator/circular_patterns). Each element of [!param](/Mesh/FlexiblePatternGenerator/circular_patterns) lists all the unit meshes uniformly distributed on a circle. The origin position of each pattern is defined through [!param](/Mesh/FlexiblePatternGenerator/circular_origins), while the radius of each pattern is provided by [!param](/Mesh/FlexiblePatternGenerator/circular_radii), respectively. Each circular pattern can be rotated around its own origin independently, as directed by [!param](/Mesh/FlexiblePatternGenerator/circular_rotations). The first unit mesh will be positioned at the azimuthal angle defined as in [!param](/Mesh/FlexiblePatternGenerator/circular_rotations), while the following unit meshes will be positioned uniformly on the circle counterclockwise.

         block=Mesh/fpg
         id=circ_pattern
         caption=Input example of circular patterning.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=single_circ_pattern
      caption=Output example of circular patterning.

##### Custom Patterning

In addition to the hexagonal, rectangular and circular patterning, users can specify the positions of unit meshes freely using [!param](/Mesh/FlexiblePatternGenerator/extra_positions). Corresponding to each position provided in [!param](/Mesh/FlexiblePatternGenerator/extra_positions), an input unit mesh index needs to be provided in [!param](/Mesh/FlexiblePatternGenerator/extra_positions_mg_indices).

         block=Mesh/fpg
         id=custom_pattern
         caption=Input example of custom patterning.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=custom_pattern_m
      caption=Output example of custom patterning.

##### Dummy Unit Meshes

In both [!param](/Mesh/FlexiblePatternGenerator/hex_patterns) and [!param](/Mesh/FlexiblePatternGenerator/rect_patterns), the use of an input unit mesh index greater than or equal to the size of [!param](/Mesh/FlexiblePatternGenerator/inputs) indicates that patterning position is a dummy and no input unit mesh will be assigned to that position. This feature allows creation of partial patterning.

         block=Mesh/fpg
         id=mixed_pattern
         caption=Input example of mixed patterning with dummy unit meshes.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=mixed_pattern_m
      caption=Output example of mixed patterning with dummy unit meshes.

#### Extra Element ID Assignment for Unit Meshes

For each unit mesh involved in the patterning, two types of extra element IDs can be automatically assigned to facilitate subsequent data analysis, using different assignment modes.

The `cell` style extra element ID can be specified using the [!param](/Mesh/FlexiblePatternGenerator/cell_id_name) parameter. It is similar to the `cell` option in [`PatternedHexMeshGenerator`](/PatternedHexMeshGenerator.md)'s [!param](/Mesh/PatternedHexMeshGenerator/assign_type) parameter, which assigns a unique extra element ID for each component unit mesh in sequential order. On the other hand, the `pattern` style extra element ID can be specified using the [!param](/Mesh/FlexiblePatternGenerator/pattern_id_name) parameter. It is similar to the `pattern` option in [`PatternedHexMeshGenerator`](/PatternedHexMeshGenerator.md)'s [!param](/Mesh/PatternedHexMeshGenerator/assign_type) parameter, which assigns the extra element ID based on the IDs (i.e., sequential order) of the input meshes defined in [!param](/Mesh/FlexiblePatternGenerator/inputs). By default, both assigned extra element IDs begin with 0 and increment by 1. Alternatively, these generated extra element IDs can be shifted using the [!param](/Mesh/FlexiblePatternGenerator/cell_id_shift) and [!param](/Mesh/FlexiblePatternGenerator/pattern_id_shift), respectively.




### HexagonConcentricCircleAdaptiveBoundaryMeshGenerator


#### Overview

The `HexagonConcentricCircleAdaptiveBoundaryMeshGenerator` object generates a 2D mesh for concentric circles with a hexagon enclosure with or without external ducts. It is similar to [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md) and the majority of the parameters and functionalities of this object are described in the documentation of [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md). The major unique feature of this object is that the [!param](/Mesh/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator/num_sectors_per_side) parameter will be overridden to enable stitching to another hexagonal mesh (provided via [!param](/Mesh/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator/meshes_to_adapt_to) to this object). This object therefore creates hexagonal meshes that can be directly stitched with hexagonal meshes generated by [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md) and [`PatternedHexMeshGenerator`](/PatternedHexMeshGenerator.md). This object only works for hexagons instead of general polygons.

##### More Information

In order to adapt the external boundary to match input meshes (typically generated by [`PatternedHexMeshGenerator`](/PatternedHexMeshGenerator.md)), two extra input parameters must be provided:

- [!param](/Mesh/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator/sides_to_adapt): a vector parameter that can include up to six elements which lists the reference hexagon side numbers to adaptively mesh. These entries must be non-repeating integers from 0 to 5 (see [Figure 1](#schematic)). The hexagon sides are indexed counterclockwise starting from the upper-right side.
- [!param](/Mesh/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator/meshes_to_adapt_to): a vector parameter that includes the same number of elements as [!param](/Mesh/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator/sides_to_adapt). These elements are input hexagonal meshes whose boundary nodes will be queried and used to adaptively mesh a side of the hexagonal mesh being created. The input hexagonal meshes are generated by [`PatternedHexMeshGenerator`](/PatternedHexMeshGenerator.md) or [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md). Multiple meshes may be input, each one corresponding to the side index value specified in [!param](/Mesh/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator/sides_to_adapt). The same input mesh may be repeated multiple times.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=schematic
      caption=A schematic drawing showing the hexagon side indices in `HexagonConcentricCircleAdaptiveBoundaryMeshGenerator` object.

The [!param](/Mesh/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator/hexagon_size) provided here must be consistent with the [!param](/Mesh/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator/hexagon_size) values of all the [!param](/Mesh/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator/meshes_to_adapt_to) generators.

The mesh generator can generate meshes with either linear or quadratic elements, which is controlled by the [!param](/Mesh/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator/tri_element_type) and [!param](/Mesh/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator/quad_element_type) parameters. The [!param](/Mesh/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator/meshes_to_adapt_to) must have the consistent element types for compatibility.

One major application of this object is to generate meshes for control drums. In that case, [!param](/Mesh/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator/is_control_drum) can be set as true so that corresponding `MeshMetaData` can be generated for future use with control drum related objects.

#### Example Syntax


Here, a simple hexagon mesh stored in an Exodus file is used as the input of `HexagonConcentricCircleAdaptiveBoundaryMeshGenerator`. Only Side 0 of the generated mesh is set to adapt the input mesh (i.e., Side 3 of the input mesh), as shown in [Figure 2](#hex_adapt). Note that only Side 0 of the generated mesh matches the input mesh (Side 3).

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=hex_adapt
      caption=A schematic drawing showing the input and generated meshes of the example case.




### HexagonMeshTrimmer


#### Overview

The `HexagonMeshTrimmer` object takes the hexagonal mesh generated by [`PatternedHexMeshGenerator`](/PatternedHexMeshGenerator.md) as [!param](/Mesh/HexagonMeshTrimmer/input) and trims off part of the mesh. The input mesh can also be `PatternedHexMeshGenerator`'s output processed by [`PeripheralRingMeshGenerator`](/PeripheralRingMeshGenerator.md) or [`PatternedHexPeripheralModifier`](/PatternedHexPeripheralModifier.md).

Two types of trimming can be performed by `HexagonMeshTrimmer`: +Peripheral Trimming+ and +Through-the-Center Trimming+, which will be introduced separately as follows.

      style=display: block;margin-left:auto;margin-right:auto;width:60%;
      id=hexagon_trimmer
      caption=A schematic drawing showing different trimming schemes for a hexagonal mesh.

##### Peripheral Trimming

Peripheral trimming trims off peripheral region(s) of one or multiple sides of the input hexagonal assembly mesh. To be specific, for each side, half of the unit pin meshes are trimmed off, as shown by the purple lines in [hexagon_trimmer]. Each side of the hexagonal assembly is assigned an index as illustrated in [hexagon_trimmer]. Users can use [!param](/Mesh/HexagonMeshTrimmer/trim_peripheral_region) to set which sides need to be trimmed off (`1`) and which need to be retained (`0`). The setting [!param](/Mesh/HexagonMeshTrimmer/trim_peripheral_region) = "1 1 1 1 1 1"  trims off all the sides (full peripheral trimming) to create a hexagonal assembly mesh with half-pins on each of the external 6 boundaries. Partial peripheral trimming may be employed for practical applications to create peripheral assemblies in a core whose normal interior assembly units contain half-pins on the boundary. The mesh metadata generated by `PatternedHexMeshGenerator` are retained, with `pattern_pitch_meta` updated to take trimming into consideration. The output of this object can be assembled into a patterned lattice using  `PatternedHexMeshGenerator`.

##### Center Trimming

Center trimming removes azimuthal sectors from the input hexagonal assembly or core mesh. The mesh may be trimmed along lines of symmetry in the input mesh. Only certain hexagonal meshes are eligible to be trimmed by this object due to imposed symmetries (see Trimmability). Valid hexagonal input meshes may be trimmed at twelve possible center trimming lines, indexed from 0 to 11 as the blue lines shown in [hexagon_trimmer]. Each unit azimuthal sector is 30$^{\circ}$. A practical application of center trimming is to reduce the domain size (and simulation scale) by leveraging symmetry through reflected boundary conditions. Therefore the largest possible output mesh after center trimming contains six consecutive azimuthal sectors (i.e., half of the input mesh), while the smallest possible output mesh has only one azimuthal sector (i.e., one twelfth of the input mesh). This mesh trimmer object RETAINS any sectors which are included between the trimming line defined by [!param](/Mesh/HexagonMeshTrimmer/center_trim_starting_index) to the trimming line defined by [!param](/Mesh/HexagonMeshTrimmer/center_trim_ending_index) swept out in a counterclockwise direction. Other sectors are discarded.

#### Trimmability

In general, `HexagonMeshTrimmer` trims meshes generated by `PatternedHexMeshGenerator`. An assembly mesh consisting of patterned pin meshes has both peripheral and center trimmability; whereas a core mesh consisting of patterned assembly meshes only has center trimmability.  Two mesh metadata entries (`peripheral_trimmability` and `center_trimmability`) are created by `PatternedHexMeshGenerator` to tell `HexagonMeshTrimmer` which trimming options are valid. In the absence of these two meta data, `HexagonMeshTrimmer` will throw an incompatible error message.

In addition, `PeripheralRingMeshGenerator`, which applies quadrilateral peripheral cylinder mesh around an assembly or core, retain these two mesh meta data from the input mesh so that valid meshes generated by `PeripheralRingMeshGenerator` may also be trimmed. Similarly, assembly meshes modified by `PatternedHexPeripheralModifier` also have these meta data retained and are thus able to be trimmed by this generator.

#### Degenerate Quadrilateral Elements

When trimming a mesh, some elements may be located across the trimming line and thus need to be processed to ensure a smooth trimming boundary. Generic tools such as [`PlaneDeletionGenerator`](/PlaneDeletionGenerator.md) is capable of trimming meshes but leaves a zigzag trimming boundary in the presence of across-trimming-line elements.

To avoid this zig-zag boundary, `HexagonMeshTrimmer` adopts a post-trimming processing algorithm to smooth the trimming boundary. The algorithm moves the nodes of the across-trimming-line elements in the normal direction of the trimming line onto the trimming line. During this procedure, some elements may become zero volume and will be removed. More importantly, after node moving, some quadrilateral elements may have three co-linear vertices on the trimming line, which make the element degenerate. To fix this issue, these degenerate quadrilateral elements are converted into triangular elements. As triangular elements and quadrilateral elements cannot share a single subdomain id/name, new subdomains are created for any affected quadrilateral element subdomains. The subdomain ids of the new subdomains are decided by shifting the original subdomain ids by [!param](/Mesh/HexagonMeshTrimmer/tri_elem_subdomain_shift) (default shift value is the maximum subdomain id of the mesh), while the subdomain names of the new subdomains are created by appending [!param](/Mesh/HexagonMeshTrimmer/tri_elem_subdomain_name_suffix) after the original subdomain names.

#### Boundary Assignment

For peripheral trimming, the new boundary formed by the trimming operation is the new external boundary. Therefore, the boundary id defined by [!param](/Mesh/HexagonMeshTrimmer/external_boundary) is assigned to the new boundary. On the other hand, for center trimming, the new boundary formed by the trimming operation is a mirror boundary instead of an external boundary. Hence, the boundary id defined by [!param](/Mesh/HexagonMeshTrimmer/external_boundary) is NOT assigned to the new boundaries.

In addition, users can optionally use [!param](/Mesh/HexagonMeshTrimmer/peripheral_trimming_section_boundary) and [!param](/Mesh/HexagonMeshTrimmer/center_trimming_section_boundary) to assign additional boundary names to the new boundary.

#### Example Syntax





### HexIDPatternedMeshGenerator

This mesh generator is deprecated. Please use a [PatternedHexMeshGenerator.md].





### PatternedCartesianMeshGenerator


#### Overview

The `PatternedCartesianMeshGenerator` object generates a 2D mesh by stitching cartesian (square-shaped) meshes generated by [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md), [`CartesianConcentricCircleAdaptiveBoundaryMeshGenerator`](/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator.md), and itself, based on a user-defined square grid pattern. The generated 2D mesh can optionally contain an extra background region and/or external duct regions to form an expanded square external shape rather than a purely stacked square of squares.

#### Geometry Information

In order to generate the square patterned mesh, three fundamental parameters are needed:

- [!param](/Mesh/PatternedCartesianMeshGenerator/inputs): a vector of mesh generator names that will be used as elements to form the patterned mesh;
- [!param](/Mesh/PatternedCartesianMeshGenerator/pattern): a two-dimensional vector that represents the pattern of mesh to be generated. The elements must be integers from 0 to N-1, where N is the length of vector parameter [!param](/Mesh/PatternedCartesianMeshGenerator/inputs).
- [!param](/Mesh/PatternedCartesianMeshGenerator/pattern_boundary): a MooseEnum parameter that can be either `none` or `expanded`. When `none` is selected, this object only stitches [!param](/Mesh/PatternedCartesianMeshGenerator/inputs) meshes into a patterned mesh without extraneous geometry, resulting in a simply stacked square of unit squares. When `expanded` is selected, a background region is added so that the generated mesh has an expanded square shape instead of a simply stacked one. Concentric duct regions may also be optionally added to the square periphery when this parameter is `expanded`. The user can refer to [Figure 1](#pattern_cart) for more details.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=pattern_cart
      caption=A schematic showing the difference between `none` and `expanded` `pattern_boundary`.

When [!param](/Mesh/PatternedCartesianMeshGenerator/pattern_boundary) is set as `expanded`, the user can also provide [!param](/Mesh/PatternedCartesianMeshGenerator/duct_sizes) in either `apothem` (center-to-face) or `radius` (center-to-vertex) style determined by [!param](/Mesh/PatternedCartesianMeshGenerator/duct_sizes_style) to add external duct regions to the generated square mesh. Also, [!param](/Mesh/PatternedCartesianMeshGenerator/square_size) must also be provided to define the external square boundary size. In some cases, if [!param](/Mesh/PatternedCartesianMeshGenerator/square_size) is small enough, the square external boundary may cut off some of the stitched square meshes. As long as the concentric circular (`rings`) regions are not cut off, the rest of the mesh is deformed to accommodate the limited external boundaries. Users can also set [!param](/Mesh/PatternedCartesianMeshGenerator/deform_non_circular_region) as `false` to prevent the non-circular regions from being deformed.

 By default, the generated boundary mesh consists of linear elements. If quadratic elements are preferred, users can set [!param](/Mesh/PatternedCartesianMeshGenerator/boundary_region_element_type) as `QUAD8` or `QUAD9`.

#### MeshMetaData of Input and Output Meshes

As mentioned before, the `PatternedCartesianMeshGenerator` is capable of two modes of mesh patterning jobs, which require different mesh metadata from the input meshes to be patterned. These mesh metadata can be automatically assigned by the typical mesh generators that produce the input meshes. Alternatively, users can manually assign the required metadata using [`AddMetaDataGenerator`](/AddMetaDataGenerator.md).

1. =+Assembly Mode:+= patterning unit cell input meshes together to form an "assembly" mesh:

 Select this mode by setting [!param](/Mesh/PatternedCartesianMeshGenerator/generate_core_metadata) as false. A typical unit cell input mesh can be generated by [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md). The `expanded` [!param](/Mesh/PatternedCartesianMeshGenerator/pattern_boundary) can only be used in this mode. In this mode, `PatternedCartesianMeshGenerator` automatically assigns the mesh metadata required for the "core mode" as discussed in the following text.

2. =+Core Mode:+= patterning assembly input meshes together to form a "core" mesh:

 Select this mode by setting [!param](/Mesh/PatternedCartesianMeshGenerator/generate_core_metadata) as true. A typical assembly input mesh can be generated by another `PatternedCartesianMeshGenerator` in assembly mode, [`CartesianConcentricCircleAdaptiveBoundaryMeshGenerator`](/CartesianConcentricCircleAdaptiveBoundaryMeshGenerator.md), or [`FlexiblePatternGenerator`](/FlexiblePatternGenerator.md).

#### Control Drum Related MeshMetaData

One of the applications of this object is to generate meshes for reactor cores with control drums. In that case, by setting [!param](/Mesh/PatternedCartesianMeshGenerator/generate_core_metadata) as true, control drum meshes can also be used as part of [!param](/Mesh/PatternedCartesianMeshGenerator/inputs) to construct the core mesh. To facilitate the use of control drum rotation simulation objects, a series of `MeshMetaData` can be generated, including:

- `control_drum_positions`: a vector of control drum center positions. This `MeshMetaData` can also be outputted as an ASCII file by setting [!param](/Mesh/PatternedCartesianMeshGenerator/generate_control_drum_positions_file) as true and providing [!param](/Mesh/PatternedCartesianMeshGenerator/position_file);
- `control_drum_angles`: a vector of the azimuthal angles of the control drum center positions to the center of the core.
- `control_drums_azimuthal_meta`: a two-dimensional vector containing the sorted azimuthal angles of nodes to the corresponding control drum center for all the control drums.

In addition, [!param](/Mesh/PatternedCartesianMeshGenerator/assign_control_drum_id) can be set as true so that the control drum [!param](/Mesh/PatternedCartesianMeshGenerator/inputs) meshes can be indexed using an element extra integer called `control_drum_id`. As illustrated in [Figure 2](#cd_id), the `control_drum_id` is indexed based on the azimuthal angles of the control drums.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=cd_id
      caption=A schematic drawing the indexing rule of `control_drum_id` in the `PatternedCartesianMeshGenerator` object.

These `MeshMetaData` as well as `control_drum_id` can be used by other MOOSE objects such as [`MultiControlDrumFunction`](/MultiControlDrumFunction.md) to simulate control drums rotation during power transients.

#### Interface Boundaries

The user can also decide whether the interface boundaries are generated or not in the peripheral region. 


The user can set [!param](/Mesh/PatternedCartesianMeshGenerator/create_inward_interface_boundaries) and [!param](/Mesh/PatternedCartesianMeshGenerator/create_outward_interface_boundaries) to control which interface boundaries will be created. If generated, the outward interface boundaries will be assigned ids using sequential odd numbers (i.e., 1, 3, 5, 7, ...) shifted by `INTRINSIC_SIDESET_ID::SLICE_ALT`=30500 from center to periphery, while the inward interface boundaries will be assigned ids using sequential even numbers (i.e., 0, 2, 4, 6, ...) shifted by `INTRINSIC_SIDESET_ID::SLICE_ALT` similarly.

The interface boundary IDs within each Cartesian lattice cell can be shifted by setting [!param](/Mesh/PatternedCartesianMeshGenerator/interface_boundary_id_shift_pattern).
Note that these IDs on each lattice cell are pre-generated when the input tiles are generated by [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md).
To customize the interface boundary IDs for each lattice cell location, the user can define a value of boundary ID shift for each lattice cell location in a two-dimensional vector form, matching the dimensions of  [!param](/Mesh/PatternedCartesianMeshGenerator/pattern).
These shift values, specified by [!param](/Mesh/PatternedCartesianMeshGenerator/interface_boundary_id_shift_pattern), are applied to each lattice cell location during the stitching process.
This allows for unique interface boundary ID values for each cell (or pattern-defined groups of cells) within the Cartesian lattice, based on its specific location.

#### Reporting ID Information

This object can generate a Cartesian lattice mesh with `reporting ID` assignments.
It can be used successively on another `PatternedCartesianMeshGenerator` output mesh to add IDs on the pin and assembly levels, for example.
The reporting ID option can be turned on by defining the name of the reporting ID variable is provided through [!param](/Mesh/PatternedCartesianMeshGenerator/id_name).

Reporting IDs are assigned to all elements in each tile of the pattern following a per-tile assignment strategy.
A user can select an ID assignment scheme using [!param](/Mesh/PatternedCartesianMeshGenerator/assign_type), and the following schemes are currently available:

- `cell` (default):  Assign unique IDs for each component/tile in the lattice in sequential order.

- `pattern`:  Assign IDs based on the ID of the input tiles.

- `manual`: Assign IDs based on user-defined mapping defined in [!param](/Mesh/PatternedCartesianMeshGenerator/id_pattern).

The default numbering scheme starts at 0 in the upper left hand corner of Cartesian grid (not including duct region) and increments by 1 as the grid is traversed left to right, top to bottom
In presence of duct regions, separate reporting IDs are automatically generated for the elements in duct regions.
For the `pattern` scheme, all tiles in the pattern with the same input will bear the same reporting ID.
The duct regions will be assigned reporting IDs starting from the next integer higher than the highest one used inside of the ducts.

The name of the reporting ID variable is provided through [!param](/Mesh/PatternedCartesianMeshGenerator/id_name) depending on the hierarchical level of component.
The ID values themselves are stored as extra element integers on the mesh.
For example, the reporting IDs for individual pins (`pin_id`) can be assigned when assemblies are built because the IDs for pin level are uniquely determined from the pin arrangement within each assembly type.
Similarly, the assembly reporting IDs (`assembly_id`) are assigned in the core construction process.

The multiple `reporting IDs` can be assigned by defining the multiple names of the reporting ID variable, which are provided through the[!param](/Mesh/PatternedCartesianMeshGenerator/id_name).
The corresponding assignment scheme should be provided in [!param](/Mesh/PatternedCartesianMeshGenerator/assign_type) for each reporting ID names, accordingly.
In the case that multiple `manual` `assign_type`s are used, the same number of manual ID patterns should be provided in [!param](/Mesh/PatternedCartesianMeshGenerator/id_pattern).
Each manual pattern in [!param](/Mesh/PatternedCartesianMeshGenerator/id_pattern) should be separated by using the delimiter '|'.
These defined ID patterns are sequentially assigned to the reporting IDs having `manual` assignment scheme.
The below is an example of using multiple `reporting ID` assignment.
Here, `manual_1_id` uses the first pattern in defined in [!param](/Mesh/PatternedCartesianMeshGenerator/id_pattern), and `manual_2_id` uses the second one.

id_name = 'manual_1_id cell_id manual_2_id'
assign_type 'manual cell manual'
id_pattern = '1 2;
              3 4|
              4 3;
              2 1;

Certain regions can be excluded from being labeled with an ID, for example dummy regions that will later be deleted.
This can be accommodated by listing mesh objects in the [!param](/Mesh/PatternedCartesianMeshGenerator/exclude_id) input parameter.
IDs will not be assigned to these mesh objects.
Usage of this parameter is helpful to retain sequential numbering when dummy region are later deleted, or to only label areas of interest.

#### Example Syntax





### PatternedCartesianPeripheralModifier


#### Overview

This `PatternedCartesianPeripheralModifier` class utilizes [`FillBetweenPointVectorsTools`](/FillBetweenPointVectorsTools.md) to replace the outmost layer of the quad elements of the 2D cartesian assembly mesh generated by [`PatternedCartesianMeshGenerator`](PatternedCartesianMeshGenerator.md) with a transition layer consisting of triangular elements so that the assembly mesh can have nodes on designated positions on the external boundary. This boundary modification facilitates the stitching of cartesian assemblies which have different node numbers on their outer periphery due to differing numbers of interior pins and/or different azimuthal discretization.

Both linear and quadratic elements are supported by `PatternedCartesianPeripheralModifier`. The order of the elements to be generated is automatically determined by the element order of the input mesh.

#### Motivation

The motivation of developing this mesh generator is similar to that of the [`PatternedHexPeripheralModifier`](/PatternedHexPeripheralModifier.md). Please refer to that documentation for details.

#### Modification of Peripheral Boundary to Allow Stitching

The `PatternedCartesianPeripheralModifier` class modifies assembly meshes so that assemblies with different number of pins can be stitched together without increasing the mesh fidelity to an impractically fine fidelity. This mesh generator only works with the [!param](/Mesh/PatternedCartesianPeripheralModifier/input) mesh created by [`PatternedCartesianMeshGenerator`](PatternedCartesianMeshGenerator.md). Users must specify the external boundary of the input assembly mesh through [!param](/Mesh/PatternedCartesianPeripheralModifier/input_mesh_external_boundary). Given this input, the mesh generator identifies and deletes the outmost layer of elements and uses the newly formed external boundary as one of the two vectors of boundary nodes needed by [`FillBetweenPointVectorsTools`](/FillBetweenPointVectorsTools.md) after symmetry reduction. In addition, uniformly distributed nodes are placed along the original external boundary of the mesh and defined as the second vector of boundary nodes needed by [`FillBetweenPointVectorsTools`](/FillBetweenPointVectorsTools.md). The number of new boundary nodes is specified using [!param](/Mesh/PatternedHexPeripheralModifier/new_num_sector). Thus, the outmost layer of the assembly mesh can be replaced with a triangular element transition layer mesh that can be easily stitched with another transition layer mesh. An example of the assembly mesh modified by this mesh generator is shown in [assembly_example]

      style=display: block;margin-left:auto;margin-right:auto;width:60%;
      id=assembly_example
      caption=A schematic drawing of an example cartesian assembly mesh with transition layer as its outmost mesh layer.

The extra element IDs from the original peripheral region are conserved. They may be modified using the [!param](/Mesh/PatternedCartesianPeripheralModifier/extra_id_names_to_modify) and [!param](/Mesh/PatternedCartesianPeripheralModifier/new_extra_id_values_to_assign) parameters.

#### Advantages

This mesh generator forces the number of nodes on a cartesian mesh to match a user-specified input. This allows assemblies with different number of pins or azimuthal discretizations (and consequently different numbers of boundary nodes) to be stitched together without increasing the mesh density to an unreasonable level.

      style=display: block;margin-left:auto;margin-right:auto;width:60%;
      id=pattern_adv
      caption=A schematic drawing showing a virtual core design with assemblies including 9, 16, 25 and 36 pins.

[pattern_adv] illustrates a core comprising four types of assemblies. This mesh generator's functionality was leveraged to force a common mesh density on each cartesian assembly side (10 nodes on each assembly side) so that the assemblies can be easily stitched.

#### Example Syntax





### PatternedHexMeshGenerator


#### Overview

The `PatternedHexMeshGenerator` object generates a 2D mesh by stitching hexagonal meshes generated by [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md), [`HexagonConcentricCircleAdaptiveBoundaryMeshGenerator`](/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator.md), and itself, based on a user-defined hexagonal grid pattern. The generated 2D mesh can optionally contain an extra background region and/or external duct regions to form a hexagonal external shape rather than a jagged boundary edge.

#### Geometry Information

In order to generate the hexagonal patterned mesh, three fundamental parameters are needed:

- [!param](/Mesh/PatternedHexMeshGenerator/inputs): a vector of mesh generator names that will be used as elements to form the patterned mesh;
- [!param](/Mesh/PatternedHexMeshGenerator/pattern): a two-dimensional vector that represents the pattern of mesh to be generated. The elements must be integers from 0 to N-1, where N is the length of vector parameter [!param](/Mesh/PatternedHexMeshGenerator/inputs).
- [!param](/Mesh/PatternedHexMeshGenerator/pattern_boundary): a MooseEnum parameter that can be either `hexagon` or `none`. When `none` is selected, this object only stitches [!param](/Mesh/PatternedHexMeshGenerator/inputs) meshes into a patterned mesh without extraneous geometry, resulting in an outer boundary with a zig-zag edge. When `hexagon` is selected, a background region is added so that the generated mesh has a hexagonal shape instead of a zig-zag one. Concentric duct regions may also be optionally added to the hexagon periphery when this parameter is `hexagon`. The user can refer to [Figure 1](#pattern_hex) for more details.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=pattern_hex
      caption=A schematic showing the difference between `none` and `hexagon` `pattern_boundary`.

When [!param](/Mesh/PatternedHexMeshGenerator/pattern_boundary) is set as `hexagon`, the user can also provide [!param](/Mesh/PatternedHexMeshGenerator/duct_sizes) in either `apothem` or `radius` style to add external duct regions to the generated hexagon mesh. Also, [!param](/Mesh/PatternedHexMeshGenerator/hexagon_size) must also be provided to define the external hexagon boundary size, which can be either `apothem` or `radius` of the hexagon, as determined by [!param](/Mesh/PatternedHexMeshGenerator/hexagon_size_style). In some cases, if [!param](/Mesh/PatternedHexMeshGenerator/hexagon_size) is small enough, the hexagon external boundary may cut off some of the stitched hexagonal meshes. As long as the concentric circular (`rings`) regions are not cut off, the rest of the mesh is deformed to accommodate the limited external boundaries. Users can also set [!param](/Mesh/PatternedHexMeshGenerator/deform_non_circular_region) as `false` to prevent the non-circular regions from being deformed.

 By default, the generated boundary mesh consists of linear elements. If quadratic elements are preferred, users can set [!param](/Mesh/PatternedHexMeshGenerator/boundary_region_element_type) as `QUAD8` or `QUAD9`.

#### MeshMetaData of Input and Output Meshes

As mentioned before, the `PatternedHexMeshGenerator` is capable of two modes of mesh patterning jobs, which require different mesh metadata from the input meshes to be patterned. These mesh metadata can be automatically assigned by the typical mesh generators that produce the input meshes. Alternatively, users can manually assign the required metadata using [`AddMetaDataGenerator`](/AddMetaDataGenerator.md).

 1. =+Assembly Mode:+= patterning unit cell input meshes together to form an "assembly" mesh:

 Select this mode by setting [!param](/Mesh/PatternedHexMeshGenerator/generate_core_metadata) as false. A typical unit cell input mesh can be generated by [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md). The `hexagon` [!param](/Mesh/PatternedHexMeshGenerator/pattern_boundary) can only be used in this mode. When [!param](/Mesh/PatternedHexMeshGenerator/pattern_boundary) is set as `hexagon`, `PatternedHexMeshGenerator` automatically assigns the mesh metadata required for the "core mode" as discussed in the following text.

 2. =+Core Mode:+= patterning assembly input meshes together to form a "core" mesh:

 Select this mode by setting [!param](/Mesh/PatternedHexMeshGenerator/generate_core_metadata) as true. A typical assembly input mesh can be generated by another `PatternedHexMeshGenerator` in assembly mode, [`HexagonConcentricCircleAdaptiveBoundaryMeshGenerator`](/HexagonConcentricCircleAdaptiveBoundaryMeshGenerator.md), or [`FlexiblePatternGenerator`](/FlexiblePatternGenerator.md).

##### Control Drum Related MeshMetaData

One of the applications of this object is to generate meshes for prismatic reactor cores. In that case, by setting [!param](/Mesh/PatternedHexMeshGenerator/generate_core_metadata) as true, control drum meshes can also be used as part of [!param](/Mesh/PatternedHexMeshGenerator/inputs) to construct the core mesh. To facilitate the use of control drum rotation simulation objects, a series of `MeshMetaData` can be generated, including:

- `control_drum_positions`: a vector of control drum center positions. This `MeshMetaData` can also be outputted as an ASCII file by setting [!param](/Mesh/PatternedHexMeshGenerator/generate_control_drum_positions_file) as true and providing [!param](/Mesh/PatternedHexMeshGenerator/position_file);
- `control_drum_angles`: a vector of the azimuthal angles of the control drum center positions to the center of the core.
- `control_drums_azimuthal_meta`: a two-dimensional vector containing the sorted azimuthal angles of nodes to the corresponding control drum center for all the control drums.

In addition, [!param](/Mesh/PatternedHexMeshGenerator/assign_control_drum_id) can be set as true so that the control drum [!param](/Mesh/PatternedHexMeshGenerator/inputs) meshes can be indexed using an element extra integer called `control_drum_id`. As illustrated in [Figure 2](#cd_id), the `control_drum_id` is indexed based on the azimuthal angles of the control drums.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=cd_id
      caption=A schematic drawing the indexing rule of `control_drum_id` in the `PatternedHexMeshGenerator` object.

These `MeshMetaData` as well as `control_drum_id` can be used by other MOOSE objects such as [`MultiControlDrumFunction`](/MultiControlDrumFunction.md) to simulate control drums rotation during power transients.

#### Interface Boundaries

The user can also decide whether the interface boundaries are generated or not in the peripheral region.


The user can set [!param](/Mesh/PatternedHexMeshGenerator/create_inward_interface_boundaries) and [!param](/Mesh/PatternedHexMeshGenerator/create_outward_interface_boundaries) to control which interface boundaries will be created. If generated, the outward interface boundaries will be assigned ids using sequential odd numbers (i.e., 1, 3, 5, 7, ...) shifted by `INTRINSIC_SIDESET_ID::SLICE_ALT`=30500 from center to periphery, while the inward interface boundaries will be assigned ids using sequential even numbers (i.e., 0, 2, 4, 6, ...) shifted by `INTRINSIC_SIDESET_ID::SLICE_ALT` similarly.

The interface boundary IDs within each hexagonal lattice cell can be shifted by setting [!param](/Mesh/PatternedHexMeshGenerator/interface_boundary_id_shift_pattern).
Note that these IDs on each lattice cell are pre-generated when the input tiles are generated by [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md).
To customize the interface boundary IDs for each lattice cell location, the user can define a value of boundary ID shift for each lattice cell location in a two-dimensional vector form, matching the dimensions of  [!param](/Mesh/PatternedHexMeshGenerator/pattern).
These shift values, specified by [!param](/Mesh/PatternedHexMeshGenerator/interface_boundary_id_shift_pattern), are applied to each lattice cell location during the stitching process.
This allows for unique interface boundary ID values for each cell (or pattern-defined groups of cells) within the hexagonal lattice, based on its specific location.

#### Reporting ID Information

This object can generate a hexagonal lattice mesh with `reporting ID` assignments, and can be used successively on its own output mesh to add IDs on the pin and assembly levels, for example.
The reporting ID option can be turned on by defining the name of the reporting ID variable is provided through [!param](/Mesh/PatternedHexMeshGenerator/id_name).

A user can select an ID assignment scheme using [!param](/Mesh/PatternedHexMeshGenerator/assign_type), and the following schemes are currently available:

- `cell` (default):  Assign unique IDs for each component/tile in the lattice in sequential order.

- `pattern`:  Assign IDs based on the ID of the input tiles.

- `manual`: Assign IDs based on user-defined mapping defined in [!param](/Mesh/PatternedHexMeshGenerator/id_pattern).

The default numbering scheme starts at 0 in the upper left hand corner of the hexagon grid (not including duct region) and increments by 1 as the grid is traversed left to right, top to bottom.
In presence of duct regions, separate reporting IDs are automatically generated for the elements in duct regions.
For the `pattern` scheme, all tiles in the pattern with the same input will bear the same reporting ID.
The duct regions will be assigned reporting IDs starting from the next integer higher than the highest one used inside of the ducts.

The name of the reporting ID variable is provided through [!param](/Mesh/PatternedHexMeshGenerator/id_name) depending on the hierarchical level of component.
The ID values themselves are stored as extra element integers on the mesh.
For example, the reporting IDs for individual pins (`pin_id`) can be assigned when assemblies are built because the IDs for pin level are uniquely determined from the pin arrangement within each assembly type.
Similarly, the assembly reporting IDs (`assembly_id`) are assigned in the core construction process.

The multiple `reporting IDs` can be assigned by defining the multiple names of the reporting ID variable, which are provided through the[!param](/Mesh/PatternedHexMeshGenerator/id_name).
The corresponding assignment scheme should be provided in [!param](/Mesh/PatternedHexMeshGenerator/assign_type) for each reporting ID names, accordingly.
In the case that multiple `manual` `assign_type`s are used, the same number of manual ID patterns should be provided in [!param](/Mesh/PatternedHexMeshGenerator/id_pattern).
Each manual pattern in [!param](/Mesh/PatternedHexMeshGenerator/id_pattern) should be separated by using the delimiter '|'.
These defined ID patterns are sequentially assigned to the reporting IDs having `manual` assignment scheme.
The below is an example of using multiple `reporting ID` assignment.
Here, `manual_1_id` uses the first pattern in defined in [!param](/Mesh/PatternedHexMeshGenerator/id_pattern), and `manual_2_id` uses the second one.

id_name = 'manual_1_id cell_id manual_2_id'
assign_type 'manual cell manual'
id_pattern = '1 1;
             2 2 2;
              3 3|
              1 2;
             1 2 3
              2 3;

Certain regions can be excluded from being labeled with an ID, for example dummy regions that will later be deleted.
This can be accommodated by listing mesh objects in the [!param](/Mesh/PatternedHexMeshGenerator/exclude_id) input parameter.
IDs will not be assigned to these mesh objects.
Usage of this parameter is helpful to retain sequential numbering when dummy region are later deleted, or to only label areas of interest.


#### Example Syntax





### PatternedHexPeripheralModifier


#### Overview

This `PatternedHexPeripheralModifier` class utilizes [`FillBetweenPointVectorsTools`](/FillBetweenPointVectorsTools.md) to replace the outmost layer of the quad elements of the 2D hexagonal assembly mesh generated by [`PatternedHexMeshGenerator`](PatternedHexMeshGenerator.md) (or its derived class [`HexIDPatternedMeshGenerator`](HexIDPatternedMeshGenerator.md)) with a transition layer consisting of triangular elements so that the assembly mesh can have nodes on designated positions on the external boundary. This boundary modification facilitates the stitching of hexagonal assemblies which have different node numbers on their outer periphery due to differing numbers of interior pins and/or different azimuthal discretization.

Both linear and quadratic elements are supported by `PatternedHexPeripheralModifier`. The order of the elements to be generated is automatically determined by the element order of the input mesh.

#### Default Behavior of `PatternedHexMeshGenerator` and the Least Common Multiple Approach

When [`PatternedHexMeshGenerator`](PatternedHexMeshGenerator.md) is used to generate a hexagonal assembly mesh, the number of nodes on each hexagon side follows a pre-determined formula based on the pin cell meshes which comprise the assembly. These pin cell hexagonal meshes used by [`PatternedHexMeshGenerator`](PatternedHexMeshGenerator.md) must have a uniform even number of sectors per side (e.g., $2M$) given by [!param](/Mesh/PolygonConcentricCircleMeshGenerator/num_sectors_per_side) in [`PolygonConcentricCircleMeshGenerator`](/PolygonConcentricCircleMeshGenerator.md). If [`PatternedHexMeshGenerator`](PatternedHexMeshGenerator.md) creates a hexagonal bundle with $N$ ($N>1$) pins on each side of the outermost ring, there are $2M\cdot(2N-1)$ sectors or $2M\cdot(2N-1)+1$ nodes on each side of the hexagonal assembly mesh. If all the assemblies within a reactor core contain identical numbers of pins, it is straightforward to make assembly meshes stitchable with each other by using the same $M$ number for the azimuthal discretization of each pin cell. However, if a reactor core includes assemblies with different numbers of pins, $M$ must be wisely selected based on the least common multiple of $4N_i-2$ ($i$ is the assembly index) of all the assemblies involved. This approach may be practical in cases where two assembly types with different pin numbers are involved, as shown in the following table:

| Assm. #1 Number of pins per side $N_1$ | Assm. #1 Number of azimuthal intervals per sector $M_1$  | Assm. #1 Number of pins per side $N_2$ | Assm. #1 Number of azimuthal intervals per sector $M_2$ | Node Number on Assembly Side |
| --- | --- | --- | --- | --- |
| 2 | 5 | 3 | 3 | 30 |
| 2 | 7 | 4 | 3 | 42 |
| 2 | 3 | 5 | 1 | 18 |
| 2 | 11 | 6 | 3 | 66 |
| 2 | 13 | 7 | 3 | 78 |
| 3 | 7 | 4 | 5 | 70 |
| 3 | 9 | 5 | 5 | 90 |
| 3 | 11 | 6 | 5 | 110 |
| 3 | 13 | 7 | 5 | 130 |
| 4 | 9 | 5 | 7 | 126 |
| 4 | 11 | 6 | 7 | 154 |
| 4 | 13 | 7 | 7 | 182 |
| 5 | 11 | 6 | 9 | 198 |
| 5 | 13 | 7 | 9 | 234 |
| 6 | 13 | 7 | 11 | 286 |

However, multiple different assemblies with unique numbers of pins are involved in a reactor core, the [!param](/Mesh/PolygonConcentricCircleMeshGenerator/num_sectors_per_side) (i.e., $2M$) may be impractically large, as indicated in the following table:

| Assm. #1 $N_1$ | Assm. #1 $M_1$  | Assm. #2 $N_2$ |  Assm. #2 $M_2$ | Assm. #3 $N_3$ |  Assm. #3 $M_3$ | Node Number on Assembly Side |
| --- | --- | --- | --- | --- | --- | --- |
| 2 | 35 | 3 | 21 | 4 | 15 | 210 |
| 2 | 15 | 3 | 9 | 5 | 5 | 90 |
| 2 | 55 | 3 | 33 | 6 | 15 | 330 |
| 2 | 21 | 4 | 9 | 5 | 7 | 126 |
| 2 | 77 | 4 | 33 | 6 | 21 | 462 |
| 2 | 33 | 5 | 11 | 6 | 9 | 198 |
| 3 | 63 | 4 | 45 | 5 | 35 | 630 |
| 3 | 77 | 4 | 55 | 6 | 35 | 770 |
| 3 | 99 | 5 | 55 | 6 | 45 | 990 |
| 4 | 99 | 5 | 77 | 6 | 63 | 1386 |

#### Modification of Peripheral Boundary to Allow Stitching

The `PatternedHexPeripheralModifier` class modifies assembly meshes so that assemblies with different number of pins can be stitched together without increasing the mesh fidelity to an impractically fine fidelity (as shown in the previous section). This mesh generator only works with the [!param](/Mesh/PatternedHexPeripheralModifier/input) mesh created by [`PatternedHexMeshGenerator`](PatternedHexMeshGenerator.md). Users must specify the external boundary of the input assembly mesh through [!param](/Mesh/PatternedHexPeripheralModifier/input_mesh_external_boundary). Given this input, the mesh generator identifies and deletes the outmost layer of elements and uses the newly formed external boundary as one of the two vectors of boundary nodes needed by [`FillBetweenPointVectorsTools`](/FillBetweenPointVectorsTools.md) after symmetry reduction. In addition, uniformly distributed nodes are placed along the original external boundary of the mesh and defined as the second vector of boundary nodes needed by [`FillBetweenPointVectorsTools`](/FillBetweenPointVectorsTools.md). The number of new boundary nodes is specified using [!param](/Mesh/PatternedHexPeripheralModifier/new_num_sector). Thus, the outmost layer of the assembly mesh can be replaced with a triangular element transition layer mesh that can be easily stitched with another transition layer mesh. An example of the assembly mesh modified by this mesh generator is shown in [Figure 1](#assembly_example)

      style=display: block;margin-left:auto;margin-right:auto;width:60%;
      id=assembly_example
      caption=A schematic drawing of an example assembly mesh with transition layer as its outmost mesh layer.

#### Advantages

This mesh generator forces the number of nodes on a hexagonal mesh to match a user-specified input. This allows assemblies with different number of pins or azimuthal discretizations (and consequently different numbers of boundary nodes) to be stitched together without increasing the mesh density to an unreasonable level.

      style=display: block;margin-left:auto;margin-right:auto;width:60%;
      id=pattern_adv
      caption=A schematic drawing showing a virtual core design with assemblies including 7, 19, 37 and 61 pins.

[Figure 2](#pattern_adv) illustrates a core comprising four types of assemblies. This mesh generator's functionality was leveraged to force a common mesh density on each hexagonal assembly side (16 nodes on each assembly side) so that the assemblies can be easily stitched. In the absence of this mesh generator, the least common multiple approach would require 631 nodes on each assembly side as shown in [Figure 3](#compare). The mesh density would be increased dramatically just to ensure stitchability, showing the prominent advantage of using this mesh generator instead of the least common multiple approach.

      style=display: block;margin-left:auto;margin-right:auto;width:80%;
      id=compare
      caption=A close-up comparison between the virtual core meshes (see [Figure 2](#pattern_adv)) generated with and without using this mesh generator.

#### Handling Reporting IDs

If the input mesh contains extra element integers (reporting IDs), the `PatternedHexPeripheralModifier` provides options to retain or reassign these reporting IDs (see [Figure 4](#reporting_id_example)). By default, all the extra element integers existing on the input mesh are retained. Due to the nature of the transition layer which creates a new set of elements, the original boundaries between different reporting ID values have to be slightly shifted after modification. When `PatternedHexPeripheralModifier` assigns reporting ID values to a new element in the transition layer, it utilizes the reporting ID values of the original element that is nearest to the new element (based on centroid positions) to retain the setting of the input mesh.

The extra element IDs from the original peripheral region are conserved. They may be modified using the [!param](/Mesh/PatternedHexPeripheralModifier/extra_id_names_to_modify) and [!param](/Mesh/PatternedHexPeripheralModifier/new_extra_id_values_to_assign) parameters.

      style=display: block;margin-left:auto;margin-right:auto;width:95%;
      id=reporting_id_example
      caption=Different approaches to handle a reporting id: (Left) input mesh with reporting id (pin_id); (Middle) retained pin_id for transition layer; (Right) user provided pin_id value for transition layer.

#### Example Syntax





### PeripheralRingMeshGenerator


#### Overview

The `PeripheralRingMeshGenerator` object adds a 2D peripheral region using either first-order or second-order quadrilateral elements (i.e., QUAD4 or QUAD9) with a circular external boundary to the input 2D mesh. The order of the elements is automatically determined by the order of the input mesh elements on its external boundary. Mixed element order is NOT supported. A common use of this mesh generator is to mesh the circular peripheral region of a reactor core. This mesh generator can be used recursively on a mesh to add as many rings of peripheral regions as desired.

#### More Information

The use of this mesh generator requires an input mesh defined by [!param](/Mesh/PeripheralRingMeshGenerator/input) and the name/ID of its external boundary defined by [!param](/Mesh/PeripheralRingMeshGenerator/input_mesh_external_boundary). `PeripheralRingMeshGenerator` examines the external boundary of the input mesh to confirm whether the algorithm will function properly for the given external boundary. Trivially, the external boundary of the input mesh must be a single-segment closed loop.

This object then calculates the azimuthal angles of all the nodes on the external boundary of the input mesh. Each node on the input mesh external boundary is then used as the start point of a line segment, whose end point (node) lies on the circle defined by [!param](/Mesh/PeripheralRingMeshGenerator/peripheral_ring_radius). The segment is therefore aligned along the same azimuthal angle as the start point. Intermediate nodes may also be added if [!param](/Mesh/PeripheralRingMeshGenerator/peripheral_layer_num) is greater than unity. Currently, the algorithm only works when the azimuthal angles of the boundary nodes change monotonically as the external boundary is traversed. This object always generates a peripheral ring with its center at the origin, no matter where the centroid of the [!param](/Mesh/PeripheralRingMeshGenerator/input) mesh is. Optionally, [!param](/Mesh/PeripheralRingMeshGenerator/force_input_centroid_as_center) can be set as `true` to move the centroid of the [!param](/Mesh/PeripheralRingMeshGenerator/input) mesh to the origin.

The added peripheral block must be assigned an ID given by [!param](/Mesh/PeripheralRingMeshGenerator/peripheral_ring_block_id) along with an optional name given by [!param](/Mesh/PeripheralRingMeshGenerator/peripheral_ring_block_name). The new external boundary of the mesh can also be assigned an ID and a name through [!param](/Mesh/PeripheralRingMeshGenerator/external_boundary_id) and [!param](/Mesh/PeripheralRingMeshGenerator/external_boundary_name), respectively.

Optionally, users can preserve the volume of the peripheral ring region by setting [!param](/Mesh/PeripheralRingMeshGenerator/preserve_volumes) as `true` to enable correction of polygonization effect.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=pattern_hex
      caption=The peripheral block (in teal) created by this mesh generator using the input shown in Example Syntax section.

In addition, the radial meshing density of the peripheral ring region can be biased by setting the [!param](/Mesh/PeripheralRingMeshGenerator/peripheral_radial_bias) parameter. The bias value should be a positive `Real` type parameter, which is the radial dimension ratio between two radially-neighboring elements (outer to inner).

Aside from the general mesh radial biasing options described above, users can also define boundary layers within the peripheral ring region. Both inner and outer boundary layers are supported. Each boundary layer has three key parameters that need to be provided:

- [!param](/Mesh/PeripheralRingMeshGenerator/peripheral_inner_boundary_layer_width)/[!param](/Mesh/PeripheralRingMeshGenerator/peripheral_outer_boundary_layer_width): the radiation width of the boundary layer within the region. Note that the summation of the inner and outer boundary layers width must be smaller than the thinnest part of the peripheral ring.
- [!param](/Mesh/PeripheralRingMeshGenerator/peripheral_inner_boundary_layer_intervals)/[!param](/Mesh/PeripheralRingMeshGenerator/peripheral_outer_boundary_layer_intervals): the number of radial mesh discretization of the boundary layer.
- [!param](/Mesh/PeripheralRingMeshGenerator/peripheral_inner_boundary_layer_bias)/[!param](/Mesh/PeripheralRingMeshGenerator/peripheral_outer_boundary_layer_bias): the growth factor used for radial mesh biasing for the boundary layer.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=boundary_layer
      caption=The peripheral block (in teal) created by this mesh generator with biased boundary layers.

#### Example Syntax





### PeripheralTriangleMeshGenerator


#### Overview

The `PeripheralTriangleMeshGenerator` utilizes the general purpose [`XYDelaunayGenerator`](XYDelaunayGenerator.md) triangulation mesh generator and the [`PolyLineMeshGenerator`](PolyLineMeshGenerator.md) to create a circular periphery region around a reactor core. The outer circle properties are specified with the [!param](/Mesh/PeripheralTriangleMeshGenerator/peripheral_ring_radius) and [!param](/Mesh/PeripheralTriangleMeshGenerator/peripheral_ring_num_segments) input parameters.

Optionally, triangle refinement parameters can be used to improve the quality of the triangles in the periphery region. These are specified with either the [!param](/Mesh/PeripheralTriangleMeshGenerator/desired_area) parameter, which specifies a single desired maximum triangle area, or the [!param](/Mesh/PeripheralTriangleMeshGenerator/desired_area_func) parameter, which specifies the desired maximum triangle area as a function of the spatial coordinates x and y. Alternatively, this type of refinement can be done following an automatically generated area function. This feature is enabled by [!param](/Mesh/XYDelaunayGenerator/use_auto_area_func), while the related parameters include [!param](/Mesh/XYDelaunayGenerator/auto_area_func_default_size), [!param](/Mesh/XYDelaunayGenerator/auto_area_func_default_size_dist), [!param](/Mesh/XYDelaunayGenerator/auto_area_function_num_points), and [!param](/Mesh/XYDelaunayGenerator/auto_area_function_power). See the full documentation for [`XYDelaunayGenerator`](XYDelaunayGenerator.md) for more details on the area refinement options.

[Figure 1](#triangle_simple) shows an example triangulation around an existing core mesh.

      style=display: block;margin-left:auto;margin-right:auto;width:60%;
      id=triangle_simple
      caption=An example triangulation generated by this `PeripheralTriangleMeshGenerator` object around an existing core mesh.

During triangulation, the triangulation library used by [`XYDelaunayGenerator`](XYDelaunayGenerator.md) will by default use only the points given in the outer boundary polyline and the points on the outer boundary of the core regions, which can result in lower quality triangles and lead to difficulty when using the triangulation in FEM calculations. The triangle refinement options described above can be used to help improve the quality of the triangulation. [Figure 2](#triangle_refinement) shows an example triangulation with area refinement added to improve triangle quality.

      style=display: block;margin-left:auto;margin-right:auto;width:60%;
      id=triangle_refinement
      caption=An example triangulation generated by this `PeripheralTriangleMeshGenerator` object using optional triangle refinement to improve triangle quality.

#### Example Syntax





### PinMeshGenerator


#### Overview

This object is designed to be used in the Reactor MeshGenerator workflow, which also consists of [`ReactorMeshParams`](ReactorMeshParams.md), [`AssemblyMeshGenerator`](AssemblyMeshGenerator.md), [`ControlDrumMeshGenerator`](ControlDrumMeshGenerator.md), and [`CoreMeshGenerator`](CoreMeshGenerator.md).

The `PinMeshGenerator` object generates square or hexagonal reactor geometry pin cell structures which may be combined into larger assembly structures using `AssemblyMeshGenerator`. The block IDs, external boundary ID, region IDs (e.g., materials), and reporting IDs (extra element integers identifying unique planes and pins, as described in [`PatternedCartesianMeshGenerator`](PatternedCartesianMeshGenerator.md) and [`PatternedHexMeshGenerator`](PatternedHexMeshGenerator.md) are automatically assigned once the user provides some basic information.

This pin may be extruded to three dimensions by setting [!param](/Mesh/PinMeshGenerator/extrude) to 'true', however such extruded pins cannot be used as input to `AssemblyMeshGenerator`. Instead, 2-D pins must be inputted to `AssemblyMeshGenerator` and [!param](/Mesh/AssemblyMeshGenerator/extrude) should be set to 'true' at the `AssemblyMeshGenerator` definition to extrude the assembly to 3-D.


The `PinMeshGenerator` object automates the use and functionality of the [`PolygonConcentricCircleMeshGenerator`](PolygonConcentricCircleMeshGenerator.md) and, if extruding to three dimensions, the [`AdvancedExtruderGenerator`](AdvancedExtruderGenerator.md) through the use of the `MeshSubgenerator` functionality and supporting functionality from [`TransformGenerator`](TransformGenerator.md), [`RenameBoundaryGenerator`](RenameBoundaryGenerator.md), and [`PlaneIDMeshGenerator`](PlaneIDMeshGenerator.md). In addition to the functionality of the `MeshGenerators` used, this object also automates block ID assignment and boundary ID and name assignment.

The `PinMeshGenerator` object adopts much of the existing input structure of [`PolygonConcentricCircleMeshGenerator`](PolygonConcentricCircleMeshGenerator.md) but uses parameters that are more typical for reactor design. Setting [!param](/Mesh/PinMeshGenerator/homogenized) to true generates a homogenized pin structure that calls [`SimpleHexagonGenerator`](SimpleHexagonGenerator.md). This currently only works for hexagonal geometries, and whether a triangular or quadrilateral discretization is used for homogenization depends on the value of [!param](/Mesh/PinMeshGenerator/quad_center_elements). In addition, setting the parameter [!param](/Mesh/PinMeshGenerator/use_as_assembly) to true defines the output pincell structure as a single assembly, ensuring that the block names, outer boundaries, and extra element integers match the conventions used by [`AssemblyMeshGenerator`](AssemblyMeshGenerator.md). This option should be used if defining single assemblies that are to be inputted directly to [`CoreMeshGenerator`](CoreMeshGenerator.md), since [`AssemblyMeshGenerator`](AssemblyMeshGenerator.md) requires the assembly to be composed of multiple pins in a lattice structure.

#### Region ID, Block ID, and Block Name Information

The [!param](/Mesh/PinMeshGenerator/region_ids) parameter provides a map of "region_id" values to assign to zones in the pin mesh. Each row in this map corresponds to a single axial layer of the pin and contains individual entries corresponding to the radial zones within the pin, starting from the centermost region and extending radially outward. The number of columns (entries in the row) should be identical to the number of rings + 1 (background region) + number of ducts. The required number of rows is dependent on the number of axial layers in the pin. For 2D pins, a single row of entries should be provided. For 3D pins, multiple rows must be provided (one for each axial layer). For 3D pins, the top row corresponds to the bottom of the pin cell.

The region_ids parameter entries can conveniently be selected to match material ids to be assigned to each region of the problem. Using the same value in multiple entries of the [!param](/Mesh/PinMeshGenerator/region_ids) parameter will effectively assign elements in multiple zones to the same region_id.

Region IDs are mapped to the mesh as an extra element integer, where the integer value for each mesh element will match the information provided in [!param](/Mesh/PinMeshGenerator/region_ids). For ease of use, block ids are generated automatically by the mesh generator, and for users who require element identification by block name, the optional parameter [!param](/Mesh/PinMeshGenerator/block_names) can be defined to set block names in the same manner as [!param](/Mesh/PinMeshGenerator/region_ids). In the resulting mesh, each block name will be prepended with the prefix `RGMB_PIN<pin_type_id>_`, where `<pin_type_id>` is the pin ID provided by the user through [!param](/Mesh/PinMeshGenerator/pin_type). If block names are not provided by the user, block names will be assigned automatically to have the name `RGMB_PIN<pin_type_id>`. If [ReactorMeshParams](ReactorMeshParams.md)/[!param](/Mesh/ReactorMeshParams/region_id_as_block_name) is set to `true`, the resulting element will have the block name `RGMB_PIN<pin_type_id>_REG<region_id>`, where `<region_id>` is the region ID of the element. Note that [!param](/Mesh/ReactorMeshParams/region_id_as_block_name) should not be used in conjunction with [!param](/Mesh/PinMeshGenerator/block_names). Regardless of whether block names are provided or not, the suffix `_TRI` is automatically added to the block name for all triangular elements in the central pin mesh elements when [!param](/Mesh/PinMeshGenerator/quad_center_elements) is set to false. This is to ensure that quadrilateral elements and triangular elements that might otherwise share the same region ID are mapped to separate block names. If [!param](/Mesh/PinMeshGenerator/use_as_assembly) is set to true, the block name will have the prefix `RGMB_ASSEMBLY<pin_type_id>` instead of `RGMB_PIN<pin_type_id>`.

#### Reporting ID Information

As mentioned above, the `PinMeshGenerator` object tags the mesh elements with the extra integer reporting ID named "region_id".

The `PinMeshGenerator` object also automatically tags the mesh with the [!param](/Mesh/PinMeshGenerator/pin_type) using the extra integer name "pin_type_id" and, if extruded, the axial layers using the extra integer name "plane_id". If [!param](/Mesh/PinMeshGenerator/use_as_assembly) is set to true, the extra integer name "assembly_type_id" will be generated with integer values equivalent to "pin_type_id".

#### Exterior Boundary ID Information

The `PinMeshGenerator` object automatically assigns boundary information derived from the [!param](/Mesh/PinMeshGenerator/pin_type) parameter. The exterior pin boundary is assigned the ID equal to 20000 + the pin type ID and is named "outer_pin_<pin_type_id>" (for example a pin with a pin type ID of 1 will have a boundary ID of 20001 and boundary name of "outer_pin_1"). If [!param](/Mesh/PinMeshGenerator/use_as_assembly) is set to true, the outer boundary name will be "outer_assembly_<pin_type_id>".

If the pin is extruded to three dimensions the top-most boundary ID must be assigned using [!param](/Mesh/ReactorMeshParams/top_boundary_id) and will have the name "top", while the bottom-most boundary must be assigned using [!param](/Mesh/ReactorMeshParams/bottom_boundary_id) and will have the name "bottom".

#### Metadata Information

Users may be interested in defining metadata to represent the reactor geometry and region IDs assigned to each geometry zone, which may be useful to users who want mesh geometry and composition information without having to inspect the generated mesh itself. At the pin level, the following metadata is defined on the pin mesh:

- `pin_type`: pin_type id associated with pin mesh, equivalent to the input parameter [!param](/Mesh/PinMeshGenerator/pin_type)
- `pitch`: Pitch of outermost boundary polygon, equivalent to the input parameter [!param](/Mesh/PinMeshGenerator/pitch)
- `is_homogenized`: Whether or not pin mesh is homogenized, equivalent to the input parameter [!param](/Mesh/PinMeshGenerator/homogenized)
- `ring_radii`: Length of ring radii comprising of pin region, equivalent to the input parameter [!param](/Mesh/PinMeshGenerator/ring_radii).
- `duct_halfpitches`: Length of apothems defining the duct locations, equivalent to the input parameter [!param](/Mesh/PinMeshGenerator/duct_halfpitch)
- `ring_region_ids`: 2-D vector of region ids corresponding to radial and axial zones within ring regions of pin mesh, based on the ring-related region ids of the input parameter [!param](/Mesh/PinMeshGenerator/region_ids). Inner indexing is radial zones, while outer index is axial zones.
- `background_region_id`: 1-D vector of region_ids corresponding to axial zones of background regions of pin mesh, based on the background-related region ids of the input parameter [!param](/Mesh/PinMeshGenerator/region_ids).
- `duct_region_ids`: 2-D vector of region ids corresponding to radial and axial zones within duct regions of pin mesh, based on the duct-related region ids of the input parameter [!param](/Mesh/PinMeshGenerator/region_ids). Inner indexing is radial zones, while outer index is axial zones.

In addition, the value of the metadata `reactor_params_name` can be used to retrieve global metadata defined by [ReactorMeshParams](ReactorMeshParams.md). Please refer to [ReactorMeshParams](ReactorMeshParams.md) to see a list of metadata defined by this mesh generator.

For applications where an output mesh does not need to be created and meshing routines can consist entirely of defining reactor-based metadata, the parameter `[Mesh]`/[!param](/Mesh/MeshGeneratorMesh/data_driven_generator) can be set to the mesh generator that would generate an output mesh from RGMB metadata.

#### Example Syntax


This is the resulting mesh block layout, where by default a single block is assigned to the triangular elements and another block is assigned to the quadrilateral elements:


This is the resulting "region_id" extra element integer layout, which was chosen by setting the region IDs for each radial region within the pin:





### PolygonConcentricCircleMeshGenerator


#### Overview

      style=display: block;margin-left:auto;margin-right:auto;width:85%;
      id=sample
      caption=Typical meshes generated by this `PolygonConcentricCircleMeshGenerator` object: the left mesh consists of linear elements while the right mesh consists of quadratic elements.

The `PolygonConcentricCircleMeshGenerator` object generates a 2D mesh for concentric circles with a regular polygon enclosure with or without external ducts. Typical meshes generated by this object are shown in [Figure 1](#sample). By default, the generated mesh consists of linear elements. If quadratic elements are preferred, users can set [!param](/Mesh/PolygonConcentricCircleMeshGenerator/tri_element_type) as `TRI6` or `TRI7`, and [!param](/Mesh/PolygonConcentricCircleMeshGenerator/quad_element_type) as `QUAD8` or `QUAD9`. Polygons with 3 or more sides (e.g. triangle, square, pentagon, hexagon,...) can be meshed using this object. The central concentric circular regions (termed `rings`) as well as the peripheral polygonal regions (termed `ducts`) are optional (see [Figure 2](#schematic)). The region excluding any rings and ducts is termed the `background` region.

#### Geometry Information

The most fundamental geometry parameters that are needed by this object is:

- [!param](/Mesh/PolygonConcentricCircleMeshGenerator/num_sides): the number of sides of the polygon enclosure;
- [!param](/Mesh/PolygonConcentricCircleMeshGenerator/polygon_size_style): the style in which the parameter [!param](/Mesh/PolygonConcentricCircleMeshGenerator/polygon_size) will be given. This parameter can be either `apothem` (center to side distance) or `radius` (center to vertex distance).
- [!param](/Mesh/PolygonConcentricCircleMeshGenerator/polygon_size): the size of the polygon enclosure in terms of either `apothem` or `radius` (selected by another parameter, [!param](/Mesh/PolygonConcentricCircleMeshGenerator/polygon_size_style))

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=schematic
      caption=A schematic drawing showing the different regions that can be generated by this `PolygonConcentricCircleMeshGenerator` object.

If concentric circle regions are needed, [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_radii) must be provided to define the outer radius of each ring. If duct regions are needed, [!param](/Mesh/PolygonConcentricCircleMeshGenerator/duct_sizes) must be provided to define the inner boundary of each duct. Similar to [!param](/Mesh/PolygonConcentricCircleMeshGenerator/polygon_size), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/duct_sizes) can either be apothems or radii of the corresponding ducts, decided by [!param](/Mesh/PolygonConcentricCircleMeshGenerator/duct_sizes_style).

#### Mesh Information

The parameters that are needed for meshing can be categorized into azimuthal and radial information, which determine the mesh density.

The azimuthal mesh discretization is controlled by [!param](/Mesh/PolygonConcentricCircleMeshGenerator/num_sectors_per_side), which is a vector that has the same length as [!param](/Mesh/PolygonConcentricCircleMeshGenerator/num_sides). Each element of [!param](/Mesh/PolygonConcentricCircleMeshGenerator/num_sectors_per_side) must be an even integer, which is the number of azimuthal intervals of the corresponding side. The sides are indexed counterclockwise with the upper-right polygon side being the first side as shown in [Figure 2](#schematic).

The radial mesh discretization is controlled by separate parameters for `rings`, `background` and `ducts` regions, which are [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_intervals), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/background_intervals), and [!param](/Mesh/PolygonConcentricCircleMeshGenerator/duct_intervals), respectively.

In addition, the radial meshing density of each `rings`, `background` and `ducts` region can be biased by setting corresponding parameters, which are [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_radial_biases), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/background_radial_bias), and [!param](/Mesh/PolygonConcentricCircleMeshGenerator/duct_radial_biases), respectively. The bias value should be a positive `Real` type parameter, which is the radial dimension ratio between two radially-neighboring elements (outer to inner).

#### Boundary Layers

Aside from the general mesh radial biasing options described above, users can also define boundary layers on each `ring`, `background`, and `duct` regions. For each region, both inner and outer boundary layers are supported (in this case, inner boundary layer refers to a boundary layer on the volume closer to the center of the polygon, and outer boundary layer refers to a boundary layer on the volume further from the center of the polygon; these two volumes are separated by the boundary itself). Each boundary layer requires three key input parameters:

- `boundary layer width`: the radial width of the boundary layer within the region. Note that the summation of the inner and outer boundary layers widths must be smaller than the width of the block layer itself. The specific input parameters are [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_inner_boundary_layer_widths), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_outer_boundary_layer_widths), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/background_inner_boundary_layer_width), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/background_outer_boundary_layer_width), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/duct_inner_boundary_layer_widths), and [!param](/Mesh/PolygonConcentricCircleMeshGenerator/duct_outer_boundary_layer_widths).
- `boundary layer intervals`: the number of radial mesh intervals within the boundary layer. The specific parameters are [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_inner_boundary_layer_intervals), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_outer_boundary_layer_intervals), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/background_inner_boundary_layer_intervals), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/background_outer_boundary_layer_intervals), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/duct_inner_boundary_layer_intervals), and [!param](/Mesh/PolygonConcentricCircleMeshGenerator/duct_outer_boundary_layer_intervals).
- `boundary layer bias`: the growth factor used for radial mesh biasing for the boundary layer. The specific parameters are [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_inner_boundary_layer_biases), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_outer_boundary_layer_biases), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/background_inner_boundary_layer_bias), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/background_outer_boundary_layer_bias), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/duct_inner_boundary_layer_biases), and [!param](/Mesh/PolygonConcentricCircleMeshGenerator/duct_outer_boundary_layer_biases). A bias greater than 1 means the element size increases with increasing radial coordinate, while a bias less than 1 means the element size decreases with increasing radial coordinate. A bias of 1 indicates uniformly spaced elements with increasing radial coordinate.

If there are multiple ring/duct regions in the generated mesh, the boundary layer related parameters of all these regions must be provided together as vectors.

#### MeshMeshData Generation

When [!param](/Mesh/PolygonConcentricCircleMeshGenerator/num_sides) is set as 6, the hexagonal meshes produced by `PolygonConcentricCircleMeshGenerator` can be used by [`PatternedHexMeshGenerator`](/PatternedHexMeshGenerator.md) to create patterned meshes. This functionality relies on a series of `MeshMetaData` generated by `PolygonConcentricCircleMeshGenerator`, including:

- `pitch_meta`, type `Real`: Provides the side-to-side distance of the hexagon generated.
- `pattern_pitch_meta`, type `Real`: Similar to `pitch_meta`. This is only used when the mesh produced here is stitched with assembly hexagon meshes generated by `PatternedHexMeshGenerator`.
- `background_intervals_meta`, type `unsigned int`: Makes the value of the input parameter [!param](/Mesh/PolygonConcentricCircleMeshGenerator/background_intervals) available to other mesh generators.
- `node_id_background_meta`, type `dof_id_type`: Records the maximum node id of the background nodes to provide a reference for node modifications.
- `max_radius_meta`, type `Real`: Provides the maximum radius of the ring regions so that `PatternedHexMeshGenerator` does not compromise the circular geometry.
- `num_sectors_per_side_meta`, type `std::vector<unsigned int>`: Makes the value of the input parameter [!param](/Mesh/PolygonConcentricCircleMeshGenerator/num_sectors_per_side) available to other mesh generators.
- `azimuthal_angle_meta`, type `std::vector<Real>`: Contains the sorted azimuthal angles of all the nodes on the external boundary.

#### Reporting ID Assignment

`PolygonConcentricCircleMeshGenerator` can assign the reporting IDs for annular rings and sectors, which allows users to manipulate sub-pin level details information such as such as the depletion zone setup.
The option for ring and sector reporting IDs can be turned on by defining the input parameters [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_id_name) and [!param](/Mesh/PolygonConcentricCircleMeshGenerator/sector_id_name), respectively.

For the ring reporting IDs, each annular blocks defined by [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_radii) has its own ID values by default.
The default may be overridden by unique ID values by setting [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_id_assign_type) as `ring_wise`, if both [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_radii) and [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_intervals) are specified.

#### Other Information

By default, the mesh generated by this object contains a mixture of QUAD4 and TRI3 elements. To be specific, the central region of the mesh consists of triangular elements, whereas the rest of the mesh consists of quadrilateral elements. The users also have an option to generate a purely QUAD4 mesh by setting `quad_center_elements` as true (see [Figure 3](#TRI3_and_QUAD4)). In that case, the $\frac{N}{N+1}$ factor shown in [Figure 3](#TRI3_and_QUAD4) can also be customized using [!param](/Mesh/PolygonConcentricCircleMeshGenerator/center_quad_factor).

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=TRI3_and_QUAD4
      caption=A schematic drawing showing the different meshing algorithms when [!param](/Mesh/PolygonConcentricCircleMeshGenerator/quad_center_elements) is set as `false` and `true`.

When `rings` regions are present, the radii of these `rings` can be auto-adjusted to preserve the meshed annular area (volume) to the true area (volume) by setting [!param](/Mesh/PolygonConcentricCircleMeshGenerator/preserve_volumes) as true. The volume preservation feature is compatible with quadratic elements.

By default, the azimuthal angles used to discretize the mesh are uniformly spaced in _angle_ on each sector of the polygon. However, uniform spacing of angles leads to non-uniform mesh intervals on the polygon external sides (unless exactly 2 sectors per side are used). However, as a uniformly spaced mesh on the polygon external boundary may facilitate mesh stitching, the user may force a uniform mesh on the polygon external boundary by setting [!param](/Mesh/PolygonConcentricCircleMeshGenerator/uniform_mesh_on_sides) as true.

The default block id numbering starts with 0 at the center region and increments by 1 for each mesh region radially outward. The user may instead set specific block id and name values to rings, background, and duct regions through the use of [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_block_ids), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/background_block_ids), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/duct_block_ids), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_block_names), [!param](/Mesh/PolygonConcentricCircleMeshGenerator/background_block_names),  and [!param](/Mesh/PolygonConcentricCircleMeshGenerator/duct_block_names).

The user should be aware that in two cases, the central geometric region is defined as two blocks instead of one:
- When rings are not present, and [!param](/Mesh/PolygonConcentricCircleMeshGenerator/background_intervals) > 1 or a boundary layer is defined in this region
- When rings are present, and the first entry of [!param](/Mesh/PolygonConcentricCircleMeshGenerator/ring_intervals) > 1 or a boundary layer is defined in this region

In both of these cases, the central geometric region will contain both blocks 0 and 1 by default. Any additional usage of block ids or name arrays will require an extra entry for the first geometric region. This extra block definition is needed to accommodate flexibility in defining the central region as either quadrilateral or triangular elements while still stitching properly to the neighboring region. Note that if [!param](/Mesh/PolygonConcentricCircleMeshGenerator/quad_center_elements) is set as `true`, the central geometric region is allowed to have a uniform block id/name. This can be achieved by providing a pair of duplicated block ids/names in the corresponding customized block ids/names input parameter. The user can also provide a single customized block id/name for the central geometric region in this case and the system will duplicate the input for the user.

The external boundary has a default boundary id of 10000. The user may instead set specific boundary id and/or name values through the use of `external_boundary_id` and `external_boundary_name`. Additionally, for each half side of the polygon, an independent boundary id can be optionally generated for side-specific applications by setting [!param](/Mesh/PolygonConcentricCircleMeshGenerator/generate_side_specific_boundaries) as `true`.

##### Interface Boundaries

The user can also decide whether the interface boundaries are generated or not.

There are two types of interface boundaries, "inward interface boundaries" and "outward interface boundaries". The "inward" and "outward" here refer to the direction of the boundary's normal vector. As a sideset must be defined on the sides of elements, which belong to one or multiple subdomains, an interface boundary can be defined either on the subdomain immediately inside the interface (i.e., with an "outward" normal vector) or on the subdomain immediately outside the interface (i.e., with an "inward" normal vector).

The user can set [!param](/Mesh/PolygonConcentricCircleMeshGenerator/create_inward_interface_boundaries) and [!param](/Mesh/PolygonConcentricCircleMeshGenerator/create_outward_interface_boundaries) to control which interface boundaries will be created. If generated, the outward interface boundaries will be assigned ids using sequential odd numbers (i.e., 1, 3, 5, 7, ...) from center to periphery, while the inward interface boundaries will be assigned ids using sequential even numbers (i.e., 2, 4, 6, 8, ...) similarly. These ids can be shifted by a user-provided parameter [!param](/Mesh/PolygonConcentricCircleMeshGenerator/interface_boundary_id_shift). The interface boundary names can also be specified through [!param](/Mesh/PolygonConcentricCircleMeshGenerator/inward_interface_boundary_names) and [!param](/Mesh/PolygonConcentricCircleMeshGenerator/outward_interface_boundary_names).

#### Example Syntax





### ReactorMeshParams


#### Overview

The `ReactorMeshParams` object stores persistent mesh information about a reactor's geometry for use with [PinMeshGenerator](/PinMeshGenerator.md), [AssemblyMeshGenerator](/AssemblyMeshGenerator.md), [ControlDrumMeshGenerator](/ControlDrumMeshGenerator.md), and [CoreMeshGenerator](/CoreMeshGenerator.md). This is where the geometry type ([!param](/Mesh/ReactorMeshParams/geom) as 'Square' or 'Hex' for cartesian and hexagonal definitions respectively) and the number of dimensions of the mesh ([!param](/Mesh/ReactorMeshParams/dim) either 2 for 2D or 3 for 3D) is declared and persistently enforced for the rest of the mesh definition. If the mesh is to be 3-dimensional, this is also where the axial information is declared ([!param](/Mesh/ReactorMeshParams/axial_regions) and [!param](/Mesh/ReactorMeshParams/axial_mesh_intervals)). In addition, the global option to automatically set block names for the output mesh based on the region IDs of the mesh can be selected in this mesh generator, by setting ([!param](/Mesh/ReactorMeshParams/region_id_as_block_name) to `true`. More information about this parameter can be found in the block naming sections of [PinMeshGenerator](/PinMeshGenerator.md), [AssemblyMeshGenerator](/AssemblyMeshGenerator.md), [ControlDrumMeshGenerator](/ControlDrumMeshGenerator.md), and [CoreMeshGenerator](/CoreMeshGenerator.md). In order to enable flexible assembly stitching between [AssemblyMeshGenerator](/AssemblyMeshGenerator.md) and [ControlDrumMeshGenerator](/ControlDrumMeshGenerator.md) objects that do not share the same number of nodes at the outer assembly interface, [!param](/Mesh/ReactorMeshParams/flexible_assembly_stitching) can be set to `true`, and the number of sectors that are created at the flexible assembly boundary interface is controlled by ([!param](/Mesh/ReactorMeshParams/num_sectors_at_flexible_boundary). More information about flexible assembly stitching can be found in [CoreMeshGenerator](/CoreMeshGenerator.md).

#### Metadata Information

The `ReactorMeshParams` object stores certain global mesh information as metadata, which can be queried from subsequent RGMB-based mesh generators. A list of metadata that is generated at the pin, assembly, and core levels can be found at [PinMeshGenerator](/PinMeshGenerator.md), [AssemblyMeshGenerator](/AssemblyMeshGenerator.md), and [CoreMeshGenerator](/CoreMeshGenerator.md), respectively, while the following metadata can be queried by passing in the name of the `ReactorMeshParams` mesh generator, which is stored at each RGMB mesh generation level with the metadata name `reactor_params_name`:

- `mesh_dimensions`: Number of dimensions in pin mesh, equivalent to  [ReactorMeshParams](ReactorMeshParams.md)/[!param](/Mesh/ReactorMeshParams/dim)
- `mesh_geometry`: Whether pin geometry is hexagonal ("Hex") or Cartesian ("Square"), equivalent to  [ReactorMeshParams](ReactorMeshParams.md)/[!param](/Mesh/ReactorMeshParams/geom)
- `axial_mesh_sizes`: Length of each axial region, equivalent to  [ReactorMeshParams](ReactorMeshParams.md)/[!param](/Mesh/ReactorMeshParams/axial_regions). Only relevant for 3-D meshes.
- `axial_mesh_intervals`: Number of elements in the axial dimension for each axial region, equivalent to [ReactorMeshParams](ReactorMeshParams.md)/[!param](/Mesh/ReactorMeshParams/axial_mesh_intervals). Only relevant for 3-D meshes.

#### Example Syntax





### RevolveGenerator


#### Overview

This `RevolveGenerator` provides an alternative tool for increasing the dimensionality of a lower dimension mesh (1D or 2D) in addition to [MeshExtruderGenerator](MeshExtruderGenerator.md)/[AdvancedExtruderGenerator](AdvancedExtruderGenerator.md). Each element is converted
to one or more copies of its corresponding higher dimensional element along an open or closed specific circular curve.

The `RevolveGenerator` can provides similar customization options as in [AdvancedExtruderGenerator](AdvancedExtruderGenerator.md).

#### Revolving Basics

`RevolveGenerator` revolves a lower-dimension mesh (1D or 2D) given by [!param](/Mesh/RevolveGenerator/input) into a higher-dimension mesh (2D or 3D) along an revolving axis defined by [!param](/Mesh/RevolveGenerator/axis_point) and [!param](/Mesh/RevolveGenerator/axis_direction). By default, the revolving can be performed along a full closed circular curve (i.e., 360 degrees) with one uniform azimuthal section. Optionally, the revolving curve can be a partial circular curve; and (or) multiple azimuthal sections can be defined. These options can be selected by specifying [!param](/Mesh/RevolveGenerator/revolving_angles). As long as the summation of the angles listed in [!param](/Mesh/RevolveGenerator/revolving_angles) is 360 degrees, a full closed circular revolving is performed. Otherwise, a partial revolving is conducted. For partial revolving or full revolving with multiple azimuthal sections, it can be conducted either clockwise or counter-clockwise, as controlled by [!param](/Mesh/RevolveGenerator/clockwise).

Each azimuthal sections can have separate subdomains, extra element extra integers, and boundaries defined. The number of azimuthal elements in the different sections can be provided through [!param](/Mesh/RevolveGenerator/nums_azimuthal_intervals).

#### Subdomain ID Remapping

By default, the revolved higher-dimension elements retain the same subdomain ids as their original lower-dimension elements. `RevolveGenerator` provides an option to remap subdomain ids for each azimuthal section through [!param](/Mesh/RevolveGenerator/subdomain_swaps), which is a double indexed array input parameter. Each elemental vector of [!param](/Mesh/RevolveGenerator/subdomain_swaps) contains subdomain remapping information for a particular elevation, where the first elemental vector represents the first revolved azimuthal section. The elemental vector contain pairs of subdomain ids: the first subdomain id is the `input` mesh subdomain id that needs to be remapped, and the second subdomain id the new subdomain id to be assigned.

#### Extra Element Integer ID Remapping

Extra element integer ID remapping works in a similar manner as subdomain ID remapping. The extra element integers to be remapped must already exist in the `input` mesh and need to be specified in [!param](/Mesh/RevolveGenerator/elem_integer_names_to_swap). The remapping information of multiple extra element integers is provided as a triple-indexed array input parameter ([!param](/Mesh/RevolveGenerator/elem_integers_swaps)). For each extra element integer, the syntax is similar to [!param](/Mesh/RevolveGenerator/subdomain_swaps). The following input example shows the remapping of two extra element integers.


#### Boundary ID Remapping

Boundary ID remapping also works similarly to subdomain ID remapping. During revolving, the lower-dimension boundaries are also converted into higher-dimension boundaries. A double indexed array input parameter, [!param](/Mesh/RevolveGenerator/boundary_swaps), can be used to remap the boundary ids. Here, the boundary ids to be remapped must exist in the `input` mesh, otherwise, dedicated boundary defining mesh generators, such as [SideSetsBetweenSubdomainsGenerator](SideSetsBetweenSubdomainsGenerator.md) and [SideSetsAroundSubdomainGenerator](SideSetsAroundSubdomainGenerator.md), need to be used to define new boundary ids along different azimuthal sections.

#### Example Syntax





### SimpleHexagonGenerator


#### Overview

SimpleHexagonGenerator is a simple version of [PolygonConcentricCircleMeshGenerator](/PolygonConcentricCircleMeshGenerator.md). This mesh generator meshes a simple hexagon with no pin. This mesh generator is commonly used to mesh homogenized pins or assemblies with either 6 triangular elements (default option, [!param](/Mesh/SimpleHexagonGenerator/element_type) as `TRI`) or 2 quadrilateral elements ([!param](/Mesh/SimpleHexagonGenerator/element_type) as `QUAD`, see [simple_hex_quad]). No additional azimuthal or radial discretizations are permitted with these two options.

A third option is available to introduce additional radial layers in the form of concentric hexagonal zones using [!param](/Mesh/SimpleHexagonGenerator/element_type) as `HYBRID`. In that case, the azimuthal discretization is identical to the TRI case (`num_sectors_per_side` = {1, 1, 1, 1, 1, 1}) but the mesh can now have multiple radial layers of elements (i.e. triangular elements in the center and quadrilateral elements in the outer layers as shown in [simple_hex_hybrid]). The number of layers is specified by [!param](/Mesh/SimpleHexagonGenerator/radial_intervals). It is important to note that this option creates two separate subdomains (one for TRI elements, one for QUAD elements), and requires two separate subdomain IDs rather than one.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=simple_hex
      caption=A schematic drawing showing a typical simple hexagonal mesh generated by this `SimpleHexagonGenerator` object with [!param](/Mesh/SimpleHexagonGenerator/element_type) as `TRI`.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=simple_hex_quad
      caption=A hexagonal mesh generated by `SimpleHexagonGenerator` with [!param](/Mesh/SimpleHexagonGenerator/element_type) as `QUAD`.

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=simple_hex_hybrid
      caption=A hexagonal mesh generated by `SimpleHexagonGenerator` with [!param](/Mesh/SimpleHexagonGenerator/element_type) as `HYBRID` (note the additional radial discretizations).

This mesh generator creates the same `MeshMetaData` as `PolygonConcentricCircleMeshGenerator`. The produced mesh can be used as inputs to [PatternedHexMeshGenerator](/PatternedHexMeshGenerator.md).

#### Example Syntax





### SubdomainExtraElementIDGenerator


#### Overview

The `SubdomainExtraElementIDGenerator` assigns extra element IDs based on mesh subdomain IDs of an input mesh.
If the extra element IDs do not exist in the input mesh, this mesh generator will add them.
The [!param](/Mesh/SubdomainExtraElementIDGenerator/subdomains) parameter can accept both subdomain names and subdomain IDs.
The [!param](/Mesh/SubdomainExtraElementIDGenerator/extra_element_ids) parameter is a two-dimensional vector separated by semicolon and then white space as normal MOOSE input syntax for two-dimensional vectors.
Its first dimensionality must be equal to the size of the [!param](/Mesh/SubdomainExtraElementIDGenerator/extra_element_id_names) parameter and the size of each sub-vector must be equal to the size of the [!param](/Mesh/SubdomainExtraElementIDGenerator/subdomains) parameter.


In the above sample input, we have four subdomains listed in the [!param](/Mesh/SubdomainExtraElementIDGenerator/subdomains) parameter and three extra element id names in the [!param](/Mesh/SubdomainExtraElementIDGenerator/extra_element_id_names) parameter, thus we have two semicolons in [!param](/Mesh/SubdomainExtraElementIDGenerator/extra_element_ids) to separate the numbers into three groups for the three id names accordingly and each group has four numbers corresponding to the four subdomains.

Default element IDs can be provided through [!param](/Mesh/SubdomainExtraElementIDGenerator/default_extra_element_ids) for elements in subdomains that are not specified in the [!param](/Mesh/SubdomainExtraElementIDGenerator/subdomains) parameter.
Because of this, [!param](/Mesh/SubdomainExtraElementIDGenerator/default_extra_element_ids) is active only when the [!param](/Mesh/SubdomainExtraElementIDGenerator/subdomains) parameter does not include all mesh subdomains.

If [!param](/Mesh/SubdomainExtraElementIDGenerator/default_extra_element_ids) is not set and [!param](/Mesh/SubdomainExtraElementIDGenerator/subdomains) does not contain all mesh subdomains, when the extra element IDs already existed in the mesh,
the extra IDs for those elements of the missing subdomains will not be changed; or when the extra element IDs are newly added by this mesh generator, invalid IDs are set to elements of those missing subdomains.




### TriPinHexAssemblyGenerator


#### Overview

The `TriPinHexAssemblyGenerator` object generates a 2D hexagonal assembly mesh consisting of three diamond sections. Each of these sections may contain one pin defined as a series of concentric circles. An example of such an assembly mesh is illustrated in [assembly].

      style=display: block;margin-left:auto;margin-right:auto;width:40%;
      id=assembly
      caption=A typical mesh generated by this `TriPinHexAssemblyGenerator` object with one large-circular-pin section, one small-circular-pin section, and one pin-free section.

The size of the assembly is defined by [!param](/Mesh/TriPinHexAssemblyGenerator/hexagon_size). Users can input either radius (which is the same as side length for a hexagon) or apothem of the hexagon by setting [!param](/Mesh/TriPinHexAssemblyGenerator/hexagon_size_style). On each side of the hexagon, the azimuthal meshing density is controlled by [!param](/Mesh/TriPinHexAssemblyGenerator/num_sectors_per_side). The nodes on each side are =+uniformly distributed+=.

The hexagon is naturally divided azimuthally into three diamond sections. The first diamond section has an optional pin at 12 o'clock (90 degrees) from the center of the hexagon; the second diamond section has an optional pin at 8 o'clock (210 degrees); and the third diamond section has an optional pin at 4 o'clock (330 degrees). [!param](/Mesh/TriPinHexAssemblyGenerator/ring_radii) is a 2D vector parameter that is used to define concentric ring regions within the diamond sections from one through three. [!param](/Mesh/TriPinHexAssemblyGenerator/ring_intervals) defines the number of radial meshing subintervals for each of the concentric rings. Optionally, [!param](/Mesh/TriPinHexAssemblyGenerator/ring_block_ids) and [!param](/Mesh/TriPinHexAssemblyGenerator/ring_block_names) can be used to assign block ids/names to these rings. For all the four aforementioned ring-related parameters, if only one vector is provided instead of three, the same ring parameters will be adopted for all three sections, providing a concise way to define 3 identical pins. The default center of a pin is halfway between the hexagon center and a vertex point (half the hexagon's radius). The center of the pin may be offset radially from the center of the diamond by a distance defined by [!param](/Mesh/TriPinHexAssemblyGenerator/ring_offset). A positive [!param](/Mesh/TriPinHexAssemblyGenerator/ring_offset) means the center of the concentric rings is radially offset towards to the assembly boundary. A negative [!param](/Mesh/TriPinHexAssemblyGenerator/ring_offset) means the center of the concentric rings is radially offset closer to the assembly center. Users can set [!param](/Mesh/TriPinHexAssemblyGenerator/preserve_volumes) as `true` to correct the polygonization effect and preserve ring volume.

The nodes on each interface between the two diamond sections are also =+uniformly distributed+= with the same number of nodes determined by [!param](/Mesh/TriPinHexAssemblyGenerator/num_sectors_per_side). Therefore, the azimuthal intervals of each diamond section are non-uniform and are determined based on three factors: [!param](/Mesh/TriPinHexAssemblyGenerator/num_sectors_per_side), [!param](/Mesh/TriPinHexAssemblyGenerator/ring_offset) and the constraints due to the uniformly distributed nodes on external sides as well as interfaces between diamond sections.

Each diamond section also contains a "background" region, which is the region outside the concentric rings (or the full diamond, if no rings are present). The background radial intervals and block id of each diamond can be defined by [!param](/Mesh/TriPinHexAssemblyGenerator/background_intervals) and [!param](/Mesh/TriPinHexAssemblyGenerator/background_block_ids)/[!param](/Mesh/TriPinHexAssemblyGenerator/background_block_names). In most cases, [!param](/Mesh/TriPinHexAssemblyGenerator/background_block_ids) and [!param](/Mesh/TriPinHexAssemblyGenerator/background_block_names) have a length of one if provided. However, if there exists a least one ring-free section, lengths of [!param](/Mesh/TriPinHexAssemblyGenerator/background_block_ids) and [!param](/Mesh/TriPinHexAssemblyGenerator/background_block_names) need to be two to accommodate the additional triangular element region required when no pin exists at the center of the diamond.

The `TriPinHexAssemblyGenerator` generates a complete set of `MeshMetaData` needed for future stitching with other assemblies. Therefore, meshes generated by this object can be directly used in [!param](/Mesh/PatternedHexMeshGenerator/inputs) of [`PatternedHexMeshGenerator`](/PatternedHexMeshGenerator.md) to form a core mesh.

As mentioned, by default (i.e., [!param](/Mesh/TriPinHexAssemblyGenerator/assembly_orientation) is set as `pin_up`), the first section is at 12 o'clock. The assembly can be rotated by 180$^{\circ}$ by setting [!param](/Mesh/TriPinHexAssemblyGenerator/assembly_orientation) as `pin_down`.

Optionally, users can also assign an element extra integer for each diamond sections. The name of the element extra integer is defined by [!param](/Mesh/TriPinHexAssemblyGenerator/pin_id_name), while the assigned values of the three sections are defined by a three-element vector parameter, [!param](/Mesh/TriPinHexAssemblyGenerator/pin_id_values). If [!param](/Mesh/TriPinHexAssemblyGenerator/assembly_orientation) is set as `pin_up`, the first element of [!param](/Mesh/TriPinHexAssemblyGenerator/pin_id_values) is assigned to the top section; the second element is assigned to the lower-left section; and the third element is assigned to the lower-right section. On the other hand,  If [!param](/Mesh/TriPinHexAssemblyGenerator/assembly_orientation) is set as `pin_down`, the first element of [!param](/Mesh/TriPinHexAssemblyGenerator/pin_id_values) is assigned to the bottom section; the second element is assigned to the upper-right section; and the third element is assigned to the upper-left section.
Additionally, users can assign the element extra integers ([reporting IDs](PolygonConcentricCircleMeshGenerator.md#reporting-id-assignment)) for annular rings and sectors by defining [!param](/Mesh/TriPinHexAssemblyGenerator/ring_id_name) and [!param](/Mesh/TriPinHexAssemblyGenerator/sector_id_name), respectively.

#### Example Syntax





## positions

### CartesianGridPositions


Certain pins may be excluded using the [!param](/Positions/CartesianGridPositions/pattern)
and [!param](/Positions/CartesianGridPositions/include_in_pattern)
parameter. The last two `CartesianGridPositions` objects created in the following snippet
display this feature by only including the '1' position in the pattern.





### HexagonalGridPositions


Certain pins may be excluded using the [!param](/Positions/HexagonalGridPositions/pattern)
and [!param](/Positions/HexagonalGridPositions/include_in_pattern)
parameter. The last two `HexagonalGridPositions` objects created in the following snippet
display this feature by excluding the '2' or the '3' positions in the pattern.
Note that the pattern is rotated 30 degrees clockwise in the positions created.





# Richards Module

The Richards module is deprecated and will be removed. Please use the PorousFlow module instead. If
Richards contains functionality not included in PorousFlow, please reach out to the 
[MOOSE Discussion forum](https://github.com/idaholab/moose/discussions).


# Scalar Transport Module

## bcs

### BinaryRecombinationBC


#### Overview

This class implements a weak form corresponding to

\begin{equation}
\int_{\Omega} \psi_i K_r uv d\Omega
\end{equation}

where $K_r$ is the recombination coefficient specified as a material property with [!param](/BCs/BinaryRecombinationBC/Kr),
$u$ corresponds to [!param](/BCs/BinaryRecombinationBC/variable) and $v$ is a coupled variable specified by [!param](/BCs/BinaryRecombinationBC/v).
As the name states, this class is meant to model binary recombination
reactions occurring at a boundary.




### DissociationFluxBC


#### Overview

This class implements a weak form corresponding to

\begin{equation}
- \int_{\Omega} \psi_i K_d v d\Omega
\end{equation}

where $K_d$ is a dissociation coefficient specified as a material property with [!param](/BCs/DissociationFluxBC/Kd) and
$v$ is the coupled variable specified with [!param](/BCs/DissociationFluxBC/v) that is
dissociating at the boundary to create the species corresponding to
[!param](/BCs/DissociationFluxBC/variable).




## kernels

### BodyForceLM


#### Overview

This object is equivalent to [BodyForce.md] except it adds its residual both to
the primal equation on which the body force is being applied and to a Lagrange
Multiplier (LM) equation when an LM is present. We can use an LM for enforcing
non-negative concentrations, but its introduction generally leads to creation of
a saddle point problem. However, by adding primal equation components to the LM
equation, we create a consistent stabilization that removes the saddle
point. See [LMKernel.md] for more details.




### CoupledForceLM


#### Overview

This object is equivalent to [CoupledForce.md] except it adds its residual both to
the primal equation on which the coupled force is being applied and to a Lagrange
Multiplier (LM) equation when an LM is present. We can use an LM for enforcing
non-negative concentrations, but its introduction generally leads to creation of
a saddle point problem. However, by adding primal equation components to the LM
equation, we create a consistent stabilization that removes the saddle
point. See [LMKernel.md] for more details.




### LMDiffusion


#### Overview

This class adds the strong form of [CoefDiffusion.md] to a Lagrange
Multiplier (LM) equation when an LM is present for enforcing non-negative
concentrations and when we are trying to remove the saddle point due to no
on-diagonal dependence in the LM equation. See [LMKernel.md] for more details.




### LMKernel

`LMKernel` enables stabilization of Lagrange multiplier (LM) methods in which
the Lagrange multiplier residual equation does not have any on-diagonal
dependence, e.g. dependence on itself. This is a saddle point problem. Use of
`LMKernel` is akin to a pressure-stabilized Petrov-Galerkin formulation for
incompressible Navier-Stokes in which the strong form of the momentum equation
is added to the mass equation. Because the momentum equation contains the
Lagrange multiplier (pressure in this case), addition of it to the mass equation
introduces on-diagonal dependence for the LM. For species transport, a user may
wish to introduce a Lagrange multiplier that ensures the species concentration
is always non-negative. This LM will appear in the (primal) species mass
transport equation in the following way. Let's assume that the mass transport
equation (without the LM) looks like:

\begin{equation}
\frac{\partial u}{\partial t} - \nabla \cdot \nabla u = f
\end{equation}

where $u$ is the primal variable and $f$ is some arbitrary source or sink. When
trying to enforce positivity of $u$ we introduce the LM into the primal equation
like so:

\begin{equation}
\label{eq:primal}
\frac{\partial u}{\partial t} - \nabla \cdot \nabla u - \lambda = f
\end{equation}

where $\lambda$ is the value of the Lagrange multiplier. The corresponding LM
equation will be a nonlinear complementarity problem (NCP) function of the form

\begin{equation}
\text{min}\left(\lambda, u\right)
\end{equation}

This NCP function ensures the following conditions:

\begin{equation}
\begin{aligned}
\label{eq:conditions}
\lambda &\geq 0\\
u &\geq 0\\
\lambda u &= 0
\end{aligned}
\end{equation}

Examining [!eqref](eq:conditions) it's clear that positive values of $\lambda$ (required
by [!eqref](eq:conditions)) will introduce a source in the primal equation. $\lambda$
will "automatically" adjust itself such that $u$ never drops below zero.  When
$u < \lambda$ the LM is no longer present in its own residual equation and we
have a saddle point problem. However, by adding the strong form of the species
mass transport equation to the LM residual equation, on-diagonal dependence is
restored because of the presence of the LM in the primal equation. This removes
the saddle point and allows use of a much wider range of preconditioners.

### TimeDerivativeLM


#### Overview

This object is equivalent to [TimeDerivative.md] except it adds its residual both to
the primal equation containing the time derivative and to a Lagrange
Multiplier (LM) equation when an LM is present. We can use an LM for enforcing
non-negative concentrations, but its introduction generally leads to creation of
a saddle point problem. However, by adding primal equation components to the LM
equation, we create a consistent stabilization that removes the saddle
point. See [LMKernel.md] for more details.




## physics

### MultiSpeciesDiffusionCG


This [Physics](syntax/Physics/index.md) implements the same kernels and boundary conditions as the [DiffusionCG.md] `Physics` does,
but for every species specified.




# Solid Mechanics Module

- [System Documentation List](solid_mechanics/systems.md)

The Solid Mechanics module is a library of simulation tools that solve
continuum mechanics problems. It provides a simple approach for implementing
even advanced mechanics models:

- Plug-n-play design enables users to incorporate the relevant physics for specific and varied simulations
- Tensor implementation matches mathematical theory
- Straight-forward procedure for adding new physics

The solid mechanics system can be used to simulate both linear and finite strain mechanics, including
Elasticity and Cosserat elasticity, Plasticity and micromechanics plasticity, Creep, and
Damage due to cracking and property degradation

## Explore the Capabilities and Start Modeling

The +Solid Mechanics module+ is used in a variety of pure mechanics simulations
and in combined physics simulations with the Heat Transfer, Phase Field, Contact,
Porous Flow, and XFEM modules; use the MOOSE combined module to perform simulations
with multiple physics modules. The following figures show results from a few
different simulations performed by solid mechanics module users.


       style=width:34%;float:right;padding-top:2.5%;
       caption=Evolution of rock failure zone in a 300m-wide, 400m-deep panel in a coal mining application.

       style=width:32%;float:right;margin-left:1%;margin-right:1%;
       caption=Evolution of the resolved shear stress on the $\mathrm{{[}112{]}(11\bar{1})}$ slip system in a polycrystalline simulation of BCC Iron.

       style=width:32%;float:right;
       caption=Thermo-mechanical stress analysis of a reactor pressure vessel.



Interested in performing some of these simulations yourself? Use the links below
to learn more about the solid mechanics module and to get started with your own
continuum mechanics and combined physics simulations.


### Plug-n-Play Structure Overview class=center style=font-weight:200;

Familiarize yourself with the [Plug-n-Play Structure](solid_mechanics/plug_n_play.md)
used by solid mechanics and then dive into the mathematical theory:

- [Strain Calculations](solid_mechanics/Strains.md)
- [Stress Models](solid_mechanics/Stresses.md)
- [Stress Divergence](solid_mechanics/StressDivergence.md)
- [Tensor Definitions](solid_mechanics/TensorClasses.md)

These types of code classes make up the core of the solid mechanics module.



### Examples and Tutorials class=center style=font-weight:200;

Get started running your own solid mechanics simulations by exploring the
introductory tutorials and examples. Next browse through the information:

- [Introduction](solid_mechanics/tutorials/introduction/index.md)
- [Visualizing Tensors](solid_mechanics/VisualizingTensors.md)
- [Setting Convergence Criteria](solid_mechanics/Convergence.md)
- [Module Documentation List](solid_mechanics/systems.md)

Now you're ready to start creating your own mechanics simulations.



### Advanced Features class=center style=font-weight:200;

Explore the different ways to use the solid mechanics module by browsing the
introductory theory pages on the various models:

- [Volumetric Locking Correction](solid_mechanics/VolumetricLocking.md)
- [Smeared Cracking](/ComputeSmearedCrackingStress.md)
- [Multiple Inelastic Stresses](/ComputeMultipleInelasticStress.md)
- [Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
- [Fracture Integrals](solid_mechanics/FractureIntegrals.md)
- [Crystal Plasticity](/ComputeMultipleCrystalPlasticityStress.md)
- [C0 Timoshenko Beam](solid_mechanics/C0TimoshenkoBeam.md)
- [Dynamics](solid_mechanics/Dynamics.md)
- [Viscoplasticity](/ADViscoplasticityStressUpdate.md)
- [Cohesive Zone Modeling](CohesiveZone/index.md)
- [Shell elements](solid_mechanics/ShellElements.md)
- [Reduced Order Models](/LAROMANCE.md)
- [Frequency Domain Dynamics](/1d_elastic_waves.md)
- [Isogeometric Analysis](solid_mechanics/examples/cframe_iga.md)
- [NEML2 material models](solid_mechanics/NEML2.md)

## New Mechanics Kernels

The Solid Mechanics module currently has two, partially interoperable
underlying systems:

- The current system based on the [StressDivergenceTensors](/StressDivergenceTensors.md) and related kernels.
- A newer system based on the [TotalLagrangianStressDivergence](/TotalLagrangianStressDivergence.md) and [UpdatedLagrangianStressDivergence](/UpdatedLagrangianStressDivergence.md) kernels.

The current system may suffer from convergence issues caused by non-exact Jacobians for large deformations problems when not used with the Automatic Differentiation variants of the kernels and underlying materials.
The newer system (referred to in the documentation as the *Lagrangian* kernels) has exact Jacobians and also includes:

- A [common interface](solid_mechanics/LagrangianKernelTheory.md) for running small or large deformation problems that simplifies how input files are setup and makes it easier to switch between different kinematic and material models.
- An [improved material system](solid_mechanics/NewMaterialSystem.md), that provides multiple options for implementing new materials models.  The new material system can also automatically convert a small deformation material model to large deformation kinematics by integrating a user-select objective stress rate.
- Both [total Lagrangian](/TotalLagrangianStressDivergence.md) and [updated Lagrangian](/UpdatedLagrangianStressDivergence.md) formulations.
- A [homogenization system](/solid_mechanics/Homogenization.md) designed to enforce cell-average deformation or stress conditions over a periodic unit cell.
- [Stabilization for linear elements](/solid_mechanics/Stabilization.md) for use in incompressible or nearly-incompressible problems through a $\bar{\boldsymbol{F}}$ formulation.

The newer kernels are compatible with the existing MOOSE materials via the [ComputeLagrangianWrappedStress](/ComputeLagrangianWrappedStress.md) object.  This object maps the output from the existing MOOSE material system into the format expected
by the Lagrangian kernels.

The Lagrangian kernels are feature-complete with the original kernels -- all simulations using the original kernels should be able to be converted to use the
Lagrangian kernels.  However, users should be aware that modules that couple to `"stress"` for the Cauchy stress using the original kernels should now either couple to `"cauchy_stress"` or `"pk1_stress"`, as appropriate, in the Lagrangian kernels.

Users should consider using the new system
for problems where numerical convergence is critical -- for example problems with large material or geometric nonlinearities -- or
for problems where the stress update provided by the constitutive model is very expensive, as the new kernels will achieve convergence
in many fewer nonlinear iterations, when compared to the older system.

Both the new and old systems are accessible through the [SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md), which simplifies the process of
setting up and running models.

## Developing New Solid Mechanics Code

The SolidMechanics module is being developed by users at national laboratories
and universities around the world. Learn how to get in touch with the developers
on the [help/contact_us.md optional=True] page.

Consider becoming a developer yourself.
The solid mechanics module uses code syntax based on tensor forms. This approach
allows the constitutive tensor equations to be implemented, clearly and concisely,
in the same format as written in mathematical notation.
Follow the MOOSE standards for [contributing](framework/contributing.md).

## Software Quality

The Solid Mechanics module follows strict software quality guidelines, refer to
[Solid Mechanics SQA](solid_mechanics/sqa/index.md) for more information.

## actions

### Cavity Pressure Action

#### Description

The `CavityPressureAction` is one of three actions in the [CavityPressure](/CavityPressure/index.md) action system which are
intended to be used concurrently.  The intention of the `CavityPressure` action system is to reduce
the number of input file blocks required to compute the pressure exerted by a gas contained in an
internal volume.

### Cavity Pressure Postprocessor Action

#### Description

The `CavityPressurePPAction` is one of three actions in the [CavityPressure](/CavityPressure/index.md) action system which are
intended to be used concurrently.  The intention of the `CavityPressure` action system is to reduce
the number of input file blocks required to compute the pressure exerted by a gas contained in an
internal volume.

### Cavity Pressure UserObject Action

#### Description

The `CavityPressurePPAction` is one of three actions in the [CavityPressure](/CavityPressure/index.md) action system which are
intended to be used concurrently.  The intention of the `CavityPressure` action system is to reduce
the number of input file blocks required to compute the pressure exerted by a gas contained in an
internal volume.

### CohesiveZoneAction


The `CohesiveZoneAction` creates the [Cohesive Zone Model](syntax/Physics/SolidMechanics/CohesiveZone/index.md) on an interface in the mesh. It does so by creating the necessary interface kernels, materials, auxiliary variables and kernels.


### Cohesive Zone Action

#### Description

The `CohesiveZoneAction` simplifies the input file syntax by adding the appropriate `CZMInterfaceKernels`, `ComputeDisplacementJump`, and `ComputeGlobalTraction` objects depending on the selected kinematic. See [CohesiveZone](CohesiveZone/index.md) for more details.


### CommonCohesiveZoneAction

#### Description

This `CommonCohesiveZoneAction` action adds the parameters supplied at the `[/Physics/SolidMechanics/CohesiveZone]` level as defaults for all the subblocks within the `CohesiveZone` block. See the description, example use, and parameters on the [SolidMechanics/CohesiveZone](/Physics/SolidMechanics/CohesiveZone/index.md) action system page.

It performs the same action for the deprecated `[Modules/TensorMechanics/CohesiveZoneMaster]` syntax.



### Common Line Element QuasiStatic Physics

#### Description

This `CommonLineElement` action adds the parameters supplied at the `[/Physics/SolidMechanics/LineElement/QuasiStatic]` level as defaults for all the subblocks within the LineElement/QuasiStatic block. See the description, example use, and parameters on the [LineElement/QuasiStatic](/LineElement/QuasiStatic/index.md) action system page.

### Common Solid Mechanics Action

#### Description

This `CommonSolidMechanicsAction` action adds the parameters supplied at the `[/Physics/SolidMechanics/QuasiStatic]` level as defaults for all the subblocks within the `QuasiStatic` block. See the description, example use, and parameters on the [SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md) action system page.

It performs the same action on the deprecated `[Modules/TensorMechanics/Master]` and
`[Modules/TensorMechanics/DynamicMaster]` syntaxes.

### Common Tensor Mechanics Action

#### Description

This `CommonTensorMechanicsAction` action adds the parameters supplied at the `[/Physics/SolidMechanics/QuasiStatic]` level as defaults for all the subblocks within the `QuasiStatic` block. See the description, example use, and parameters on the [SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md) action system page.

It performs the same action on the deprecated `[Modules/TensorMechanics/Master]` and
`[Modules/TensorMechanics/DynamicMaster]` syntaxes.

### Coupled Pressure Action

#### Description

The `CoupledPressure` Action is used to create a set of pressure boundary conditions for a string of displacement variables; the typical use case for this action is when the pressure is computed in a field variable, for example by a multi-app. See the description, example use, and parameters on the [CoupledPressure](/CoupledPressure/index.md) action system page.

### DomainIntegralAction


#### Description

The `DomainIntegral` action is used to set up all of the objects used in computing all fracture domain integrals, including the $J$-integral, interaction integral, and T-stress. To use the fracture domain integrals, one must set up a model that incorporates a crack using one of two techniques:

Meshed crack: The crack can be explicitly included by creating a mesh with a topology that conforms to the crack. The location of the crack tip is provided to the code by defining a nodeset that includes all nodes in the finite element mesh that are located along the crack front. For 2D analyses, this nodeset would only contain a single node at the crack tip.  For 3D analyses, the mesh connectivity is used to construct a set of line segments that connect these nodes, and this is used to order the crack nodes.

XFEM: Rather than defining the topology of the crack through the mesh, XFEM can be used to cut the mesh. In this case, a set of points, which does not need to conform to points in the mesh, must be provided by the user, and is used to define the location of the crack for computing the fracture integrals. Fracture integrals are computed at the locations of these points, in the order provided by the user.  If the `DomainIntegral` is setting up an [InteractionIntegral.md] being used as a growth criterion for the XFEM crack, i.e. [!param](/DomainIntegral/DomainIntegralAction/used_by_xfem_to_grow_crack) = true, the [CrackFrontDefinition.md] must be executed before the `DomainIntegral` vectorpostprocessors.  This is done by default in the `DomainIntegral` action which sets the the `CrackFrontDefinition` [!param](/UserObjects/CrackFrontDefinition/execution_order_group) to -1.

#### Theory

Details on the theory behind the computation of the various fracture integrals are provided [here](FractureIntegrals.md).

#### Objects created by this Action

| Class                                            | Type                | Functionality |
|--------------------------------------------------|---------------------|---------------|
| [JIntegral](JIntegral.md)                        | VectorPostprocessor | Computes $J$-Integral at all points on crack front for a given integration ring |
| [InteractionIntegral](InteractionIntegral.md)    | VectorPostprocessor | Computes $K_I$, $K_{II}$, $K_{III}$, or $T$ stress using interaction integral at all points on crack front for a given integration ring |
| [MixedModeEquivalentK](MixedModeEquivalentK.md)  | VectorPostprocessor | Computes an equivalent stress intensity factor from $K_I$, $K_{II}$, and $K_{III}$ |
| [CrackFrontDefinition](CrackFrontDefinition.md)  | UserObject | Defines crack front and provides geometry-related functions used by [JIntegral](JIntegral.md) and [InteractionIntegral](InteractionIntegral.md) |
| [VectorPostprocessorComponent](VectorPostprocessorComponent.md) | Postprocessor | Reports individual quantities computed by VectorPostprocessors at a specific point on the crack front |
| [CrackFrontData](CrackFrontData.md) | Postprocessor | Reports values of requested variables at crack front points |
| [VectorOfPostprocessors](VectorOfPostprocessors.md) | VectorPostprocessor | Assembles CrackFrontData values into a vector for output |
| [ThermalFractureIntegral](ThermalFractureIntegral.md) | Material | Computes derivative of all eigenstrains with respect to temperature for use in fracture integrals |
| [StrainEnergyDensity](StrainEnergyDensity.md) | Material | Computes strain energy density for use in fracture integrals |
| [DomainIntegralQFunction](DomainIntegralQFunction.md) | AuxKernel | Optionally populates AuxVariables with values of the geometry-based q function when `output_q=true` |
| [DomainIntegralTopologicalQFunction](DomainIntegralTopologicalQFunction.md) | AuxKernel | Optionally populates AuxVariables with values of the topology-based q function when `output_q=true` |


### DynamicTensorMechanics


#### Description

This action creates the [DynamicStressDivergenceTensors](/DynamicStressDivergenceTensors.md) kernel input blocks in all coordinate directions. More information about the usage of this action can be found at [Dynamics](/Dynamics.md)

This action is deprecated. Please use the [DynamicSolidMechanicsPhysics.md] `Physics` syntax instead.


### Generalized Plane Strain Action

#### Description

This action simplifies the input file syntax for creating a generalized plane strain model. It creates the following MOOSE objects (i.e. Kernel, ScalarKernel and UserObject) related to the out-of-plane scalar variable.

##### Kernel

- [Generalized Plane Strain Off-diagonal Kernel](/GeneralizedPlaneStrainOffDiag.md): in-plane displacement variables and scalar out-of-plane strain coupling

##### ScalarKernel

- [Generalized Plane Strain ScalarKernel](/GeneralizedPlaneStrain.md): out-of-plane equilibrium condition

##### UserObject

- [Generalized Plane Strain UserObject](/GeneralizedPlaneStrainUserObject.md): residual and diagonal Jacobian calculation for scalar out-of-plane strain variable

#### Generalized Plane Strain and Reference Residual

Generalized plane strain problems may use `ReferenceResidualProblem`. In this case, a reference scalar variable is needed to correspond with the scalar strain variable.


The reference scalar variable is set using the `AuxScalarKernel` [Generalized Plane Strain Reference Residual](/GeneralizedPlaneStrainReferenceResidual.md) using the [Generalized Plane Strain UserObject](/GeneralizedPlaneStrainUserObject.md).




### Global Strain Action


This action simplifies the input file syntax for global strain calculation required for maintaining strain periodicity. It also generates the auxiliary displacement field created by the global strain. It creates following MOOSE objects,

##### UserObject

- [Global Strain UserObject](/GlobalStrainUserObject.md): Calculates the residual and jacobian corresponding to the scalar variable

##### ScalarKernel

- [Global Strain ScalarKernel](/GlobalStrain.md): Solves for the global strain in terms of the scalar variable

##### Material

- [Global Strain Material](/ComputeGlobalStrain.md): Calculates the global strain components from the scalar variable

##### AuxVariables

- [Global Displacement AuxVariables](/GlobalDisplacementAux.md): Creates AuxVariables for each additional displacement components

##### AuxKernels

- [Global Displacement AuxKernels](/GlobalDisplacementAux.md): Calculates the global displacement field from the scalar variable



### InclinedNoDisplacementBC Action

#### Description

The `InclinedNoDisplacementBC` Action is used to create a set of InclinedNoDisplacementBC for a string of displacement variables. See the description, example use, and parameters on the [InclinedNoDisplacementBC](/InclinedNoDisplacementBC/index.md) action system page.

### Legacy Kernel-Only Dynamic Solid Mechanics Action

This legacy action will soon be deprecated in favor of the more inclusive
+[SolidMechanics/Dynamic](/Physics/SolidMechanics/Dynamic/index.md)+.
See the description, example use, and parameters on the
+[SolidMechanics/Dynamic](/Physics/SolidMechanics/Dynamic/index.md)+ action system page.

#### Description

The legacy kernel only solid mechanics action simplifies the input file syntax
for creating a solid mechanics model by reducing the number of kernels
required. See a description of the action and parameters on the
[LegacyDynamicSolidMechanicsPhysics](/Kernels/DynamicTensorMechanics/index.md)
action system page.

### Legacy Kernel-Only Solid Mechanics Action

This legacy action will soon be deprecated in favor of the more inclusive
+[SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md)+.
See the description, example use, and parameters on the
+[SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md)+ action system page.

#### Description

The legacy kernel only solid mechanics action simplifies the input file syntax
for creating a solid mechanics model by reducing the number of kernels required.
See a description of the action and parameters on the
[LegacyQuasiStaticSolidMechanicsPhysics](/Kernels/TensorMechanics/index.md) action system page.

### LineElement Action

#### Description

This `LineElement` action simplifies the input file syntax for creating a beam and truss element models. See the description, example use, and parameters on the [LineElement/QuasiStatic](/LineElement/QuasiStatic/index.md) action system page.

### Material Vector Body Force Action

#### Description

See the description, example use, and parameters on the
[MaterialVectorBodyForce](SolidMechanics/MaterialVectorBodyForce/index.md) action system page.

### PoroMechanicsAction


The coupling between displacements and pore-pressure is added for every dimension of the
displacements vector passed to the action.


### Pressure Action

#### Description

The `Pressure` Action is used to create a set of pressure boundary conditions for a string of displacement variables; the typical use case for this action is the application of hydrostatic pressure. See the description, example use, and parameters on the [Pressure](/Pressure/index.md) action system page.

When using the [Controls system](syntax/Controls/index.md) to control the active status of Pressure boundary conditions,
the [Pressure.md] boundary conditions created by the `Pressure Action` cannot be controlled individually,
they will all follow the same enabled/disabled status.

### Tensor Mechanics Master Action

#### Description

This [Action.md] simplifies the input file syntax for creating a solid mechanics model. See the description, example use, and parameters on the [TensorMechanics/Master](/Modules/TensorMechanics/Master/index.md) syntax page.

This action is deprecated. Please use the [QuasiStaticSolidMechanicsPhysics.md] Action syntax instead.

## auxkernels

### AccumulateAux


Multiple variables can be accumulated in the target variable.
The accumulation is performed for the entire field within the block / boundary restriction
on every execution of the auxkernel.

The accumulation is performed on a quadrature point basis, and thus projections are automatically performed at the same time as the accumulation if the variable finite element types are different.




### Cylindrical Rank Two Aux


#### Description

The AuxKernel `CylindricalRankTwoAux` transforms a Rank-2 tensor, $T$, into cylindrical coordinates,
where the cylindrical rotation axis is along the Cartesian $\hat{z}$ axis and the user-defined center
point lies within the Cartesian $\hat{x}$-$\hat{y}$ plane, as shown in [eq:cylindrical_rank_two_aux].
The AuxKernel will save the component of the transformed Rank-2 tensor, $T^R$, as defined by the
arguments for the `index_i` and `index_j` parameters.
\begin{equation}
\label{eq:cylindrical_rank_two_aux}
T^R_{ij} = \boldsymbol{R} \cdot \boldsymbol{T} \cdot \boldsymbol{R}^T
\end{equation}
The rotation tensor $R$ is defined as
\begin{equation}
\label{eq:cylindrical_rotation_tensor}
  R = \begin{bmatrix}
      cos(\theta) & sin(\theta) \\
      -sin(\theta) & cos(\theta)
      \end{bmatrix}
      \quad \text{ where } \quad \theta = atan2 \left( \frac{P^{qp}_y - P^c_y}{P^{qp}_x - P^c_x} \right)
\end{equation}
where $P^{qp}$ is the location of the current quadrature point being evaluated and $P^c$ is the
center point defined by the user with the parameter `center_point` in the input file.

#### Example Input File Syntax


and an AuxVariable is required to store the AuxKernel information. Note that the name of the
AuxVariable is used as the argument for the `variable` input parameter in the `CylindricalRankTwoAux`
block.





### DomainIntegralQFunction


### Description

This object is used to compute the value of the $q$ function used in the computation of fracture domain integrals, as described in [FractureIntegrals](/FractureIntegrals.md). The $q$ function is computed based on the distance of a given point from the crack front. It evaluates to 1 if the point is within the inner radius of the integration domain, 0 if it is beyond the outer radius, and is linearly interpolated between the inner and outer radius. In 3-dimensional simulations, this function also ramps up linearly from 0 to its full value based on its position tangentially along a crack relative to the point that it is associated with along the crack front along the segments of the crack front connected to that point. 

This object is not typically directly defined by a user, but is defined using the [DomainIntegralAction](/DomainIntegralAction.md) block. Also, this object is used only for output purposes for debugging models, as the actual value of the $q$ function used in the computation is computed by the fracture domain integral Postprocessor objects.




### DomainIntegralTopologicalQFunction


### Description

This object is used to compute the value of the $q$ function used in the computation of fracture domain integrals, as described in [FractureIntegrals](/FractureIntegrals.md). This form of the $q$ function is based on the mesh topology. Rings of elements in layers expanding from the crack front are formed, and the $q$ function varies from 1 to 0 from the inside nodes to the outside nodes of a given ring.

This object is not typically directly defined by a user, but is defined using the [DomainIntegralAction](/DomainIntegralAction.md) block. Also, this object is used only for output purposes for debugging models, as the actual value of the $q$ function used in the computation is computed by the fracture domain integral Postprocessor objects.




### ElasticEnergyAux


### Description

This object is used to compute the local value of the elastic energy of continuum finite elements using elemental variables. This auxiliary kernel can be used in conjunction with [ElementIntegralVariablePostprocessor](/ElementIntegralVariablePostprocessor.md) in order to compute the integral of the elastic energy corresponding to a block or various blocks. 




### Generalized Plane Strain Reference Residual


#### Description

The AuxScalarKernel `GeneralizedPlaneStrainReferenceResidual` retrieves and stores a reference residual value
from [GeneralizedPlaneStrainUserObject](/GeneralizedPlaneStrainUserObject.md).

#### Example Input syntax





### GlobalDisplacementAux


#### Description

The AuxKernel `GlobalDisplacementAux` calculates the displacement components from the [global strain tensor](/ComputeGlobalStrain.md). Optionally, it can combine the global displacement with the displacements calculated from the stress divergence kernel to provide the total displacement. It saves individual displacement components into an AuxVariable for visualization and/or post-processing purposes.


#### Example Input File Syntax


An AuxVariable is required to store the displacements calculated by the AuxKernel.
The name of the AuxVariable is used as the argument for the `variable` input parameter.


#### Visualization

 In order to visualize the deformed shape with respect to the displacements calculated here, name the AuxVariables as `disp_x, disp_y, disp_z` and use some other names for the displacement variables.





### KineticEnergyAux


### Description

This object is used to compute the value of the kinetic energy of continuum finite elements using elemental variables. This auxiliary kernel can be used in conjunction with [ElementIntegralVariablePostprocessor](/ElementIntegralVariablePostprocessor.md) in order to compute a single kinetic energy value corresponding to a block or various blocks. 




### NewmarkAccelAux


#### Description

This class computes the current acceleration ($\mathbf{\ddot{u}}(t+\Delta t)$) given the current displacement ($\mathbf{u}(t+\Delta t)$), old displacement ($\mathbf{u}(t)$), old velocity ($\mathbf{\dot{u}}(t)$) and old acceleration ($\mathbf{\ddot{u}}(t)$) as follows:

\begin{equation}
\mathbf{\ddot{u}}(t+\Delta t) = \frac{\mathbf{u}(t+\Delta t)-\mathbf{u}(t)}{\beta \Delta t^2}- \frac{\mathbf{\dot{u}}(t)}{\beta \Delta t}+\frac{\beta -0.5}{\beta}\mathbf{\ddot{u}}(t)
\end{equation}

Here, $\beta$ is the Newmark time integration parameter and $\Delta t$ is the time step. More information about the Newmark method can be found at [Dynamics](Dynamics.md).




### NewmarkVelAux


#### Description

This class computes the current velocity ($\mathbf{\dot{u}}(t+\Delta t)$) given the old velocity ($\mathbf{u}(t)$), old acceleration ($\mathbf{\ddot{u}}(t)$) and current acceleration ($\mathbf{\ddot{u}}(t+\Delta t)$) as follows:

\begin{equation}
\mathbf{\dot{u}}(t+ \Delta t) = \mathbf{\dot{u}}(t)+ (1-\gamma)\Delta t \mathbf{\ddot{u}}(t) + \gamma \Delta t \mathbf{\ddot{u}}(t+\Delta t)
\end{equation}

Here, $\gamma$ is the Newmark time integration parameter and $\Delta t$ is the time step. More information about the Newmark method can be found at [Dynamics](Dynamics.md).




### RadialDisplacementCylinderAux


Computing the radial displacement for axisymmetric models is simply a matter
of reporting $u_r$.

For a 2D Cartesian model, the center axis is in the out-of-plane direction.  In this case, the vector from the origin to a node is $p_{n0} = p_n - p_0$.  The radial displacement is then $u_r = u_n \cdot \frac{p_{n0}}{\left\lVert{p_{n0}}\right\rVert}$.

For a 3D Cartesian model, we first find the point on the axis of rotation that is closest to a particular node.  This is done by
\begin{equation}
  p_{n0} = p_n - p_0
\end{equation}
\begin{equation}
  d = p_{n0} \cdot a_r
\end{equation}
\begin{equation}
  p = p_0 + d a_r
\end{equation}
\begin{equation}
  p_r = p_n - p
\end{equation}
where $a_r$ is the axis of rotation.
Then
\begin{equation}
u_r = u_n \cdot \frac{p_{r}}{\left\lVert{p_{r}}\right\rVert}.
\end{equation}





### RadialDisplacementSphereAux


Computing the radial displacement for spherically symmetric models is simply a matter
of reporting $u_r$.

For a 2D and 3D spherical models, the vector from the origin to a node is $p_{n0} = p_n - p_0$.  The radial displacement is then $u_r = u_n \cdot \frac{p_{n0}}{\left\lVert{p_{n0}}\right\rVert}$.





### Rank Four Aux


#### Description

The AuxKernel `RankFourAux` is used to save single components of Rank-4 tensors into an AuxVariable
for visualization and/or post-processing purposes, similar to the functionality provided by
[RankTwoAux](/RankTwoAux.md) for Rank-2 tensors `RankFourAux` is commonly used to output components
of the elasticity (or stiffness) tensor, $C_{ijkl}$, in mechanics simulations.

The `RankFourAux` takes as arguments the values of the `index_i`, `index_j`, `index_k`, and `index_l` for the single Rank-4 tensor component to save into an AuxVariable.
\begin{equation}
\label{eq:rank4tensor_aux_indices}
  \begin{aligned}
        C_{ijkl} \implies & \underbrace{\begin{bmatrix}
                      C_{11} & C_{12} & C_{13} & C_{14} & C_{15} & C_{16} \\
                      C_{21} & C_{22} & C_{23} & C_{24} & C_{25} & C_{26} \\
                      C_{31} & C_{32} & C_{33} & C_{34} & C_{35} & C_{36} \\
                      C_{41} & C_{42} & C_{43} & C_{44} & C_{45} & C_{46} \\
                      C_{51} & C_{52} & C_{53} & C_{54} & C_{55} & C_{56} \\
                      C_{61} & C_{62} & C_{63} & C_{64} & C_{65} & C_{66}
                      \end{bmatrix}}_{\text{textbook notation}} \\[5.0em]
         \implies & \underbrace{\begin{bmatrix}
                      C_{0000} & C_{0011} & C_{0022} & C_{0012} & C_{0020} & C_{0001} \\
                      C_{1100} & C_{1111} & C_{1122} & C_{1112} & C_{1120} & C_{1101} \\
                      C_{2200} & C_{2211} & C_{2222} & C_{2212} & C_{2220} & C_{2201} \\
                      C_{1200} & C_{1211} & C_{1222} & C_{1212} & C_{1220} & C_{1201} \\
                      C_{2000} & C_{2011} & C_{2022} & C_{2012} & C_{2020} & C_{2001} \\
                      C_{0100} & C_{0111} & C_{0122} & C_{0112} & C_{0120} & C_{0101}
                      \end{bmatrix}}_{\text{Rank Four Aux indices}}
  \end{aligned}
\end{equation}
[eq:rank4tensor_aux_indices] shows the index values for a linear hyperelastic stiffness tensor with
21 independent material parameters; the various available elasticity tensor symmetry options is
discussed in the material [ComputeElasticityTensor](/ComputeElasticityTensor.md)
documentation.

#### Example Input File Syntax


An AuxVariable is required to store the `RankFourAux` AuxKernel information. Note that the name of
the AuxVariable is used as the argument for the `variable` input parameter in the `RankFourAux`
block.





### Rank Two Aux


#### Description

The AuxKernel `RankTwoAux` is used to save single components of Rank-2 tensors into an AuxVariable
for visualization and/or post-processing purposes. An antisymmetric Rank-2 tensor would require nine
separate `RankTwoAux` AuxKernel-AuxVariable pairs to store all of the components of the antisymmetric
Rank-2 tensor; six separate AuxKernel-AuxVariable pairs are required to print out all the unique
components of a symmetric Rank-2 tensor.  Quantities commonly examined with `RankTwoAux` are stress
($\boldsymbol{\sigma}$) and strain ($\boldsymbol{\epsilon}$).

The `RankTwoAux` takes as arguments the values of the `index_i` and the `index_j` for the single
tensor component to save into an AuxVariable.  [eq:rank2tensor_aux_indices] shows the index
values for each Rank-2 tensor component.
\begin{equation}
\label{eq:rank2tensor_aux_indices}
\sigma_{ij} \implies \begin{bmatrix}
                      \sigma_{00} & \sigma_{01} & \sigma_{02} \\
                      \sigma_{10} & \sigma_{11} & \sigma_{12} \\
                      \sigma_{20} & \sigma_{21} & \sigma_{22}
                      \end{bmatrix}
\end{equation}

If desired, `RankTwoAux` can be restricted to save data from a Rank-2 tensor at a single specified
quadrature point per element. This option is generally used for debugging purposes.

#### AuxVariable Order

Results will have different quality based on the AuxVariable:

- +Elemental Constant Monomial+ Using an AuxVariable with `family = MONOMIAL` and `order = CONSTANT` will give a constant value of
  the AuxVariable for the entire element, which is computed by taking a volume-weighted average of the integration
  point quantities. This is the default option using SolidMechanics Action and requires the least computational cost.
- +Elemental Higher-order Monomial+ Using an AuxVariable with `family = MONOMIAL` and `order = FIRST` or higher will result in
  fields that vary linearly (or with higher order) within each element. Because the Exodus mesh format does not
  support higher-order elemental variables, these AuxVariables are output by libMesh as nodal variables for visualization
  purposes. Using higher order monomial variables in this way can produce smoother visualizations of results for a properly
  converged simulation.
- +Nodal Lagrange+ Using an AuxVariable with `family = LAGRANGE` will result in a smooth nodal field of the material property,
  constructed using [nodal patch recovery](nodal_patch_recovery.md optional=True).
  `patch_polynomial_order` is set to equal the order of the AuxVariable by default.
  Use this option for the best (smoothest, most accurate) results, but there is
  some additional computational cost. Furthermore, this method is suitable +only
  for serial simulations+ at present.

#### Example Input File Syntax


An AuxVariable is required to store the `RankTwoAux` AuxKernel information. Note that the name of the
AuxVariable is used as the argument for the `variable` input parameter in the `RankTwoAux` block.





### Rank Two Scalar Aux


#### Description

This AuxKernel uses a set of functions to compute scalar quantities such as
invariants and components in specified directions from rank-2 tensors such as
stress or strain.  See [RankTwoScalarTools](RankTwoScalarTools.md) for further
information.

##### Example Input File Syntax

         block=AuxKernels/vonmises

An AuxVariable is required to store the AuxKernel information. Note that the name of the AuxVariable
is used as the argument for the `variable` input parameter in the `RankTwoScalarAux` block.

         block=AuxVariables/vonmises

As with the [RankTwoAux](/RankTwoAux.md) AuxKernel, `RankTwoScalarAux` requires the inclusion of an
AuxVariable block for each AuxKernel block.

#### AuxVariable Order

Results will have different quality based on the AuxVariable:

- +Elemental Constant Monomial+ Using an AuxVariable with `family = MONOMIAL` and `order = CONSTANT` will give a constant value of
  the AuxVariable for the entire element, which is computed by taking a volume-weighted average of the integration
  point quantities. This is the default option using SolidMechanics Action and requires the least computational cost.
- +Elemental Higher-order Monomial+ Using an AuxVariable with `family = MONOMIAL` and `order = FIRST` or higher will result in
  fields that vary linearly (or with higher order) within each element. Because the Exodus mesh format does not
  support higher-order elemental variables, these AuxVariables are output by libMesh as nodal variables for visualization
  purposes. Using higher order monomial variables in this way can produce smoother visualizations of results for a properly
  converged simulation.
- +Nodal Lagrange+ Using an AuxVariable with `family = LAGRANGE` will result in a smooth nodal field of the material property,
  constructed using [nodal patch recovery](nodal_patch_recovery.md optional=True).
  `patch_polynomial_order` is set to equal the order of the AuxVariable by default.
  Use this option for the best (smoothest, most accurate) results, but there is
  some additional computational cost. Furthermore, this method is suitable +only
  for serial simulations+ at present.





### RotationAngle


#### Overview

This AuxKernel computes the rotation angle $\alpha$ in radians around an axis
given by a reference point (the `origin`) and a `direction` vector $\vec d$ for
every node. The vectors $\vec r_1$ from the origin to the undisplaced node and
$\vec r_2$ from the to the displaced node are computed. The displaced point is
determined by adding the `displacements` components to the undisplaced node
location. Projection of $\vec r_{1,2}$ onto the normalized direction
$\frac1{|d|}\vec d$ are then subtracted from $\vec r_{1,2}$.

The angle $\alpha$ is computed as

\alpha = \arccos\frac{\vec r_1 \cdot \vec r_1}{|r_1|\cdot|r_2|} \cdot \text{sign}\left((\vec r_1 \times \vec r_2)\cdot \vec d\right)

If the denominator of this fraction is too small, zero is returned as the angle.
The sign of the angle is determined by comparing the cross product of the
projected $\vec r_{1,2}$ vectors to the direction vector $\vec d$. Right hand
rule applies.

#### Example Input File Syntax




### ShellLocalCoordinatesAux


The three Cartesian local vectors for each shell element are indexed as follows: the first vector is indexed by 0, the second vector by 1, and the normal vector by 2. The convention used to define the direction of these vectors is explained in [ShellElements](/ShellElements.md)



#### Example Input Syntax





### ShellResultantsAux


The three Cartesian local vectors for each shell element are indexed as follows: the first vector is indexed by 0, the second vector by 1, and the normal vector by 2. The convention used to define the direction of these vectors is explained in [ShellElements](/ShellElements.md)

The following stress resultants are computed using this auxiliary kernel:

axial_force_0: The in-plane axial force in the direction of the first local coordinate axis:

  $$F_{0} = \int_{-t/2}^{t/2} \sigma_{00} dz$$


axial_force_1: The in-plane axial force in the direction of the second local coordinate axis:

 $$ F_{1} = \int_{-t/2}^{t/2} \sigma_{11} dz$$


normal_force: The normal force applied to the shell element in the thickness direction. This force is expected to be always zero due to the plane stress assumption used in the shell element formulation, which disregards out-of-plane stresses:

  $$F_{N} = \int_{-t/2}^{t/2} \sigma_{22} dz$$


bending_moments_0: The bending moment about the first local coordinate axis:

  $$M_{0} = \int_{-t/2}^{t/2} \sigma_{11} z dz$$


bending_moment_1: The bending moment about the second local coordinate axis:

 $$ M_{1} = \int_{-t/2}^{t/2} \sigma_{00} z dz$$


bending_moment_01: The in-plane bending moment:

$$  M_{01} =M_{10}= \int_{-t/2}^{t/2} \sigma_{01} z dz$$


shear_force_01: The in-plane shear force:

 $$ Q_{01} =Q_{10}= \int_{-t/2}^{t/2} \sigma_{01} dz$$


shear_force_02: The transverse shear force:

$$Q_{02} =Q_{20}= \int_{-t/2}^{t/2} \sigma_{02} dz$$


shear_force_12: The transverse shear force:

$$  Q_{12} =Q_{21}= \int_{-t/2}^{t/2} \sigma_{12} dz$$




#### Example Input Syntax





### TestNewmarkTI


#### Description

This class assigns the value of the first/second time derivative of the coupled displacement variable to the provided auxvariable. `first` parameter decides whether the first or second time derivative needs to be assigned. By default, `first` is set to true and the first time derivative is assigned to the auxvariable.




## bcs

### Coupled Pressure BC

#### Description

The boundary condition `CoupledPressureBC` applies a force computed in a variable to a mesh boundary.
A `component` of the normal vector to the mesh surface (0, 1, or 2 corresponding to the $\hat{x}$, $\hat{y}$, and $\hat{z}$ vector components) is used to determine the direction in which to apply the traction.

The boundary condition is always applied to the displaced mesh.

The `CoupledPressureBC` is typically used in a multi-app scenario.
The pressure variable can be computed by a sub-app (it can be for example a flow code) and then transferred into an auxiliary variable, which is then coupled into this boundary condition so that it is applied in the parent app.

A set of `CoupledPressure` boundary conditions applied to multiple variables in multiple components can be defined with the [CoupledPressureAction](/CoupledPressureAction.md).

#### Example Input File Syntax





### DashpotBC


The boundary condition represents a friction term proportional to the velocity.
The local contribution to the residual is computed as:

(\psi, K \vec{n} \cdot \vec{v})

where $K$ is the friction coefficient, $\vec{n}$ the local surface normal and
$\vec{v}$ is the velocity, computed from the displacements.

This boundary condition hard-codes an implicit Euler time integration scheme in its
contribution to the Jacobian.




### DirectDirichletBC


#### Overview

This applies a Dirichlet BC meant to be used in conjunction with [DirectCentralDifference](source/timeintegrators/DirectCentralDifference.md).

BC's are applied by calculating the residual force needed,$\mathbf{F}_g$, to enforce BC's during a central difference solution update.

At each boundary node:

\begin{equation}
    \begin{aligned}
        F_g & = \frac{u_g-u_n}{\Delta t * \Delta t_\text{avg}} - \frac{v_{n-\frac{1}{2}}}{\Delta t_\text{avg}},\\
        \Delta t_\text{avg} & = \frac{\Delta t_n-\Delta t_{n-1}}{2}
    \end{aligned}
\end{equation}

where $\mathbf{F_g}$ is the force required to enforce the BC and ${\mathbf{u}_g}$ is the displacement to be enforced.




### DirectFunctionDirichletBC


#### Overview

This applies a function Dirichlet BC meant to be used in conjunction with [DirectCentralDifference](source/timeintegrators/DirectCentralDifference.md).

BC's are applied by calculating the residual force needed to enforce BC's during a central difference solution update.

At each boundary node:

\begin{equation}
\begin{aligned}
        F_g & = \frac{u_g-u_n}{\Delta t * \Delta t_\text{avg}} - \frac{v_{n-\frac{1}{2}}}{\Delta t_\text{avg}},\\
        \Delta t_\text{avg} & = \frac{\Delta t_n-\Delta t_{n-1}}{2}
    \end{aligned}
\end{equation}

where $\mathbf{F_g}$ is the force required to enforce the BC and ${\mathbf{u}_g}$ is the function value of the displacement to be enforced.




### Displacement About Axis


#### Description

The boundary condition class `DisplacementAboutAxis` applies a rotating displacement to the specified
mesh surface according to the user defined rotation function.  The boundary condition is always
applied to the displaced mesh.  The rotation function can be given in either radians or in angles,
and an axis of rotation can be specified with the `axis_origin` and `axis_direction` parameters. By default,
the function defines the rotation, but if the `angular_velocity` parameter is set, it allows for
the function to define an angular velocity instead of a total rotation angle.

The rotating displacement value at the current node is calculated according to
[eq:rotating_displacement]:
\begin{equation}
\label{eq:rotating_displacement}
u_{rotation} = \boldsymbol{T}^{-1} \cdot \boldsymbol{R}_x^{-1} \cdot \boldsymbol{R}_y^{-1} \cdot \boldsymbol{R}_z \cdot \boldsymbol{R}_y \cdot \boldsymbol{R}_x \cdot \boldsymbol{T}
\end{equation}
where $\boldsymbol{T}$ is the translation matrix for axes of rotation not centered at the coordinate
system origin, and $\boldsymbol{R}_x$, $\boldsymbol{R}_y$, and $\boldsymbol{R}_z$ are rotation matrices about the
$\hat{x}$, $\hat{y}$, and $\hat{z}$ coordinate system axes, respectively.

#### Example Input File Syntax

         block=BCs/top_x

A Function is required to prescribe either the total rotation or angular velocity of the `DisplacementAboutAxis` boundary condition
applied to the mesh. Either the name of another function defined elsewhere or a parsed
function is used as the argument for the `function` input parameter in the `DisplacementAboutAxis`
block. In this example, a parsed function is used.




### InteractionIntegralBenchmarkBC


#### Description

This object provides a boundary condition that enforces a displacement field around a crack tip based on applied stress intensity factors KI, KII, and KIII. This is used to test the interaction integral capability.




### PenaltyInclinedNoDisplacementBC


#### Description

`PenaltyInclinedNoDisplacementBC` is a `IntegratedBC` used for enforcing inclined boundary conditions $\mathbf{u}\cdot \mathbf{normal} = 0$ for mechanics problems. With a penalty method, the residual is given as
\begin{equation}
\mathcal{R}_i = \alpha(\mathbf{u}\cdot \mathbf{normal})\mathbf{normal}(\text{component})\psi_i
\end{equation}
where $\alpha$ is the penalty parameter and `component` corresponds to the direction in which to apply the residual. The normal directly comes from the surface normal defined in a mesh.

### PresetAcceleration


The PresetAcceleration class takes an acceleration time history (provided using a function) as input and converts the acceleration into displacement using Newmark time integration method. This displacement is then prescribed at the user provided boundary in the direction corresponding to the displacement variable provided as input.





### PresetDisplacement


The PresetDisplacement class takes a displacement time history as input (provided using a function), differentiates it twice using backward Euler method to obtain the corresponding acceleration time history. This acceleration time history is then integrated using Newmark time integration method to obtain a modified displacement time history which is prescribed at the user provided boundary in the direction corresponding to the displacement variable provided as input. This modification in displacement time history ensures that there are no numerical errors in the acceleration or velocity response. 





### PresetVelocity


This Dirichlet boundary condition lets the user set the displacement using the [!param](/BCs/PresetVelocity/function) and [!param](/BCs/PresetVelocity/velocity) parameters.

The displacement is updated as:

u(t) = u(t-dt) + v \dfrac{f(t) + f(t-dt)}{2}

where $u$ is the displacement, $f$ the [!param](/BCs/PresetVelocity/function) parameter and $v$ the [!param](/BCs/PresetVelocity/velocity) parameter, $t$ the current time and dt the time step.

This boundary condition hard-codes the use of a first order Euler time integration scheme.




### Pressure


#### Description

The boundary condition, `Pressure` applies a force to a mesh boundary in the magnitude
specified by the user.
A `component` of the normal vector to the mesh surface (0, 1, or 2 corresponding
to the $\hat{x}$, $\hat{y}$, and $\hat{z}$ vector components) is used to determine
the direction in which to apply the traction.
The boundary condition is typically applied to the displaced mesh.

The magnitude of the `Pressure` boundary condition can be specified as either a
scalar (use the input parameter `factor`, which defaults to 1.0), a `function` parameter, or a `Postprocessor`
name.  If more than one of these are given, they are multiplied by one another.

A set of +`Pressure`+ boundary conditions applied to multiple variables in multiple
components can be defined with the [PressureAction](/BCs/Pressure/index.md).

##### Jacobian

###### Cartesian

Let $N$ be the number of nodes on a finite element face.  Also, let $h_i$ be the shape function at node $i$.  Then the vector $f$, which has dimension $3N\times1$ for a 3D model, is defined as
\begin{equation}
  f = \int \gamma F^T n\;\; dA
\end{equation}
where $\gamma$ represents a scaling factor, $n$ is the normal vector, and
\begin{equation}
  F = \begin{bmatrix}
      {h_1}I & {h_2}I & ... & {h_N}I
      \end{bmatrix}
\end{equation}
where $I$ is the identity tensor.

To find the Jacobian, we take the variation of the term in the integral,
\begin{equation}
  \delta(\gamma F^T n) = \gamma(\delta(F^T)n + F^T\delta(n))
\end{equation}

We define $F_{,\alpha}$ as
\begin{equation}
  F_{,\alpha} = \begin{bmatrix}
                {h_{1,\alpha}}I & {h_{2,\alpha}}I & ... & {h_{N,\alpha}}I
                \end{bmatrix}
\end{equation}
where $\alpha$ may be either $\xi$ or $\eta$, the two parametric coordinates associated with the face of an element. $F_{,\alpha}$ has dimensions $3 \times 3n$.  This allows
\begin{equation}
\delta F = \begin{bmatrix}
           F_{,\xi}\delta\xi & F_{,\eta}\delta\eta
           \end{bmatrix}
\end{equation}
Since the values of the parametric coordinates are fixed according to the integration rule and do not vary, this term becomes zero.  We are left with $\gamma F^T\delta n$.

The normal vector $n$ is an outward unit vector at the integration points.  We define $b = q_{,\xi} \times q_{,\eta}$ where
\begin{equation}
q_{,\alpha} = F_{,\alpha}p
\end{equation}
defined at the integration points with
\begin{equation}
p^T = \begin{bmatrix}
      x^T_1 & x^T_2 & ... & x^T_n
      \end{bmatrix}
\end{equation}
$x_i = X_i + u_i$ where $X_i$ is the vector of coordinates for node $i$ and $u_i$ is the vector of displacements for node $i$.

\begin{equation}
\begin{aligned}
  \delta b = & \delta q_{,\xi} \times q_{,\eta} + q_{,\xi} \times \delta q_{,\eta} \\
  \delta q_{,\xi} = & F_{,\xi}\delta p + q_{,\xi\eta}\delta \eta \\
  \delta q_{,\eta} = & F_{,\eta}\delta p + q_{,\xi\eta}\delta \xi
\end{aligned}
\end{equation}
If $\delta\xi = \delta\eta = 0$,
\begin{equation}
\begin{aligned}
  \delta b = & F_{,\xi}\delta p \times q_{,\eta} + q_{,\xi} \times F_{,\eta}\delta p \\
           = & q_{,\xi} \times F_{,\eta}\delta p - q_{,\eta} \times F_{,\xi}\delta p \\
           = & (q_{,\xi} \times F_{,\eta} - q_{,\eta} \times F_{,\xi}) \delta p
\end{aligned}
\end{equation}

We are left with
\begin{equation}
  \delta(\gamma F^T n) = \frac{\gamma}{||b||}F^T(q_{,\xi} \times F_{,\eta} - q_{,\eta} \times F_{,\xi}) \delta p
\end{equation}

To take the cross product of a vector and a set of vectors in a matrix, we take the cross product of the vector with each vector in the matrix in turn.  The $j$th $3\times3$ submatrix of $F_{,\alpha}$ is $h_{j,\alpha}I$.  This gives
\begin{equation}
  (q_{,\xi} \times F_{,\eta} - q_{,\eta} \times F_{,\xi})_j =
  \begin{bmatrix}
  0 & -q_{,\xi(3)}h_{j,\eta}+q_{,\eta(3)}h_{j,\xi} & q_{,\xi(2)}h_{j,\eta}-q_{,\eta(2)}h_{j,\xi} \\
  q_{,\xi(3)}h_{j,\eta}-q_{,\eta(3)}h_{j,\xi} & 0 & -q_{,\xi(1)}h_{j,\eta}+q_{,\eta(1)}h_{j,\xi} \\
  -q_{,\xi(2)}h_{j,\eta}+q_{,\eta(2)}h_{j,\xi} & q_{,\xi(1)}h_{j,\eta}-q_{,\eta(1)}h_{j,\xi} & 0
  \end{bmatrix}
\end{equation}
The integrand of the $(i,j)$ $3\times3$ submatrix of the stiffness is
\begin{equation}
\frac{\gamma}{||b||}(F^T(q_{,\xi} \times F_{,\eta} - q_{,\eta} \times F_{,\xi}))_{ij} = \frac{\gamma}{||b||}h_i
\begin{bmatrix}
  0 & -q_{,\xi(3)}h_{j,\eta}+q_{,\eta(3)}h_{j,\xi} & q_{,\xi(2)}h_{j,\eta}-q_{,\eta(2)}h_{j,\xi} \\
  q_{,\xi(3)}h_{j,\eta}-q_{,\eta(3)}h_{j,\xi} & 0 & -q_{,\xi(1)}h_{j,\eta}+q_{,\eta(1)}h_{j,\xi} \\
  -q_{,\xi(2)}h_{j,\eta}+q_{,\eta(2)}h_{j,\xi} & q_{,\xi(1)}h_{j,\eta}-q_{,\eta(1)}h_{j,\xi} & 0
\end{bmatrix}
\end{equation}

###### Spherical symmetry

For a problem using spherical symmetry, the Jacobian is much simpler.  Here we have
\begin{equation}
f = \int \gamma F^Tn \;\; dA = \int\int \gamma F^T n r^2 \sin \phi \;\; d\phi \; d\theta = 4\pi\gamma F^T n r^2
\end{equation}
with $r = X + u$.
Here, $n$ is not a function of the displacements.  The variation is
\begin{equation}
8 \pi \gamma F^T n r\delta r
\end{equation}

###### Axisymmetry

For 1D axisymmetry, we have
\begin{equation}
f = \int \gamma F^Tn \;\; dA = \int \gamma F^T nr \;\; d\theta = 2\pi \gamma F^T n r
\end{equation}
with $r = X + u$ and a unit height.
Here, $n$ is not a function of the displacements.  The variation is
\begin{equation}
2 \pi \gamma F^T n \delta r
\end{equation}

For 2D axisymmetry, we have
\begin{equation}
f = \int \gamma F^Tn \;\; dA = \int \int \gamma F^T n r \;\; d\theta \; dz = \int 2\pi\gamma F^T n r \;\; dz
\end{equation}
with $r = X + u$.  However, both $n$ and $r$ depend on the displacements.  Thus, we have
\begin{equation}
\delta(2\pi\gamma F^T n r) = 2 \pi \gamma F^T (r \delta n + n \delta r)
\end{equation}


#### Example Input File Syntax





### StickyBC



#### Description

This nodal boundary condition imposes the condition
\begin{equation}
u = u_{\mathrm{old}} \ ,
\end{equation}
if $u_{\mathrm{old}}$ exceeds either
\begin{equation}
u_{\mathrm{old}} \geq u_{\mathrm{max}}
\end{equation}
or
\begin{equation}
u_{\mathrm{old}} \leq u_{\mathrm{min}} \ .
\end{equation}
Hence the name "sticky": as soon as $u$ exceeds the bounds it is fixed at subsequent timesteps.

`StickyBC` should be used with care.  It only approximates a Constraint imposed by a wall, for
instance, for: the boundary nodes may penetrate the wall in a single timestep before they are then
stuck (inside the wall); boundary nodes can never move away from the wall again once they are stuck.
However, it offers the advantage over a full-blown Constraint that it does not adversely affect
numerical convergence.




### Torque


#### Overview

This boundary condition applies a torque $T$ (`direction`) with respect to a
reference point (`origin`) through tractions distributed over a surface
according to the right hand rule. It requires the calculation of the *polar
moment of inertia* $J$ (or $I_z$), which can be performed using the
[PolarMomentOfInertia](PolarMomentOfInertia.md) postprocessor.

The application of a torque is currently only validated for small strains.

#### Example Input File Syntax




## constraints

### NodalFrictionalConstraint


Only a penalty formulation is implemented.
First, the previous time step tangential force is computed as:

F_{old} = \text{tangeantial penalty} (u_{primary-old} - u_{secondary-old})

If it is greater than the allowed frictional force (normal force times the friction coefficient),
then the local nodes are in the slippage regime and the old force is recomputed as:

F_{old} = \text{friction coefficient} * \text{normal force} * \dfrac{F_{old}}{|F_{old}|}

From the previous time step force $F_{old}$, and the previous and current values of $u$ on the
primary and secondary side, the current force is computed as:

F = F_{old} + ((u_{secondary-old} - u_{secondary}) - (u_{primary} - u_{primary-old})) *
          \text{tangeantial penalty}

If it is greater than the allowed frictional force (normal force times the friction coefficient),
then the local nodes are in the slippage regime and the current force is recomputed as:

F = \text{friction coefficient} * \text{normal force} * \dfrac{F}{|F|}

and the opposite on the secondary side, where $u$ is usually the displacement component variable value for
mechanical contact applications.

The primary and secondary variables must be different for this implementation of the nodal
frictional constraint.




### NodalStickConstraint


Both kinematic and penalty formulations are implemented.

For the penalty formulation, the contribution to the residual for the constrained nodes on the primary side is equal to

\text{penalty} (u_{primary} - u_{secondary})

and the opposite on the secondary side, where $u$ is usually the displacement component variable value at the node for
mechanical contact applications.

The primary and secondary variables must be different for this implementation of the nodal
stick constraint.




## controls

### StepPeriod

The `StepPeriod` class derives from [ConditionalEnableControl](/ConditionalEnableControl.md).

`StepPeriod` objects are designed to control the active state of a MOOSE object,
based on whether the time value is in some range.

For example, consider a simulation that contains two [Kernels] "diff0" and "diff1". Initially,
"diff0" is active and after time 0.49 "diff1" becomes active and "diff0" is disabled. The following
code snippet demonstrates how this switching of kernels is achieved with the `TimePeriod` object.

This object, unlike [TimePeriod](/TimePeriod.md), is controlled by the loading 'step' concept. The user defines time periods,
i.e. steps, over which the boundary conditions and constraints are not disabled/enabled.
A step number is thus a required input to this control object. At the beginning of this step number,
boundary conditions and constraints are enabled or disabled, as directed by
[StepUserObject](/StepUserObject.md). Only one step is allowed per `StepPeriod` object.





## dampers

### ElementJacobianDamper


This damper limits the change in the Jacobians of elements. The damper becomes active if the relative change in Jacobian of any element exceeds the user defined maximum. This damper must be run on the displaced mesh.




### ReferenceElementJacobianDamper


This damper functions in the same way as [ElementJacobianDamper](ElementJacobianDamper.md). This damper must be run on the undisplaced mesh.




## ics

### Volume Weighted Weibull


The VolumeWeightedWeibull class generates a spatially randomized distribution of a variable following a Weibull distribution, but weighted by the element volume to account for the fact that larger volumes are more likely to contain defects, and would thus have a reduced strength. This class follows the approach documented in [!cite](strack_aleatory_2015), and using it to describe local strength for fracture models minimizes mesh size dependence.

The randomized value of a given variable $\eta$ used to characterize a strength can be expressed as:
\begin{equation}
\label{eqn:vww}
\eta=\bar{\eta}\biggl[\frac{\bar{V}\ln(R)}{V\ln(0.5)}\biggr]^{1/k}
\end{equation}
where $\bar{\eta}$ is the median value of the strength variable, $\bar{V}$ is the reference volume, which is the volume of a test specimen that has a median strength equal to $\bar{\eta}$, $R$ is a uniform random number on the interval from 0 to 1, and $k$ is the Weibull modulus.

This has two important differences from using the standard Weibull distribution, which can also be used to define a randomized strength in MOOSE using a combination of the WeibullDistribution object in the `stochastic_tools` module and the MOOSE [RandomIC](RandomIC.md) object:

 1. This Weibull distribution is defined by two parameters: the Weibull modulus, $k$, and the median value of the randomized variable, $\bar{\eta}$. This in contrast to the standard version, which has three parameters: the Weibull modulus, $k$, the shape parameter, $\lambda$, and the location parameter, $\theta$. The distribution generated by this Weibull distribution implicitly assumes that $\theta=0$. The value for $\lambda$ for the standard set of parameters in a Weibull distribution can be computed from $\bar{\eta}$ and $k$ as:
\begin{equation}
\lambda=\bar{\eta}\biggl[\frac{-1}{\ln(0.5)}\biggr]^{1/k}
\end{equation}

 2. The value of the samples from the standard Weibull distribution is scaled by the factor:
\begin{equation}
\biggl[\frac{\bar{V}}{V}\biggr]^{1/k}
\end{equation}
As a result of this scaling, elements larger than the reference volume typically have decreased strength, and elements smaller than the reference volume have increased strength (because $k$ is typically greater than 1).





## interfacekernels

### ADCZMInterfaceKernelSmallStrain


#### Description

This is the automatic-differentiation version of [`ADCZMInterfaceKernelSmallStrain`](ADCZMInterfaceKernelSmallStrain.md).




### ADCZMInterfaceKernelTotalLagrangian


#### Description

This is the automatic-differentiation version of [`ADCZMInterfaceKernelTotalLagrangian`](ADCZMInterfaceKernelTotalLagrangian.md).




### CZM InterfaceKernelSmallStrain


#### Description

This class assembles the integrated traction computed by a cohesive zone model (CZM) to the system residual vector, which ensures traction equilibrium across an interface. A `CZMInterfaceKernelSmallStrain` acts only on one displacement component and therefore the user must set up a separate instance of this kernel for each dimension of the problem.
The `CZMInterfaceKernelSmallStrain` uses the traction and its derivatives provided by the [CZM Compute Global Traction Small Strain](CZMComputeGlobalTractionSmallStrain.md) to compute the appropriate residual and Jacobian.
This kernel does not account for interface area chagnes and rotations.
##### Residual

The strong form of the force equilibrium equation in vector form can be written as:
\begin{equation}
  F^- -F^+ = \int_{A^-}{T^- dA^-} - \int_{A^+}{T^+ dA^+} = 0
\end{equation}
where superscripts $+$ and $-$ identify the primary and secondary surfaces of the cohesive zone, respectively. Furthermore, $F$ represents the force, $T$ the traction, and $A$ the area.
The primary surface is the one where the interface normal is computed.

By utilizing the principle of virtual work and recognizing that forces are work conjugate of displacements, the weak form of the equilibrium equation can be written as  
\begin{equation}
  \int_{A^-}{T^- \psi^- dA^-}  - \int_{A^+}{T^+ \psi^+ dA^+} = 0
\end{equation}
where $\psi$ is a vector of test functions. Each of the test function in $\psi$ is associated to a specific displacement component.

Because of the small deformation assumption $A^-=A^+=A$ and $T^+=T^-=T$. Therefore, the equilibrium equation for the displacement component $i$ can be rewritten as
\begin{equation}
  T_i (\psi^- - \psi^+) = 0
\end{equation}
Therefore the residual for the primary and secondary surfaces can be rewritten as
\begin{equation}
\begin{aligned}
  R_i^+ & = & - T_i \psi^+ \\
  R_i^- & = & T_i \psi^-
\end{aligned}
\end{equation}

These are the residual equations implemented in the `CZMInterfaceKernelSmallStrain`.
The traction vector $T$ is provided to the `CZMInterfaceKernelSmallStrain` by the `CZMMaterial`.

##### Jacobian

The Jacobian for this model is exact.
The Jacobian requires calculating the derivative of the residual with respect to the discrete displacements $u^{\pm,k}$.
\begin{equation}
\begin{aligned}
  \frac{\partial R_i^+}{\partial u^{+,k}_s} & = & - \frac{\partial  T_{i}}{\partial u^{+,k}_s} \psi^{+}_{j} \\
  \frac{\partial R_i^+}{\partial u^{-,k}_s} & = & - \frac{\partial  T_{i}}{\partial u^{-,k}_s} \psi^{+}_{j} \\
  \frac{\partial R_i^-}{\partial u^{+,k}_s} & = &  \frac{\partial  T_{i}}{\partial u^{+,k}_s} \psi^{-}_{j} \\
  \frac{\partial R_i^-}{\partial u^{-,k}_s} & = &  \frac{\partial  T_{i}}{\partial u^{-,k}_s} \psi^{-}_{j} \\
\end{aligned}
\end{equation}

Assuming the traction is only a function of the midplane deformation gradient,$\hat{F}$, and of the displacement jump in global coordinates,  $\llbracket u \rrbracket$, the partial derivatives of the traction can be rewritten using the chain rule as:
\begin{equation}
\begin{aligned}
  \frac{\partial  T_{i}}{\partial u^{+,k}_s} & = & \frac{\partial  T_{i}}{\partial \llbracket u \rrbracket_{p}} \frac{\partial \llbracket u \rrbracket_{p}}{\partial u^{+,k}_s}\\
  \frac{\partial  T_{i}}{\partial u^{-,k}_s} & = & \frac{\partial  T_{i}}{\partial \llbracket u \rrbracket_{p}} \frac{\partial \llbracket u \rrbracket_{p}}{\partial u^{-,k}_s}\\
\end{aligned}
\end{equation}

Substituting the last two equations in the Jacobian definition one obtains the equation implemented in this kernel.

The [CZM Equilibrium Traction Calculator Small Strain Lagrangian](CZMComputeGlobalTractionSmallStrain.md) provides $\partial  T_{i} / \partial \llbracket u \rrbracket_{p}$ . This kernel is responsible for computing $\partial  \llbracket u \rrbracket_{p} / \partial  u^{\pm,k}_{s}$.

###### Displacement Jump derivatives

Recalling $\llbracket u \rrbracket = u^{-} - u^{+}$ and that $u_i =\sum_z \phi_{i} u^z_i$ we can write,
\begin{equation}
\begin{aligned}
\frac{\partial \llbracket u \rrbracket_i}{\partial u^{+,z}_j} &=-
\begin{bmatrix} \phi_{1}^{+,z} & 0 & 0 \\ 0 & \phi_{2}^{+,z} & 0 \\ 0 & 0 & \phi_{3}^{+,z} \\  \end{bmatrix} \\
\frac{\partial \llbracket u \rrbracket_i}{\partial u^{-,z}_i} & =
\begin{bmatrix} \phi_{1}^{-,z} & 0 & 0 \\ 0 & \phi_{2}^{-,z} & 0 \\ 0 & 0 & \phi_{3}^{-,z} \\  \end{bmatrix}
\end{aligned}
\end{equation}

#### Example Input File Syntax

This object is automatically added from the [Cohesive Zone Physics](CohesiveZone/index.md) when `strain=SMALL`.


### CZMInterfaceKernelTotalLagrangian


#### Description

This class assembles the integrated first Piola-Kirchhoff traction computed by a cohesive zone model (CZM) to the system residual vector, which ensures traction equilibrium across an interface. A `CZMInterfaceKernelTotalLagrangian` acts only on one displacement component and therefore the user must set up a separate instance of this kernel for each dimension of the problem.
The `CZMInterfaceKernelTotalLagrangian` uses the PK1 traction and its derivatives provided by a [CZM Compute Global Traction Total Lagrangian](CZMComputeGlobalTractionTotalLagrangian.md)  to impose the appropriate residual and to provide the appropriate Jacobian.
This kernel accounts for both interface area changes and rotations.

##### Residual

The strong form of the force equilibrium equation in vector form can be written as:
\begin{equation}
  F^- -F^+ = \int_{A^-}{T^- dA^-} - \int_{A^+}{T^+ dA^+} = 0
\end{equation}
where superscripts $+$ and $-$ identify the primary and secondary surfaces of the cohesive zone, respectively. Furthermore, $F$ represents the force, $T$ the first Piola-Kirchhoff traction, and $A$ the undeformed area.
The primary surface is the one where the interface normal is computed.

By utilizing the principle of virtual work and recognizing that forces are work conjugate of displacements, the weak form of the equilibrium equation can be written as  
\begin{equation}
  \int_{A^-}{T^- \psi^- dA^-}  - \int_{A^+}{T^+ \psi^+ dA^+} = 0
\end{equation}
where $\psi$ is a vector of test functions. Each of the test function in $\psi$ is associated to a specific displacement component.

In the undeformed configuration, $A^-=A^+=A$ and $T^+=T^-=T$. Therefore, the equilibrium equation for the displacement component $i$ can be rewritten as
\begin{equation}
  T_i (\psi^- - \psi^+) = 0
\end{equation}
Therefore the residual for the primary and secondary surfaces, for a specific test function $j$ can be rewritten as
\begin{equation}
\begin{aligned}
  R_i^+ & = & - T_i \psi^{+}_{j} \\
  R_i^- & = & T_i \psi^{-}_{j}
\end{aligned}
\end{equation}

These are the residual equations implemented in the `CZMInterfaceKernelTotalLagrangian`.
The traction vector $T$ by the [CZM Equilibrium Traction Calculator Total Lagrangian](CZMComputeGlobalTractionTotalLagrangian.md)

##### Jacobian

The Jacobian for this model is exact.
The Jacobian requires calculating the derivative of the residual with respect to the discrete displacements $u^{\pm,k}$.
\begin{equation}
\begin{aligned}
  \frac{\partial R_i^+}{\partial u^{+,k}_s} & = & - \frac{\partial  T_{i}}{\partial u^{+,k}_s} \psi^{+}_{j} \\
  \frac{\partial R_i^+}{\partial u^{-,k}_s} & = & - \frac{\partial  T_{i}}{\partial u^{-,k}_s} \psi^{+}_{j} \\
  \frac{\partial R_i^-}{\partial u^{+,k}_s} & = &  \frac{\partial  T_{i}}{\partial u^{+,k}_s} \psi^{-}_{j} \\
  \frac{\partial R_i^-}{\partial u^{-,k}_s} & = &  \frac{\partial  T_{i}}{\partial u^{-,k}_s} \psi^{-}_{j} \\
\end{aligned}
\end{equation}


Assuming the traction is only a function of the midplane deformation gradient,$\hat{F}$, and of the displacement jump in global coordinates,  $\llbracket u \rrbracket$, the partial derivatives of the traction can be rewritten using the chain rule as:
\begin{equation}
\begin{aligned}
  \frac{\partial  T_{i}}{\partial u^{+,k}_s} & = &\frac{\partial  T_{i} }{\partial \hat{F}_{pq}} \frac{\partial \hat{F}_{pq}}{\partial u^{+,k}_s}
  + \frac{\partial  T_{i}}{\partial \llbracket u \rrbracket_{p}} \frac{\partial \llbracket u \rrbracket_{p}}{\partial u^{+,k}_s}\\
  \frac{\partial  T_{i}}{\partial u^{-,k}_s} & = & \frac{\partial  T_{i} }{\partial \hat{F}_{pq}} \frac{\partial \hat{F}_{pq}}{\partial u^{-,k}_s}
  + \frac{\partial  T_{i}}{\partial \llbracket u \rrbracket_{p}} \frac{\partial \llbracket u \rrbracket_{p}}{\partial u^{-,k}_s}\\
\end{aligned}
\end{equation}
Substituting the last two equations in the Jacobian definition one obtains the equation implemented in this kernel.

The [CZM Equilibrium Traction Calculator Total Lagrangian](CZMComputeGlobalTractionTotalLagrangian.md) provides $\partial  T_{i}/\partial \hat{F}_{pq}$ and $\partial  T_{i} / \partial \llbracket u \rrbracket_{p}$ . This kernel is responsible for computing $\partial  \llbracket u \rrbracket_{p} / \partial  u^{\pm,k}_{s}$ and $\partial \hat{F}_{pq} / \partial u^{\pm,k}_{s}$.

###### Displacement Jump and deformation gradient derivatives

Recalling $\llbracket u \rrbracket = u^{-} - u^{+}$ and that $u_i =\sum_z \phi_{i} u^z_i$ we can write,
\begin{equation}
\begin{aligned}
\frac{\partial \llbracket u \rrbracket_i}{\partial u^{+,z}_j} &=-
\begin{bmatrix} \phi_{1}^{+,z} & 0 & 0 \\ 0 & \phi_{2}^{+,z} & 0 \\ 0 & 0 & \phi_{3}^{+,z} \\  \end{bmatrix} \\
\frac{\partial \llbracket u \rrbracket_i}{\partial u^{-,z}_i} & =
\begin{bmatrix} \phi_{1}^{-,z} & 0 & 0 \\ 0 & \phi_{2}^{-,z} & 0 \\ 0 & 0 & \phi_{3}^{-,z} \\  \end{bmatrix}
\end{aligned}
\end{equation}

Recalling $\hat{F} = 0.5 \left( F^+ + F^-\right)$ and that $F_{ij}=\delta_{ij}\sum_z \left(\phi_{i,j} u^z \right)$ we can write
\begin{equation}
\begin{aligned}
\frac{\partial F_{ij}}{\partial u^{+,z}_k} = \frac{1}{2} \begin{bmatrix} \begin{bmatrix} \nabla \phi_{1,1}^{+,z} & \nabla \phi_{1,2}^{+,z} & \nabla \phi_{1,3}^{+,z} \\ 0 & 0 & 0 \\ 0 & 0 & 0 \\  \end{bmatrix}_{k=1} \\ \\  \begin{bmatrix} 0 & 0 & 0 \\ \nabla \phi_{2,1}^{+,z} & \nabla \phi_{2,2}^{+,z} & \nabla \phi_{2,3}^{+,z} \\  0 & 0 & 0 \\ \end{bmatrix}_{k=2} \\ \\ \begin{bmatrix} 0 & 0 & 0 \\  0 & 0 & 0 \\ \nabla \phi_{3,1}^{+,z} & \nabla \phi_{3,2}^{+,z} & \nabla \phi_{3,3}^{+,z} \\  \end{bmatrix}_{k=3} \end{bmatrix} \\
 \frac{\partial F_{ij}}{\partial u^{-,z}_k} = \frac{1}{2} \begin{bmatrix} \begin{bmatrix} \nabla \phi_{1,1}^{-,z} & \nabla \phi_{1,2}^{-,z} & \nabla \phi_{1,3}^{-,z} \\ 0 & 0 & 0 \\ 0 & 0 & 0 \\  \end{bmatrix}_{k=1} \\ \\  \begin{bmatrix} 0 & 0 & 0 \\ \nabla \phi_{2,1}^{-,z} & \nabla \phi_{2,2}^{-,z} & \nabla \phi_{2,3}^{-,z} \\  0 & 0 & 0 \\ \end{bmatrix}_{k=2} \\ \\ \begin{bmatrix} 0 & 0 & 0 \\  0 & 0 & 0 \\ \nabla \phi_{3,1}^{-,z} & \nabla \phi_{3,2}^{-,z} & \nabla \phi_{3,3}^{-,z} \\ \end{bmatrix}_{k=3} \end{bmatrix}
\end{aligned}
\end{equation}

#### Example Input File Syntax

This object is automatically added from the [Cohesive Zone Physics](CohesiveZone/index.md) when `strain=FINITE`.


## interfaces

### Gradient operators

#### 3D Cartesian coordinates id=3D_cartesian

The reference coordinates of a Cartesian coordinate system can be expressed as:
\begin{equation}
  \boldsymbol{X} = X \textbf{e}_X + Y \textbf{e}_Y + Z \textbf{e}_Z.
\end{equation}
The current coordinates can be expressed as:
\begin{equation}
  \boldsymbol{x} = x \textbf{e}_x + y \textbf{e}_y + z \textbf{e}_z,
\end{equation}
and the underlying motion is
\begin{equation}
  \begin{aligned}
    x(X,Y,Z) &= X + u_x(X,Y,Z), \\
    y(X,Y,Z) &= Y + u_y(X,Y,Z), \\
    z(X,Y,Z) &= Z + u_z(X,Y,Z).
  \end{aligned}
\end{equation}

The gradient operator (with respect to the reference coordinates) is given as
\begin{equation}
  (\cdot)_{,\boldsymbol{X}} = (\cdot)_{,X}\textbf{e}_X + (\cdot)_{,Y}\textbf{e}_Y + (\cdot)_{,Z}\textbf{e}_Z,
\end{equation}
and the deformation gradient is given as
\begin{equation}
  \begin{aligned}
    \boldsymbol{F} = &\ (1+u_{x,X}) \textbf{e}_x\textbf{e}_X + u_{x,Y} \textbf{e}_x\textbf{e}_Y + u_{x,Z} \textbf{e}_x\textbf{e}_Z \\
    &+ u_{y,X} \textbf{e}_y\textbf{e}_X + (1+u_{y,Y}) \textbf{e}_y\textbf{e}_Y + u_{y,Z} \textbf{e}_y\textbf{e}_Z \\
    &+ u_{z,X} \textbf{e}_z\textbf{e}_X + u_{z,Y} \textbf{e}_z\textbf{e}_Y + (1+u_{z,Z}) \textbf{e}_z\textbf{e}_Z.
  \end{aligned}
\end{equation}

Components of the gradient operator are
\begin{equation}
  \begin{aligned}
    \nabla^x \phi_x &= \phi_{x,X}\textbf{e}_x\textbf{e}_X + \phi_{x,Y}\textbf{e}_x\textbf{e}_Y + \phi_{x,Z}\textbf{e}_x\textbf{e}_Z, \\
    \nabla^y \phi_y &= \phi_{y,X}\textbf{e}_y\textbf{e}_X + \phi_{y,Y}\textbf{e}_y\textbf{e}_Y + \phi_{y,Z}\textbf{e}_y\textbf{e}_Z, \\
    \nabla^z \phi_z &= \phi_{z,X}\textbf{e}_z\textbf{e}_X + \phi_{z,Y}\textbf{e}_z\textbf{e}_Y + \phi_{z,Z}\textbf{e}_z\textbf{e}_Z.
  \end{aligned}
\end{equation}

#### 2D axisymmetric cylindrical coordinates id=2D_axisymmetric_cylindrical

The reference coordinates of an axisymmetric cylindrical coordinate system can be expressed in terms of the radial coordinate $R$, the axial coordinate $Z$, and unit vectors $\textbf{e}_R$ and $\textbf{e}_Z$:
\begin{equation}
  \boldsymbol{X} = R \textbf{e}_R + Z \textbf{e}_Z.
\end{equation}
The current coordinates can be expressed in terms of coordinates and unit vectors in the current (displaced) configuration:
\begin{equation}
  \boldsymbol{x} = r \textbf{e}_r + z \textbf{e}_z,
\end{equation}
and the underlying motion is
\begin{equation}
  \begin{aligned}
    r(R,Z) &= R + u_r(R,Z), \\
    z(R,Z) &= Z + u_z(R,Z), \\
    \theta(\Theta) &= \Theta + u_\theta(\Theta).
  \end{aligned}
\end{equation}
Notice that the motion is assumed to be torsionless and $\nabla_{\Theta} \boldsymbol{x} = 0$.

In axisymmetric cylindrical coordinates, the gradient operator (with respect to the reference coordinates) is given as
\begin{equation}
  (\cdot)_{,\boldsymbol{X}} = (\cdot)_{,R}\textbf{e}_R + (\cdot)_{,Z}\textbf{e}_Z + \frac{1}{R}(\cdot)_{,\Theta}\textbf{e}_\Theta,
\end{equation}
and the deformation gradient is given as
\begin{equation}
  \begin{aligned}
    \boldsymbol{F} &= (1+u_{r,R}) \textbf{e}_r\textbf{e}_R + u_{r,Z} \textbf{e}_r\textbf{e}_Z + \left(1+\frac{u_r}{R}\right)\textbf{e}_\theta\textbf{e}_\Theta + u_{z,R} \textbf{e}_z\textbf{e}_R + (1+u_{z,Z}) \textbf{e}_z\textbf{e}_Z
  \end{aligned}
\end{equation}

Components of the gradient operator are
\begin{equation}
  \begin{aligned}
    \nabla^r \phi_r &= \phi_{r,R}\textbf{e}_r\textbf{e}_R + \phi_{r,Z}\textbf{e}_r\textbf{e}_Z + \frac{\phi_{r}}{R}\textbf{e}_\theta\textbf{e}_\Theta, \\
    \nabla^z \phi_z &= \phi_{z,R}\textbf{e}_z\textbf{e}_R + \phi_{z,Z}\textbf{e}_z\textbf{e}_Z.
  \end{aligned}
\end{equation}

#### 1D centrosymmetric spherical coordinates id=1D_centrosymmetric_spherical

The reference coordinates of a centrosymmetric spherical coordinate system can be expressed in terms of the radial coordinate $R$ and the unit vector $\textbf{e}_R$:
\begin{equation}
  \boldsymbol{X} = R \textbf{e}_R.
\end{equation}
The current coordinates can be expressed in terms of the radial coordinate and the unit vector in the current (displaced) configuration:
\begin{equation}
  \boldsymbol{x} = r \textbf{e}_r,
\end{equation}
and the underlying motion is
\begin{equation}
  \begin{aligned}
    r(R,Z) &= R + u_r(R,Z), \\
    \theta(\Theta) &= \Theta + u_\theta(\Theta), \\
    \phi(\Phi) &= \Phi + u_\phi(\Phi). \\
  \end{aligned}
\end{equation}
Notice that the motion is torsionless.

In centrosymmetric spherical coordinates, the gradient operator (with respect to the reference coordinates) is given as
\begin{equation}
  (\cdot)_{,\boldsymbol{X}} = (\cdot)_{,R}\textbf{e}_R + \frac{1}{R}(\cdot)_{,\Theta}\textbf{e}_\Theta + \frac{1}{R}(\cdot)_{,\Phi}\textbf{e}_\Phi,
\end{equation}
and the deformation gradient is given as
\begin{equation}
  \begin{aligned}
    \boldsymbol{F} &= (1+u_{r,R}) \textbf{e}_r\textbf{e}_R + \left(1+\frac{u_r}{R}\right)\textbf{e}_\theta\textbf{e}_\Theta + \left(1+\frac{u_r}{R}\right)\textbf{e}_\phi\textbf{e}_\Phi.
  \end{aligned}
\end{equation}

Components of the gradient operator are
\begin{equation}
  \nabla^r \phi_r = \phi_{r,R}\textbf{e}_r\textbf{e}_R + \frac{\phi_{r}}{R}\textbf{e}_\theta\textbf{e}_\Theta + \frac{\phi_{r}}{R}\textbf{e}_\phi\textbf{e}_\Phi.
\end{equation}

## kernels

### ADDynamicStressDivergenceTensors


#### Description

This class computes the stress divergence and the stiffness proportional Rayleigh damping for  
structural dynamics problems. Each ADDynamicStressDivergenceTensors input block computes force in  
one direction. So, a separate ADDynamicStressDivergenceTensors input block should be set up for  
each coordinate direction. The [DynamicSolidMechanics](/DynamicSolidMechanicsPhysics.md) action  
automatically sets up the ADDynamicStressDivergenceTensors input block in all coordinate directions.  
More information about the residual calculation and usage can be found at [Dynamics](Dynamics.md).




### ADGravity


#### Description

The kernel `ADGravity` provides a body force term in the stress divergence equilibrium
equation to account for ADGravity force due to self weight.
In a continuum mechanics problem, momentum conservation is prescribed assuming
static equilibrium at each time increment,
\begin{equation}
\nabla \cdot \boldsymbol{\sigma} + g = 0,
\end{equation}
where $\boldsymbol{\sigma}$ is the Cauchy stress tensor and $\boldsymbol{g}$ is
the ADGravity body force per unit mass.

#### Example Input File Syntax





### ADInertialForceShell


It accounts for inertia on both displacement (translational) and rotational degrees of freedom.
Forward mode automatic differentiation is used to compute an exact Jacobian. Please refer to [ShellElements](/ShellElements.md) for details.

Each `ADInertialForceShell` kernel calculates the force only along one coordinate direction. So, a separate `ADInertialForceShell` input block should be set up for each coordinate direction. Additionally, separate
`ADInertialForceShell` kernels should be specified for the rotation variables.




### ADStressDivergenceRSphericalTensors


#### Description

The kernel `ADStressDivergenceRSphericalTensors` solves the stress divergence
equation for a spherically symmetric system on a 1D mesh. Forward mode automatic
differentiation is used to compute an exact Jacobian.

#### Residual Calculation


The stress divergence in spherical coordinates includes contributions from the
normal polar and azimuthal stresses even in the 1D case.  After simplifying for
the 1D case, the spherical stress divergence reduces to

\begin{equation}
\label{eqn:strongformspherical}
\nabla \sigma  =  \left[ \frac{\partial \sigma_{rr}}{\partial r} + \frac{2}{X_r} \sigma_{rr} - \frac{1}{X_r} \left( \sigma_{\phi \phi} + \sigma_{\theta \theta} \right)  \right] \hat{e}_r
\end{equation}

In deriving the weak form of this equation, the second term in
[eqn:strongformspherical] goes to zero and the residual contribution in the
`ADStressDivergenceRSphericalTensors` kernel becomes

\begin{equation}
\boldsymbol{R} = \sigma_{rr} \frac{ \partial \phi_i }{ \partial r} + \frac{ \phi_i}{X_r} \left( \sigma_{\phi \phi} + \sigma_{\theta \theta} \right)
\end{equation}

The coordinate type in the `[Problem]` block of the input file must be set to
`coord_type = RSPHERICAL`.





### ADStressDivergenceRZTensors


#### Description

The kernel `ADStressDivergenceRZTensors` solves the stress divergence equation
for an Axisymmetric problem in the cylindrical coordinate system on a 2D mesh.
Forward mode automatic differentiation is used to compute an exact Jacobian.

The axis of symmetry must lie along the $z$-axis in a $\left(r, z, \theta \right)$
or cylindrical coordinate system. This symmetry orientation is required for the
calculation of the residual and of the jacobian, as defined in [eq-solid_mechanics-RZ-stress-divergence].

#### Residual Calculation


In cylindrical coordinates, the [divergence of a rank-2 tensor](https://en.wikipedia.org/wiki/Tensor_derivative_%28continuum_mechanics%29#Cylindrical_polar_coordinates_2)
includes mixed term contributions.  In the axisymmetric model we assume
symmetric loading conditions, in addition to the zero out-of-plane shear
strains, so that the residual computation is simplified.

\begin{equation}
  \label{eq-solid_mechanics-RZ-stress-divergence}
  \begin{aligned}
  \nabla \sigma  & = \left[ \frac{\partial \sigma_{rr}}{\partial r} + \frac{u_r}{X_r}\sigma_{\theta \theta} + \frac{\partial \sigma_{rz}}{\partial z} \right] \hat{e}_r \\
   & + \left[ \frac{\partial \sigma_{zz}}{\partial z} + \frac{\partial \sigma_{rz}}{\partial r}    \right] \hat{e}_z
  \end{aligned}
\end{equation}

The axisymmetric system changes the order of the displacement vector from $(u_r, u_{\theta}, u_z)$,
usually seen in textbooks, to $(u_r, u_z, u_{\theta})$. Take care to follow this convention in your
input files and when adding extra stresses.

The coordinate type in the `[Problem]` block of the input file must be set to
`coord_type = RZ`.





### ADStressDivergenceShell


#### Description

The `ADStressDivergenceShell` kernel calculates the contribution to the residual from the stress divergence for shell elements. Forward mode automatic differentiation is used to compute an exact Jacobian. Please refer to [ShellElements](/ShellElements.md) for details.

#### Example Input File syntax




### ADStressDivergenceTensors


#### Description

The `ADStressDivergenceTensors` kernel calculates the residual of the stress
divergence for 1D, 2D, and 3D problems in the Cartesian coordinate system.
Forward mode automatic differentiation is used to compute an exact Jacobian.

Either 1, 2, or 3 displacement variables can be used in the stress divergence
calculator for the Cartesian system.

#### Residual Calculation


#### Example Input File syntax





### ADWeakPlaneStress


#### Description

In 2D plane stress conditions, the out-of-plane stress is zero.  The `ADWeakPlaneStress` kernel
operates on an out-of-plane strain variable and computes the following residual:
\begin{equation}
  \int \phi \; \sigma_{zz} \; \textrm{dV}.
\end{equation}
Thus, the out-of-plane stress is driven toward zero but may not be strictly zero everywhere.
The computed out-of-plane strain may vary at different points on the plane.

For finite deformation models, this kernel should be run on the displaced mesh by setting
`use_displaced_mesh = true`.





### AsymptoticExpansionHomogenizationKernel


#### Description

This `Kernel` computes
\begin{equation}
 \int_\text{Y} \frac{\partial v_i}{\partial y_j}D_{ijkl}\;\text{d}\bm{y}
\end{equation}
where $D_{ijkl}$ is the elasticity tensor.  It is used in conjunction with the [Stress Divergence](StressDivergenceTensors.md) `Kernel` and the [Asymptotic Expansion Homogenization Elastic Constants](AsymptoticExpansionHomogenizationElasticConstants.md) `PostProcessor` to compute homogenized elasticity tensor values according to
\begin{equation}
\int_\text{Y}\frac{\partial v_i}{\partial y_j} D_{ijkl} \frac{\partial\chi_\kappa^{mn}}{\partial y_l}\text{d}\bm{y} = \int_\text{Y} \frac{\partial v_i}{\partial y_j}D_{ijkl}\;\text{d}\bm{y}
\end{equation}
and
\begin{equation}
D_{ijkl}^\text{H} = \frac{1}{\left|\text{Y}\right|}\int_\text{Y}D_{ijkl} \left(\bm{I}+\frac{\partial\chi^{mn}_\kappa}{\partial y_l}\right)\;d\bm{y}.
\end{equation}
where $D_{ijkl}^\text{H}$ is the homogenized elasticity tensor.  See [!cite](hales15homogenization).

#### Example Input File Syntax






### CosseratStressDivergenceTensors


This kernel is used to model Cosserat media, notably in a Cosserat layered elasticity model.

This kernel should be specified for each component of the displacements variable.
All Cosserat rotation variables should also be specified to each instance of this kernel.




### DynamicStressDivergenceTensors


#### Description

This class computes the stress divergence and the stiffness proportional Rayleigh damping for structural dynamics problems. Each DynamicStressDivergenceTensors input block computes force in one direction. So, a separate DynamicStressDivergenceTensors input block should be set up for each coordinate direction. The [DynamicSolidMechanics](/DynamicSolidMechanicsPhysics.md) action automatically sets up the DynamicStressDivergenceTensors input block in all coordinate direction. More information about the residual calculation and usage can be found at [Dynamics](Dynamics.md).




### Generalized Plane Strain Off Diagonal


Kernel `GeneralizedPlaneStrainOffDiag` computes the off-diagonal Jacobian entries to couple the in-plane displacement degree of freedoms with the out-of-plane strain degree of freedom. The out-of-plane direction can be $x$, $y$, or $z$. This object is usually set up by the [GeneralizedPlaneStrainAction](SolidMechanics/GeneralizedPlaneStrain/index.md).




### Gravity


#### Description

The kernel `Gravity` provides a body force term in the stress divergence equilibrium
equation to account for gravity force due to self weight.
In a continuum mechanics problem, momentum conservation is prescribed assuming
static equilibrium at each time increment,
\begin{equation}
\nabla \cdot \boldsymbol{\sigma} + g = 0,
\end{equation}
where $\boldsymbol{\sigma}$ is the Cauchy stress tensor and $\boldsymbol{g}$ is
the gravity body force per unit mass.

#### Example Input File Syntax





### InertialForce


#### Description

This class computes the inertial force using a consistent mass matrix and also computes the mass proportional Rayleigh damping. More information about the residual calculation and usage can be found at [Dynamics](Dynamics.md). Each InertialForce kernel calculates the force only along one coordinate direction. So, a separate InertialForce input block should be set up for each coordinate direction.




### Inertial Force Beam


#### Description

This class computes the $i^{th}$ component of the inertial force/torque and mass/inertia proportional Rayleigh damping for the beam element due to mass/rotational inertia. Please look at [C0TimoshenkoBeam](/C0TimoshenkoBeam.md) for details.




### Inertial Torque


#### Description

This kernel computes the $i^{\mathrm{th}}$ component of inertial torque using

\begin{equation}
\rho \epsilon_{ijk}u_{j}\ddot{u}_{k} \ .
\end{equation}

In this equation $\rho$ is the material's density (a Material Property), $\epsilon_{ijk}$ is the
permutation pseudotensor (the Levi-Cevita tensor), $u_{j}$ is the $j^{\mathrm{th}}$ component of
displacement, and $\ddot{u}_{k}$ is the $k^{\mathrm{th}}$ component of the acceleration.

This Kernel is used in dynamic Cosserat continuum-mechanics problems.

Newmark time integration is used, which means the Newmark acceleration is defined by
\begin{equation}
\ddot{u}_{\mathrm{Newmark}} = \frac{1}{\beta} \left( \frac{u - u_{\mathrm{old}}}{{\mathrm{d}t}^{2}} - \frac{\dot{u}_{\mathrm{old}}}{{\mathrm{d}t}} - (\tfrac{1}{2} - \beta)\ddot{u}_{\mathrm{old}} \right) \
\end{equation}
and the velocity by
\begin{equation}
\dot{u} = \dot{u}_{\mathrm{old}} + {\mathrm{d}t} \cdot (1 - \gamma) \cdot \ddot{u}_{\mathrm{old}} + \gamma \cdot {\mathrm{d}t} \cdot \ddot{u}_{\mathrm{Newmark}} \ .
\end{equation}
The Newmark parameters must satisfy $0\leq \gamma\leq 1$ and $0 \leq \beta \leq 1/2$.  When
$\gamma\geq 1/2$ and $\beta\geq \tfrac{1}{4}(\gamma + \tfrac{1}{2})^{2}$, the Newmark scheme is
unconditionally stable.

Parameters ($\eta$ and $\alpha$) are also included that allow Rayleigh damping and HHT time
integration, meaning that the final form for acceleration is
\begin{equation}
\ddot{u} = \ddot{u}_{\mathrm{Newmark}} + \eta \cdot \left((1 + \alpha) \cdot \dot{u}_{\mathrm{Newmark}} - \alpha\dot{u}_{\mathrm{old}}\right) \ .
\end{equation}
If damping is utilized (ie, if $\eta\neq 0$) then the "Dynamic" versions of the
StressDivergenceTensors Kernels should be used.




### MaterialVectorBodyForce


#### Description

The kernel `MaterialVectorBodyForce` provides a body force term from a vector valued
material property in the stress divergence equilibrium. Kernels for all spatial
directions can be set up using the [MaterialVectorBodyForce action](SolidMechanics/MaterialVectorBodyForce/index.md).

#### Example Input File Syntax





### MomentBalancing


This kernel is used to model Cosserat media, notably in a Cosserat layered elasticity model.
It is only implemented for 3D.

This kernel should be specified for each of the two components in-plane for the layered model.
All components of the displacement vector and all Cosserat rotation variables should be specified
to each instance of this kernel.




### Out-Of-Plane Pressure


#### Description

The `OutOfPlanePressure` kernel applies an out-of-plane pressure value in the
out-of-plane direction of [Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
or 2D plane stress problems.
Either a function or a postprocessor can be used to specify the value of the
out-of-plane pressure at each quadrature point.
\begin{equation}
  \label{eqn:out_of_plane_pressure}
  P = f \cdot \hat{n}
\end{equation}
where $P$ is the computed pressure, $f$ is the function or postprocessor value of
the pressure to be applied, and $\hat{n}$ is the unit normal vector to the out-of-plane
surface.
Following the convention of the [Pressure](bcs/Pressure.md) boundary condition,
the unit normal vector is considered to be positive when pointing inward towards
the surface.




### PhaseFieldFractureMechanicsOffDiag


The (`Dynamic`)`StressDivergenceTensors` specifies the contribution to the residual and
to the Jacobian for displacements, eigenstrain variables, out-of-plane strains etc, while this
kernel only adds the off-diagonal Jacobian terms for the phase field damage variable.




### PlasticHeatEnergy


This kernel is used in the solid energy equation to capture the energy losses due to plastic strain.




### PoroMechanicsCoupling


This kernel should be added for every direction of the displacement variables. It is usually created automatically using the [PoroMechanicsAction.md].




### Stress Divergence Beam


#### Description

This class computes the $i^{th}$ component of internal forces/moments for a beam element. Stiffness proportional Rayleigh damping is also calculated by this class. Please refer to [C0 Timoshenko Beam](/C0TimoshenkoBeam.md) for details.




### Stress Divergence RSpherical Tensors


#### Description

The kernel `StressDivergenceRSphericalTensors` solves the stress divergence equation for a
spherically symmetric system on a 1D mesh.

The `COORD_TYPE` in the Problem block of the input file must be set to RSPHERICAL.

The `StressDivergenceRSphericalTensors` kernel can be automatically created with the
[Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md). Use of the tensor
mechanics quasi-static physics is recommended to ensure the consistent setting of the *use_displaced_mesh*
parameter for the strain formulation selected.  For a detailed explanation of the settings for
_use_displaced_mesh_ in mechanics problems and the Solid Mechanics Physics usage, see the
[Introduction/StressDivergence](/StressDivergence.md) page.

#### Residual Calculation


The stress divergence in spherical coordinates includes contributions from the normal polar and
azimuthal stresses even in the 1D case.  After simplifying for the 1D case, the spherical stress
divergence reduces to
\begin{equation}
\label{eqn:strongformspherical}
\nabla \sigma  =  \left[ \frac{\partial \sigma_{rr}}{\partial r} + \frac{2}{X_r} \sigma_{rr} - \frac{1}{X_r} \left( \sigma_{\phi \phi} + \sigma_{\theta \theta} \right)  \right] \hat{e}_r
\end{equation}

In deriving the weak form of this equation, the second term in [eqn:strongformspherical]
goes to zero and the residual contribution in the `StressDivergenceRSphericalTensors` kernel becomes
\begin{equation}
\boldsymbol{R} = \sigma_{rr} \frac{ \partial \phi_i }{ \partial r} + \frac{ \phi_i}{X_r} \left( \sigma_{\phi \phi} + \sigma_{\theta \theta} \right)
\end{equation}

#### Example Input File syntax

Using the solid mechanics quasi-static physics, as shown

         block=Physics/SolidMechanics/QuasiStatic

the `StressDivergenceRSphericalTensors` kernel will be automatically built when the coordinate system
in the Problem block is specified for the spherical system,


and only a single displacement variable is provided:






### Stress Divergence RZ Tensors


#### Description

The kernel `StressDivergenceRZTensors` solves the stress divergence equation for an Axisymmetric
problem in the cylindrical coordinate system on a 2D mesh.

The axis of symmetry must lie along the $z$-axis in a $\left(r, z, \theta \right)$
or cylindrical coordinate system. This symmetry orientation is required for the
calculation of the residual and of the jacobian, as defined in [eq-solid_mechanics-RZ-stress-divergence].

The `StressDivergenceRZTensors` kernel can be automatically created with the
[Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md). Use of the tensor
mechanics quasi-static physics is recommended to ensure the consistent setting of the `use_displaced_mesh`
parameter for the strain formulation selected.  For a detailed explanation of the settings for
_use_displaced_mesh_ in mechanics problems and the Solid Mechanics Physics usage, see the
[Introduction/Stress Divergence](/solid_mechanics/StressDivergence.md) page.


#### Residual Calculation


In cylindrical coordinates, the
[divergence of a rank-2 tensor](https://en.wikipedia.org/wiki/Tensor_derivative_%28continuum_mechanics%29#Cylindrical_polar_coordinates_2)
includes mixed term contributions.  In the axisymmetric model we assume symmetric loading conditions,
in addition to the zero out-of-plane shear strains, so that the residual computation is simplified.

\begin{equation}
  \label{eq-solid_mechanics-RZ-stress-divergence}
  \begin{aligned}
  \nabla \sigma  & = \left[ \frac{\partial \sigma_{rr}}{\partial r} + \frac{u_r}{X_r}\sigma_{\theta \theta} + \frac{\partial \sigma_{rz}}{\partial z} \right] \hat{e}_r \\
   & + \left[ \frac{\partial \sigma_{zz}}{\partial z} + \frac{\partial \sigma_{rz}}{\partial r}    \right] \hat{e}_z
  \end{aligned}
\end{equation}

The calculation of the Jacobian is similarly complex, requiring up to four terms in the calculation
of the diagonal entries.

The axisymmetric system changes the order of the displacement vector from $(u_r, u_{\theta}, u_z)$,
usually seen in textbooks, to $(u_r, u_z, u_{\theta})$. Take care to follow this convention in your
input files and when adding extra stresses.

#### Example Input File

The coordinate type in the Problem block of the input file must be set to
+`COORD_TYPE = RZ`+.

Using the solid mechanics quasi-static physics, as shown


the `StressDivergenceRZTensors` kernel will be automatically built when the coordinate system in the
Problem block is specified for the axisymmetric RZ system,


and only two displacement variables are provided:






### Stress Divergence Tensors


#### Description

The `StressDivergenceTensors` kernel calculates the residual of the stress divergence for 1D, 2D, and
3D problems in the Cartesian coordinate system.  This kernel can be automatically created with the
[Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md). Use of the tensor
mechanics quasi-static physics is recommended to ensure the consistent setting of the _use_displaced_mesh_
parameter for the strain formulation selected.  For a detailed explanation of the settings for
_use_displaced_mesh_ in mechanics problems and the Solid Mechanics Physics usage, see the
[Introduction/StressDivergence](auto::/introduction/StressDivergence) page.

#### Residual Calculation


#### Use with Planar Models

When used with 2D planar models (plane stress, plane strain, or generalized plane strain),
it is used to compute the residuals for the in-plane response. In all of these cases,
it assumed that the out-of-plane thickness is 1, and the computation of the in-plane
residuals is identical to that for the 3D case.

The only exception to this is the plane stress case with finite deformation, because
the out-of-plane thickness change can be significant, and in general is not spatially
uniform, so local thickness changes must be accounted for. In this case, the standard
residual is multiplied by the modified thickness, $t$, which is computed from the logarithmic
out of plane strain $\varepsilon_{oop}$ as:
\begin{equation}
t = e^{\varepsilon_{oop}}
\end{equation}
This correction is made for 2D planar models when the deformed mesh is used by setting
`use_displaced_mesh = true` and `out_of_plane_strain` is specified.

#### Example Input File syntax

The Cartesian `StressDivergenceTensors` is the default case for the tensor
mechanics quasi-static physics

         block=Physics

Either 1, 2, or 3 displacement variables can be used in the stress divergence calculator for the
Cartesian system.





### StressDivergenceTensorsTruss


#### Description

This class computes the axial force in the truss local coordinate system using the axial stress and the cross-section area. This local force is then transformed to the global coordinate system using the orientation vector of the truss. The component of the force in the $i^{th}$ global coordinate direction is returned as the residual.





### WeakPlaneStress


#### Description

In 2D plane stress conditions, the out-of-plane stress is zero.  The `WeakPlaneStress` kernel
operates on an out-of-plane strain variable and computes the following residual:
\begin{equation}
  \int \phi \; \sigma_{zz} \; \textrm{dV}.
\end{equation}
Thus, the out-of-plane stress is driven toward zero but may not be strictly zero everywhere.
The computed out-of-plane strain may vary at different points on the plane.

For finite deformation models, this kernel should be run on the displaced mesh by setting
`use_displaced_mesh = true`.





## materials

### Abrupt Softening


#### Description

The material `AbruptSoftening` computes the reduced stress and stiffness
in the direction of a crack according to a step function. The computed
cracked stiffness ratio softens the tensile response of the material once the
principle stress exceeds the cracking stress threshold of the material.

As with the other smeared cracking softening models, which all follow the
nomenclature convention of using the `Softening` suffix, this model is intended
to be used with the [ComputeSmearedCrackingStress](/ComputeSmearedCrackingStress.md)
material.

##### Softening Model

As the class name implies, `AbruptSoftening` does not allow any gradual softening
of the material and instantly drops the stiffness of the material in response to
cracking.
The tensile stress response to cracking is based on the value of the residual
stress retained after softening, $\sigma_{res}$, and is given as
\begin{equation}
  \label{eqn:abrupt_crack_stress}
  \sigma = \begin{cases}
            1 \times 10^{-16} \cdot E \epsilon_c^{init} & \text{ if } \sigma_{res} = 0 \\
            \sigma_{res} \cdot \sigma_c & \text{ if } \sigma_{res} \neq 0
           \end{cases}
\end{equation}
where the calculated stress, $\sigma$ is the principle stress along the direction
of the crack, $\sigma_c$ is the stress threshold beyond which cracking occurs,
$E$ is the Young's modulus value, and $\epsilon_c^{init}$ is the strain in
direction of the crack when crack initiation occurred.
The ratio of the current stiffness to the original material stiffness is
similarly determined based on the value of the residual stress
\begin{equation}
  \label{eqn:abrupt_stiffness_ratio}
  R = \begin{cases}
        1 \times 10^{-16} & \text{ if } \sigma_{res} = 0 \\
        \frac{\sigma}{E \epsilon_c^{max}} & \text{ if } \sigma_{res} \neq 0
       \end{cases}
\end{equation}
where $\sigma$ is the principle stress along the direction of the crack,
$E$ is the Young's modulus value, and $\epsilon_c^{max}$ is the maximum strain
in the direction of crack.
The stiffness ratio is passed back to the
[ComputeSmearedCrackingStress](/ComputeSmearedCrackingStress.md)
to compute the softened cracked material stiffness.


#### Example Input File


`AbruptSoftening` must be run in conjunction with the fixed smeared cracking material model as shown below:






### AD Abrupt Softening


#### Description

The material `ADAbruptSoftening` computes the reduced stress and stiffness
in the direction of a crack according to a step function. The computed
cracked stiffness ratio softens the tensile response of the material once the
principle stress exceeds the cracking stress threshold of the material. 
It uses automatic differentiation for the computation of its Jacobian. 
For more details, refer to the non-AD version [`AbruptSoftening`](/AbruptSoftening.md).


#### Example Input File


`ADAbruptSoftening` must be run in conjunction with the fixed ad smeared cracking material model as shown below:






### ADComputeAxisymmetricRZFiniteStrain


#### Description

The material `ADComputeAxisymmetricRZFiniteStrain` calculates the finite strain
for 2D Axisymmetric systems.


Once the deformation gradient is calculated for the specific 2D geometry, the
deformation gradient is passed to the strain and rotation methods used by
default 3D Cartesian simulations, as described in the
[Finite Strain Class](ADComputeFiniteStrain.md) page.

#### Example Input File





### ADComputeAxisymmetricRZIncrementalStrain


#### Description

The material `ADComputeAxisymmetricRZIncrementalStrain` calculates the small
incremental strain for Axisymmetric systems.


Once the deformation gradient is calculated for the specific 2D geometry, the
deformation gradient is passed to the strain and rotation methods used by
default 3D Cartesian simulations, as described in the
[Incremental Finite Strain Class](ADComputeIncrementalStrain.md) page.




### ADComputeAxisymmetricRZSmallStrain


#### Description

The material `ADComputeAxisymmetricRZSmallStrain` calculates the small total
strain for Axisymmetric systems.


Only minimal changes are required to adapt a plane strain problem to an
axisymmetric problem. The axisymmetric specific
`ADComputeAxisymmetricRZSmallStrain` code overwrites the method used to
calculate the total strain component $\epsilon_{\theta \theta}$ before
calculating the total strain measure with the small strain assumptions.




### Compute Finite Shell Strain


#### Description

This class computes the finite strain increments for shell elements. Please refer to [ShellElements](/ShellElements.md) for details.




### ADComputeFiniteStrain


#### Description

This class is used to compute the strain increment, total strain, and
incremental rotation for finite strain problems. The finite strain approach used
is the incremental corotational form [!citep](rashid1993incremental). This
approach computes logarithmic strains and strain increments. This material
supplies material properties with all derivatives required to form an exact
Jacobian.

##### Incremental Configurations

In this form, the generic time increment under consideration is such that

\begin{equation}
  \label{eqn:time_notation}
  t \in [t_n, t_{n+1}]
\end{equation}

The configurations of the material element under consideration at $t = t_n$ and
$t = t_{n+1}$ are denoted by $\kappa_n$, and $\kappa_{n + 1}$, respectively for
the previous and the current incremental configurations.

##### Deformation Gradient Definition

The deformation gradient represents the change in a material element from the
reference configuration to the current configuration
[!citep](malvern1969introduction). In the incremental formulation used in the
`ADComputeFiniteStrain` class, the incremental deformation gradient represents
the change in the material element from the previous configuration, $\kappa_n$,
to the current configuration, $\kappa_{n+1}$. Mathematically this relationship
is given as

\begin{equation}
  \hat{\boldsymbol{F}} = \frac{\partial{\boldsymbol{x}_{n+1}}}{\partial{\boldsymbol{x}_n}},
\end{equation}

where $\boldsymbol{x}_{n+1}$ is the position vector of materials points in
$\kappa_{n+1}$, and $\boldsymbol{x}_{n}$ is the position vector of materials
points in $\kappa_{n}$.

Note that $\hat{\boldsymbol{F}}$ is NOT the deformation gradient, but rather the
incremental deformation gradient of $\kappa_{n+1}$ with respect to $\kappa_n$.
Thus $\hat{\boldsymbol{F}} = \boldsymbol{F}_{n+1} \boldsymbol{F}_n^{-1}$, where
$\boldsymbol{F}_n$ is the total deformation gradient at time $t_n$.

Following the explanation of this procedure given by [!cite](zhang2018modified),
the incremental deformation gradient can be multiplicatively decomposed into an
incremental rotation tensor, $\boldsymbol{\hat{R}}$, and the incremental right
stretch tensor, $\boldsymbol{\hat{U}}$

\begin{equation}
  \label{eqn:polar_decomposition_deform_grad}
  \boldsymbol{\hat{F}} = \boldsymbol{\hat{R}} \cdot \boldsymbol{\hat{U}}
\end{equation}

where $\boldsymbol{\hat{R}}$ is a proper orthogonal rotation tensor and the
stretch tensor, $\boldsymbol{\hat{U}}$, is symmetric and positive definite. The
incremental right Cauchy-Green deformation tensor, $\boldsymbol{\hat{C}}$, can
be given in terms of $\boldsymbol{\hat{U}}$ by substituting
[eqn:polar_decomposition_deform_grad] into the definition for
$\boldsymbol{\hat{C}}$ from [!cite](malvern1969introduction):

\begin{equation}
  \label{eqn:right_green_cauchy_deformation_tensor}
  \boldsymbol{\hat{C}} = \boldsymbol{\hat{F}}^T \cdot \boldsymbol{\hat{F}} = \boldsymbol{\hat{U}}^T \cdot \boldsymbol{\hat{R}}^T \cdot \boldsymbol{\hat{R}} \cdot \boldsymbol{\hat{U}} = \boldsymbol{\hat{U}}^2
\end{equation}

where the orthogonal nature of $\boldsymbol{\hat{R}}$ enables the simplification
given above. Thus $\boldsymbol{\hat{U}}$ can be computed from
$\boldsymbol{\hat{C}}$ as

\begin{equation}
  \label{eqn:definition_stretch_tensor}
  \boldsymbol{\hat{U}} = \boldsymbol{\hat{C}}^\frac{1}{2}
\end{equation}

which can be evaluated by performing a spectral decomposition of
$\boldsymbol{\hat{C}}$. Once $\boldsymbol{\hat{U}}$ has been computed, the
multiplicative decomposition of the deformation gradient is used to find the
incremental rotation tensor $\boldsymbol{\hat{R}}$ and the stretching rate
$\boldsymbol{D}$. Following [!cite](rashid1993incremental), the stretching rate
tensor can be expressed in terms of the 'incremental' right Cauchy-Green
deformation tensor

\begin{equation}
  \label{eqn:stretching_tensor_definition}
  \boldsymbol{D} = \frac{1}{\Delta t}\log({\hat{\boldsymbol{C}}^{1/2}})
\end{equation}

This incremental stretching rate tensor can then be used as the work conjugate
for a stress measure, or used to compute another strain measure. The most
computationally expensive part of this procedure is the spectral decomposition
of $\boldsymbol{\hat{C}}$ to find $\boldsymbol{\hat{U}}$. This decomposition can
be computed exactly using an [Eigensolution](#eigensolution), yet an
approximation of this can be computed with much lower computational expense
using a [Taylor expansion](#taylorexpansion) procedure. This class provides
options to perform this calculation either way, and the
[Taylor expansion](#taylorexpansion) is the default.

#### Taylor Expansion id=taylorexpansion

The stretching rate tensor $\boldsymbol{D}$ and incremental rotation matrix
$\hat{\boldsymbol{R}}$ can be approximated using Taylor expansion as
[!cite](rashid1993incremental): the approximated stretching rate tensor

\begin{equation}
\boldsymbol{D}^{a} = \frac{1}{\Delta t}\left[ -\frac{1}{2}(\hat{\boldsymbol{C}}^{-1} - \boldsymbol{I}) + \frac{1}{4}(\hat{\boldsymbol{C}}^{-1} - \boldsymbol{I})^{2} - \frac{1}{6}(\hat{\boldsymbol{C}}^{-1} - \boldsymbol{I})^{3} + ... \right]
\end{equation}

the approximated rotation matrix

\begin{equation}
\hat{R}_{ij}^{a} = \delta_{ij}\cos \theta^{a} + \frac{1-\cos \theta^{a}}{4Q} \alpha_{i}\alpha_{j} - \frac{\sin \theta^{a}}{2\sqrt{Q}}\epsilon_{ijk}\alpha_{k}
\end{equation}

with

\begin{equation}
\begin{aligned}
\sin^{2} \theta^{a} =& Q \\[1.5em]
\frac{\sin \theta^{a}}{2\sqrt{Q}} =& \frac{1}{2}\left[ \frac{PQ(3-Q)+P^{3}+Q^{2}}{(P+Q)^{3}} \right]^{1/2}\\[1.5em]
\frac{1-\cos \theta^{a}}{4Q} =& \frac{1}{8} + Q\frac{P^{2}-12(P-1)}{32P^2} + Q^{2}\frac{(P-2)(P^{2}-10P+32)}{64P^3}\\[1.5em]
 +& Q^{3}\frac{1104-992P+376P^{2}-72P^{3}+5P^{4}}{512P^{4}}\\[1.5em]
\cos^{2} \theta^{a} =& P + \frac{3P^{2}[1-(P+Q)]}{(P+Q)^{2}} - \frac{2P^{3}[1-(P+Q)]}{(P+Q)^{3}}\\[1.5em]
P =& \frac{1}{4}(tr(\hat{\boldsymbol{F}}^{-1}) - 1)^{2}
\end{aligned}
\end{equation}

The sign of $\cos \theta^{a}$ is set by examining the sign of $(tr(\hat{\boldsymbol{F}}^{-1}) - 1)$.

#### Eigen-Solution id=eigensolution

The stretching rate tensor can be calculated by the eigenvalues $\lambda$ and eigenvectors
$\boldsymbol{v}$ of $\hat{\boldsymbol{C}}$.
\begin{equation}
\boldsymbol{D} = \log{\sqrt{\lambda_{1}}}\boldsymbol{N}_{1} + \log{\sqrt{\lambda_{2}}}\boldsymbol{N}_{2} + \log{\sqrt{\lambda_{3}}}\boldsymbol{N}_{3}
\end{equation}

with $\lambda$ being the eigenvalue and $\boldsymbol{N}$ matrix being
constructed from the corresponding eigenvector.

\begin{equation}
\boldsymbol{N}_{i} = \boldsymbol{v}_{i}\boldsymbol{v}_{i}^{T}
\end{equation}

the 'incremental' stretching tensor

\begin{equation}
\hat{\boldsymbol{U}} = \sqrt{\lambda_{1}}\boldsymbol{N}_{1} + \sqrt{\lambda_{2}}\boldsymbol{N}_{2} + \sqrt{\lambda_{3}}\boldsymbol{N}_{3}
\end{equation}

and thus

\begin{equation}
\hat{\boldsymbol{R}} = \hat{\boldsymbol{F}} \hat{\boldsymbol{U}}^{-1}
\end{equation}

#### Volumetric Locking Correction

In `ADComputeFiniteStrain`, $\hat{\boldsymbol{F}}$ is calculated in the
computeStrain method, including a volumetric locking correction of

\begin{equation}
\hat{\boldsymbol{F}}_{corr} = \hat{\boldsymbol{F}} \left( \frac{|\mathrm{av}_{el}(\hat{\boldsymbol{F}})|}{|\hat{\boldsymbol{F}}|} \right)^{\frac{1}{3}},
\end{equation}

where $\mathrm{av}_{el}()$ is the average value for the entire element. The
strain increment and the rotation increment are calculated in
`computeQpStrain()`. Once the strain increment is calculated, it is added to the
total strain from $t_n$. The total strain from $t_{n+1}$ must then be rotated
using the rotation increment.

When directly using `ADComputeFiniteStrain` in an input file as shown above, the
[ADStressDivergenceTensors](/ADStressDivergenceTensors.md) kernel must be modified
from the default by setting the parameter `use_displaced_mesh = true`. This setting
is required to maintain consistency in the test function gradients and the
strain formulation. For a complete discussion of the stress divergence kernel
settings and the corresponding strain classes, see the section on
[Consistency Between Stress and Strain](/solid_mechanics/StressDivergence.md#consistency_stress_strain_use_displaced_mesh)
in the SolidMechanics module overview. In addition, be aware of the loading
cycle limitations while using finite strains as outlined in the section
[Large Strain Closed Loop Loading Cycle](/solid_mechanics/Strains.md#large_strain_closed_loop_loading_cycle).





### ADComputeFiniteStrainElasticStress


#### Description

This material, `ADComputeFiniteStrainElasticStress` computes the elastic stress
for an incremental formulation, both incremental small
([ADComputeIncrementalStrain](/ADComputeIncrementalStrain.md) type) and
incremental finite ([ADComputeFiniteStrain](/ADComputeFiniteStrain.md) type)
strain formulations. This stress class is compatible with both Cartesian and
non-Cartesian strain calculators, including
[Axisymmetric](/ADComputeAxisymmetricRZFiniteStrain.md) and
[RSpherical](/ADComputeRSphericalFiniteStrain.md).

Elastic materials do not experience permanent deformation, and all elastic
strain and elastic stress is recoverable. Elastic stress is related to elastic
strain through the elasticity tensor

\begin{equation}
  \label{eq:incremental_stress_calculator}
  \sigma_{ij} = C_{ijkl} \Delta \epsilon_{kl}
\end{equation}

where $\Delta \boldsymbol{\epsilon}$ is the strain increment; this strain
measure is also the sum of the mechanical elastic strain and any eigenstrains in
the system.




### ADComputeGreenLagrangeStrain


The Green-Lagrange strain $E$ is a non-linear total strain

\begin{equation}
  E=\frac12 \left(F^TF-1\right)
\end{equation}

Where $F$ is the deformation gradient tensor. It can be combined with
ADComputeLinearElasticStress to compute a second Piola-Kirchhoff stress (use the
ADStressDivergence kernel on the *undisplaced* mesh). This combination is
called a St. Venant-Kirchhoff hyper elasticity model.





### Compute Incremental Shell Strain


#### Description

This class computes the incremental small strain for shell elements. Please refer to [ShellElements](/ShellElements.md) for details.




### ADComputeIncrementalStrain


#### Description

The material `ADComputeIncrementalStrain` is designed for linear elasticity
problems formulated within an incremental framework.  As with
[ADComputeSmallStrain](/ADComputeSmallStrain.md), this material is useful for
verifying material models with hand calculations because of the simplified
strain calculations.  As in the small strain material, the incremental small
strain class assumes the gradient of displacement with respect to position is
much smaller than unity, and the squared displacement gradient term is neglected
in the small strain definition to give:

\begin{equation}
\epsilon = \frac{1}{2} \left( u \nabla + \nabla u \right) \quad when \quad \frac{\partial u}{ \partial x} << 1
\end{equation}

As the class name suggests, `ADComputeIncrementalStrain` is an incremental
formulation.  The stress increment is calculated from the current strain
increment at each time step.  In this class, the rotation tensor is defined to
be the rank-2 Identity tensor: no rotations are allowed in the model. Stateful
properties, including `strain_old` and `stress_old`, are stored. This
incremental small strain material is useful as a component of verifying more
complex finite incremental strain-stress calculations.




### Compute Isotropic Elasticity Tensor Shell


#### Description

This class computes the plane stress isotropic elasticity tensor for shell elements. Please refer to [ShellElements](/ShellElements.md) for details.




### ADComputeLinearElasticStress


#### Description

This material, `ADComputeLinearElasticStress` computes the elastic stress for a
total and small strain formulation: this stress class is compatible with the
[ADComputeSmallStrain](/ADComputeSmallStrain.md) type of strain calculators,
including those for non-Cartesian coordinate systems. This stress calculator
class can be used with any coordinate system to calculate the elastic stress
response for a small total formulation strain.

Elastic materials do not experience permanent deformation, and all elastic
strain and elastic stress is recoverable. Elastic stress is related to elastic
strain through the elasticity tensor

\begin{equation}
\sigma_{ij} = C_{ijkl} \epsilon_{kl}^{total}
\end{equation}

where $\boldsymbol{\epsilon}^{total}$ is the total strain formulation; this
strain measure is also the sum of the mechanical elastic strain and any
eigenstrains in the system.




### ADComputeMeanThermalExpansionFunctionEigenstrain


#### Description

This model computes the eigenstrain tensor resulting from isotropic thermal expansion where the
temperature-dependent thermal expansion is defined by a user-supplied function that describes the
mean thermal expansion coefficient $\bar{\alpha}$ as a function of temperature, $T$. This function is
defined relative to a reference temperature, $T_{ref}$, such that the total expansion at a given
temperature relative to the reference temperature is $\bar{\alpha}(T-T_{ref})$.  Following the
notation of [!cite](niffenegger2012proper), $\bar{\alpha}_{(T_{ref},T)}$ is defined as:

\begin{equation}
\bar{\alpha}_{(T_{ref},T)} = \frac{L_{(T)} - L_{(T_{ref})}}{L_{(T_{ref})}(T-T_{ref})}
\end{equation}
where $L_{T}$ is the length of a body at the current temperature, and $L_{T_{ref}}$ is the length of
that body at the reference temperature.

It is important to emphasize that this reference temperature is tied to the definition of the thermal
expansion function, and differs in general from the stress-free temperature for a specific
simulation.  For the general case where the stress-free temperature, $T_{sf}$, differs from the
reference temperature, the total thermal expansion eigenstrain is computed as:

\begin{equation}
\boldsymbol{\epsilon}^{th} = \frac{\bar{\alpha}_{(T_{ref},T)}(T-T_{ref}) - \bar{\alpha}_{(T_{ref},T_{sf})}(T_{sf}-T_{ref})}
{1 + \bar{\alpha}_{(T_{ref},T_{sf})}(T_{sf}-T_{ref})} \cdot \boldsymbol{I}
\end{equation}
where $T$ is the current temperature and $\boldsymbol{I}$ is the identity matrix.  Note that the
denominator in this equation is a correction to account for the ratio of $L_{(T_{sf})}$ to
$L_{(T_{ref})}$. As discussed in [!cite](niffenegger2012proper), that ratio is very close to 1, so it
is not strictly necessary to include that correction, but it is done here for completeness.

Functions are not able to handle dual numbers at this time, so no automatic differentiation
information can be retained via the $\bar{\alpha}$ function

#### Example Input File Syntax

         block=Materials/thermal_expansion_strain1

The `eigenstrain_name` parameter value must also be set for the strain calculator, and an example
parameter setting is shown below:

         block=Physics/SolidMechanics/QuasiStatic





### ADComputeMultipleInelasticStress


#### Description

`ADComputeMultipleInelasticStress` computes the stress and a decomposition of
the strain into elastic and inelastic components for a series of different
inelastic material models (e.g. creep and plasticity) which inherit from
`ADStressUpdateBase`. This material supplies material properties with all
derivatives required to form an exact Jacobian. By default finite strains are
assumed. The elastic strain is calculated by subtracting the computed inelastic
strain increment tensor from the mechanical strain increment tensor.

\begin{equation}
  \label{cmis_elastic_strain_definition}
  \Delta \boldsymbol{\epsilon}^{el} = \Delta \boldsymbol{\epsilon}^{mech} - \Delta \boldsymbol{\epsilon}^{inel}
\end{equation}
Mechanical strain, $\epsilon^{mech}$, is considered to be the sum of the elastic
and inelastic (e.g. plastic and creep) strains.

This class uses the finite incremental strain formulation as a default. Users
may elect to use a small incremental strain formulation and set
`perform_finite_strain_rotations = false` if the simulation will only ever use
small strains. This class is not intended for use with a total small linearize
strain formulation.

`ADComputeMultipleInelasticStress` is designed to be used in conjunction with a
separate model or set of models that computes the inelastic strain for a given
stress state. These inelastic models must derive from the `ADStressUpdateBase` class.

All of the inelastic material models that are compatible with
`ADComputeMultipleInelasticStress` follow the nomenclature convention of `StressUpdate`
as a suffix to the class name.

`ADComputeMultipleInelasticStress` can accommodate as few as zero inelastic
models (in which case the algorithm from
[ADComputeFiniteStrainElasticStress](/ADComputeFiniteStrainElasticStress.md) is
applied) to as many inelastic material models as is required by the physics. If
more than one inelastic material model is supplied to
`ADComputeMultipleInelasticStress`, it is recommended that all of the inelastic
models inherit from the same base class.

#### Multiple Inelastic Models

       id=fig:multiple_materials
       style=width:55%;margin-left:2%;float:right
       caption=The `ADComputeMultipleInelasticStress` algorithm for calculating the
               strains and stresses for multiple inelastic material models. (Note that
               computation of the consistent tangent operator is not performed in this
               version of the class. An exact Jacobian is guaranteed through automatic
               differentiation)

The algorithm used to compute the stress for multiple inelastic models is shown
in [fig:multiple_materials].

When multiple inelastic models are given, `ADComputeMultipleInelasticStress`
iterates over the specified inelastic models until the change in stress is
within a user-specified tolerance.

##### Inner Iteration over Inelastic Models

The inner iteration over the multiple inelastic material models is shown in the
green components in [fig:multiple_materials].

When each inelastic model is evaluated, a trial stress is computed using the
current elastic strain, which is the total mechanical strain minus the current
summation of inelastic strain for all inelastic models. This trial stress can be
expressed as

\begin{equation}
  \label{eqn:trial_stress}
  \sigma^{tr}_i = \begin{cases}
    C_{ijkl} \cdot \left( \epsilon^{el}_{old} + \Delta \epsilon^{el}_i \right) & \text{if $C_{ijkl}$ is isotropic}  \\
    \sigma_{old} + C_{ijkl} \cdot \left( \Delta \epsilon^{el}_i \right) & \text{if $C_{ijkl}$ is anisotropic}
  \end{cases}
\end{equation}

where $C_{ijkl}$ is the elasticity tensor for the material.

The $i^{th}$ inelastic material model, represented by the blue element
[fig:multiple_materials], is then called. The inelastic material model
calculates the inelastic strain increment necessary to produce an admissible
stress, as a function of the trial stress. The total inelastic strain increment
is updated for each model's contribution. The details of this calculation vary
by model and can include the effects of plasticity or creep.

The elastic and inelastic strain increments and the stress are returned to
`ADComputeMultipleInelasticStress` from the $i^{th}$ inelastic material model.

##### Outer Iteration over Stress Difference

After each inelastic model is called to compute an update to the stress tensor,
the minimum and maximum values of each component of the stress tensor, over the
course of those iterations, are stored to two tensors denoted as
$\boldsymbol{\sigma}_{max}$ and $\boldsymbol{\sigma}_{min}$, respectively. An
$L^2$ norm of the difference of these two tensors is then computed as

\begin{equation}
  \label{eqn:l2_norm_stress}
  L^2 \left(\Delta \boldsymbol{\sigma} \right) = \sqrt{\Delta \sigma_{ij} \Delta \sigma_{ij}}
    \text{, where } \Delta \boldsymbol{\sigma} = \boldsymbol{\sigma}_{max} - \boldsymbol{\sigma}_{min}
\end{equation}

The $L^2$ norm of the stress difference is compared to the absolute and relative
tolerances to determine if the solution from the combined inelastic material
models is converged

\begin{equation}
  \label{eqn:l2_norm_convergence}
  L^2 \left(\Delta \boldsymbol{\sigma} \right) < \text{absolute tolerance, or }
  \frac{L^2 \left(\Delta \boldsymbol{\sigma} \right)}{L^2 \left(\Delta \boldsymbol{\sigma}_o \right)} < \text{relative tolerance}
\end{equation}

where $L^2 \left(\Delta \sigma_o \right)$ is the $L^2$ norm from the very first
outer iteration over all of the inelastic material models. The solution will not
converge if the outer iteration loop, shown in the top half of
[fig:multiple_materials], exceeds the maximum number of iterations set by the
user.

Once convergence on the stress is obtained, the calculation of the inelastic
strains is finalized by applying a weighting factor, as shown in
[fig:multiple_materials]. This weighting factor has a default value of unity.

###### Material Time Step Size Limitations

Prior to calculating the final strain values, the algorithm checks the size of
the current time step against any limitations on the size of the time step as
optionally defined by the inelastic material models. As described in the
Material Time Step Limiter section, the time step size involves a post processor
to ensure that the current time step size is reasonable for each of the
inelastic material models used in the simulation.

At the end of the algorithm, the final value of the elastic and inelastic
strain tensors are calculated as shown in the last element of [fig:multiple_materials].

#### Single Inelastic Model

`ADComputeMultipleInelasticStress` can also be used to calculate the inelastic
strain and the stress when only a single inelastic material model is provided.

       id=fig:single_material
       style=width:40%;margin-right:2%;float:left
       caption=The optimized algorithm for calculating the strains and stress
               in the case when only a single inelastic material model is specified.

The algorithm, shown in [fig:single_material], used for a single inelastic
material model is an optimized version of the multiple materials algorithm. With
no need to iterate over multiple inelastic models, both the inner and outer
iterations from [fig:multiple_materials] are removed from the algorithm in
[fig:single_material].

The initial elastic strain increment guess is assumed to be the initial
mechanical strain increment, and the trial stress for the single inelastic model
is calculated from that elastic strain increment as in [eqn:trial_stress]. These
stress and strain values are passed directly to the inelastic material model.

The material model computes the admissible stress and strain states, as
indicated by the blue element in [fig:single_material]. The maximum size of the
allowable time step is then optionally calculated by the inelastic material
model, as described in the section below on the Material Time Step Limiter. At
the conclusion of the algorithm, the value of the elastic and inelastic strain
states are updated as shown in [fig:single_material].

##### Cycle Through One Inelastic Model per Time Step

`ADComputeMultipleInelasticStress` also includes an option to run a series of
inelastic models in a rotating fashion such that only a single inelastic model
is run on a timestep. This option uses the same algorithm as in
[fig:single_material] to determine the strains and stress value based on the
rotated single inelastic model. A separate method is then employed to propagate
the strain and stress values to the other inelastic material models for storage
as old material property values.

#### Other Calculations Performed by `StressUpdate` Materials

The `ADComputeMultipleInelasticStress` material relies on two helper
calculations to aid the simulation in converging. These helper computations are
defined within the specific inelastic models, and only a brief overview is given
here. These methods are represented within the blue inelastic material model
boxes in [fig:multiple_materials] and [fig:single_material]. For specific
details of the implementations, see the documentation pages for the individual
inelastic `StressUpdate` materials.

##### Material Time Step Limiter

In some cases, particularly in creep, limits on the time step are required by the
material model formulation. Each inelastic material model is responsible for
calculating the maximum time step allowable for that material model.
The [MaterialTimeStepPostprocessor](/MaterialTimeStepPostprocessor.md)
finds the minimum time step size limits from the entire simulation domain. The
postprocessor then interfaces with the [IterationAdaptiveDT](/IterationAdaptiveDT.md)
to restrict the time step size based on the limit calculated in the previous
time step.

#### Example Input Files

The input settings for multiple inelastic material models and a single inelastic
model are similar, and examples of both are shown below.

##### Multiple Inelastic Models

For multiple inelastic models, all of the inelastic material
model names must be listed as arguments to the `inelastic_models` parameter.
The inelastic material blocks must also be present.


##### Single Inelastic Model

For a single inelastic material model the input syntax is simply condensed


and only a single inelastic material model is included in the input. This example
includes the `max_inelastic_increment` parameter which is used to limit the time
step size.






### AD Compute Multiple Porous Inelastic Stress


#### Description

`ADComputeMultiplePorousInelasticStress` computes the stress and a decomposition of the strain into
elastic and inelastic components for a series of different inelastic material models (e.g. creep and
plasticity) which inherit from `ADStressUpdateBase`. The tangent operator and relevant Jacobian
information is computed using automatic differentiation techniques.
`ADComputeMultiplePorousInelasticStress` operates almost exactly the same as
[ADComputeMultipleInelasticStress](ADComputeMultipleInelasticStress.md) but adds a `porosity`
material property. After a inelastic strain $\epsilon_{in}$ is calculated, the porosity, $f$ is
updated by,
\begin{equation}
  \dot{f} = [1.0 - f] * \dot{\epsilon}_{in}.\text{tr}()
\end{equation}
The porosity can then in turn be used by [viscoplasticity methods](ADViscoplasticityStressUpdate.md)
or other porosity dependent materials

Refer to [ADComputeMultipleInelasticStress](ADComputeMultipleInelasticStress.md) for the remainder of
the details of how `ADComputeMultiplePorousInelasticStress` computes stress.

#### Example Input Files

`ADComputeMultiplePorousInelasticStress` can take individual or combinations of different inelastic
material models that inherit from `ADStressUpdateBase`.






### Compute Plane Finite Strain



#### Description

The material `ADComputePlaneFiniteStrain` calculates the finite strain for 2D
plane strain problems. It can be used for classical
[plane strain or plane stress](https://en.wikipedia.org/wiki/Plane_stress)
problems, or in
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md) simulations.

#### Out of Plane Strain

In the classical plane strain problem, it is assumed that the front and back
surfaces of the body are constrained in the out-of-plane direction, and that
the displacements in that direction on those surfaces are zero. As a
result, the strain and deformation gradient components in the out-of-plane
direction are held constant at zero:
\begin{equation}
  \label{eqn:classical_dop_deform_grad}
  F|^{dop} = 0 \text{  and  } \epsilon|^{dop} = 0
\end{equation}
$F|^{dop}$ is the deformation gradient tensor diagonal component for the
direction of the out-of-plane strain and $\epsilon|^{dop}$ is the corresponding
strain component.

##### Plane Stress and Generalized Plane Strain

In the cases of the plane stress and generalized plane strain assumptions, the
component of strain and the deformation gradient in the out-of-plane direction
is non-zero. To solve for this out-of-plane strain, we invoke the approximation
of the stretch rate tensor
\begin{equation}
  \label{eqn:stretch_tensor_approx}
  \boldsymbol{D} = \log \left( \sqrt{\hat{\boldsymbol{F}}^T \cdot \hat{\boldsymbol{F}}} \right) \cdot \frac{1}{dt}
\end{equation}
and define the deformation gradient component in the out-of-plane direction as
\begin{equation}
  \label{eqn:dop_deform_grad}
  F|^{dop} = \exp \left( \epsilon|^{op} - 1.0  \right)
\end{equation}
where $F|^{dop}$ is the deformation gradient tensor diagonal component for the
direction of the out-of-plane strain and $\epsilon|^{op}$ is a prescribed
out-of-plane strain value: this strain value can be given either as a scalar
variable or a nonlinear field variable.

For the case of plane stress, the [ADWeakPlaneStress](ADWeakPlaneStress.md) kernel
is used to integrate the out-of-plane component of the stress over the area of
each element, and assemble that integral to the residual of the out-of-plane
strain field variable. This results in a weak enforcement of the condition that
the out-of-plane stress is zero, which allows for re-use of the same constitutive
models for models of all dimensionality.

The [Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
problems use scalar variables. Multiple scalar variables can be provided such
that one strain calculator is needed for multiple generalized plane strain
models on different subdomains.


#### Strain and Deformation Gradient Formulation

The incremental deformation gradient for the 2D planar system is defined as
\begin{equation}
  \label{eqn:incremental_deformation_grad}
  \hat{\boldsymbol{F}} = \boldsymbol{A} : \bar{\boldsymbol{F}}^{-1} + \boldsymbol{I}
\end{equation}
where $\boldsymbol{I}$ is the Rank-2 identity tensor, $\boldsymbol{A}$ is the deformation
gradient, and $\bar{\boldsymbol{F}}$ is the old deformation gradient.

###### $Z$-Direction of Out-of-Plane Strain (Default)

The default out-of-plane direction is along the $z$-axis. For this direction
the current and old deformation gradient tensors, used in
[eqn:incremental_deformation_grad], are given as
\begin{equation}
  \label{eqn:deform_grads}
  \boldsymbol{A} = \begin{bmatrix}
                u_{x,x} & u_{x,y} & 0 \\
                u_{y,x} & u_{y,y} & 0 \\
                0 & 0 & F|^{dop}
              \end{bmatrix} + \boldsymbol{I}
  \qquad \text{  and  } \qquad
  \bar{\boldsymbol{F}} = \begin{bmatrix}
                u_{x,x}|_{old} & u_{x,y}|_{old} & 0 \\
                u_{y,x}|_{old} & u_{y,y}|_{old} & 0 \\
                0 & 0 & F|^{dop}_{old}
              \end{bmatrix} + \boldsymbol{I}
\end{equation}
where $F|^{dop}$ is defined in [eqn:dop_deform_grad].
Note that $\bar{\boldsymbol{F}}$ uses the values of the strain expressions from
the previous time step.
As in the classical presentation of the strain tensor in plane strain problems,
the components of the deformation tensor associated with the $z$-direction are
zero; these zero components indicate no coupling between the in-plane displacements
and the out-of-plane strain variable.

###### $X$-Direction of Out-of-Plane Strain

If the user selects the out-of-plane direction as along the $x$-direction, the
current and old deformation gradient tensors from [eqn:incremental_deformation_grad]
are formulated as
\begin{equation}
  \label{eqn:deform_grads_xdirs}
  \boldsymbol{A} = \begin{bmatrix}
                F|^{dop} & 0 & 0 \\
                0 & u_{y,y} & u_{z,y} \\
                0 & u_{y,z} & u_{z,z}
              \end{bmatrix} + \boldsymbol{I}
  \qquad \text{  and  } \qquad
  \bar{\boldsymbol{F}} = \begin{bmatrix}
                F|^{dop}_{old} & 0 & 0 \\
                0 & u_{y,y}|_{old} & u_{y,z}|_{old} \\
                0 & u_{z,y}|_{old}& u_{z,z}|_{old}
              \end{bmatrix} + \boldsymbol{I}
\end{equation}
so that the off-diagonal components of the deformation tensors associated with
the $x$-direction are zeros.

###### $Y$-Direction of Out-of-Plane Strain

If the user selects the out-of-plane direction as along the $y$-direction, the
current and old deformation gradient tensors from [eqn:incremental_deformation_grad]
are formulated as
\begin{equation}
  \label{eqn:deform_grads_ydirs}
  \boldsymbol{A} = \begin{bmatrix}
                u_{x,x} & 0 & u_{z,x} \\
                0 & F|^{dop} & 0 \\
                u_{x,z} & 0 & u_{z,z}
              \end{bmatrix} + \boldsymbol{I}
  \qquad \text{  and  } \qquad
  \bar{\boldsymbol{F}} = \begin{bmatrix}
                u_{x,x}|_{old} & 0 & u_{x,z}|_{old} \\
                0 & F|^{dop}_{old} & 0 \\
                u_{z,x}|_{old} & 0 & u_{z,z}|_{old}
              \end{bmatrix} + \boldsymbol{I}
\end{equation}
so that the off-diagonal components of the deformation tensors associated with
the $y$-direction are zeros.


##### Finalized Deformation Gradient

If selected by the user, the incremental deformation gradient is conditioned with
a $\bar{B}$ formulation to mitigate volumetric locking of the elements.
The volumetric locking correction is applied to both the incremental deformation
gradient
\begin{equation}
  \label{eqn:vlc_fhat}
  \hat{\boldsymbol{F}}|_{vlc} = \left( \frac{1}{det(\hat{\boldsymbol{F}})} \frac{\hat{\boldsymbol{F}}_{avg}}{V_{elem}} \right)^{1/3}
\end{equation}
and the total deformation gradient. For more details about the theory behind
[eqn:vlc_fhat] see the
[Volumetric Locking Correction](/solid_mechanics/VolumetricLocking.md)
documentation.

Once the incremental deformation gradient is calculated for the specific 2D geometry,
the deformation gradient is passed to the strain and rotation methods used by the
3D Cartesian simulations, as described in the [Finite Strain Class](ADComputeFiniteStrain.md)
documentation.

#### Example Input Files

##### Plane Stress

The solid mechanics [QuasiStatic Physics](/Physics/SolidMechanics/QuasiStatic/index.md)
can be used to create the `ADComputePlaneFiniteStrain` class by setting
`planar_formulation = WEAK_PLANE_STRESS` and `strain = FINITE` in the
QuasiStatic Physics block.


Note that for plane stress analysis, the `out_of_plane_strain` parameter must be
defined, and is the name of the out-of-plane strain field variable.


In the case of this example, `out_of_plane_strain` is defined in the `GlobalParams` block.

##### Generalized Plane Strain

The use of this plane strain class for
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
simulations uses the scalar out-of-plane strains. The solid mechanics
[QuasiStatic Physics](/Physics/SolidMechanics/QuasiStatic/index.md) is used to create the
`ADComputePlaneFiniteStrain` class with the `planar_formulation = GENERALIZED_PLANE_STRAIN`
and the `strain = FINITE` settings.


Note that the argument for the `scalar_out_of_plane_strain` parameter is the
name of the scalar strain variable






### Compute Plane Incremental Strain


#### Description

The material `ADComputePlaneIncrementalStrain` calculates the small incremental
strain for 2D plane strain problems. It can be used for classical
[plane strain or plane stress](https://en.wikipedia.org/wiki/Plane_stress)
problems, or in
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md) simulations.

#### Out of Plane Strain

In the classical plane strain problem, it is assumed that the front and back
surfaces of the body are constrained in the out-of-plane direction, and that
the displacements in that direction on those surfaces are zero. As a
result, the strain and deformation gradient components in the out-of-plane
direction are held constant at zero:
\begin{equation}
  \label{eqn:classical_dop_deform_grad}
  F|^{dop} = 0 \text{  and  } \epsilon|^{dop} = 0
\end{equation}
$F|^{dop}$ is the deformation gradient tensor diagonal component for the
direction of the out-of-plane strain and $\epsilon|^{dop}$ is the corresponding
strain component.

##### Generalized Plane Strain

In the cases of the generalized plane strain and weak plane stress models, the
component of strain and the deformation gradient in the out-of-plane direction
is non-zero. To solve for this out-of-plane strain, we use the out-of-plane
strain variable as the deformation gradient component
\begin{equation}
  \label{eqn:dop_deform_grad}
  F|^{dop} = \epsilon|^{op}
\end{equation}
where $F|^{dop}$ is the deformation gradient tensor diagonal component for the
direction of the out-of-plane strain and $\epsilon|^{op}$ is a prescribed
out-of-plane strain value: this strain value can be given either as a scalar
variable or a nonlinear field variable.
The [Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
problems use scalar variables. Multiple scalar variables can be provided such
that one strain calculator is needed for multiple generalized plane strain
models on different subdomains.

For the case of plane stress, the [ADWeakPlaneStress](ADWeakPlaneStress.md) kernel
is used to integrate the out-of-plane component of the stress over the area of
each element, and assemble that integral to the residual of the out-of-plane
strain field variable. This results in a weak enforcement of the condition that
the out-of-plane stress is zero, which allows for re-use of the same constitutive
models for models of all dimensionality.

#### Strain and Deformation Gradient Formulation

The small strain increment is calculated with the form
\begin{equation}
  \label{eqn:strain_increment}
  \Delta \boldsymbol{\epsilon} = \frac{1}{2} \left( \boldsymbol{D} + \boldsymbol{D}^T \right)
  \text{ where } \boldsymbol{D} = \boldsymbol{A} - \bar{\boldsymbol{F}} + \boldsymbol{I}
\end{equation}
where $\boldsymbol{I}$ is the Rank-2 identity tensor, $\boldsymbol{A}$ is the deformation
gradient, and $\bar{\boldsymbol{F}}$ is the old deformation gradient.

###### $Z$-Direction of Out-of-Plane Strain (Default)

The default out-of-plane direction is along the $z$-axis. For this direction
the current and old deformation gradient tensors, used in
[eqn:strain_increment], are given as
\begin{equation}
  \label{eqn:deform_grads}
  \boldsymbol{A} = \begin{bmatrix}
                u_{x,x} & u_{x,y} & 0 \\
                u_{y,x} & u_{y,y} & 0 \\
                0 & 0 & F|^{dop}
              \end{bmatrix} + \boldsymbol{I}
  \qquad \text{  and  } \qquad
  \bar{\boldsymbol{F}} = \begin{bmatrix}
                u_{x,x}|_{old} & u_{x,y}|_{old} & 0 \\
                u_{y,x}|_{old} & u_{y,y}|_{old} & 0 \\
                0 & 0 & F|^{dop}_{old}
              \end{bmatrix} + \boldsymbol{I}
\end{equation}
where $F|^{dop}$ is defined in [eqn:dop_deform_grad].
Note that $\bar{\boldsymbol{F}}$ uses the values of the strain expressions from
the previous time step.
As in the classical presentation of the strain tensor in plane strain problems,
the components of the deformation tensor associated with the $z$-direction are
zero; these zero components indicate no coupling between the in-plane displacements
and the out-of-plane strain variable.

###### $X$-Direction of Out-of-Plane Strain

If the user selects the out-of-plane direction as along the $x$-direction, the
current and old deformation gradient tensors from [eqn:strain_increment] are
formulated as
\begin{equation}
  \label{eqn:deform_grads_xdirs}
  \boldsymbol{A} = \begin{bmatrix}
                F|^{dop} & 0 & 0 \\
                0 & u_{y,y} & u_{z,y} \\
                0 & u_{y,z} & u_{z,z}
              \end{bmatrix} + \boldsymbol{I}
  \qquad \text{  and  } \qquad
  \bar{\boldsymbol{F}} = \begin{bmatrix}
                F|^{dop}_{old} & 0 & 0 \\
                0 & u_{y,y}|_{old} & u_{y,z}|_{old} \\
                0 & u_{z,y}|_{old}& u_{z,z}|_{old}
              \end{bmatrix} + \boldsymbol{I}
\end{equation}
so that the off-diagonal components of the deformation tensors associated with
the $x$-direction are zeros.

###### $Y$-Direction of Out-of-Plane Strain

If the user selects the out-of-plane direction as along the $y$-direction, the
current and old deformation gradient tensors from [eqn:strain_increment] are
formulated as
\begin{equation}
  \label{eqn:deform_grads_ydirs}
  \boldsymbol{A} = \begin{bmatrix}
                u_{x,x} & 0 & u_{z,x} \\
                0 & F|^{dop} & 0 \\
                u_{x,z} & 0 & u_{z,z}
              \end{bmatrix} + \boldsymbol{I}
  \qquad \text{  and  } \qquad
  \bar{\boldsymbol{F}} = \begin{bmatrix}
                u_{x,x}|_{old} & 0 & u_{x,z}|_{old} \\
                0 & F|^{dop}_{old} & 0 \\
                u_{z,x}|_{old} & 0 & u_{z,z}|_{old}
              \end{bmatrix} + \boldsymbol{I}
\end{equation}
so that the off-diagonal components of the deformation tensors associated with
the $y$-direction are zeros.

##### Finalized Deformation Gradient

Once the incremental deformation gradient is calculated for the specific 2D geometry,
the deformation gradient is passed to the strain and rotation methods used by the
3D Cartesian simulations, as described in the
[Compute Incremental Small Strain](ComputeIncrementalStrain.md) documentation.

If selected by the user, the incremental strain tensor is conditioned with
a $\bar{B}$ formulation to mitigate volumetric locking of the elements.
The volumetric locking correction is applied to the total strain
\begin{equation}
  \label{eqn:vlc_strain}
  \Delta \boldsymbol{\epsilon}|_{vlc} = \boldsymbol{\epsilon} + \frac{\left( \boldsymbol{\epsilon}_V - tr(\boldsymbol{\Delta \epsilon}) \right)}{3} \cdot \boldsymbol{I}
\end{equation}
where $\boldsymbol{\epsilon}_V$ is the volumetric strain and $\boldsymbol{I}$
is the Rank-2 identity tensor. For more details about the theory
behind [eqn:vlc_strain] see the
[Volumetric Locking Correction](/solid_mechanics/VolumetricLocking.md)
documentation.

#### Example Input Files

##### Plane Stress

The solid mechanics [QuasiStatic Physics](/Physics/SolidMechanics/QuasiStatic/index.md)
can be used to create the `ADComputePlaneIncrementalStrain` class by setting
`planar_formulation = WEAK_PLANE_STRESS`, `strain = SMALL`, and `incremental = true` in the
QuasiStatic Physics block.


Note that for plane stress analysis, the `out_of_plane_strain` parameter must be
defined, and is the name of the out-of-plane strain field variable.


In the case of this example, `out_of_plane_strain` is defined in the `GlobalParams` block.

##### Generalized Plane Strain

The use of this plane strain class for
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
simulations uses the scalar out-of-plane strains. The solid mechanics
[QuasiStatic Physics](/Physics/SolidMechanics/QuasiStatic/index.md) is used to create the
`ADComputePlaneIncrementalStrain` class with the `planar_formulation = GENERALIZED_PLANE_STRAIN`,
`strain = SMALL`, and `incremental = true` settings.


Note that the argument for the `scalar_out_of_plane_strain` parameter is the
name of the scalar strain variable







### Compute Plane Small Strain


#### Description

The material `ADComputePlaneSmallStrain` calculates the small total
strain for 2D plane strain problems. It can be used for classical
[plane strain or plane stress](https://en.wikipedia.org/wiki/Plane_stress)
problems, or in
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md) simulations.

#### Out of Plane Strain

In the classical plane strain problem, it is assumed that the front and back
surfaces of the body are constrained in the out-of-plane direction, and that
the displacements in that direction on those surfaces are zero. As a
result, the strain and deformation gradient components in the out-of-plane
direction are held constant at zero:
\begin{equation}
  \label{eqn:classical_dop_deform_grad}
  \epsilon|^{dop} = 0
\end{equation}
$\epsilon|^{dop}$ is the strain tensor diagonal component for the
direction of the out-of-plane strain.

##### Plane Stress and Generalized Plane Strain

In the cases of the plane stress and generalized plane strain assumptions, the
component of strain and the deformation gradient in the out-of-plane direction
is non-zero. To solve for this out-of-plane strain, we use the out-of-plane
strain variable as the strain tensor component
\begin{equation}
  \label{eqn:dop_deform_grad}
  \epsilon|^{dop} = \epsilon|^{op}
\end{equation}
where $\epsilon|^{dop}$ is the strain tensor diagonal component for
the direction of the out-of-plane strain and $\epsilon|^{op}$ is a
prescribed out-of-plane strain value: this strain value can be
given either as a scalar variable or a nonlinear field variable.
The [Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
problems use scalar variables. Multiple scalar variables can be provided such
that one strain calculator is needed for multiple generalized plane strain
models on different subdomains.

For the case of plane stress, the [ADWeakPlaneStress](ADWeakPlaneStress.md) kernel
is used to integrate the out-of-plane component of the stress over the area of
each element, and assemble that integral to the residual of the out-of-plane
strain field variable. This results in a weak enforcement of the condition that
the out-of-plane stress is zero, which allows for re-use of the same constitutive
models for models of all dimensionality.

#### Strain and Deformation Gradient Formulation

The definition of a small total linearized strain is
\begin{equation}
  \label{eqn:def_small_total_strain}
  \epsilon_{ij} = \frac{1}{2} \left( u_{i,j} + u_{j,i}  \right)
\end{equation}
The values of each of the strain tensor components depends on the direction
selected by the user as the out-of-plane direction.

###### $Z$-Direction of Out-of-Plane Strain (Default)

The default out-of-plane direction is along the $z$-axis. For this direction
the strain tensor, [eqn:def_small_total_strain], is given as
\begin{equation}
  \label{eqn:strain_tensor}
  \boldsymbol{\epsilon} = \begin{bmatrix}
                u_{x,x} & \frac{1}{2} \left(u_{x,y} + u_{y,x} \right) & 0 \\
                \frac{1}{2} \left(u_{x,y} + u_{y,x} \right) & u_{y,y} & 0 \\
                0 & 0 & \epsilon|^{dop}
              \end{bmatrix}
\end{equation}
where $\epsilon|^{dop}$ is defined in [eqn:dop_deform_grad].
As in the classical presentation of the strain tensor in plane
strain problems, the components of the strain tensor associated
with the $z$-direction are zero; these zero components indicate no
coupling between the in-plane and the out-of-plane strains.

###### $X$-Direction of Out-of-Plane Strain

If the user selects the out-of-plane direction as along the
$x$-direction, the strain tensor from [eqn:def_small_total_strain]
is given as
\begin{equation}
  \label{eqn:deform_grads_xdirs}
  \boldsymbol{\epsilon} = \begin{bmatrix}
                \epsilon|^{dop} & 0 & 0 \\
                0 & u_{y,y} & \frac{1}{2} \left(u_{y,z} + u_{z,y} \right) \\
                0 & \frac{1}{2} \left(u_{y,z} + u_{z,y} \right) & u_{z,z}
              \end{bmatrix}
\end{equation}
so that the off-diagonal components of the strain tensor associated
with the $x$-direction are zeros.

###### $Y$-Direction of Out-of-Plane Strain

If the user selects the out-of-plane direction as along the
$y$-direction, the strain tensor from [eqn:def_small_total_strain]
is given as
\begin{equation}
  \label{eqn:deform_grads_ydirs}
  \boldsymbol{\epsilon} = \begin{bmatrix}
                u_{x,x} & 0 & \frac{1}{2} \left(u_{x,z} + u_{z,x} \right) \\
                0 & \epsilon|^{dop} & 0 \\
                \frac{1}{2} \left(u_{x,z} + u_{z,x} \right) & 0 & u_{z,z}
              \end{bmatrix}
\end{equation}
so that the off-diagonal components of the strain tensor associated
with the $y$-direction are zeros.

##### Volumetric Locking Correction for Strain Tensor

If selected by the user, the strain tensor is conditioned with
a $\bar{B}$ formulation to mitigate volumetric locking of the elements.
The volumetric locking correction is applied to the total strain
\begin{equation}
  \label{eqn:vlc_strain}
  \boldsymbol{\epsilon}|_{vlc} = \boldsymbol{\epsilon} + \frac{\left( \boldsymbol{\epsilon}_V - tr(\boldsymbol{\epsilon}) \right)}{3} \cdot \boldsymbol{I}
\end{equation}
where $\boldsymbol{\epsilon}_V$ is the volumetric strain and $\boldsymbol{I}$
is the Rank-2 identity tensor. For more details about the theory
behind [eqn:vlc_strain] see the
[Volumetric Locking Correction](/solid_mechanics/VolumetricLocking.md)
documentation.

#### Example Input Files

##### Plane Stress

The solid mechanics [QuasiStatic Physics](/Physics/SolidMechanics/QuasiStatic/index.md)
can be used to create the `ADComputePlaneSmallStrain` class by setting
`planar_formulation = WEAK_PLANE_STRESS` and `strain = SMALL` in the
QuasiStatic Physics block.


Note that for plane stress analysis, the `out_of_plane_strain` parameter must be
defined, and is the name of the out-of-plane strain field variable.


In the case of this example, `out_of_plane_strain` is defined in the `GlobalParams` block.

##### Generalized Plane Strain

The use of this plane strain class for
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
simulations uses the scalar out-of-plane strains. The solid mechanics
[QuasiStatic Physics](/Physics/SolidMechanics/QuasiStatic/index.md) is used to create the
`ADComputePlaneSmallStrain` class with the `planar_formulation = GENERALIZED_PLANE_STRAIN`
and `strain = SMALL` settings.


Note that the argument for the `scalar_out_of_plane_strain` parameter is the
name of the scalar strain variable


##### $Y$-Direction of Out-of-Plane Strain

This plane strain class is used to model plane strain with an out-of-plane strain
in directions other than in the $z$-direction. As an example, the solid mechanics
[QuasiStatic Physics](/Physics/SolidMechanics/QuasiStatic/index.md) can be used to create
the `ComputePlaneFiniteStrain` class for a $y$-direction out-of-plane strain with
the `planar_formulation = PLANE_STRAIN` and the `out_of_plane_direction = y`
settings.






### ADComputeRSphericalFiniteStrain


#### Description

The material `ADComputeRSphericalFiniteStrain` calculates the small incremental
strain for 1D R-Spherical systems.

The 1D RSpherical materials and kernel are designed to model sphere geometries
with 1D models. Symmetry in the polar ($\theta$) and azimuthal ($\phi$)
directions is assumed, and the model is considered to revolve in both of these
directions.  In the 1D R-Spherical code, the material properties, variables
(e.g. temperature), and loading conditions are all assumed to be spherically
symmetric: these attributes only depend on the axial position.

The coordinate type in the `[Problem]` block of the input file must be set to
`coord_type = RSPHERICAL`.

As in the plane strain and axisymmetric cases, the stress and strain tensors are
modified in the spherical problem; only the diagonal components are non-zero in
this 1D problem.

\begin{equation}
\begin{bmatrix}
\epsilon_{rr} & 0 & 0 \\
0 & \epsilon_{\theta \theta} & 0 \\
0 & 0 & \epsilon_{\phi \phi}
\end{bmatrix}
\end{equation}

where the value of the normal strain components in the polar and azimuth
directions $\epsilon_{\theta \theta}$ and $\epsilon_{\phi \phi}$ depends on the
displacement and position in the radial direction

\begin{equation}
  \label{eq:polar_azimuthal_rspherical_strains}
  \epsilon_{\theta \theta} = \epsilon_{\phi \phi} = \frac{u_r}{X_r}.
\end{equation}

Although axisymmetric problems solve for 3D stress and strain fields, the
problem is mathematically 1D. In the cylindrical coordinate axisymmetric system,
the values of stress and strain in the $\theta$ and $\phi$ directions do not
depend on the $\theta$ or $\phi$ coordinates.

Once the deformation gradient is calculated for the 1D geometry, the deformation
gradient is passed to the strain and rotation methods used by default 3D
Cartesian simulations, as described in the [Finite Strain Class](ADComputeFiniteStrain.md) page.




### ADComputeRSphericalIncrementalStrain


#### Description

The material `ADComputeRSphericalIncrementalStrain` calculates the small
incremental strain for 1D R-Spherical systems.

The 1D RSpherical materials and kernel are designed to model sphere geometries
with 1D models. Symmetry in the polar ($\theta$) and azimuthal ($\phi$)
directions is assumed, and the model is considered to revolve in both of these
directions.  In the 1D R-Spherical code, the material properties, variables
(e.g. temperature), and loading conditions are all assumed to be spherically
symmetric: these attributes only depend on the axial position.

The coordinate type in the `[Problem]` block of the input file must be set to
`coord_type = RSPHERICAL`.

As in the plane strain and axisymmetric cases, the stress and strain tensors are
modified in the spherical problem; only the diagonal components are non-zero in
this 1D problem.

\begin{equation}
\begin{bmatrix}
\epsilon_{rr} & 0 & 0 \\
0 & \epsilon_{\theta \theta} & 0 \\
0 & 0 & \epsilon_{\phi \phi}
\end{bmatrix}
\end{equation}

where the value of the normal strain components in the polar and azimuth
directions $\epsilon_{\theta \theta}$ and $\epsilon_{\phi \phi}$ depends on the
displacement and position in the radial direction

\begin{equation}
  \label{eq:polar_azimuthal_rspherical_strains}
  \epsilon_{\theta \theta} = \epsilon_{\phi \phi} = \frac{u_r}{X_r}.
\end{equation}

Although axisymmetric problems solve for 3D stress and strain fields, the
problem is mathematically 1D.  In the cylindrical coordinate axisymmetric
system, the values of stress and strain in the $\theta$ and $\phi$ directions do
not depend on the $\theta$ or $\phi$ coordinates.

The RSpherical specific `ADComputeRSphericalIncrementalStrain` class calculates
the radial strain as normally done for an incremental small total strain
material:

\begin{equation}
  \epsilon_{rr} = \frac{1}{2} \left( \nabla u_r + u_r \nabla \right)
\end{equation}

while the calculation of the total strain components $\epsilon_{\theta \theta}$
and $\epsilon_{\phi \phi}$ are found with
[eq:polar_azimuthal_rspherical_strains].




### Compute R-Spherical Small Strain


#### Description

The material `ADComputeRSphericalSmallStrain` calculates the small total strain
for 1D R-Spherical systems.

The 1D RSpherical materials and kernel are designed to model sphere geometries
with 1D models. Symmetry in the polar ($\theta$) and azimuthal ($\phi$)
directions is assumed, and the model is considered to revolve in both of these
directions.  In the 1D R-Spherical code, the material properties, variables
(e.g. temperature), and loading conditions are all assumed to be spherically
symmetric: these attributes only depend on the axial position.

The coordinate type in the `[Problem]` block of the input file must be set to
`coord_type = RSPHERICAL`.

As in the plane strain and axisymmetric cases, the stress and strain tensors are
modified in the spherical problem; only the diagonal components are non-zero in
this 1D problem.

\begin{equation}
\begin{bmatrix}
\epsilon_{rr} & 0 & 0 \\
0 & \epsilon_{\theta \theta} & 0 \\
0 & 0 & \epsilon_{\phi \phi}
\end{bmatrix}
\end{equation}

where the value of the normal strain components in the polar and azimuth
directions $\epsilon_{\theta \theta}$ and $\epsilon_{\phi \phi}$ depends on the
displacement and position in the radial direction

\begin{equation}
  \label{eq:polar_azimuthal_rspherical_strains}
  \epsilon_{\theta \theta} = \epsilon_{\phi \phi} = \frac{u_r}{X_r}.
\end{equation}

Although axisymmetric problems solve for 3D stress and strain fields, the
problem is mathematically 1D. In the cylindrical coordinate axisymmetric system,
the values of stress and strain in the $\theta$ and $\phi$ directions do not
depend on the $\theta$ or $\phi$ coordinates.

The RSpherical specific `ADComputeRSphericalSmallStrain` class calculates the
radial strain as normally done for a small total strain material:

\begin{equation}
  \epsilon_{rr} = \nabla u_r
\end{equation}

while the calculation of the total strain components $\epsilon_{\theta \theta}$
and $\epsilon_{\phi \phi}$ are found with
[eq:polar_azimuthal_rspherical_strains].




### Compute Shell Stress


#### Description

This class computes the stress increments and total stresses for shell elements. Please refer to [ShellElements](/ShellElements.md) for details.




### ADComputeSmallStrain


#### Description

The material `ADComputeSmallStrain` is designed for linear elasticity problems,
which calculates the small, total strain. This material is useful for verifying
material models with hand calculations because of the simplified strain
calculations. This material supplies material properties with all derivatives
required to form an exact Jacobian.

Linearized small strain theory assumes that the gradient of displacement with
respect to position is much smaller than unity, and the squared displacement
gradient term is neglected in the small strain definition to give:

\begin{equation}
\epsilon = \frac{1}{2} \left( u \nabla + \nabla u \right) \quad when \quad \frac{\partial u}{ \partial x} << 1
\end{equation}

For more details on the linearized small strain assumption and derivation, see a
Continuum Mechanics text such as [!cite](malvern1969introduction) or
[!cite](bower2009applied), specifically
[Chapter 2](http://solidmechanics.org/Text/Chapter2_1/Chapter2_1.php#Sect2_1_7).

Total strain theories are path independent: in MOOSE, path independence means
that the total strain, from the beginning of the entire simulation, is used to
calculate stress and other material properties.  Incremental theories, on the
other hand, use the increment of strain at timestep to calculate stress.
Because the total strain formulation `ADComputeSmallStrain` is path independent,
no old values of strain or stress from the previous timestep are stored in
MOOSE. For a comparison of total strain vs incremental strain theories with
experimental data, see [!cite](shammamy1967incremental).





### AD Compute Smeared Cracking Stress


#### Description
Similar to the [`ComputeSmearedCrackingStress`](/ComputeSmearedCrackingStress.md) object
except that the Jacobian of the internal forces is computed via automatic differentiation.

#### Example Input File Syntax





### Compute Strain Increment Based Stress


#### Description

This stress calculator finds the value of the stress as a function of the elastic
strain increment when a series of inelastic strains are specified in the input file.
The stress is calculated as
\begin{equation}
  \label{eqn:stress}
  \sigma_{ij} = \sigma_{ij}^{old} + C_{ijkl} \Delta \epsilon_{jk}^{el}
\end{equation}
where $\sigma_{ij}$ is the stress and $C_{ijkl}$ is the elasticity tensor of the
material.
The elastic strain increment, $\Delta \epsilon_{jk}^{el}$ is found by subtracting
the sum of the inelastic strains from the mechanical strain:
\begin{equation}
  \label{eqn:elastic_strain_incr}
  \Delta \boldsymbol{\epsilon}^{el} = \boldsymbol{\epsilon}^{mech} - \boldsymbol{\epsilon}^{mech-old}
      - \sum_n \left( \boldsymbol{\epsilon}^{inel}_n - {\boldsymbol{\epsilon}^{inel-old}}_n \right)
\end{equation}
where $\boldsymbol{\epsilon}^{mech}$ is the mechanical strain and
$\boldsymbol{\epsilon}^{inel}$ is the inelastic strain.
In the solid mechanics module mechanical strain is defined as the sum of the
elastic and inelastic (e.g. creep and/or plasticity) strains.

#### Example Input File






### ADCompute Variable Isotropic Elasticity Tensor


#### Description

This model computes an elasticity tensor for which the elastic moduli, prescribed in terms of the
Young's modulus and Poisson's ratio, vary as defined by user-specified material properties. Every
time this material is evaluated, the full tensor is updated to reflect the current values of those
elastic constants.

#### Example Input File Syntax





### AD Compute Volumetric Eigenstrain


#### Description

This material computes the eigenstrain tensor based on a set of scalar material properties
which when summed together define the volumetric strain. The materials taken as input to this
model specify the ratio $V/V_0$, where $V$ is the current volume and $V_0$ is the initial
volume.

In models that use finite strain formulations, the volume change resulting from
this eigenstrain will exactly equal the specified volumetric strain.

#### Example Input File Syntax

         block=Materials/volumetric_eigenstrain

where the volumetric material is defined as a separate material model

         block=Materials/volumetric_change

The `eigenstrain_name` parameter value must also be set for the strain calculator. When the
[SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md) Action is used, it automatically creates the strain
calculator. In that case, the `eigenstrain_name` is specified in the QuasiStatic block, and
passed in to the strain calculator as shown:

         block=Physics/SolidMechanics/QuasiStatic




### AD Exponential Softening


#### Description

The material `ADExponentialSoftening` computes the reduced stress and stiffness
in the direction of a crack according to a exponential function. The computed
cracked stiffness ratio softens the tensile response of the material once the
principle stress exceeds the cracking stress threshold of the material. 
It uses automatic differentiation for the computation of its Jacobian.

For more details, refer to the non-AD version [ExponentialSoftening](/ExponentialSoftening.md).

#### Example Input File


`ADExponentialSoftening` must be run in conjunction with the ad fixed smeared cracking material model as shown below:






### ADMultiplePowerLawCreepStressUpdate


#### Description

Metals can exhibit distinctively different creep behavior depending on the stress
level. This object represents creep behavior with various power law expressions (following
logic analogous to [PowerLawCreepStressUpdate](PowerLawCreepStressUpdate.md)), 
and selects the right set of parameters for the von Mises stress value seen during
the return mapping. 

A set of von Mises stress intervals is required in the input. `stress_thresholds` is a 
vector of stresses defining a minimum and maximum modeled stress. In between pairs of
stress values, in strict order, the corresponding ordered power law parameters must be
provided, i.e. `coefficient`, `n_exponent`, `m_exponent`, and `activation_energy`.
 
This class relies on the implicit integration algorithm in
[!cite](dunne2005introduction) pg. 146 - 149.

`ADMultiplePowerLawCreepStressUpdate` must be run in conjunction with an inelastic
strain return mapping stress calculator such as
[ADComputeMultipleInelasticStress](ADComputeMultipleInelasticStress.md)





### ADNonlocal Damage


#### Description

`ADNonlocalDamage` is a model to define the effect of damage on the stress and
stiffness in a continuum damage mechanics setting. Uses automatic
differentiation material properties. Similar to the [`NonlocalDamage`](/NonlocalDamage.md) object except that the
material properties generated can be used with automatic differentiation.






### ADPorosityFromStrain


#### Description

`ADPorosityFromStrain` computes the porosity, $f$, from the combined inelastic strain, $\epsilon_{in}$:
\begin{equation}
  f = (1.0 - f^{old}) * ({\epsilon}_{in} - {\epsilon}_{in}^{old}).\text{tr} + f^{old};
\end{equation}

Here, $\epsilon_{in}$ is typically computed by [ADComputeMultipleInelasticStress](ADComputeMultipleInelasticStress.md) using [ADViscoplasticityStressUpdate](ADViscoplasticityStressUpdate.md) methods.

#### Example Input Files






### AD Power Law Softening


#### Description

The material `ADPowerLawSoftening` computes the reduced stress and stiffness along
the direction of a crack according to a power law equation. The computed
reduced stiffness softens the tensile response of the material once the principle
stress applied to a material exceeds the cracking stress threshold of the material. 
It uses automatic differentiation for the computation of its Jacobian.
As with the other smeared cracking softening models, which all follow the
nomenclature convention of using the `Softening` suffix, this model is intended
to be used with the [ADComputeSmearedCrackingStress](/ADComputeSmearedCrackingStress.md)
material.

For more details, refer to the non-AD class [PowerLawSoftening](/PowerLawSoftening.md).

#### Example Input File


`ADPowerLawSoftening` must be run in conjunction with the ad fixed smeared cracking material model as shown below:






### Radial Return Stress Update with automatic differentiation

Base class which calculates the effective inelastic strain increment required to
return the isotropic stress state to a J2 yield surface.  This class is intended
to be a parent class for classes with specific constitutive models.


##### Algorithm References

The radial return mapping method, introduced by Simo and Taylor (1985), uses a
von Mises yield surface to determine the increment of plastic strain necessary
to return the stress state to the yield surface after a trial stress increment
takes the computed stress state across the yield surface.  Because the von Mises
yield surface in the deviatoric stress space has the shape of a circle, the
_plastic correction stress_ is always directed towards the center of the yield
surface circle.

In addition to the [!cite](simo2006computational) textbook,
[!cite](dunne2005introduction) is an excellent reference for users working with
the `RadialReturnStressUpdate` materials; several of the isotropic plasticity
and creep effective plastic strain increment algorithms are taken from
[!cite](dunne2005introduction).

##### The Radial Return Stress Update Description

The stress update materials are not called by MOOSE directly but instead only by
other materials using the `computeProperties` method.  For the
`ADRadialReturnStressUpdate` materials, this calling material is
[ADComputeMultipleInelasticStress](ADComputeMultipleInelasticStress.md).
Separating the call to the stress update materials from MOOSE allows us to
iteratively call the stress update materials as is required to achieve
convergence.

#### Radial Return Algorithm Overview

       style=width:30%;margin-left:2%;float:right
       caption=A trial stress is shown outside of the deviatoric yield surface and the radial return
                 stress which is normal to the yield surface.


In the case of isotropic linear hardening plasticity, with the hardening function $r = hp$, the
effective plastic strain increment has the form:
\begin{equation}
 d \Delta p = \frac{\sigma^{trial}_{effective} - 3 G \Delta p - r - \sigma_{yield}}{3G + h}
\end{equation}
where G is the isotropic shear modulus, and $\sigma^{trial}_{effective}$ is the scalar von Mises trial stress.

Once convergence has been reached on the scalar inelastic strain increment, the full inelastic strain
tensor is calculated.
\begin{equation}
\Delta \epsilon^{inelastic}_{ij} = \frac{3}{2} \Delta p^{(t+1)} \frac{dev(\sigma^{trial}_{ij})}{\sigma^{trial}_{effective}}
\end{equation}

The elastic strain is calculated by subtracting the return mapping inelastic strain increment tensor
from the mechanical strain tensor.  Mechanical strain is considered as the sum of the elastic and
inelastic (plastic, creep, ect) strains.
\begin{equation}
\epsilon_{total} = \epsilon_{mechanical} + \epsilon_{eigenstrain}
= \left( \epsilon_{elastic} + \epsilon_{inelastic} \right) + \epsilon_{eigenstrain}
= \epsilon_{elastic} + \left( \epsilon_{plastic} + \epsilon_{creep} + \epsilon_{damage}  \right) + \epsilon_{eigenstrain}
\end{equation}

The final inelastic strain is returned from the radial return stress update material, and
`ComputeMultipleInelasticStress` computes the stress, with a return mapping stress increment
following elasticity theory for finite strains. The final stress is calculated from the elastic
strain increment.
\begin{equation}
\sigma^{new}_{ij} = C_{ijkl} \left( \Delta \epsilon^{elastic}_{kl} + \epsilon^{old-elastic}_{kl} \right)
\end{equation}

When more than one radial recompute material is included in the simulation, as in Combined Power Law
Creep and Linear Strain Hardening, `ComputeMultipleInelasticStress` will iterate over the change in
the calculated stress until the return stress has reached a stable value.

Users can print out any of these strains and stresses using the `RankTwoAux` as described on the
[Visualizing Tensors](/solid_mechanics/VisualizingTensors.md) page.

#### Writing a New Stress Update Material
New radial return models must inherit from `RadialReturnStressUpdate` and must overwrite the six
virtual methods.

- +initQpStatefulProperties+: Set the initial values for all new material properties that are not
  initialized by an input parameter; generally the material properties initialized in this method are
  all set to zero.
- +computeStressInitialize+: Calculate the initial trial stress state, the yield surface value, and
  any hardening or softening parameters at the start of the simulation time increment.
- +computeResidual+: In each iteration over the inelastic strain increment, calculate the value of
  the effective scalar trial stress subtracted by the yield surface function.
- +computeDerivative+: In each iteration over the inelastic strain increment, calculate the
  derivative of the yield surface function with respect to the inelastic strain increment.
- +iterationFinalize+: Store the value of the inelastic strain increment at the end of each
  iteration.
- +computeStressFinalize+: Update the stress after convergence on the inelastic strain increment has
  been reached.

Additionally, new radial return methods must also overwrite a single method from the MOOSE `Material`
class.

- +resetQpProperties+: Set the material property used in the iteration, usually $\Delta p$, to zero
  at the start the iteration.  This method is necessary to avoid incorrect material property values.

More details on how to write the equivalent yield surface equation for a creep model are given in
Dunne and Petrinic.

#### Substepping

We provide the substepping capability in `ADRadialReturnStressUpdate` for nonlinear material models in order to improve the convergence. The idea is that when material is undergoing large deformation and the return mapping algorithm struggles to converge, we would divide the original strain into smaller strain increments and take several substeps where incremental strain is applied at each substep.  The following shows an example of the syntax for using substepping.


<!-- !syntax children /Materials/RadialReturnStressUpdate -->


### ADRank Two Tensor Component


#### Description

This is a ADMaterial model used to extract components of a rank-2 tensor in a
Cartesian coordinate system. This can be used regardless of the coordinate
system used by the model.

This ADMaterial model is set up by
[SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md) automatically
when stress components are requested in the generate_output parameter, but can
also be set up directly by the user.  

The `ADRankTwoCartesianComponent` takes as arguments the values of the
`index_i` and the `index_j` for the single tensor component to save into an
MaterialProperty.  [eq:rank2tensor_component_indices] shows the index values
for each Rank-2 tensor component.

\sigma_{ij} \implies \begin{bmatrix}
                      \sigma_{00} & \sigma_{01} & \sigma_{02} \\
                      \sigma_{10} & \sigma_{11} & \sigma_{12} \\
                      \sigma_{20} & \sigma_{21} & \sigma_{22}
                      \end{bmatrix}




### ADRank Two Cylindrical Component


#### Description

This is a ADMaterial model used to extract components of a rank-2 tensor in a
cylindrical coordinate system. This can be used regardless of the coordinate
system used by the model.

This ADMaterial model is set up by
[SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md) automatically
when stress components are requested in the generate_output parameter, but can
also be set up directly by the user.  This class provides the ability to compute
hoop, radial, and axial stress ($\boldsymbol{\sigma}$) and strain
($\boldsymbol{\epsilon}$)quantities for a Rank-2 tensor, as described in
[RankTwoScalarTools](RankTwoScalarTools.md).  

The component of the rank-2 tensor extracted is stored as a scalar material
property, which allows for it to be more accurately represented in calculations
that use this quantity at quadrature points than would be possible using the
related [RankTwoScalarAux](RankTwoScalarAux.md)




### ADRank Two Directional Component


#### Description

This is a ADMaterial model used to extract components of a rank-2 tensor in a
Cartesian coordinate system based on an input direction. This can be used
regardless of the coordinate system used by the model.

This ADMaterial model is set up by
[SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md) automatically
when stress components are requested in the generate_output parameter, but can
also be set up directly by the user. This class calculates the component of a
Rank-2 tensor, $T$, in the direction selected by the user as shown by, as
described in [RankTwoScalarTools](RankTwoScalarTools.md).  


The component of the rank-2 tensor extracted is stored as a scalar material
property, which allows for it to be more accurately represented in calculations
that use this quantity at quadrature points than would be possible using the
related [RankTwoScalarAux](RankTwoScalarAux.md)




### ADRank Two Invariant


#### Description

This is a ADMaterial model used to extract an invariant of a rank-2 tensor in a
Cartesian coordinate system. This can be used regardless of the coordinate
system used by the model.

This ADMaterial model is set up by
[SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md) automatically
when stress components are requested in the generate_output parameter, but can
also be set up directly by the user. This class provides the ability to compute
VonMises, Effective, Hydrostatic, L2norm, Volumetric, Triaxiality, MaxShear,
StressIntensity, First, Second, and Third Invariant as well as Max, Mid, and Min
Primary stresses ($\boldsymbol{\sigma}$) and strains
($\boldsymbol{\epsilon}$)quantities for a Rank-2 tensor, as described in
[RankTwoScalarTools](RankTwoScalarTools.md).  


The component of the rank-2 tensor extracted is stored as a scalar material
property, which allows for it to be more accurately represented in calculations
that use this quantity at quadrature points than would be possible using the
related [RankTwoScalarAux](RankTwoScalarAux.md)




### AD Viscoplasticity Stress Update


#### Description

`ADViscoplasticityStressUpdate` implements the [Gurson-Tvergaard-Needleman](Gurson:1977gg) (GTN) and
[Leblond-Perrin-Suqeut](Leblond:1994kl) (LPS) following the theory described above.
`ADViscoplasticityStressUpdate` uses similar techniques as
[ADRadialReturnStressUpdate](ADRadialReturnStressUpdate.md) to compute the gauge stress in order to
correctly calculate the plastic strain in a porous material. `ADViscoplasticityStressUpdate` must be
used in conjunction with
[ADComputeMultiplePorousInelasticStress](ADComputeMultiplePorousInelasticStress.md) in order to capture
the porosity evolution.

##### Notation

Mean stress: $\boldsymbol{\Sigma}, \Sigma_{ij}$\\
Microscopic stress: $\boldsymbol{\sigma}, \sigma_{ij}$\\
Mean strain: $\mathbf{E}, E_{ij}$\\
Microscopic strain: $\boldsymbol{\epsilon}, \epsilon_{ij}$\\
Hydrostatic stress: $\Sigma_m$\\
Deviatoric stress: $\boldsymbol{\Sigma}^{\prime} = \Sigma_{ij} - \tfrac{1}{3}\delta_{ij}\Sigma_{kk}$\\
Equivalent stress: $\Sigma_{eq} = \sqrt{\tfrac{3}{2}\left(\boldsymbol{\Sigma}^{\prime}:\boldsymbol{\Sigma}^{\prime}\right)}$\\
Trace: $\text{tr}(\mathbf{T})=T_{11} + T_{22} + T_{33}$ \\
Porosity: $f$ \\
Stress exponent: $n$


#### Theory

As pores nucleate within a material system, the dissipative potential that governs overall
stress-strain response and drives local void growth mechanisms is enhanced. Simply put, +the
constitutive behavior of a material and the evolution of porosity within are highly coupled
processes+.  In high-temperature and other extreme environments, this potential should include
effects of viscoplasticity and diffusion.

Homogenization of a composite material's plastic potential can be accomplished using the
[!cite](Bishop:1951fb) upper-bound theorem for dissipation, which says that any possible dissipation
field solved at the macroscopic level is an upper bound to the volume average of local dissipation
within a material system.

\begin{equation}
  \boldsymbol{\Sigma}:\dot{\mathbf{E}} \geq \langle \boldsymbol{\sigma}:\boldsymbol{\dot{\epsilon}} \rangle = \int_V \boldsymbol{\sigma}:\boldsymbol{\dot{\epsilon}} \text{d}V.
\end{equation}

In many continuum level modeling problems, the simulation length scale is larger than individual
voids themselves, and therefore methods in homogenization are required to model the voided material
response with an approximated, simplified medium. These methods aim to match the dissipative
potential of the true medium [true_vs_homo], thereby ensuring accurate stress-strain constitutive
behavior of the porous material system.

      style=width:80%;margin-left:5%;
      id=true_vs_homo
      caption=Schematic comparing the true sub-material response and the homogenized response and showing that the two methods match energy dissipation.

[!cite](Gurson:1977gg) employed this approach to solve for dissipation in a purely-plastic
(rate-insensitive) material, and derived an exact expression for the velocity and strain fields
within a unit cell based on isotropic expressions of the [!cite](Rice:1969ky) fields. The solution
to these velocity fields was derived using boundary conditions of strain at the surface of the unit
cell, local incompressibility of the material system, and an overall minimization of work to bring
the approximate upper-bound solution as close as possible to the true solution. In Gurson's
formulation, it should be noted that despite incompressibility of the material itself, the overall
unit cell (void + material) is in fact compressible due to the void. Therefore, void growth,
$\dot{f}$ can be modeled simply based on overall dilatation:

\begin{equation}
  \dot{f} = (1-f)\text{tr}(\dot{\mathbf{E}})  
\end{equation}

The exact result for average dissipation in the unit cell was correlated against an analytical
solution so that it would be useful for application in finite element codes for large-scale
component analysis. Several fitting parameters were introduced into Gurson's model by
[!cite](Tvergaard:1984ip) to account for a periodic array of voids (rather than the original unit
cell), leading to the famous GTN model that is the most widely-used damage and porosity evolution
model for ductile materials.

[!cite](Leblond:1994kl) (LPS) extended the GTN model to account for rate-sensitive plastics. While
far less common than the rate-insensitive GTN model, the work by Leblond et al. generated a similar
analytical solution to GTN, but accounted for dissipation in the material, making it also very accessible to
finite element implementation. It is expected that differences between rate-sensitive (i.e. LPS) and
rate-insensitive (i.e. GTN) plasticity will become significant at lower temperatures and stresses. As such, the
LPS model is selected for describing dissipation in a rate-sensitive voided material. In the case of
a single dissipative potential, described by a Norton-type power law:

\begin{equation}
  \psi(\Lambda _n (\boldsymbol{\Sigma},f)) = \frac{\sigma_0 \dot{\epsilon}_0}{n+1} \left(\frac{\Lambda_n(\boldsymbol{\Sigma},f)}{\sigma_0}\right)^{n+1},
  \label{eq:dissipation}
\end{equation}
\begin{equation}
  \dot{\mathbf{E}} = \frac{\partial\psi(\boldsymbol{\Sigma})}{\partial\boldsymbol{\Sigma}} = \frac{\partial\psi(\boldsymbol{\Sigma})}{\partial\Lambda_n} \frac{\partial\Lambda_n}{\partial\boldsymbol{\Sigma}}.
  \label{eq:lps_strain}
\end{equation}
Here, the gauge stress, $\Lambda_n$,  is used to translate applied stress and porosity to strain rate response in a power law creeping material with rate-sensitivity factor $n$, is given via the minimization of the residual $\mathcal{R}$:
\begin{equation}
  \mathcal{R} = \left(\frac{\Sigma_{eq}}{\Lambda_n(\boldsymbol{\Sigma},f)}\right)^2 + f\left[h_n + \frac{n-1}{n+1}\frac{1}{h_n}\right] - 1-\frac{n-1}{n+1}f^2 = 0
\end{equation}
where $h_n$ is a rate sensitivity factor. The law proposed by [!cite](Leblond:1994kl)reduces exactly to the [!cite](Gurson:1977gg) model when
using a rate-insensitive exponent.

#### Implementation

The inelastic strain is currently calculated explicitly,
\begin{equation}
\mathbf{E}(t+\Delta t) = \mathbf{E}(t) + \dot{\mathbf{E}}\Delta t,
\end{equation}
where the strain rate is calculated via,
\begin{equation}
  \dot{\mathbf{E}} = \frac{\partial\psi(\boldsymbol{\Sigma})}{\partial\boldsymbol{\Sigma}} = \frac{\partial\psi(\boldsymbol{\Sigma})}{\partial\Lambda_n} \frac{\partial\Lambda_n}{\partial\boldsymbol{\Sigma}}.
  \label{eq:strain_rate}
\end{equation}
By taking the derivative of [eq:strain_rate] with respect to the gauge stress, the familiar Norton power law is formed,
\begin{equation}
  \frac{\partial\psi(\boldsymbol{\Sigma})}{\partial\Lambda_n} = \frac{\dot{\epsilon}_0}{\sigma_0^n} \left(\Lambda_n(\boldsymbol{\Sigma},f)\right)^n,
  \label{eq:norton}
\end{equation}
providing a clear link between traditional power law creep solves; by replacing $\Sigma_{eq}$
utilized in traditional power law creep equations with a gauge stress, the exact strain dissipation
is captured due to the act of homogenization.

Using the LPS model, the gauge stress is calculated by minimizing the residual,
\begin{equation}
  \mathcal{R} = \left(\frac{\Sigma_{eq}}{\Lambda_n(\boldsymbol{\Sigma},f)}\right)^2 + f\left[h_n + \frac{n-1}{n+1}\frac{1}{h_n}\right] - 1-\frac{n-1}{n+1}f^2 = 0
  \label{eq:residual}
\end{equation}

The rate sensitivity factor $h_n$ is a function of the strain rate stress exponent, gauge stress, and equivalent stress,
\begin{equation}
  h_n = \left(1+\frac{1}{n}\left(s_f\frac{|\Sigma_m|}{\Lambda_n(\boldsymbol{\Sigma},f)}\right)^{\frac{n+1}{n}}\right)^n
\label{eq:h}
\end{equation}
where $s_f$ is a shape factor that depends on the pore shape:
\begin{equation}
s_f =\begin{cases}
  \frac{3}{2} &\text{for spherical pores} \\
  \sqrt{3} &\text{for cylindrical pores}
  \label{eq:shape_factor}
\end{cases}
\end{equation}

In addition, the mean stress utilized in [eq:h] is different depending on the shape of the pore,
\begin{equation}
\Sigma_m =\begin{cases}
  \frac{1}{3}(\Sigma_{1,1} + \Sigma_{2,2} + \Sigma_{3,3})  &\text{for spherical pores} \\
  \frac{1}{2}(\Sigma_{1,1} + \Sigma_{2,2}) &\text{for cylindrical pores}
  \label{eq:mean_stress}
\end{cases}
\end{equation}

The GTN can be solved in exactly the same manner as the LPS model by taking $n\rightarrow \infty$ in [eq:residual] and [eq:shape_factor], reducing $\mathcal{R}$ to,
\begin{equation}
  \mathcal{R} = \left(\frac{\Sigma_{eq}}{\Lambda_{\infty}(\boldsymbol{\Sigma},f)}\right)^2 + 2f \cosh\left(s_f\frac{\Sigma_m}{\Lambda_{\infty}}\right) - 1 - f^2 = 0
\end{equation}

Once a solution for $\Lambda_n$ is found, the strain rate can be determined using [eq:strain_rate] with the relationship,
\begin{equation}
 \frac{\partial\Lambda_n}{\partial\boldsymbol{\Sigma}} = \frac{\Lambda_n \frac{\partial\mathcal{R}}{\partial\boldsymbol{\Sigma}}}{\frac{\partial\mathcal{R}}{\partial\boldsymbol{\Sigma}}:\boldsymbol{\Sigma}}.
\end{equation}

#### Example Input Files

In all cases, `ADViscoplasticityStressUpdate` must be combined with
[ADComputeMultiplePorousInelasticStress](ADComputeMultiplePorousInelasticStress.md) in order to
calculate the stress and capture the porosity evolution of the material:


In this case, the power law coefficient defined in [eq:norton] is provided as an example here as a
`ParsedMaterial`. Note, if necessary, the coefficient must be provided as an AD material if
variables or variable dependent materials are utilized to calculate coefficient.

If several different stress exponents are required, separate `ADViscoplasticityStressUpdate` must be
specified, and combined in
[ADComputeMultiplePorousInelasticStress](ADComputeMultiplePorousInelasticStress.md):

Here,  materials calculated by `ADViscoplasticityStressUpdate` are prepended with `base_name` to
separate their contributions to the overall system. Note, this is different than the `base_name`
provided in the [Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md)














### CappedWeakInclinedPlaneStressUpdate


See [CappedWeakPlaneStressUpdate.md] for details on the
capped weak plane stress model with a non-inclined weak plane, where
the weak plane's normal is $(0, 0, 1)$.

This material accepts an arbitrary weak plane normal vector. In the reference frame where
the inclined plane's normal aligns with the $z$ axis, the assumptions
listed in [this section](CappedWeakPlaneStressUpdate.md#assumptions) must hold.

See the theory manual  (at [solid_mechanics/doc/theory/capped_weak_plane.pdf](https://github.com/idaholab/moose/tree/next/modules/solid_mechanics/doc/theory/capped_weak_plane.pdf))
for more explanation.





### CappedWeakPlaneCosseratStressUpdate


See [CappedWeakPlaneStressUpdate.md] for details on the non-Cosserat
capped weak plane stress model.

The difference between the Cosserat and non-Cosserat case is that the
stress tensor is potentially non-symmetric, and that only
$\sigma_{xz}$ and $\sigma_{yz}$ enter into the definition of $q$.
That is the equations in [CappedWeakPlaneStressUpdate.md#theory] for the stress variables hold as it is written.  This means
that the return-map process often results in a non-symmetric stress
tensor, even if the trial stress was symmetric.  The equations of
moment equilibrium then typically generate a spatially-varying moment
stress, the precise nature of which depends on the problem at hand,
such as the boundary conditions.

The differences between the presentation in [CappedWeakPlaneStressUpdate.md] for the non-Cosserat
case, and the Cosserat case are only:

- The equations for the ZX and ZY components of the stress (in [CappedWeakPlaneStressUpdate.md#rmap]) do not hold.  These components of stress take their trial values after the
  return-map problem has been solved: $\sigma_{zx} =
  \sigma_{zx}^{\mathrm{trial}}$ and $\sigma_{zy} =
  \sigma_{zy}^{\mathrm{trial}}$.
- The elasticity tensor need not have the symmetries given in
  the equations in section [CappedWeakPlaneStressUpdate.md#assumptions]: it only needs to satisfy
  $E_{ijkl}=E_{klij}$.


See the theory manual  (at [solid_mechanics/doc/theory/capped_weak_plane.pdf](https://github.com/idaholab/moose/tree/next/modules/solid_mechanics/doc/theory/capped_weak_plane.pdf))
for more explanation.




### CappedWeakPlaneStressUpdate


#### Theory id=theory

Weak-plane plasticity is designed to simulate a layered material.
Each layer can slip over adjacent layers, and be separated from those
adjacent layers.  An example of particular interest is
stratified rocks, which consist of large sheets of fairly strong rock
separated by weak and very thin joints.  Upon application of stress,
the joints can fail, either by slipping or separating.  The idea is to
use one finite element that potentially contains many layers, and
prescribe ``weak plane plasticity'' for that finite element, so that
it can fail by joint separation and joint slipping.

Denote the normal to the layers by $z$, and the tangential directions
by $x$ and $y$.  It is convenient to introduce two new stress variables in
terms of the stress tensor $\sigma$:

\begin{equation}
p = \sigma_{zz} \ \ \ \text{and}\ \ \ q = \sqrt{\sigma_{xz}^{2} +
  \sigma_{yz}^{2}} \ .
\label{eqn.defn.p.q}
\end{equation}

In standard elasticity, the stress tensor is symmetric, so an
equivalent definition of $q$ is
$q=\sqrt{\frac{1}{2}(\sigma_{xz}+\sigma_{zx})^{2} + \frac{1}{2}(\sigma_{yz}+\sigma_{zy})^{2}}$, however the symmetrization is deliberately not written in
[eqn.defn.p.q] and below so that the equations also hold for
the Cosserat case (see [CappedWeakPlaneCosseratStressUpdate.md]).

The joint slipping is assumed to be governed by a
Drucker-Prager type of plasticity with a cohesion $C$, and friction
angle $\phi$:

\begin{equation}
f_{0} = q + p\tan\phi - C \ .
\end{equation}

The parameter $C$ and $\phi$ may be constants, or they may harden or
soften (more on this later).

Joints may also open, and this type of failure is assumed to be
governed by a tensile failure yield function:

\begin{equation}
f_{1} = p - S_{T} \ ,
\end{equation}

where $S_{T}$ is the tensile strength, which may be constant or harden
or soften.

Joints may also close, and this type of failure is assumed to be
governed by a compressive failure yield function:

\begin{equation}
f_{2} = - p - S_{C} \ ,
\end{equation}

where $S_{C}$ is the compressive strength (a positive quantity), which
may be constant or harden or soften.

The yield functions $f_{1}$ and $f_{2}$ place ``caps'' on the shear
yield function $f_{0}$.
The combined yield function is simply

\begin{equation}
f = \max(f_{0}, f_{1}, f_{2}) \ ,
\label{one.yf.eqn}
\end{equation}

which defines the admissible domain where all yield functions are
non-positive, and the inadmissible domain where at least one yield
function is positive.


One of the features of this plasticity is the
ability to model cyclic behavior. For instance, the compressive
strength may be initially very high. However, after tensile failure,
the compressive strength can soften to zero in order to model the fact
that the material now contains open joints which cannot support any
compressive load. If the material then fails in compression (eg,
because it gets squashed) and the joints close then the compressive
strength can be made high again.

#### Flow rules and hardening

This plasticity is non-associative.  Define the dilation angle $\psi$,
which may be constant, or harden or soften.  The shear flow potential
is

\begin{equation}
g_{0} = q + p\tan\psi .
\end{equation}

The tensile flow potential is

\begin{equation}
g_{1} = p \ ,
\end{equation}

and the compressive flow potential is

\begin{equation}
g_{2} = - p \ .
\end{equation}

The overall flow potential is

\begin{equation}
g = \left\{
\begin{array}{ll}
g_{0} & \text{ if } f = f_{0} \\
g_{1} & \text{ if } f = f_{1} \\
g_{2} & \text{ if } f = f_{2}\ .
\end{array}
\label{one.g.eqn}
\right.
\end{equation}

Obviously there are problems here where $g$ is not defined properly at
the corners where $f_{0}=f_{1}$ and $f_{0}=f_{2}$ (or even
$f_{0}=f_{1}=f_{2}$).  This is resolved by using smoothing (more on
this later).

This plasticity model contains two internal parameters, denote by
$i_{0}$ and $i_{1}$.   It is assumed
that

\begin{equation}
\begin{split}
C & = C(i_{0}) \ , \\
\phi & = \phi(i_{0}) \ , \\
\psi & = \psi(i_{0}) \ , \\
S_{T} & = S_{T}(i_{1}) \ , \\
S_{C} & = S_{C}(i_{1}) \ . \\
\end{split}
\end{equation}

That is, $i_{0}$ can be thought of as the ``shear'' internal parameter,
while $i_{1}$ is the ``tensile'' internal parameter.

To complete the definition of this plasticity model, the increments of
$i_{0}$ and $i_{1}$ during the return-map process must be defined.
The return-map process involves being provided with a trial stress
$\sigma^{\mathrm{trial}}$ and an existing value of the internal
parameters $i^{\mathrm{old}}$, and finding a ``returned'' stress,
$\sigma$, and internal parameters, $i$, that satisfy

\begin{equation}
\begin{split}
0 & = f(\sigma, i) \ . \\\label{f.zero.return}
\sigma & = \sigma^{\mathrm{trial}} - E\gamma \frac{\partial g}{\partial\sigma} \ , \\
\end{split}
\end{equation}

where $E$ is the elasticity tensor, and $\gamma$ is a ``plastic
multiplier'', that must be positive.  The former expresses that the
stress must be admissible, while the latter is called the ``normality
condition''.  Loosely speaking, the returned stress lies at a position
on the yield surface where the normal points to the trial stress
(actually $E$ and $\partial g/\partial\sigma$ must be used to define
the ``normal direction'').

Let us express the normality condition in $(p, q)$ space.  The $zz$
component is easy:

\begin{equation}
p = \sigma_{zz} = \sigma_{zz}^{\mathrm{trial}} - E_{zzij}\gamma
\frac{\partial g}{\partial \sigma_{ij}} = \sigma_{zz}^{\mathrm{trial}} - E_{zzzz}\gamma
\frac{\partial g}{\partial p}  \ ,
\label{p.norm.eqn}
\end{equation}

where the last equality holds by assumption (see full list of
assumptions below).  The $xz$ and $yz$ components are similar:

\begin{equation}
\sigma_{xz} = \sigma_{xz}^{\mathrm{trial}} - E_{xzxz}\gamma
\frac{\partial g}{\partial q}\frac{\partial q}{\partial \sigma_{xz}}
\ . \label{eqn.xz.flow}
\end{equation}

Another assumption has been made about $E$.  The final term is

\begin{equation}
\frac{\partial q}{\partial\sigma_{xz}} = \frac{\sigma_{xz}}{q} \ .
\end{equation}

This means that [eqn.xz.flow] can be re-written

\begin{equation}
\sigma_{xz}^{2} \left( 1 + E_{xzxz}\gamma \frac{\partial g}{\partial
  q} \frac{1}{q} \right)^{2} =
\left(\sigma^{\mathrm{trial}}_{xz}\right)^{2} \ .
\end{equation}

A similar equation holds for the $yz$ component, and these can be
summed and rearranged to yield

\begin{equation}
q = q^{\mathrm{trial}} - E_{xzxz}\gamma \frac{\partial g}{\partial q}
\ . \label{q.norm.eqn}
\end{equation}

[f.zero.return], [p.norm.eqn]
and~[q.norm.eqn] are the three conditions that need to be
satisfied, and the three variables to be found are $p$, $q$ and
$\gamma$.

Consider the case of returning to the shear yield surface.
Since $\partial g/\partial p =
\tan\psi$ and $\partial g/\partial q = 1$ for this flow, the
return-map process must solve the following system of equations

\begin{equation}
\begin{split}
0 & = q + p\tan\phi - C \ , \\
p & = p^{\mathrm{trial}} - E_{zzzz}\gamma\tan\psi \ , \\
q & = q^{\mathrm{trial}} - E_{xzxz}\gamma \ . \\
\end{split}
\end{equation}

The solution satisfied $p^{\mathrm{trial}} - p =
E_{zzzz}\gamma\tan\psi$ and $q^{\mathrm{trial}} - q = E_{xzxz}\gamma$.

Now consider the case of returning to the tensile yield surface.  The
equations are

\begin{equation}
\begin{split}
0 & = p - S_{T} \ , \\
p & = p^{\mathrm{trial}} - E_{zzzz}\gamma \ , \\
q & = q^{\mathrm{trial}} \ . \\
\end{split}
\end{equation}

Comparing these two types of return, it is obvious that
$q^{\mathrm{trial}} - q$ quantifies the amount of shear failure.
Therefore, the following definitions are used in this plasticity model

\begin{equation}
\begin{split}
i_{0} & = i_{0}^{\mathrm{old}} + \frac{q^{\mathrm{trial}} - q}{E_{xzxz}} \ , \\
i_{1} & = i_{1}^{\mathrm{old}} + \frac{p^{\mathrm{trial}} - p}{E_{zzzz}} - \frac{(q^{\mathrm{trial}} - q)\tan\psi}{E_{xzxz}} \ . \\
\end{split}
\end{equation}

The final term ensures that $i_{1}$ does not increase during pure
shear failure.  The scaling by $E$ ensures that these internal
parameters are dimensionless.

In summary, this plasticity model is defined by the yield function of
[one.yf.eqn], the flow potential of
[one.g.eqn], and the following return-map problem.

##### Return-map problem id=rmap

At any given MOOSE timestep, given the
old stress $\sigma_{ij}^{\mathrm{old}}$, and a total strain increment
$\delta \epsilon$ (that comes from the nonlinear solver proposing
displacements) the trial stress is

\begin{equation}
\sigma_{ij}^{\mathrm{trial}} = \sigma_{ij}^{\mathrm{old}} +
E_{ijkl}\delta\epsilon_{kl} \ ,
\end{equation}

This gives $p^{\mathrm{trial}}$ and $q^{\mathrm{trial}}$.  If
$p^{\mathrm{trial}}$, $q^{\mathrm{trial}}$, $i_{0}^{\mathrm{old}}$ and
$i_{1}^{\mathrm{old}}$ are such that $f(p^{\mathrm{trial}}, q^{\mathrm{trial}},
i^{\mathrm{old}}) > 0$, the return-map problem is: find $p$, $q$,
$\gamma$, $i_{0}$ and $i_{1}$ such that

\begin{equation}
\begin{split}
0 & = f(p, q, i) \ ,  \\
p & = p^{\mathrm{trial}} - E_{zzzz}\gamma \frac{\partial g}{\partial p} \ ,  \\
q & = q^{\mathrm{trial}} - E_{xzxz}\gamma \frac{\partial g}{\partial q} \ ,  \\
i_{0} & = i_{0}^{\mathrm{old}} + \frac{q^{\mathrm{trial}} - q}{E_{xzxz}} \ ,  \\
i_{1} & = i_{1}^{\mathrm{old}} + \frac{p^{\mathrm{trial}} - p}{E_{zzzz}} - \frac{(q^{\mathrm{trial}} - q)\tan\psi}{E_{xzxz}} \ . \\
\label{rmp.eqn}
\end{split}
\end{equation}

The latter two equations are assumed to hold in the smoothed situation
(discussed below) too, and note that $\psi = \psi(i_{0})$, so the
these two equations are not completely trivial.

After the return-map problem has been solved, the stress components
are $\sigma_{ij} = \sigma_{ij}^{\mathrm{trial}}$, except for the following

\begin{equation}
\begin{split}
\sigma_{xx} & = \sigma_{xx}^{\mathrm{trial}} - E_{zzxx}\gamma\frac{\partial g}{\partial p} \ , \\
\sigma_{yy} & = \sigma_{yy}^{\mathrm{trial}} - E_{zzyy}\gamma\frac{\partial g}{\partial p} \ , \\
\sigma_{zz} & = p \ , \\
\sigma_{zx} & = \sigma_{zx}^{\mathrm{trial}} q / q^{\mathrm{trial}} \ , \\
\sigma_{xz} & = \sigma_{xz}^{\mathrm{trial}} q / q^{\mathrm{trial}} \ , \\
\sigma_{zy} & = \sigma_{zy}^{\mathrm{trial}} q / q^{\mathrm{trial}} \ , \\
\sigma_{yz} & = \sigma_{yz}^{\mathrm{trial}} q / q^{\mathrm{trial}} \ . \\
\end{split}
\end{equation}

The plastic strain is

\begin{equation}
\epsilon_{ij}^{\mathrm{plastic}} = \epsilon_{ij}^{\mathrm{plastic, old}} +
\delta\epsilon_{ij} + E_{ijkl}^{-1}(\sigma_{kl}^{\mathrm{old}} -
\sigma_{kl}) = \epsilon_{ij}^{\mathrm{plastic, old}} + E_{ijkl}\gamma
\frac{\partial g}{\partial \sigma_{kl}}\ .
\end{equation}

The elastic strain is

\begin{equation}
\epsilon_{ij}^{\mathrm{elastic}} = \epsilon_{ij}^{\mathrm{elastic, old}} +
\delta\epsilon_{ij} - \epsilon_{ij}^{\mathrm{plastic}} +
\epsilon_{ij}^{\mathrm{plastic, old}} \ .
\end{equation}


#### Yield Smoothing

The shear yield function, $f_{0}$, describes a cone in $(\sigma_{yz},
\sigma_{xz}, \sigma_{zz})$ space.  The cone's tip is problematic for the
return-map process (the derivative is not defined there) and there are
two main ways of getting around this.  Firstly, a multi-surface
technique can be used to define the return-map process.  Secondly, the
cone's tip can be smoothed.  This plasticity model uses the second
technique.  The yield function is defined to be

\begin{equation}
f_{0} = \sqrt{q^{2} + s_{t}^{2}} + p\tan\phi - C \ ,
\end{equation}

and the flow potential is

\begin{equation}
g_{0} = \sqrt{q^{2} + s_{t}^{2}} + p\tan\psi \ .
\end{equation}

The vertices where the shear yield surface meets the tensile and
compressive yield surfaces also need to be handled.  Smoothing is also
used here.  This uses a new type of smoothing.  For
the case at hand only two yield surfaces and flow potentials need to
be smoothed (there are no points where three or more yield surfaces
get close to each other) and only in 2D space, and a single parameter
$s$ can be used.  The parameter $s$ has the units of stress.  At any
point $(p, q, i)$ order the 3 yield function values, and denote the
largest by $A$, the second largest by $B$ and the smallest by $C$:

\begin{equation}
A\geq B\geq C
\end{equation}

Then the single, smoothed yield function is defined to be

\begin{equation}
f = \left\{
\begin{array}{ll}
A & \ \ \ \text{if}\ \ A\geq B+s \\
\frac{A+B+s}{2} -
\frac{s}{\pi}\cos\left(\frac{(B-A)\pi}{2s}\right) \ .
\end{array}
\right.
\end{equation}

The derivative of the flow potential is smoothed similarly.

#### Constraints and assumptions concerning parameters id=assumptions

The friction angle and cohesion should be positive, and the dilation
angle should be non-negative.  Furthermore, the MOOSE user must ensure that
\begin{equation}
\psi \leq \phi \ .
\end{equation}
These conditions should be satisfied for all values of the internal
parameter $i_{0}$.  MOOSE checks that these conditions hold for
$i_{0}=0$ only.

The tensile and compressive strength must satisfy
\begin{equation}
S_{T} \geq -S_{C} \ ,
\end{equation}
otherwise the ``caps'' are swapped and the assumption of a convex
yield surface is violated.  MOOSE checks this condition holds for
$i_{1}=0$ only: the MOOSE user must ensure that it actually holds for
all values of the internal parameter

The smoothing parameter $s$ must be chosen carefully.  At no time should
the tensile cap mix with the compressive cap via smoothing, otherwise
this typically means that no stress is admissible and MOOSE will never
converge.  For instance, if $S_{T}=1=S_{C}$, then a smoothing
parameter of 0.1 is fine, but a smoothing parameter $\geq 2$ will
cause mixing of tension with compression.  The MOOSE user must ensure
that this holds for all values of the internal parameters.

The tip-smoothing parameter $s_{t}$ is important, even if the tensile cap
completely chops off the shear-cone's tip.  This is because MOOSE can
explore regions of parameter space where the cone's tip is exposed.

It is vital that the smoothing parameters $s$ and $s_{t}$ are chosen so
that the yield surface is not wildly varying around $q=0$, otherwise
poor convergence of the return-map process will occur.

It is assumed that the elasticity tensor has the following symmetries:

\begin{equation}
E_{ijkl} = E_{jikl} = E_{ijlk} = E_{klij} \ ,
\label{eqn.elas.symms}
\end{equation}

and that

\begin{equation}
0 = E_{zzij} \ \ \ \text{if}\ \ \ i\neq j \ ,
\end{equation}

and that

\begin{equation}
E_{xzxz} = E_{yzyz} \ ,
\end{equation}

and that

\begin{equation}
0 = E_{xzij} \ \ \text{ unless } (i, j) = (z, x) \ \ \text{ or } (i,
j) = (x, z) \ .
\label{eqn.elas.xz.con}
\end{equation}

These are quite standard conditions that hold for all non-Cosserat
materials to our knowledge.

#### Technical discussions

##### Unknowns and the convergence criterion

The return-map problem [rmp.eqn] is solved as a $3\times 3$
system consisting of the first 3 equations, and substituting the fourth and
fifth equations wherever needed.  The three unknowns are $p$, $q$ and
$\gamma_{E}=\gamma E_{zzzz}$, which all have the same units.  Convergence
is deemed to be achieved when the sum of squares of the residuals of
these 3 equations is less than a user-defined tolerance.

##### Iterative procedure and initial guesses

A Newton-Raphson process is used, along with a cubic line-search.  The
process may be initialized with the solution that is correct for
perfect plasticity (no hardening) and no smoothing, if the user
desires.  Smoothing adds nonlinearities, so this initial guess will
not always be the exact answer. For hardening, it is not
always advantageous to initialize the Newton-Raphson process in this
way, as the yield surfaces can move dramatically during the return
process.

##### Sub-stepping the strain increments

Because of the difficulties encountered during the Newton-Raphson
process during rapidly hardening/softening moduli, it is possible to
subdivide the applied strain increment, $\delta\epsilon$, into smaller
sub-steps, and do multiple return-map processes.  The final returned configuration will then
be dependent on the number of sub-steps.  While this is simply
illustrating the non-uniqueness of plasticity problems, in my
experience it does adversely affect MOOSE's nonlinear convergence as
some Residual calculations will take more sub-steps than other Residual
calculations: in effect this is reducing the accuracy of the Jacobian.

#### The consistent tangent operator

MOOSE's Jacobian depends on the derivative

\begin{equation}
H_{ijkl} = \frac{\delta\sigma_{ij}}{\delta \epsilon_{kl}} \ .
\end{equation}

The quantity $H$ is called the consistent tangent operator.  For pure
elasticity it is simply the elastic tensor, $E$, but it is more
complicated for plasticity.  Note that a small $\delta\epsilon_{kl}$
simply changes $\delta\sigma^{\mathrm{trial}}$, so $H$ is capturing the
change of the returned stress ($\delta\sigma$) with respect to a
change in the trial stress ($\delta\sigma^{\mathrm{trial}}$).  In
$(p,q)$ language, we need to the sx derivatives

\begin{equation}
\frac{\delta (p, q, \gamma)}{\delta (p^{\mathrm{trial}},
  q^{\mathrm{trial}})} \ .
\end{equation}

The algebra is extremely tedious, but it is fairly easy for the
computer.  The MOOSE code contains two implementations of the
consistent tangent operator.  One is valid for any general $(p, q)$
model, while the other is specialized to the weak-plane case.

##### General consistent tangent operator

The return-map algorithm provides

\begin{equation}
\sigma_{ij} = \sigma_{ij}^{\mathrm{trial}} - E_{ijmn}\gamma
\frac{\partial g}{\partial \sigma_{mn}} \ .
\end{equation}

Since $\sigma^{\mathrm{trial}} = E\epsilon$, the consistent tangent
operator is

\begin{equation}
\begin{split}
H_{ijkl} &= E_{ijkl} - E_{ijmn} E_{pqkl} \frac{\partial}{\partial \sigma_{pq}^{\mathrm{trial}}} \gamma \frac{\partial g}{\partial \sigma_{mn}} \\
&= E_{ijkl} - E_{ijmn} E_{pqkl} \left( \frac{\partial p^{\mathrm{trial}}}{\partial \sigma_{pq}^{\mathrm{trial}}} \frac{\partial}{\partial p^{\mathrm{trial}}} + \frac{\partial q^{\mathrm{trial}}}{\partial \sigma_{pq}^{\mathrm{trial}}} \frac{\partial}{\partial q^{\mathrm{trial}}} \right) \gamma \left( \frac{\partial g}{\partial p} \frac{\partial p}{\partial \sigma_{mn}} + \frac{\partial g}{\partial q} \frac{\partial q}{\partial \sigma_{mn}} \right)
\end{split}
\end{equation}

However, note that

\begin{equation}
\frac{\partial}{\partial p^{\mathrm{trial}}} \left( p -
p^{\mathrm{trial}} + \gamma E_{pp}\frac{\partial g}{\partial p}
\right) = 0 \ ,
\end{equation}

because the return-map algorithm guarantees that the expression inside
parentheses is zero.  Therefore

\begin{equation}
\frac{\partial}{\partial p^{\mathrm{trial}}}\gamma\frac{\partial
  g}{\partial p} = \frac{1}{E_{pp}} \left( 1- \frac{\partial
  p}{\partial p^{\mathrm{trial}}} \right) \ .
\end{equation}

A similar expression holds for three other cases.  There are still
terms that involve derivatives of $\partial p/\partial \sigma_{mn}$
  and $\partial q/\partial\sigma_{mn}$, but these may be separated off
  as seen below.

The consistent tangent operator may therefore be written as

\begin{equation}
\begin{split}
H_{ijkl} & = E_{ijkl} - E_{ijmn}E_{pqkl} \left\{ \frac{\partial p^{\mathrm{trial}}}{\partial\sigma_{pq}^{\mathrm{trial}}} \frac{1}{E_{pp}}\left(1 - \frac{\partial p}{\partial p^{\mathrm{trial}}} \right) \frac{\partial p}{\partial\sigma_{mn}} \right.  \\
& \left. \frac{\partial q^{\mathrm{trial}}}{\partial\sigma_{pq}^{\mathrm{trial}}} \frac{1}{E_{pp}}\left( - \frac{\partial p}{\partial q^{\mathrm{trial}}} \right) \frac{\partial p}{\partial\sigma_{mn}} + \frac{\partial p^{\mathrm{trial}}}{\partial\sigma_{pq}^{\mathrm{trial}}}\ \frac{1}{E_{qq}}\left(- \frac{\partial q}{\partial p^{\mathrm{trial}}} \right) \frac{\partial q}{\partial\sigma_{mn}} + \frac{\partial q^{\mathrm{trial}}}{\partial\sigma_{pq}^{\mathrm{trial}}} \frac{1}{E_{qq}}\left(1 - \frac{\partial q}{\partial q^{\mathrm{trial}}} \right) \frac{\partial q}{\partial\sigma_{mn}} \right\}  \\
& \frac{\partial \sigma_{ab}}{\partial\epsilon_{kl}} E_{ijmn} \gamma \left( \frac{\partial g}{\partial p}\frac{\partial^{2} p}{\partial\sigma_{mn}\partial\sigma_{ab}} + \frac{\partial g}{\partial q}\frac{\partial^{2} q}{\partial\sigma_{mn}\partial\sigma_{ab}} \right) \ . \\
\end{split}
\end{equation}

All terms but the final line have already been computed during the
return-map process.  The final line may be brought to the right-hand
side (since $H_{ijkl} = \partial\sigma_{ij}/\partial\epsilon_{kl}$)
and the resulting expression multiplied inverse $H$'s coefficient to
finally yield $H$.  This inversion, and all the multiplication of
rank-four tensors may be computationally expensive, so a cheaper (but
more lengthy looking) version is derived below for the capped
weak-plane case.

##### Specialization to the weak-plane case

The return-map equations [rmp.eqn] are obtaining $(p, q)$
given the trial variables.  Finding $H$ is really just re-solving
these equations for a slightly changed trial variable.  Denote

\begin{equation}
\left( \begin{array}{l} R_{0} \\ R_{1} \\ R_{2} \end{array} \right)
=
\left( \begin{array}{l} -f \\ -p + p^{\mathrm{trial}} - E_{zzzz}\gamma \frac{\partial g}{\partial
  p} \\ -q + q^{\mathrm{trial}} - E_{xzxz}\gamma \frac{\partial g}{\partial
  q} \end{array} \right) \ .
\end{equation}

Then

\begin{equation}
\begin{split}
\frac{\partial R_{0}}{\partial p^{\mathrm{trial}}} & = -\frac{\partial f}{\partial i_{1}} \frac{\partial i_{i}}{\partial p^{\mathrm{trial}}}  \ , \\
\frac{\partial R_{1}}{\partial p^{\mathrm{trial}}} & = 1 - E_{zzzz}\gamma \frac{\partial^{2}g}{\partial p\partial i_{i}}\frac{\partial i_{i}}{\partial p^{\mathrm{trial}}} \ , \\
\frac{\partial R_{2}}{\partial p^{\mathrm{trial}}} & = -E_{xzxz}\gamma \frac{\partial^{2}g}{\partial q\partial i_{i}}\frac{\partial i_{i}}{\partial p^{\mathrm{trial}}} \\
\end{split}
\end{equation}

In these equations

\begin{equation}
\frac{\partial i_{1}}{\partial p^{\mathrm{trial}}} =
\frac{1}{E_{zzzz}} \ ,
\end{equation}

which comes from [rmp.eqn].  The derivatives with respect to
$q^{\mathrm{trial}}$ are similar but more lengthy due to both $i_{0}$
and $i_{1}$ being dependent on $q^{\mathrm{trial}}$.  The system to
solve is

\begin{equation}
\left( \begin{array}{ccc}
\frac{\partial R_{0}}{\partial \gamma} & \frac{\partial R_{0}}{\partial p} & \frac{\partial R_{0}}{\partial q} \\
\frac{\partial R_{1}}{\partial \gamma} & \frac{\partial R_{1}}{\partial p} & \frac{\partial R_{1}}{\partial q} \\
\frac{\partial R_{2}}{\partial \gamma} & \frac{\partial
  R_{2}}{\partial p} & \frac{\partial R_{2}}{\partial q}
\end{array} \right)
\left( \begin{array}{c}
\delta \gamma/\delta p^{\mathrm{trial}} \\
\delta p/\delta p^{\mathrm{trial}} \\
\delta q/\delta p^{\mathrm{trial}}
\end{array} \right) =
\left( \begin{array}{c}
\partial R_{0}/\delta p^{\mathrm{trial}} \\
\partial R_{1}/\delta p^{\mathrm{trial}} \\
\partial R_{2}/\delta p^{\mathrm{trial}}
\end{array} \right)
\end{equation}

The $3\times 3$ Jacobian matrix is identical to the one used in the
Newton-Raphson process, but of course that process has completed
before calculation of the consistent tangent operator.  A similar
system of equations gives the derivatives with respect to
$q^{\mathrm{trial}}$.

Once the six derivatives have been computed they need to be assembled
into $H$.  For instance,

\begin{equation}
\frac{\delta p^{\mathrm{trial}}}{\delta \epsilon_{ii}} = E_{zzii}
\ ,
\end{equation}

so that

\begin{equation}
H_{zzii} = \frac{\delta p}{\delta p^{\mathrm{trial}}} E_{zzii} \ ,
\end{equation}

and other more complicated expressions appear for other components, such as

\begin{equation}
\begin{split}
H_{xxii} & = E_{xxii} - E_{zzxx} E_{zzii}\left( \frac{\delta \gamma}{\delta p^{\mathrm{trial}}} \frac{\partial g}{\partial p} + \gamma \frac{\partial^{2} g}{\partial p^{2}} \frac{\delta p}{\delta p^{\mathrm{trial}}} + \gamma \frac{\partial^{2} g}{\partial p\partial i_{1}} \frac{\delta q}{\delta p^{\mathrm{trial}}} + \gamma \frac{\partial^{2} g}{\partial p\partial i_{0}} \frac{\partial i_{0}}{\partial q} \frac{\delta q}{\delta p^{\mathrm{trial}}} \right.  \\
& \ \ \ \ + \left. \gamma \frac{\partial^{2} g}{\partial p\partial i_{1}} \left( \frac{\delta i_{1}}{\delta p^{\mathrm{trial}}} + \frac{\partial i_{1}}{\partial p} \frac{\delta p}{\delta p^{\mathrm{trial}}} \frac{\partial i_{1}}{\partial q} \frac{\delta q}{\delta p^{\mathrm{trial}}} \right) \right) \ . \\
\end{split}
\end{equation}

##### The consistent tangent operator and sub-stepping strain increments

One extra complication arises from the potential sub-stepping of the
applied strain increment $\delta\epsilon$.  At each sub-step,
the six derivatives must be computed.  While this may seem expensive,
in my experience it increases the accuracy of the Jacobian, and the
main computational expense is building and solving the $3\times 3$
system which is pretty quick for the computer to compared with the
entire Newton-Raphson process.

Let the $n^{\mathrm{th}}$ substep be

\begin{equation}
\delta\epsilon^{n} = \lambda_{n}\delta\epsilon \ ,
\end{equation}

with

\begin{equation}
1 = \sum_{n=1}^{N}\lambda_{n} \ ,
\end{equation}

where $N$ is the total number of substeps.  Denoting the initial
stress by $(p^{\mathrm{old}}, q^{\mathrm{old}})$, and the returned
stress at step $n-1$ by $(p_{n-1}, q_{n-1})$, of course the trial
stress at step $n$ is

\begin{equation}
(p_{n}^{\mathrm{trial}}, q_{n}^{\mathrm{trial}}) = (p_{n-1},q_{n-1}) +
  \lambda_{n} ( p^{\mathrm{trial}} - p^{\mathrm{old}},
    q^{\mathrm{trial}} - q^{\mathrm{old}}) \ .
\end{equation}

This means that

\begin{equation}
\begin{split}
\frac{\partial p_{n}}{\partial p^{\mathrm{trial}}} & = \frac{\partial p_{n}}{\partial p_{n}^{\mathrm{trial}}} \frac{\partial p_{n}^{\mathrm{trial}}}{\partial p^{\mathrm{trial}}} + \frac{\partial p_{n}}{\partial q_{n}^{\mathrm{trial}}} \frac{\partial q_{n}^{\mathrm{trial}}}{\partial p^{\mathrm{trial}}} \\
& = \frac{\partial p_{n}}{\partial p_{n}^{\mathrm{trial}}} \left(\lambda_{n} + \frac{\partial p_{n-1}}{\partial p^{\mathrm{trial}}} \right) + \frac{\partial p_{n}}{\partial q_{n}^{\mathrm{trial}}} \frac{\partial q_{n-1}}{\partial p^{\mathrm{trial}}} \ . \\
\end{split}
\end{equation}

Similar inductive equations hold for the other derivatives, and note
that $\partial p_{0}/\partial p^{\mathrm{trial}} = \partial
p^{\mathrm{old}}/\partial p^{\mathrm{trial}} = 0$.  The derivative of
$\gamma$ is slightly different: it is

\begin{equation}
\frac{\partial \gamma}{\partial p^{\mathrm{trial}}} = \sum_{n=1}^{N}
\frac{\partial \gamma_{n}}{\partial p_{n}^{\mathrm{trial}}}
\left(\lambda_{n} + \frac{\partial p_{n-1}}{\partial p^{\mathrm{trial}}}
\right)
+ \frac{\partial \gamma_{n}}{\partial q_{n}^{\mathrm{trial}}}
\frac{\partial q_{n-1}}{\partial p^{\mathrm{trial}}} \ ,
\end{equation}

and similarly for the derivative with respect to $q^{\mathrm{trial}}$.





### Combined Nonlinear Hardening Plasticity


#### Description



In this model, the linear isotropic hardening function is given by $r = Q(1-exp(-bp))$, and kinematic
hardening is governed by a backstress evolution equation of the form: $dX = Cdp - DXp$, where X is the backstress, and the two coefficients, C and D, represent the evolution of kinematic hardening.

The non-linear equations for Isotropic and Kinematic Hardening are based on
[!cite](besson2009non)
pg. 82--84. The reference uses the nonlinear kinematic hardening rule proposed by Armstrong and Frederick [!cite](armstrong1966mathematical), while the isotropic hardening rule follows the Voce isotropic hardening model [!cite](voce1948relationship).

The effective plastic strain
increment for combined hardening has the form:
\begin{equation}
 d \Delta p = \frac{\sigma^{trial}_{effective} - 3 G \Delta p - r - \sigma_{yield}}{3G + h}
\end{equation}
where $G$ is the isotropic shear modulus, and $\sigma^{trial}_{effective}$ is the scalar part
of (von Mises trial stress - backstress).

The non-linear equations for Isotropic and Kinematic Hardening are based on
[!cite](besson2009non)
pg. 82--84.

This class calculates an effective trial stress, an effective scalar plastic strain increment, and
the derivative of the scalar effective plastic strain increment; these values are passed to the
RadialReturnBackstressStressUpdateBase to compute the radial return stress
increment.  This class also computes the plastic strain as a stateful material
property.

This class is based on the implicit integration algorithm in [!cite](dunne2005introduction)
pg. 146--149.

The `ADCombinedNonlinearHardeningPlasticity` version of this class uses forward mode automatic
differentiation to provide all necessary material property derivatives to
assemble a perfect Jacobian (this replaces the approximated tangent operator).

This model can be reduced to a purely linear isotropic model, if the kinematic hardening modulus is set to zero, as the backstress in the effective trial stress will remain zero and will not be updated. Conversely, if only the kinematic hardening modulus is set to a nonzero value, the hardening model will behave purely as linear kinematic.

To model the nonlinear hardening behavior of a material, the constants Q (saturation hardening) and b (rate of hardening) should be set to nonzero values for nonlinear isotropic hardening. Additionally, to capture nonlinear kinematic hardening behavior, the kinematic saturation gamma should be nonzero. For a combined nonlinear hardening model, all constants (Q, b, and gamma) should be set to nonzero values.

The following cyclic stress-strain plots below verify some of the responses

This combined hardening model is verified by plotting cyclic stress-strain curves using the same values of constants from [!cite](besson2009non) pg. 87--90. The model's results are compared to those from that reference, confirming that the implementation is functioning as expected. Some of the examples of cyclic hardening plots are shown below:

       style=width:650px;margin-left:70px;float:center;
       id=fig:non_linear_isotropic_symmetric_strain_controlled
       caption=Isotropic Hardening under prescribed symmetric strain

       style=width:650px;margin-left:70px;float:center;
       id=fig:non_linear_combined_symmetric_strain_controlled
       caption=Isotropic and Kinematic Nonlinear Hardening under prescribed symmetric strain

       style=width:650px;margin-left:70px;float:center;
       id=fig:non_linear_kinematic_nonsymmetric_strain_controlled
       caption=Nonlinear Kinematic Hardening under nonsymmetric imposed strain

       style=width:650px;margin-left:70px;float:center;
       id=fig:1d_ratcheting_non_linear_kinematic_load_controlled
       caption=1D Ratcheting under nonsymmetrical imposed stress path due to nonlinear kinematic hardening

#### Example Input File Syntax


`CombinedNonlinearHardeningPlasticity` must be used in conjunction with this inelastic strain return mapping stress calculator as shown below:






### CombinedScalarDamage


#### Description

`CombinedScalarDamage` is a model to define the effect of damage on the stress and stiffness in a continuum damage mechanics setting. It does not directly compute the stress, but must be used in conjunction with [ComputeDamageStress](/ComputeDamageStress.md).

This model is a scalar damage model in which the stress $\boldsymbol{\sigma}$ is computed as a function of the damage $d$, the original stiffness of the material $\mathbb{C}$ and the elastic strain $\boldsymbol{\varepsilon}$:

\begin{equation}
    \boldsymbol{\sigma} = (1 - d)\ \mathbb{C} : \boldsymbol{\varepsilon}
\end{equation}

The damage variable $d$ itself is computed as a combination of a series of external scalar damage models defined by the `damage_models` input parameters.
Two combination types are possible: `Maximum` (default) and `Product`:

\begin{equation}
\begin{split}
    \mathrm{Maximum:} & d = \mathrm{max}(d_1 ... d_N) \\
    \mathrm{Product:} & d = 1 - \Prod\limits_{i=1}^{N} (1 - d_i)
\end{split}
\end{equation}





### Compliance Sensitivity


#### Description

The `ComplianceSensitivity` material class extends the `StrainEnergyDensity` class to compute the compliance sensitivity in a material. This class is particularly useful in topology optimization problems, where the sensitivity of the compliance to design variables is required. The class makes use of `DerivativeParsedMaterial` to automatically compute derivatives.

#### Example Input File

An example of how to use the `ComplianceSensitivity` class in an input file:

listing test/tests/materials/compliance_sensitivity/2d_mbb.i block=Materials/dc





### Composite Eigenstrain


#### Description

The material `CompositeEigenstrain` calculates a Rank-2 tensor that can be used as an Eigenstrain
tensor in a mechanics simulation.  This tensor is computed as a weighted sum of base Eigenstrain
tensors, as shown in [eq:weighted_rank_two], where each weight can be a scalar material property that
may depend on simulation variables.
\begin{equation}
  \label{eq:weighted_rank_two}
  \boldsymbol{T}^{composite} = \sum_n w_n \cdot \boldsymbol{T}_n
\end{equation}
where $\boldsymbol{T}$ is a Rank-2 tensor and $w$ is the weighting factor for each Rank-2 tensor.


object for RankTwoTensor eigenstrains with the
[QuasiStaticSolidMechanicsPhysics](SolidMechanics/QuasiStatic/index.md) setting
`automatic_eigenstrain_names = true`, eigenstrains listed as `MaterialADConverter`
input tensors will not be included in the `eigenstrain_names` list passed. Set
the automatic/_eigenstrain/_names = false and populate this list manually if
these components need to be included.

#### Example Input File Syntax


The `eigenstrain_name` parameter value must also be set for the strain calculator, and an example
parameter setting is shown below:





### Composite Elasticity Tensor


#### Description

`CompositeElasticityTensor` calculates a simple Rank-4 tensor that can be used as an Elasticity
tensor in a mechanics simulation.  This tensor is computed as a weighted sum of base elasticity
tensors, as shown in [eq:weighted_rank_four], where each weight can be a scalar material
property that may depend on simulation variables.
\begin{equation}
  \label{eq:weighted_rank_four}
  \boldsymbol{T}^{composite} = \sum_n w_n \cdot \boldsymbol{T}_n
\end{equation}
where $\boldsymbol{T}$ is a Rank-4 tensor and $w$ is the weighting factor for each Rank-4 tensor.

#### Example Input File Syntax





### Composite Power Law Creep Stress Update


#### Description



The increment of inelastic strain is computed from the creep rate in this class.

\begin{equation}
  \label{eq:composite_power_law_creep}
  \dot{\epsilon} = \sum_{i=1}^N h_i \left[ A_i \left( \sigma^{trial}_{effective} - 3 G \Delta p \right)^{n_i} \exp \left( \frac{-Q_i}{RT} \right) \right] \left(t - t_o \right)^m
\end{equation}

where subscript $i$ denotes phase specific material property, $h_i$ is the phase interpolation function, $A_i$ is the power law creep coefficient, also known as Dorn's Constant, $\sigma^{trial}_{effective}$ is the scalar von Mises trial stress, $G$ is
the isotropic shear modulus, $Q$ is the activation energy, $R$ is the universal
gas constant, $T$ is the temperature, $t$ and $t_o$ are the current and initial
times, respectively, and $n$ and $m$ are exponent values.

This class calculates an effective trial stress, an effective creep strain rate
increment and the derivative of the creep strain rate, and an effective scalar
inelastic strain increment based on different contributions from different phases; these values are passed to the
[ADRadialReturnStressUpdate](/ADRadialReturnStressUpdate.md) to compute the radial
return stress increment. This isotropic plasticity class also computes the
plastic strain as a stateful material property.

This class is based on the implicit integration algorithm in
[!cite](dunne2005introduction) pg. 146 - 149.

`CompositePowerLawCreepStressUpdate` must be run in conjunction with an inelastic
strain return mapping stress calculator such as
[ADComputeMultipleInelasticStress](ADComputeMultipleInelasticStress.md)

#### Example Input File Syntax






### Compute Axisymmetric 1D Finite Strain


#### Description

The material `ComputeAxisymmetric1DFiniteStrain` calculates the finite strain for
1D Axisymmetric systems and is intended for use with
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md) simulations.
This material assumes symmetry about the $z$-axis.
This 'strain calculator' material computes the strain within the cylindrical
coordinate system and relies on the specialized
[Axisymmetric RZ kernel](/StressDivergenceRZTensors.md) to handle the stress
divergence calculation.

The axis of symmetry must lie along the $z$-axis in a $\left(r, z, \theta \right)$
cylindrical coordinate system. This symmetry orientation is required for the
calculation of the residual and of the jacobian.
See [StressDivergenceRZTensors](/StressDivergenceRZTensors.md) for the
residual equation and the germane discussion.

#### 1D Axisymmetric Strain Formulation

The axisymmetric model uses the cylindrical coordinates, $r$, $z$, and $\theta$,
where the linear section formed by the $r$ axis is rotated about the $z$ axis in
the $\theta$ direction.
The incremental deformation gradient for the 1D axisymmetric system is defined as
\begin{equation}
  \label{eqn:incremental_deformation_grad}
  \hat{\boldsymbol{F}} = \boldsymbol{A} : \bar{\boldsymbol{F}}^{-1} + \boldsymbol{I}
\end{equation}
where $\boldsymbol{I}$ is the Rank-2 identity tensor, and the deformation gradient,
$\boldsymbol{A}$, and the old deformation gradient,
$\bar{\boldsymbol{F}}$, are given as
\begin{equation}
  \label{eqn:deform_grads}
  \boldsymbol{A} = \begin{bmatrix}
                \epsilon_{rr} & 0 & 0 \\
                0 & \epsilon_{zz} & 0 \\
                0 & 0 & \epsilon_{\theta \theta}
              \end{bmatrix} + \boldsymbol{I}
  \qquad \text{  and  } \qquad
  \bar{\boldsymbol{F}} = \begin{bmatrix}
                \epsilon_{rr}|_{old} & 0 & 0 \\
                0 & \epsilon_{zz}|_{old} & 0 \\
                0 & 0 & \epsilon_{\theta \theta}|_{old}
              \end{bmatrix} + \boldsymbol{I}
\end{equation}
Note that $\bar{\boldsymbol{F}}$ uses the values of the strain expressions from
the previous time step.
The components of the tensors in [eqn:deform_grads] are given as
\begin{equation}
  \label{eqn:strain_components}
  \begin{aligned}
  \epsilon_{rr} & = u_{r,r} \\
  \epsilon_{zz} & = \exp \left[ \epsilon|^{op} - 1.0  \right] \\
  \epsilon_{\theta \theta} & = \frac{u_r}{X_r}
  \end{aligned}
\end{equation}
where $\epsilon|^{op}$ is a prescribed out-of-plane strain value: this strain
value can be given either as a scalar variable or a nonlinear variable.
The [Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
problems use scalar variables.
The value of the strain $\epsilon_{\theta \theta}$ depends on the displacement
and position in the radial direction.

The axisymmetric system changes the order of the displacement vector from
$(u_r, u_{\theta}, u_z)$, usually seen in textbooks, to $(u_r, u_z, u_{\theta})$.
Take care to follow this convention in your input files and when adding
eigenstrains or extra stresses.


Once the incremental deformation gradient ([eqn:incremental_deformation_grad])
is calculated for the 1D geometry, the deformation gradient is passed to the
strain and rotation methods used by default 3D Cartesian simulations, as
described in the [Finite Strain Class](ComputeFiniteStrain.md) documentation.

#### Example Input File

The coordinate type in the Problem block of the input file must be set to
+`COORD_TYPE = RZ`+.

The common use of the `ComputeAxisymmetric1DFiniteStrain` class is with the
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md) system;
this type of simulation uses the scalar strain variables


which uses a scalar variable for the coupled out-of-plane strain; the argument
for the `scalar_out_of_plane_strain` parameter is the name of the scalar strain
variable:







### Compute Axisymmetric 1D Incremental Strain


#### Description

The material `ComputeAxisymmetric1DIncrementalStrain` calculates the small
incremental strain for 1D Axisymmetric systems and is intended for use with
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md) simulations.
This material assumes symmetry about the $z$-axis.
This 'strain calculator' material computes the strain within the cylindrical
coordinate system and relies on the specialized
[Axisymmetric RZ kernel](/StressDivergenceRZTensors.md) to handle the stress
divergence calculation.

The axis of symmetry must lie along the $z$-axis in a $\left(r, z, \theta \right)$
cylindrical coordinate system. This symmetry orientation is required for the
calculation of the residual and of the jacobian.
See [StressDivergenceRZTensors](/StressDivergenceRZTensors.md) for the
residual equation and the germane discussion.

#### 1D Axisymmetric Strain Formulation

The axisymmetric model uses the cylindrical coordinates, $r$, $z$, and $\theta$,
where the linear section formed by the $r$ axis is rotated about the $z$ axis in
the $\theta$ direction.
The small, total, strain increment is calculated with the form
\begin{equation}
  \label{eqn:strain_increment}
  \Delta \boldsymbol{\epsilon} = \frac{1}{2} \left( \boldsymbol{D} + \boldsymbol{D}^T \right)
  \text{ where } \boldsymbol{D} = \boldsymbol{A} - \bar{\boldsymbol{F}} + \boldsymbol{I}
\end{equation}
where $\boldsymbol{I}$ is the Rank-2 identity tensor and the deformation gradient,
$\boldsymbol{A}$, and the old deformation gradient,
$\bar{\boldsymbol{F}}$, are given as
\begin{equation}
  \label{eqn:deform_grads}
  \boldsymbol{A} = \begin{bmatrix}
                \epsilon_{rr} & 0 & 0 \\
                0 & \epsilon_{zz} & 0 \\
                0 & 0 & \epsilon_{\theta \theta}
              \end{bmatrix}
  \text{  and  }
  \bar{\boldsymbol{F}} = \begin{bmatrix}
                \epsilon_{rr}|_{old} & 0 & 0 \\
                0 & \epsilon_{zz}|_{old} & 0 \\
                0 & 0 & \epsilon_{\theta \theta}|_{old}
              \end{bmatrix}
\end{equation}
Note that $\bar{\boldsymbol{F}}$ uses the values of the strain expressions from
the previous time step.
The components of the tensors in [eqn:deform_grads] are given as
\begin{equation}
  \label{eqn:strain_components}
  \begin{aligned}
  \epsilon_{rr} & = u_{r,r} \\
  \epsilon_{zz} & = \epsilon|^{op} \\
  \epsilon_{\theta \theta} & = \frac{u_r}{X_r}
  \end{aligned}
\end{equation}
where $\epsilon|^{op}$ is a prescribed out-of-plane strain value: this strain
value can be given either as a scalar variable or a nonlinear variable.
The [Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
problems use scalar variables.
The value of the strain $\epsilon_{\theta \theta}$ depends on the displacement
and position in the radial direction.

The axisymmetric system changes the order of the displacement vector from
$(u_r, u_{\theta}, u_z)$, usually seen in textbooks, to $(u_r, u_z, u_{\theta})$.
Take care to follow this convention in your input files and when adding
eigenstrains or extra stresses.


#### Example Input File

The coordinate type in the Problem block of the input file must be set to
+`COORD_TYPE = RZ`+.

The common use of the `ComputeAxisymmetric1DIncrementalStrain` class is with the
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md) system;
this type of simulation uses the scalar strain variables


which uses a scalar variable for the coupled out-of-plane strain; the argument
for the `scalar_out_of_plane_strain` parameter is the name of the scalar strain
variable:







### Compute Axisymmetric 1D Small Strain


#### Description

The material `ComputeAxisymmetric1DSmallStrain` calculates the small total
strain for 1D Axisymmetric systems and is intended for use with
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md) simulations.
This material assumes symmetry about the $z$-axis.
This 'strain calculator' material computes the strain within the cylindrical
coordinate system and relies on the specialized
[Axisymmetric RZ kernel](/StressDivergenceRZTensors.md) to handle the stress
divergence calculation.

The axis of symmetry must lie along the $z$-axis in a $\left(r, z, \theta \right)$
cylindrical coordinate system. This symmetry orientation is required for the
calculation of the residual and of the jacobian.
See [StressDivergenceRZTensors](/StressDivergenceRZTensors.md) for the
residual equation and the germane discussion.

#### 1D Axisymmetric Strain Formulation

The axisymmetric model uses the cylindrical coordinates, $r$, $z$, and $\theta$,
where the linear section formed by the $r$ axis is rotated about the $z$ axis in
the $\theta$ direction.

The definition of a small total linearized strain is
\begin{equation}
  \label{eqn:def_small_total_strain}
  \epsilon_{ij} = \frac{1}{2} \left( u_{i,j} + u_{j,i}  \right)
\end{equation}
In this axisymmetric 1D formulation, the strain tensor is diagonal. [eqn:def_small_total_strain]
is therefore implemented in a straight-forward manner as
\begin{equation}
  \label{eqn:1d_axisym_strain}
  \epsilon_{ij} = \begin{bmatrix}
                    \epsilon_{rr} & 0 & 0 \\
                    0 & \epsilon_{zz} & 0 \\
                    0 & 0 & \epsilon_{\theta \theta}
                  \end{bmatrix}
\end{equation}
where the components of the strain tensor in [eqn:1d_axisym_strain] are given as
\begin{equation}
  \label{eqn:strain_components}
  \begin{aligned}
  \epsilon_{rr} & = u_{r,r} \\
  \epsilon_{zz} & = \epsilon|^{op} \\
  \epsilon_{\theta \theta} & = \frac{u_r}{X_r}
  \end{aligned}
\end{equation}
where $\epsilon|^{op}$ is a prescribed out-of-plane strain value: this strain
value can be given either as a scalar variable or a nonlinear variable.
The [Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
problems use scalar variables.
The value of the strain $\epsilon_{\theta \theta}$ depends on the displacement
and position in the radial direction.

The axisymmetric system changes the order of the displacement vector from
$(u_r, u_{\theta}, u_z)$, usually seen in textbooks, to $(u_r, u_z, u_{\theta})$.
Take care to follow this convention in your input files and when adding
eigenstrains or extra stresses.


#### Example Input File

The coordinate type in the Problem block of the input file must be set to
+`COORD_TYPE = RZ`+.

The common use of the `ComputeAxisymmetric1DSmallStrain` class is with the
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md) system;
this type of simulation uses the scalar strain variables


which uses a scalar variable for the coupled out-of-plane strain; the argument
for the `scalar_out_of_plane_strain` parameter is the name of the scalar strain
variable:





### Compute Axisymmetric RZ Finite Strain


#### Description

The material `ComputeAxisymmetricRZFiniteStrain` calculates the finite strain for
2D Axisymmetric systems.


Once the deformation gradient is calculated for the specific 2D geometry, the deformation gradient is
passed to the strain and rotation methods used by default 3D Cartesian simulations, as described in
the [Finite Strain Class](ComputeFiniteStrain.md) page.

#### Example Input File





### Compute Axisymmetric RZ Incremental Strain


#### Description

The material `ComputeAxisymmetricRZIncrementalStrain` calculates the small incremental strain for
Axisymmetric systems.


Once the deformation gradient is calculated for the specific 2D geometry, the deformation gradient is
passed to the strain and rotation methods used by default 3D Cartesian simulations, as described in
the [Incremental Finite Strain Class](ComputeIncrementalStrain.md) page.

#### Example Input File

         block=Materials/bot_strain




### Compute Axisymmetric RZ Small Strain


#### Description

The material `ComputeAxisymmetricRZSmallStrain` calculates the small total strain for Axisymmetric
systems.


Only minimal changes are required to adapt a plane strain problem to an axisymmetric problem. The
axisymmetric specific `ComputeAxisymmetricRZSmallStrain` code overwrites the method used to calculate
the total strain component $\epsilon_{\theta \theta}$ before calculating the total strain measure
with the small strain assumptions.

#### Example Input File Syntax

         block=Materials/small_strain_rz




### ComputeBeamResultants


#### escription
This class computes the forces and moments at time $t$ in the global coordinate system from the displacement and rotational strain increments and the constitutive relation. Please refer to [C0 Timeshenko Beam](/C0TimoshenkoBeam.md) for details.




### ComputeConcentrationDependentElasticityTensor


The concentration variable $c$, specified using the [!param](/Materials/ComputeConcentrationDependentElasticityTensor/c),
acts as a mixing function for the two elasticity tensors, $\boldsymbol{C_0}$ and $\boldsymbol{C_1}$, specified in the [!param](/Materials/ComputeConcentrationDependentElasticityTensor/C0_ijkl) and [!param](/Materials/ComputeConcentrationDependentElasticityTensor/C1_ijkl)
vector parameters. See [ComputeElasticityTensor.md] for an explanation about the fill methods, e.g. how to input a tensor as a vector parameter.

The elasticity tensor is then:

\boldsymbol{C} = \boldsymbol{C_0} + c (\boldsymbol{C_1} - \boldsymbol{C_0})

the derivative tensor of the elasticity tensor with regards to the concentration variable is then naturally:

\dfrac{\partial \boldsymbol{C}}{\partial c} = \boldsymbol{C_1} - \boldsymbol{C_0}




### ComputeCosseratElasticityTensor


Both the elasticity tensor and the elasticity flexural rigidity tensors are simply set as constants through the
[!param](/Materials/ComputeCosseratElasticityTensor/E_ijkl) and [!param](/Materials/ComputeCosseratElasticityTensor/B_ijkl)
parameters respectively.

See [ComputeElasticityTensor.md] for an explanation about the fill methods, e.g. how to input a tensor in a parameter.

Note that the elasticity tensor can still be made to vary in space and time using the [!param](/Materials/ComputeCosseratElasticityTensor/elasticity_tensor_prefactor)
[Function](Functions/index.md) parameter. The elasticity rigidity tensor is constant.

This object is part of the Cosserat mechanics model. See the theory manual  (at [solid_mechanics/doc/theory/cosserat.pdf](https://github.com/idaholab/moose/tree/next/modules/solid_mechanics/doc/theory/cosserat.pdf))
for more explanation.




### ComputeCosseratIncrementalSmallStrain


Incremental small strain tensors rely on stateful material properties to keep track of the 'old' (previous time step)
value of the material properties.
The Cosserat small strain tensor and its increment are computed from the gradients of the displacements and
the Cosserat rotation variables in the current and previous time steps as:

\gamma_{increment} = \nabla_{j}u_{i} - \nabla_{j}u_{i,old} + \epsilon_{ijkl}\theta_{c}^{k} - \epsilon_{ijkl}\theta_{c,old}^{k}

\gamma_{ij} = \gamma_{old, ij} + \gamma_{inc}

where

- the $_{inc}$ index indicates an increment, which is also defined as a material property
- the $_{old}$ index indicates a material property computed at the previous time step
- $\gamma_{ij}$ are the (i,j) components of the strain tensor
- $\nabla_{j}u_{i}$ are the  (i,j) components of the gradients of the displacements
- $\epsilon_{ijkl}$ is the permutation tensor, where the $k$ and $l$ indexes indicate sums
- $\theta_{c}^{k}$ are the Cosserat rotation variables

The curvature tensor $C$ and its increment are also computed by this `Material` from the gradients of the Cosserat rotations as:

C_{inc} = \nabla_{j}\theta_{c}^{i} - \nabla_{j}\theta_{c,old}^{i}

C = C_{old} + C_{inc}

This object is part of the Cosserat mechanics model. See the theory manual (at [solid_mechanics/doc/theory/cosserat.pdf](https://github.com/idaholab/moose/tree/next/modules/solid_mechanics/doc/theory/cosserat.pdf))
for more explanation.




### ComputeCosseratLinearElasticStress


The Cosserat linear elastic stress tensor is computed from the Cosserat elasticity tensor, within the small strain approximation:

\boldsymbol{\sigma} = \boldsymbol{E} \boldsymbol{\gamma}

\boldsymbol{\sigma}_c = \boldsymbol{B} C

where

- $\boldsymbol{\sigma}$ is the linear elastic stress tensor
- $\boldsymbol{E}$ the elasticity tensor (for example computed by [ComputeCosseratElasticityTensor.md])
- $\boldsymbol{\gamma}$ the strain tensor (for example computed by [ComputeCosseratSmallStrain.md])
- $\boldsymbol{\sigma}_c$ the coupled elastic stress tensor
- $\boldsymbol{B}$ the elastic flexural rigidity tensor
- C the local curvature tensor (for example computed by [ComputeCosseratSmallStrain.md])

The elastic strain is also computed to be the same as the mechanical strain, as there is no plasticity.
The Jacobian, derivative of the stress with regards to strain, is simply set to the elasticity tensor,
and the derivative of the coupled stress with regards to strain, is simply set to the elasticity flexural rigidity tensor.

This object is part of the Cosserat mechanics model. See the theory manual (at [solid_mechanics/doc/theory/cosserat.pdf](https://github.com/idaholab/moose/tree/next/modules/solid_mechanics/doc/theory/cosserat.pdf))
for more explanation.




### ComputeCosseratSmallStrain


The Cosserat small strain tensor is computed from the gradients of the displacements and
the Cosserat rotation variables as:

\gamma_{ij} = \nabla_{j}u_{i} + \epsilon_{ijkl}\theta_{c}^{k}

where

- $\gamma_{ij}$ are the (i,j) components of the strain tensor
- $\nabla_{j}u_{i}$ are the  (i,j) components of the gradients of the displacements
- $\epsilon_{ijkl}$ is the permutation tensor, where the $k$ and $l$ indexes indicate sums
- $\theta_{c}^{k}$ are the Cosserat rotation variables

The curvature tensor $C$ is also computed by this `Material` from the gradients of the Cosserat rotations as:

C = \nabla_{j}\theta_{c}^{i}

This object is part of the Cosserat mechanics model. See the theory manual (at [solid_mechanics/doc/theory/cosserat.pdf](https://github.com/idaholab/moose/tree/next/modules/solid_mechanics/doc/theory/cosserat.pdf))
for more explanation.




### Compute Cracked Stress


#### Description

This material implements a phase field fracture model that can include anisotropic elasticity tensors, modifying the stress and computing the free energy derivatives required for the model. It works with the standard phase field
kernels for nonconserved variables. In the model, a nonconserved order parameter $c$ defines the
crack, where $c = 0$ in undamaged material and $c = 1$ in cracked material. Cracked material can
sustain a compressive stress, but not a tensile one. $c$ evolves to minimize the elastic free energy
of the system.

This model takes the stress and Jacobian_mult that were calculated by another material and modifies them to include cracks.

#### Model Summary

In the model, the uncracked stress $\sigma_0$ is provided by another material. It is decomposed into its compressive $(-)$ and tensile $(+)$ parts using a spectral decomposition
\begin{equation}
\boldsymbol{\sigma}_0 = \boldsymbol{Q} \boldsymbol{\Lambda} \boldsymbol{Q}^T,
\end{equation}
The compressive and tensile parts of the stress are computed from positive and negative projection tensors (computed from the spectral decomposition) according to
\begin{equation}
	\boldsymbol{\sigma}^+ = \mathbf{P}^+ \boldsymbol{\sigma}_0
\end{equation}
\begin{equation}
	\boldsymbol{\sigma}^- = \mathbf{P}^- \boldsymbol{\sigma}_0,
\end{equation}

#### Free Energy Calculation

The total strain energy density is defined as
\begin{equation}
\Psi = [(1-c)^2(1-k) + k] \Psi^{+} +\Psi^{-},
\end{equation}
where $\psi^{+}$ is the strain energy due to tensile stress, $\psi^{-}$ is the strain energy due to
compressive stress, and $k \ll 0$ is a parameter used to avoid non-positive definiteness at or near
complete damage. The compressive and tensile strain energies are determined from:
\begin{equation}
\psi^{+} = \frac{1}{2} \boldsymbol{\sigma}^{+} : \boldsymbol{\epsilon}
\end{equation}
\begin{equation}
\psi^{-} = \frac{1}{2} \boldsymbol{\sigma}^{-} : \boldsymbol{\epsilon}.
\end{equation}

The crack energy density is defined as
\begin{equation}
\gamma = g_c \frac{1}{2l}c^2 + g_c \frac{l}{2} {| \nabla c |}^2,
\end{equation}
where $l$ is the width of the crack interface and $g_c$ is a parameter related to the energy release rate.

The total local free energy density is defined as
\begin{equation}
\begin{aligned}
F =& \Psi + \gamma \\
  =&[(1-c)^2(1-k) + k] \Psi^{+} +\Psi^{-} + \frac{g_c}{2l}c^2 + \frac{g_c l}{2} {|{\nabla c}|}^2.
\end{aligned}
\end{equation}

#### Stress Definition

To be thermodynamically consistent, the stress is related to the deformation energy density according
to
\begin{equation}
  \boldsymbol{\sigma} = \frac{\partial \psi_e}{\partial \boldsymbol{\epsilon}} = ((1-c)^2(1-k) + k)\frac{\partial \psi^+}{\partial \boldsymbol{\epsilon}} + \frac{\partial \psi^-}{\partial \boldsymbol{\epsilon}}.
\end{equation}
Since
\begin{equation}
	\frac{\partial \psi^+}{\partial \boldsymbol{\epsilon}} = \boldsymbol{\sigma}^+
\end{equation}
\begin{equation}
	\frac{\partial \psi^-}{\partial \boldsymbol{\epsilon}} = \boldsymbol{\sigma}^-,
\end{equation}
then,
\begin{equation}
	\boldsymbol{\sigma} = ((1-c)^2(1-k) + k)\boldsymbol{\sigma}^+ + \boldsymbol{\sigma}^-
\end{equation}

The Jacobian matrix for the stress is
\begin{equation}
  \boldsymbol{\mathcal{J}} = \frac{\partial \boldsymbol{\sigma}}{\partial \boldsymbol{\epsilon}} = \left(((1-c)^2(1-k) + k) \boldsymbol{\mathcal{P}}^+ + \boldsymbol{\mathcal{P}}^- \right) \boldsymbol{\mathcal{M}},
\end{equation}
where $\boldsymbol{\mathcal{M}}$ is the Jacobian_mult that was calculated by the constitutive model.

#### Evolution Equation and History Variable

To avoid crack healing, a history variable $H$ is defined that is the maximum energy density over the
time interval $t=[0,t_0]$, where $t_0$ is the current time step, i.e.
\begin{equation}
H = \max_t (\Psi^{+})
\end{equation}

Now, the total free energy is redefined as:
\begin{equation}
\begin{aligned}
F =& \left[ (1-c)^2(1-k) + k \right] H +\Psi^{-} + \frac{g_c}{2l}c^2 + \frac{g_c l}{2} {|{\nabla c}|}^2 \\
  =& f_{loc} + \frac{g_c l}{2} {|{\nabla c}|}^2
\end{aligned}
\end{equation}
with
\begin{equation}
f_{loc} = \left[ (1-c)^2(1-k) + k \right] H +\Psi^{-} + \frac{g_c}{2l}c^2.
\end{equation}
Its derivatives are
\begin{equation}
\begin{aligned}
\frac{\partial f_{loc}}{\partial c} =& -2 (1-c)(1-k) H + 2 \frac{g_c}{2l} c\\
\frac{\partial^2 f_{loc}}{\partial c^2} =& 2 (1-k) H + 2 \frac{g_c}{2l}.
\end{aligned}
\end{equation}

The evolution equation for the damage parameter follows the Allen-Cahn equation
\begin{equation}
\dot{c} = -L \frac{\delta F}{\delta c} = -L \left( \frac{\partial f_{loc}}{\partial c} - \nabla \cdot \kappa \nabla c \right),
\end{equation}
where $L = (g_c \eta)^{-1}$ and $\kappa = g_c l$.

This equation follows the standard Allen-Cahn and thus can be implemented in MOOSE using the standard
Allen-Cahn kernels, TimeDerivative, AllenCahn, and ACInterface. There is now an action that automatically generates these kernels:
NonconservedAction. See the +PhaseField module documentation+ for more information.

#### Example Input File Syntax

         block=Materials/cracked_stress




### Compute Creep and Plasticity Inelastic Stress


#### Description

`ComputeCreepPlasticityStress` computes the stress, the consistent tangent
operator (or an approximation), and a decomposition of the strain
into elastic and inelastic components for a pair inelastic
material models, namely creep and plasticity.
By default finite strains are assumed.

The elastic strain is calculated by subtracting the computed inelastic strain
increment tensor from the mechanical strain increment tensor.
\begin{equation}
  \label{cmis_elastic_strain_definition}
  \Delta \boldsymbol{\epsilon}^{el} = \Delta \boldsymbol{\epsilon}^{mech} - \Delta \boldsymbol{\epsilon}^{inel}
\end{equation}
Mechanical strain, $\epsilon^{mech}$, is considered to be the sum of the elastic
and inelastic (creep and plastic) strains.

This class uses the finite incremental strain formulation as a default. Users may
elect to use a small incremental strain formulation and set
+`perform_finite_strain_rotations = false`+ if the simulation will only ever use
small strains.
This class is not intended for use with a total small linearize strain formulation.

`ComputeCreepPlasticityStress` requires one creep model and one
plasticity model.  These need to be "stress update" models that derive from the
following base classes for creep and plasticity:

- [PowerLawCreepStressUpdate](PowerLawCreepStressUpdate.md)
- [IsotropicPlasticityStressUpdate](IsotropicPlasticityStressUpdate.md)

#### Combined Newton Iteration

The power law creep equation is
\begin{equation}
  \dot{p}_c=A\sigma^n_e=A(\sigma^{tr}_e-3G(\Delta p_c + \Delta p_p))^n
\end{equation}
where $\dot{p}_c$ is the creep inelastic strain rate, $A$ is a prefactor that does
not depend on stress, $\sigma_e$ is the effective stress, $\sigma^{tr}_e$ is the
trial effective stress, $G$ is the shear modulus, $\Delta p_c$ is the creep inelastic
strain increment, $\Delta p_p$ is the plastic inelastic strain increment, and $n$ is
the exponent.  A residual $f_c$ is formed as
\begin{equation}
f_c = \dot{p}_c \Delta t - \Delta p_c = 0
\end{equation}

The isotropic plasticity residual $f_p$ is
\begin{equation}
f_p = \sigma^{tr}_e - 3G(\Delta p_c + \Delta p_p)-r-\sigma_y=0
\end{equation}
where $r$ is the hardening value and $\sigma_y$ is the yield stress.

A Taylor expansion of $f(x)$ with two terms is
\begin{equation}
f(x) \approx f(a) + f'(a)(x-a)
\end{equation}

By setting $f_c$ and $f_p$ to zero and using this two-term Taylor expansion, we obtain
\begin{equation}
\begin{bmatrix}
\frac{\partial f_c}{\partial\Delta p_{c0}} & \frac{\partial f_c}{\partial\Delta p_{p0}} \\
\frac{\partial f_p}{\partial\Delta p_{c0}} & \frac{\partial f_p}{\partial\Delta p_{p0}}
\end{bmatrix}
\begin{bmatrix}
\Delta p_c - \Delta p_{c0} \\
\Delta p_p - \Delta p_{p0}
\end{bmatrix} =
\begin{bmatrix}
-f_c \\
-f_p
\end{bmatrix}
\end{equation}

where the subscript $0$ represents the current value.  This leads to

\begin{equation}
\begin{bmatrix}
\Delta p_c \\
\Delta p_p
\end{bmatrix} =
\begin{bmatrix}
\Delta p_{c0} \\
\Delta p_{p0}
\end{bmatrix} -
\begin{bmatrix}
\frac{\partial f_c}{\partial\Delta p_{c0}} & \frac{\partial f_c}{\partial\Delta p_{p0}} \\
\frac{\partial f_p}{\partial\Delta p_{c0}} & \frac{\partial f_p}{\partial\Delta p_{p0}}
\end{bmatrix}^{-1}
\begin{bmatrix}
f_c \\
f_p
\end{bmatrix}
\end{equation}

The diagonal terms in the matrix are the derivative of the creep residual with respect to the inelastic creep increment and the derivative of the plasticity residual with respect to the inelastic plastic strain increment.  These are available from the two inelastic models.

###### Jacobian Multiplier and the Consistent Tangent Operator

The Jacobian multiplier, which is used in the [StressDivergenceTensors](/StressDivergenceTensors.md)
kernel to condition the Jacobian calculation, must be calculated from the combination
of the two inelastic material models. There are three options used to
calculate the combined Jacobian multiplier: Elastic, Partial, and Nonlinear, which
are set by the individual elastic material models.
\begin{equation}
  \label{eqn:combined_jacobian_mult}
  \boldsymbol{J}_m = \begin{cases}
                  \boldsymbol{C} & \text{Elastic option} \\
                  \boldsymbol{A}^{-1} \cdot \boldsymbol{C} \text{, where }
                      \boldsymbol{A} = \boldsymbol{I} + \sum_i \boldsymbol{H}^{cto}_i & \text{Partial option} \\
                  \prod_i \boldsymbol{H}^{cto}_i \cdot \boldsymbol{C}^{-1}  & \text{Nonlinear option}
                 \end{cases}
\end{equation}
where $\boldsymbol{J}_m$ is the Jacobian multiplier, $\boldsymbol{C}$ is the elasticity
tensor, $\boldsymbol{I}$ is the Rank-4 identity tensor, and $\boldsymbol{H}^{cto}$ is the
consistent tangent operator.

The consistent tangent operator, defined in [eqn:elastic_cto] provides the information
on how the stress changes with respect to changes in the displacement variables.
\begin{equation}
  \label{eqn:elastic_cto}
  \delta \sigma_{ij} = H_{ijkl} \delta \epsilon_{kl}
\end{equation}
where $\delta \epsilon_{kl}$ is an arbitrary change in the total strain
(which occurs because the displacements are changed) and $\delta \sigma_{ij}$
is the resulting change in the stress.
In a purely elastic situation $H_{ijkl} = C_{ijkl}$ (the elasticity tensor), but
the inelastic mapping of changes in the stress as a result of changes in the
displacement variables is more complicated.
In a plastic material model, the proposed values
of displacements for the current time step were used to calculate a trial
inadmissible stress, $\sigma_{trial}=C_{ijkl} ( \epsilon^{el}_{old} + \Delta \epsilon^{el}_i )$,
that was brought back
to the yield surface through a radial return algorithm. A slight change in the
proposed displacement variables will produce a slightly different trial stress
and so on.
Other inelastic material models follow a similar pattern.

The user can chose to force all of the inelastic material models to use the elasticity
tensor as the consistent tangent operator by setting `tangent_operator = elastic`.
This setting will reduce the computational load of the inelastic material models
but may hamper the convergence of the simulation.
By default, the inelastic material models are allowed to compute the consistent
tangent operator implemented in each individual inelastic model with the
`tangent_operator = nonlinear` option.

###### Material Time Step Size Limitations

Prior to calculating the final strain values, the algorithm checks the size of
the current time step against any limitations on the size of the time step as
optionally defined by the inelastic material models.
As described in the [#limiter] section, the time step size
involves a post processor to ensure that the current time step size is reasonable
for each of the inelastic material models used in the simulation.

At the end of the algorithm, the final value of the elastic and inelastic
strain tensors are calculated by adding the increments to the old values.


#### Other Calculations Performed by `StressUpdate` Materials

The `ComputeCreepPlasticityStress` material relies on two helper calculations
to aid the simulation in converging.
These helper computations are defined within the specific inelastic models, and
only a brief overview is given here.
For specific details of the implementations, see the documentation pages for the
individual inelastic `StressUpdate` materials.

The first helper computation, the consistent tangent operator, is an optional
feature which is implemented for only certain inelastic
stress material models, and the material time step limiter is implemented in the
models which use the [Radial Return Stress Update](/RadialReturnStressUpdate.md)
algorithm.

##### Consistent Tangent Operator

The consistent tangent operator is used to improve the convergence of mechanics
problems (see a reference such as [!cite](simo1985cto) for an introduction to
consistent tangent operators).
The Jacobian matrix, [eqn:combined_jacobian_mult],
is used to capture how the change in the residual calculation changes with respect
to changes in the displacement variables.
To calculate the Jacobian, MOOSE relies on knowing how the stress changes with
respect to changes in the displacement variables.

Because the change of the stress with respect to the change in displacements is
material specific, the value of the consistent tangent operator
is computed in each inelastic material model. By default the consistent tangent
operator is set equal to the elasticity tensor (the option Elastic in
[eqn:combined_jacobian_mult]).
Inelastic material models which use either the Partial or Nonlinear options in
[eqn:combined_jacobian_mult] define a material
specific consistent tangent operator.

Generally Partial consistent tangent operators should be implemented for
non-yielding materials (e.g. volumetric swelling) and Full consistent tangent
operators should be implemented for yielding material models (e.g. plasticity).

##### Include Damage Model

Optionally, the effect of damage on the stress calculation can be included in
the model. Another material that defines the evolution of damage should be
coupled using parameter `damage_model`. Here, first the inelastic strains and
corresponding effective stresses are calculated based on the undamaged
properties. Afterwards, the damage index is applied on the effective stress to
calculate the damaged stress. This captures the effect of damage in a material
undergoing creep or plastic deformation.

##### Material Time Step Limiter id=limiter

In some cases, particularly in creep, limits on the time step are required by
the material model formulation. Each inelastic material model is responsible for
calculating the maximum time step allowable for that material model. The
[MaterialTimeStepPostprocessor](/MaterialTimeStepPostprocessor.md) finds the
minimum time step size limits from the entire simulation domain. The
postprocessor then interfaces with the
[IterationAdaptiveDT](/IterationAdaptiveDT.md) to restrict the time step size
based on the limit calculated in the previous time step. When the damage model
is included, the timestep is limited by the minimum timestep between the
inelastic models and the damage model.


#### Example Input File







### Compute Damage Stress


#### Description

`ComputeDamageStress` computes the stress for damaged elastic material in conjunction with another material that defines the evolution of damage, which must be derived from `DamageBase`. The only source of material nonlinearity in this model is the damage model, as there is no provision for including effects such as creep or plasticity.

See [ScalarMaterialDamage](/ScalarMaterialDamage.md) for a simple example of a damage material that can be used in conjunction with this model to define the effect of damage. The `ScalarMaterialDamage` model simply uses another scalar material property to define the evolution of the damage index.




### ComputeDeformGradBasedStress


#### Description

This class takes the deformation gradient and elasticity tensor as input, and computes the lagrangian strain using the deformation gradient. This lagrangian strain, elasticity tensor and the deformation gradient are used to compute the stress.





### ComputeDilatationThermalExpansionFunctionEigenstrain


#### Description

This model computes the eigenstrain tensor resulting from isotropic thermal expansion where the
temperature-dependent thermal expansion is defined by a user-supplied function that describes the
total dilatation as a function of temperature, $T$.

The thermal strain is given by,
\begin{equation}
  \boldsymbol{\epsilon}^{th} = \lambda (T) - \lambda(T_0) \boldsymbol{I}
  \label{eq:epsilon}
\end{equation}
where $T_0$ is the stress free temperature, $\lambda$ is the function that describes dilatation as a
function of temperature, and $\boldsymbol{I}$ is the identity matrix. For this material model,
$\lambda$ must be provided as a function.

Functions are not able to handle dual numbers at this time, so no automatic differentiation
information can be retained via the $\lambda$ function

#### Example Input File Syntax

         block=Materials/thermal_expansion_strain

The `eigenstrain_name` parameter value must also be set for the strain calculator, and an example
parameter setting is shown below:

         block=Physics/SolidMechanics/QuasiStatic




### Compute Eigenstrain


#### Description

The class `ComputeEigenstrain` allows the user to specify a constant value of an eigenstrain for a simulation.
The eigenstrain is added to the mechanical strain, which can be elastic or inelastic, before computing the corresponding stress measure:
\begin{equation}
  \epsilon_{ij}^{total} = \epsilon_{ij}^{mechanical} + \epsilon_{ij}^{eigenstrain}
\end{equation}

Eigenstrain is the term given to a strain which does not result directly from an applied force.
Chapter 3 of [!cite](qu2006fundamentals) describes the relationship between total, elastic, and eigen- strains and provides examples using thermal expansion and dislocations.
Eigenstrains are also referred to as residual strains, stress-free strains, or intrinsic strains; translated from German, [Eigen](http://dict.tu-chemnitz.de/deutsch-englisch/Eigen....html) means own or intrinsic in English.
The term eigenstrain was introduced by [!cite](mura1982general).

Based on the number and values of constants provided as the argument to the `eigen_base` parameter, `ComputeEigenstrain` will build an isotropic, symmetric, or skew-symmetric Rank-2 eigenstrain tensor.

#### Example Input File Syntax






### Compute Eigenstrain Beam From Variable


#### Description

`ComputeEigenstrainBeamFromVariable` class takes in a set of 3 displacement or rotation variables or both and uses them to calculate the displacement and rotational beam eigenstrain in the global coordinate system. If either displacement or rotational aux variables are provided, they should be provided in all three global coordinate directions.

#### Example Input File Syntax





### ComputeEigenstrainFromInitialStress


#### Description

Computes an eigenstrain, $\epsilon$, defined by $\sigma_{\mathrm{initial}}=E\epsilon$, where $E$ is
the elasticity tensor and $\sigma_{\mathrm{initial}}$ is the initial stress entered by the user.  The
initial stress is entered as a vector of 9 Functions, which may be optionally multiplied by a vector of 9 AuxVariables.

This allows a user to enter an insitu stress in rock-mechanics problems, for instance, by specifying
the $zz$ component to be a function of depth into the ground, and the $xx$, $xy$, $yx$ and $yy$
components of the initial stress to be related to the maximum and minimum principal horizontal
tectonic stresses.  A general anisotropic initial stress is allowed.  Using AuxVariables to set the initial stress may be advantageous when reading from a solution file using a [SolutionAux](/SolutionAux.md).

The eigenstrain thus computed is added to the mechanical strain on the first time step, and is
unchanged in subsequent timesteps.  The eigenstrain thus computed is given a name that is specified
by the user, and that name must be included in the `eigenstrain_names` input parameter of the strain
calculator (eg, in `ComputeSmallStrain`), otherwise MOOSE will not add the eigenstrain to the
mechanical strain!

The eigenstrain is computed on the first time step, using the elasticity tensor; hence, the
elasticity tensor should not be time-varying in the first timestep.

#### Example Input File Syntax


In this example the eigenstrain is given the name `ini_stress`.  This name is passed to the
`ComputeSmallStrain` strain calculator using the `eigenstrain_names` parameter.  The initial stress
is defined by the functions defined in





### Compute Elasticity Beam


#### Description

This class computes the elasticity vectors (material stiffness and flexure) for the beam element which relates the displacement and rotational strain increments to force and moment increments, respectively. Please refer to [C0 Timoshenko Beam](/C0TimoshenkoBeam.md) for details.  




### Compute Elasticity Tensor


#### Description

The material `ComputeElasticityTensor` builds the elasticity (stiffness) tensor with various
user-selected material symmetry options.  `ComputeElasticityTensor` also rotates the elasticity
tensor during the initial time step only; this class does not rotate the elasticity tensor during the
simulation.  The initial rotation is performed if the user provides arguments to the three Euler
angle parameters; the Bunge Euler angles provided in this class are used to perform passive (from the
sample to the crystal) rotations using the [extrinsic $Z_1 X_2 Z_3$ convention](https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix)
to build the rotation matrix $R$. Alternatively, the 3x3 rotation matrix can be defined directly in the input file.
Rotations to the elasticity tensor are applied as
\begin{equation}
\label{eq:rotate_elasticity_tensor}
  C_{ijkl} = R_{im} R_{jn} R_{ko} R_{lp} C_{mnop}
\end{equation}
See [below](#rotation-examples) for examples of tensor rotations.

For a general stiffness tensor with 21 independent components, the elasticity tensor within the
solid mechanics module can be represented with the notation shown in
[eq:rank4tensor_aux_indices].  Nonetheless, the full Rank-4 tensor with all 81 components is
created by `ComputeElasticityTensor`.
\begin{equation}
\label{eq:rank4tensor_aux_indices}
  \begin{aligned}
        C_{ijkl} \implies & \underbrace{\begin{bmatrix}
                      C_{11} & C_{12} & C_{13} & C_{14} & C_{15} & C_{16} \\
                      C_{21} & C_{22} & C_{23} & C_{24} & C_{25} & C_{26} \\
                      C_{31} & C_{32} & C_{33} & C_{34} & C_{35} & C_{36} \\
                      C_{41} & C_{42} & C_{43} & C_{44} & C_{45} & C_{46} \\
                      C_{51} & C_{52} & C_{53} & C_{54} & C_{55} & C_{56} \\
                      C_{61} & C_{62} & C_{63} & C_{64} & C_{65} & C_{66}
                      \end{bmatrix}}_{\text{textbook engineering notation}} \\[5.0em]
         \implies & \underbrace{\begin{bmatrix}
                                   C_{1111} & C_{1122} & C_{1133} & C_{1123} & C_{1131} & C_{1112} \\
                                   C_{2211} & C_{2222} & C_{2233} & C_{2223} & C_{2231} & C_{2212} \\
                                   C_{3311} & C_{3322} & C_{3333} & C_{3323} & C_{3331} & C_{3312} \\
                                   C_{2311} & C_{2322} & C_{2333} & C_{2323} & C_{2331} & C_{2312} \\
                                   C_{3111} & C_{3122} & C_{3133} & C_{3123} & C_{3131} & C_{3112} \\
                                   C_{1211} & C_{1222} & C_{1233} & C_{1223} & C_{1231} & C_{1212}
                                   \end{bmatrix}}_{\text{textbook Einstein index notation}} \\[5.0em]
         \implies & \underbrace{\begin{bmatrix}
                      C_{0000} & C_{0011} & C_{0022} & C_{0012} & C_{0020} & C_{0001} \\
                      C_{1100} & C_{1111} & C_{1122} & C_{1112} & C_{1120} & C_{1101} \\
                      C_{2200} & C_{2211} & C_{2222} & C_{2212} & C_{2220} & C_{2201} \\
                      C_{1200} & C_{1211} & C_{1222} & C_{1212} & C_{1220} & C_{1201} \\
                      C_{2000} & C_{2011} & C_{2022} & C_{2012} & C_{2020} & C_{2001} \\
                      C_{0100} & C_{0111} & C_{0122} & C_{0112} & C_{0120} & C_{0101}
                      \end{bmatrix}}_{\text{Compute Elasticity Tensor indices}}
  \end{aligned}
\end{equation}

There are several different material symmetry options that a user can apply to build the elasticity
tensor for a mechanics simulation that are discussed below.

#### General Symmetry

The fill method `symmetric21` is used to create the elasticity tensor for a linear hyperelastic
material with 21 independent components: the symmetries shown in
[eq:symmetric21_cijkl_cases] are used to determine the independent components
[!citep](slaughter2012linearized).
\begin{equation}
\label{eq:symmetric21_cijkl_cases}
  \begin{aligned}
    C_{ijkl} & = C_{jikl} \impliedby \quad \text{satisfies angular momentum} \\
    C_{ijkl} & = C_{ijlk} \impliedby \quad \text{symmetric strain tensor assumption} \\
    C_{ijkl} & = C_{klij} \impliedby \quad \text{linear hyperelastic material assumption}
  \end{aligned}
\end{equation}

##### Example Input File Syntax


which shows the expected order of the elasticity tensor components in the input argument string.

#### Orthotropic Symmetry

The fill method `symmetric9` is appropriate for materials with three orthotropic planes of symmetry
[!citep](malvern1969introduction), and is often used for simulations of anisotropic materials such as
cubic crystals.  The engineering elasticity tensor notation, [eq:rank4tensor_aux_indices],
for an orthotropic material is given in [eq:symmetric9_fill_method]
\begin{equation}
\label{eq:symmetric9_fill_method}
C_{ijkl}^{orthotropic} = \begin{bmatrix}
              C_{11} & C_{12} & C_{13} &      0 &      0 &      0 \\
              C_{12} & C_{22} & C_{23} &      0 &      0 &      0 \\
              C_{13} & C_{23} & C_{33} &      0 &      0 &      0 \\
                   0 &      0 &      0 & C_{44} &      0 &      0 \\
                   0 &      0 &      0 &      0 & C_{55} &      0 \\
                   0 &      0 &      0 &      0 &      0 & C_{66}
              \end{bmatrix}
\end{equation}

The user can also select the fill method `orthotropic`, which generates an elasticity tensor based directly on material parameters. That is, the elasticity tensor is computed via moduli of elasticity, Poisson's ratios, and shear stiffnesses, see [eq:orhotropic_fill_method]
\begin{equation}
\label{eq:orhotropic_fill_method}
C_{ijkl}^{orthotropic} = \begin{bmatrix}
              E_{1} (1 - \nu_{23} \nu_{32})/k & E_{1} (\nu_{23} \nu_{31} + \nu_{21})/k & E_{1} (\nu_{21} \nu_{32} + \nu_{31})/k  &      0 &      0 &      0 \\
              E_{2} (\nu_{13} \nu_{32} + \nu_{12})/k & E_{2} (1 - \nu_{13} \nu_{31})/k & E_{2} (\nu_{12} \nu_{31} + \nu_{32})/k &      0 &      0 &      0 \\
              E_{3} (\nu_{12} \nu_{23} + \nu_{13})/k & E_{3} (\nu_{13} \nu_{21} + \nu_{23})/k & E_{3} (1 - \nu_{12} \nu_{21})/k &      0 &      0 &      0 \\
                   0 &      0 &      0 & G_{12} &      0 &      0 \\
                   0 &      0 &      0 &      0 & G_{31} &      0 \\
                   0 &      0 &      0 &      0 &      0 & G_{23}
              \end{bmatrix}
\end{equation}
where $k = 1 - \nu_{12} \nu_{21} - \nu_{23} \nu_{32} - \nu_{31} \nu_{13} - \nu_{12} \nu_{23} \nu_{31} - \nu_{21} \nu_{32} \nu_{13}$.


##### Example Input File Syntax


In the Einstein index notation shown in [eq:rank4tensor_aux_indices], the parameter `C_ijkl`
expects the elasticity components in the order `C_ijkl = '1111 1122 1133 2222 2233 3333 2323 3131
1212'` for the `symmetric9` fill method option. Note that, in this case, the method `symmetric9` is used
to enter an isotropic elasticity tensor.


For the `orthotropic` fill method, the material parameters need to be referred to the global frame and introduced in the following order: $E_{11}\;E_{22}\;E_{33}\;G_{12}\;G_{23}\;G_{31}\;\nu_{21}\;\nu_{31}\;\nu_{32}\;\nu_{12}\;\nu_{13}\;\nu_{23}$. For cases where axes of orthotropy do not coincide with global axes, Euler angles can be provided to perform a general rotation of the elasticity tensor at the beginning of the simulation.


#### Linear Isotropic Symmetry

The two constant isotropic symmetry fill methods `symmetric_isotropic` and `symmetric_isotropic_E_nu`
are used in the dedicated isotropic elasticity tensor
[ComputeIsotropicElasticityTensor](/ComputeIsotropicElasticityTensor.md).  These two fill methods use
the symmetries shown in [eq:symmetric_isotropic_fill_method] to build the elasticity tensor.
\begin{equation}
\label{eq:symmetric_isotropic_fill_method}
C_{ijkl} = C_{klij} = C_{jikl} = C_{jilk}
\end{equation}
Please see the documentation page for [ComputeIsotropicElasticityTensor](/ComputeIsotropicElasticityTensor.md) for details and examples of the input file syntax for linear elastic isotropic elasticity tensors.

#### Antisymmetric Isotropic Symmetry

The fill method `antisymmetric_isotropic` is used for an antisymmetric isotropic material in a shear
case.  The elasticity tensor is built using the symmetries shown in
[eq:antisymmetric_isotropic_fill_method]
\begin{equation}
\label{eq:antisymmetric_isotropic_fill_method}
C_{ijkl}^{antisymmetric-isotropic} = \kappa e_{ijm} e_{klm}
\end{equation}
where $e$ is the permutation tensor and $m$ is the summation index.

#### Transverse Isotropic (Axisymmetric)

The fill method `axisymmetric_rz` is used for materials which are isotropic with respect to an axis of symmetry, such as a material composed of fibers which are parallel to the axis of symmetry [!citep](slaughter2012linearized).
The engineering notation matrix in this case is shown by [eq:axisymmetric_rz_fill_method].
\begin{equation}
\label{eq:axisymmetric_rz_fill_method}
C_{ijkl}^{axisymmetric} = \begin{bmatrix}
              C_{11} & C_{12} & C_{13} &      0 &      0 &      0 \\
              C_{12} & C_{11} & C_{13} &      0 &      0 &      0 \\
              C_{13} & C_{13} & C_{33} &      0 &      0 &      0 \\
                   0 &      0 &      0 & C_{44} &      0 &      0 \\
                   0 &      0 &      0 &      0 & C_{44} &      0 \\
                   0 &      0 &      0 &      0 &      0 & \frac{1}{2} \left( C_{11} - C_{12} \right)
              \end{bmatrix}
\end{equation}

##### Example Input File Syntax

         block=Materials/elasticity_tensor

In the Einstein index notation shown in [eq:rank4tensor_aux_indices], the parameter `C_ijkl`
expects the elasticity components in the order `C_ijkl = '1111, 1122, 1133, 3333, 2323'` for the
`axisymmetric_rz` fill method option.

#### Principal Directions for Stress and Strain

The fill method `principal` is appropriate for the case when the principal directions of strain and
stress align.  The engineering notation representation of the elasticity tensor is shown in
[eq:principal_fill_method].
\begin{equation}
\label{eq:principal_fill_method}
C_{ijkl}^{orthotropic} = \begin{bmatrix}
              C_{11} & C_{12} & C_{13} &      0 &      0 &      0 \\
              C_{21} & C_{22} & C_{23} &      0 &      0 &      0 \\
              C_{31} & C_{32} & C_{33} &      0 &      0 &      0 \\
                   0 &      0 &      0 &      0 &      0 &      0 \\
                   0 &      0 &      0 &      0 &      0 &      0 \\
                   0 &      0 &      0 &      0 &      0 &      0
              \end{bmatrix}
\end{equation}

In the Einstein index notation shown in [eq:rank4tensor_aux_indices], the parameter `C_ijkl`
expects the elasticity components in the order `C_ijkl = '1111 1122 1133 2211 2222 2233 3311 3322
3333'` for the `principal` fill method option.

#### Cosserat Elasticity Specific Fill Methods

The following fill methods are available within `ComputeElasticityTensor`, but the use cases for
these methods fall within the Cosserat applications which do not preserve the equilibrium of angular
momentum.

##### General Isotropic Symmetry

The fill method `general_isotropic` is used for the case of three independent components of an
elasticity tensor, [eq:general_isotropic_cijkl].
\begin{equation}
\label{eq:general_isotropic_cijkl}
C_{ijkl}^{isotropic} = \lambda \delta_{ij} \delta_{kl} + \mu \delta_{ik} \delta_{ji} + \kappa \delta_{il} \delta_{jk}
\end{equation}

This fill method case is used in the child class
[ComputeCosseratElasticityTensor](/ComputeCosseratElasticityTensor.md); please see the documentation
for [ComputeCosseratElasticityTensor](/ComputeCosseratElasticityTensor.md) for details and examples
of the input file syntax.

##### General Antisymmetric

The fill method `antisymmetric` builds an antisymmetric elasticity tensor for a shear-only case.  The
symmetries shown in [eq:antisymmetric_symmetries] are used to create the complete tensor
\begin{equation}
\label{eq:antisymmetric_symmetries}
C_{ijkl} = - C_{jikl} = - C_{ijlk} = C_{klij}
\end{equation}
and the engineering notation representation of the antisymmetric elasticity tensor is given in
[eq:antisymmetric_fill_method].
\begin{equation}
\label{eq:antisymmetric_fill_method}
C_{ijkl}^{antisymmetric} = \begin{bmatrix}
                   0 &      0 &      0 &      0 &      0 &      0 \\
                   0 &      0 &      0 &      0 &      0 &      0 \\
                   0 &      0 &      0 &      0 &      0 &      0 \\
                   0 &      0 &      0 &  C_{44} & -C_{54} &  C_{64} \\
                   0 &      0 &      0 & -C_{54} & -C_{55} & -C_{65} \\
                   0 &      0 &      0 &  C_{64} & -C_{65} &  C_{66}
              \end{bmatrix}
\end{equation}

This fill method case is used in the child class
[ComputeCosseratElasticityTensor](/ComputeCosseratElasticityTensor.md); please see the documentation
for [ComputeCosseratElasticityTensor](/ComputeCosseratElasticityTensor.md) for details and examples
of the input file syntax.

##### No Symmetry

The `general` fill method for the Compute Elasticity Tensor class does not make any assumptions about
symmetry for the elasticity tensor and requires all 81 components of the stiffness tensor as an input
string.  This fill method case is used in the child class
[ComputeCosseratElasticityTensor](/ComputeCosseratElasticityTensor.md); please see the documentation
for [ComputeCosseratElasticityTensor](/ComputeCosseratElasticityTensor.md) for details and examples
of the input file syntax.

#### Rotation Examples

Since the elasticity tensor is defined with respect to a given crystal orientation which may be
different than the simulation coordinate frame, one may wish to apply a rotation to the
elasticity tensor. Some example use cases include simulating a specific crystal plane
in a 2D simulation or embedding a secondary phase in a matrix phase. The rotation ensures the
correct stress is generated when a given strain is applied. Strain is calculated in the "sample"
or "simulation" reference frame and so the proper "sample to crystal" rotation must be applied.
As shown in [eq:rotate_elasticity_tensor], a rotation matrix is needed for this operation, which
can be built with Euler angles or entered in the input file directly.

##### Rotation About An Axis

Suppose we wish to rotate the elasticity tensor about the z-axis by 30 degrees. The rotation matrix
for rotating a vector by 30 degrees about the z-axis (an "active" rotation matrix) is
\begin{equation}
\label{eq:z_axis_rotation_30_degrees}
R_z = \begin{bmatrix}
          \frac{\sqrt{3}}{2} & -\frac{1}{2}       &  0  \\
          \frac{1}{2}        & \frac{\sqrt{3}}{2} &  0  \\
          0                  &      0             &  1
      \end{bmatrix}
  \approx
      \begin{bmatrix}
             0.8660254 & -0.5      &  0  \\
             0.5       & 0.8660254 &  0  \\
             0         & 0         &  1
      \end{bmatrix}
\end{equation}
Such a rotation can be implemented by directly supplying the rotation matrix in the input file
using the `rotation_matrix` parameter in `ComputeElasticityTensor`.

##### Example Input File Syntax

         block=Materials/elasticity_matrix

Note that the same rotation can be applied using Euler angles. MOOSE expects the "passive"
(Bunge) convention, so the input angle is -30 degrees. Also note that since the $Z_1 X_2 Z_3$ convention
is used, and only a single rotation is needed, the angle could be entered as either
`euler_angle_1` or `euler_angle_3`.

##### Example Input File Syntax

         block=Materials/elasticity_euler

##### Orientation Relationship Rotation

Rather than a specific axis-angle rotation, sometimes the elasticity tensor must be rotated to
satisfy a particular orientation relationship. In this case, the basis vectors of the rotated
coordinate system are known, and the corresponding rotation matrix can be built using the
unit basis vectors as rows of the rotation matrix. For example suppose we have the following
rotation matrix that can be used in the case where the $\left<111\right>$ direction of our
rotated or "crystal" system points along the z-axis of our simulation or "sample" system.
\begin{equation}
\label{eq:orientation_rotation}
R = \begin{bmatrix}
        \frac{\sqrt{2}}{2} & \frac{\sqrt{6}}{6} & \frac{\sqrt{3}}{3}  \\
       -\frac{\sqrt{2}}{2} & \frac{\sqrt{6}}{6} & \frac{\sqrt{3}}{3}  \\
        0                  & -\frac{\sqrt{6}}{3} & \frac{\sqrt{3}}{3}
    \end{bmatrix}
 \approx
    \begin{bmatrix}
         0.70710678 &  0.40824829 & 0.57735027  \\
        -0.70710678 &  0.40824829 & 0.57735027  \\
         0          & -0.81649658 & 0.57735027
    \end{bmatrix}
\end{equation}
To verify, we apply this rotation matrix to the $\hat{z}=\left<001\right>$ direction of our "sample" or
simulation frame: $R\hat{z}=\left<111\right>$, meaning it correctly converts directions from "sample" to
"crystal" frame, which is a "passive" rotation.

##### Example Input File Syntax

         block=Materials/elasticity_matrix

The rotation matrix in [eq:orientation_rotation] can also be built in an "active" sense
by doing a 45 degree rotation about the z-axis and then a ~54.7 degree ($\arccos\left(1/\sqrt{3}\right)$ radians)
rotation about the x-axis, then taking the transpose. Therefore these
are the corresponding Euler angles to be used since we rotated the elasticity tensor by the "passive" matrix
rather than the "active" matrix in the previous example. However, where more than 1 rotation is needed, the
order of rotations matter. Since the Euler angle convention in MOOSE uses "extrinsic" rotations, the
order must be reversed.

##### Example Input File Syntax

         block=Materials/elasticity_euler





### Compute Extra Stress Constant


#### Description

The class `ComputeExtraStressConstant` adds an additional stress term, ($\boldsymbol{\sigma}_0$), to
the residual calculation after the constitutive model calculation of the stress, as shown in
[eq:extra_stress_addition].  An extra stress may be a residual stress, such as in large civil
engineering simulations.

The extra stress material property, `extra_stress` stores the Rank-2 tensor values of the extra stress.
\begin{equation}
  \label{eq:extra_stress_addition}
  \sigma_{ij} = \sigma_{ij} + \sigma^{extra}_{ij}
\end{equation}
where the value of $\boldsymbol{\sigma}^{extra}$ is constant across the entire mesh in this class.

`ComputeExtraStressConstant` creates a symmetric stress tensor, and expects the values of the stress
tensor components in the specific order specified in the input parameter description below.

#### Example Input File Syntax





### Compute Extra Stress van der Waals Gas


#### Description

The class `ComputeExtraStressVDWGas` adds an additional hydrostatic stress term, ($\sigma^g_{ij}$), to
the residual calculation after the constitutive model calculation of the stress, as shown in
[eq:extra_stress_vdwgas].  This additional hydrostatic stress represents to the pressure
exerted by a van der Waals gas.


The diagonal components of the stress tensor are given by
\begin{equation}
  \label{eq:extra_stress_vdwgas}
  \sigma^g_{ii} = -\frac{kT}{\left(\frac{V_a}{c_g} - b \right) E^* }
\end{equation}
where $k$ is Boltzmann's constant, $T$ is the temperature, $V_a$ is the atomic volume of the lattice
atoms in the solid surrounding the gas phase, $c_g$ is the local gas atomic fraction (relative to
the surrounding solid), $b$ is the van der Waals gas hard-sphere exclusion volume, and $E^* $ is
an optional scale factor for non-dimensionalization. The off-diagonal components are
$\sigma^g_{ij} = 0$ for $i \neq j$.

#### Example Input File Syntax





### Compute Finite Beam Strain


#### Description

This class computes the rotation matrix that relates the global coordinate system to the current beam local coordinate system for large rotation scenarios in beam elements. Using this rotation matrix, the small/large strain increments in the current local configuration of the beam are also computed by this class. Please refer to [C0 Timoshenko Beam](/C0TimoshenkoBeam.md) for details. 




### Compute Finite Strain in Cartesian System


#### Description

This class is used to compute the strain increment, total strain, and incremental rotation for finite strain problems. The finite strain approach used is the incremental
corotational form [!citep](rashid1993incremental). This approach computes logarithmic strains and strain increments.

##### Incremental Configurations

In this form, the generic time increment under consideration is such that
\begin{equation}
  \label{eqn:time_notation}
  t \in [t_n, t_{n+1}]
\end{equation}
The configurations of the material element under consideration at $t = t_n$ and
$t = t_{n+1}$ are denoted by $\kappa_n$, and $\kappa_{n + 1}$, respectively for
the previous and the current incremental configurations.

##### Deformation Gradient Definition

The deformation gradient represents the change in a material element from the
reference configuration to the current configuration [!citep](malvern1969introduction).
In the incremental formulation used in the `ComputeFiniteStrain` class, the incremental
deformation gradient represents the change in the material element from the previous
configuration, $\kappa_n$, to the current configuration, $\kappa_{n+1}$.
Mathematically this relationship is given as
\begin{equation}
  \hat{\boldsymbol{F}} = \frac{\partial{\boldsymbol{x}_{n+1}}}{\partial{\boldsymbol{x}_n}},
\end{equation}
where $\boldsymbol{x}_{n+1}$ is the position vector of materials points in $\kappa_{n+1}$,
and $\boldsymbol{x}_{n}$ is the position vector of materials points in $\kappa_{n}$.

Note that $\hat{\boldsymbol{F}}$ is NOT the deformation gradient, but rather the incremental deformation gradient
of $\kappa_{n+1}$ with respect to $\kappa_n$. Thus $\hat{\boldsymbol{F}} = \boldsymbol{F}_{n+1}
\boldsymbol{F}_n^{-1}$, where $\boldsymbol{F}_n$ is the total deformation gradient at time $t_n$.

Following the explanation of this procedure given by [!cite](zhang2018modified),
the incremental deformation gradient can be multiplicatively decomposed into an
incremental rotation tensor, $\boldsymbol{\hat{R}}$, and the incremental right
stretch tensor, $\boldsymbol{\hat{U}}$
\begin{equation}
  \label{eqn:polar_decomposition_deform_grad}
  \boldsymbol{\hat{F}} = \boldsymbol{\hat{R}} \cdot \boldsymbol{\hat{U}}
\end{equation}
where $\boldsymbol{\hat{R}}$ is a proper orthogonal rotation tensor and the stretch
tensor, $\boldsymbol{\hat{U}}$, is symmetric and positive definite.
The incremental right Cauchy-Green deformation tensor, $\boldsymbol{\hat{C}}$,
can be given in terms of $\boldsymbol{\hat{U}}$ by substituting
[eqn:polar_decomposition_deform_grad] into the definition for $\boldsymbol{\hat{C}}$
from [!cite](malvern1969introduction):
\begin{equation}
  \label{eqn:right_green_cauchy_deformation_tensor}
  \boldsymbol{\hat{C}} = \boldsymbol{\hat{F}}^T \cdot \boldsymbol{\hat{F}} = \boldsymbol{\hat{U}}^T \cdot \boldsymbol{\hat{R}}^T \cdot \boldsymbol{\hat{R}} \cdot \boldsymbol{\hat{U}} = \boldsymbol{\hat{U}}^2
\end{equation}
where the orthogonal nature of $\boldsymbol{\hat{R}}$ enables the simplification
given above. Thus $\boldsymbol{\hat{U}}$ can be computed from $\boldsymbol{\hat{C}}$ as
\begin{equation}
  \label{eqn:definition_stretch_tensor}
  \boldsymbol{\hat{U}} = \boldsymbol{\hat{C}}^\frac{1}{2}
\end{equation}
which can be evaluated by performing a spectral decomposition of $\boldsymbol{\hat{C}}$.
Once $\boldsymbol{\hat{U}}$ has been computed, the multiplicative decomposition
of the deformation gradient is used to find the incremental rotation tensor
$\boldsymbol{\hat{R}}$ and the stretching rate $\boldsymbol{D}$.
Following [!cite](rashid1993incremental), the stretching rate tensor can be expressed in terms
of the 'incremental' right Cauchy-Green deformation tensor
\begin{equation}
  \label{eqn:stretching_tensor_definition}
  \boldsymbol{D} = \frac{1}{\Delta t}\log({\hat{\boldsymbol{C}}^{1/2}})
\end{equation}

This incremental stretching rate tensor can then be used as the work conjugate
for a stress measure, or used to compute another strain
measure. The most computationally expensive part of this procedure is the spectral
decomposition of $\boldsymbol{\hat{C}}$ to find $\boldsymbol{\hat{U}}$. This
decomposition can be computed exactly using an [Eigensolution](#eigensolution),
yet an approximation of this can be computed with much lower computational expense
using a [Taylor expansion](#taylorexpansion) procedure.
This class provides options to perform this calculation either way, and the
[Taylor expansion](#taylorexpansion) is the default.

This class also provides an additional option for
computing the stretching rate tensor $\boldsymbol{D}$ and incremental rotation tensor $\boldsymbol{\hat{R}}$
using the method of [!cite](hughes1980finite). This method involves evaluating the displacement field at the midpoint of the timestep, and as a
result, requires updating stress and strain measures at the old configuration rather than the current.

###### Taylor Expansion id=taylorexpansion

The stretching rate tensor $\boldsymbol{D}$ and incremental rotation matrix $\hat{\boldsymbol{R}}$
can be approximated using Taylor expansion as [!cite](rashid1993incremental):
the approximated stretching rate tensor
\begin{equation}
\boldsymbol{D}^{a} = \frac{1}{\Delta t}\left[ -\frac{1}{2}(\hat{\boldsymbol{C}}^{-1} - \boldsymbol{I}) + \frac{1}{4}(\hat{\boldsymbol{C}}^{-1} - \boldsymbol{I})^{2} - \frac{1}{6}(\hat{\boldsymbol{C}}^{-1} - \boldsymbol{I})^{3} + ... \right]
\end{equation}
the approximated rotation matrix
\begin{equation}
\hat{R}_{ij}^{a} = \delta_{ij}\cos \theta^{a} + \frac{1-\cos \theta^{a}}{4Q} \alpha_{i}\alpha_{j} - \frac{\sin \theta^{a}}{2\sqrt{Q}}\epsilon_{ijk}\alpha_{k}
\end{equation}
with
\begin{equation}
\begin{aligned}
\sin^{2} \theta^{a} =& Q \\[1.5em]
\frac{\sin \theta^{a}}{2\sqrt{Q}} =& \frac{1}{2}\left[ \frac{PQ(3-Q)+P^{3}+Q^{2}}{(P+Q)^{3}} \right]^{1/2}\\[1.5em]
\frac{1-\cos \theta^{a}}{4Q} =& \frac{1}{8} + Q\frac{P^{2}-12(P-1)}{32P^2} + Q^{2}\frac{(P-2)(P^{2}-10P+32)}{64P^3}\\[1.5em]
 +& Q^{3}\frac{1104-992P+376P^{2}-72P^{3}+5P^{4}}{512P^{4}}\\[1.5em]
\cos^{2} \theta^{a} =& P + \frac{3P^{2}[1-(P+Q)]}{(P+Q)^{2}} - \frac{2P^{3}[1-(P+Q)]}{(P+Q)^{3}}\\[1.5em]
P =& \frac{1}{4}(tr(\hat{\boldsymbol{F}}^{-1}) - 1)^{2}
\end{aligned}
\end{equation}
The sign of $\cos \theta^{a}$ is set by examining the sign of $(tr(\hat{\boldsymbol{F}}^{-1}) - 1)$.

###### Eigen-Solution id=eigensolution

The stretching rate tensor can be calculated by the eigenvalues $\lambda$ and eigenvectors
$\boldsymbol{v}$ of $\hat{\boldsymbol{C}}$.
\begin{equation}
\boldsymbol{D} = \log{\sqrt{\lambda_{1}}}\boldsymbol{N}_{1} + \log{\sqrt{\lambda_{2}}}\boldsymbol{N}_{2} + \log{\sqrt{\lambda_{3}}}\boldsymbol{N}_{3}
\end{equation}
with $\lambda$ being the eigenvalue and $\boldsymbol{N}$ matrix being constructed from the corresponding
eigenvector.
\begin{equation}
\boldsymbol{N}_{i} = \boldsymbol{v}_{i}\boldsymbol{v}_{i}^{T}
\end{equation}
the 'incremental' stretching tensor
\begin{equation}
\hat{\boldsymbol{U}} = \sqrt{\lambda_{1}}\boldsymbol{N}_{1} + \sqrt{\lambda_{2}}\boldsymbol{N}_{2} + \sqrt{\lambda_{3}}\boldsymbol{N}_{3}
\end{equation}
and thus
\begin{equation}
\hat{\boldsymbol{R}} = \hat{\boldsymbol{F}} \hat{\boldsymbol{U}}^{-1}
\end{equation}

###### Hughes-Winget Approximation id=hugheswinget

As also described in [!cite](rashid1993incremental), the stretching rate tensor $\boldsymbol{D}$ and incremental
rotation matrix $\hat{\boldsymbol{R}}$ in for the Hughes-Winget method are based on the spatial gradient $\boldsymbol{G}$
of the displacement field evaluated at the mid-point of the time step
\begin{equation}
\boldsymbol{G} = 2\left( \hat{\boldsymbol{F}} - \boldsymbol{I}\right) \left( \hat{\boldsymbol{F}} + \boldsymbol{I}\right)^{-1}
\end{equation}
The approximate stretching rate tensor can then be computed as
\begin{equation}
\boldsymbol{D} = \frac{1}{2 \Delta t}\left(\boldsymbol{G} + \boldsymbol{G}^{T} \right)
\end{equation}
and the incremental rotation matrix is approximated by
\begin{equation}
\hat{\boldsymbol{R}} = \left(\boldsymbol{I} + \frac{1}{2}\omega \right) \left(\boldsymbol{I} - \frac{1}{2}\omega \right)^{-1}
\end{equation}
where $\omega = \frac{1}{2}\left(\boldsymbol{G} - \boldsymbol{G}^{T} \right)$.

##### Volumetric Locking Correction

In `ComputeFiniteStrain`, $\hat{\boldsymbol{F}}$ is calculated in the computeStrain method, including a
volumetric locking correction of
\begin{equation}
\hat{\boldsymbol{F}}_{corr} = \hat{\boldsymbol{F}} \left( \frac{|\mathrm{av}_{el}(\hat{\boldsymbol{F}})|}{|\hat{\boldsymbol{F}}|} \right)^{\frac{1}{3}},
\end{equation}
where $\mathrm{av}_{el}()$ is the average value for the entire element. The strain increment and the
rotation increment are calculated in `computeQpStrain()`. Once the strain increment is calculated, it
is added to the total strain from $t_n$. The total strain from $t_{n+1}$ must then be rotated using
the rotation increment.

#### Example Input File Syntax

The finite strain calculator can be activated in the input file through the use of the
Solid Mechanics Physics, as shown below.

         block=Physics/SolidMechanics

The [Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md) is designed to
automatically determine and set the strain and stress divergence parameters correctly for the
selected strain formulation.  We recommend that users employ the
[Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md) whenever possible
to ensure consistency between the test function gradients and the strain formulation selected.

Although not recommended, it is possible to directly use the `ComputeFiniteStrain` material
in the input file.

         block=Materials/strain

When directly using `ComputeFiniteStrain` in an input file as shown above, the
[StressDivergenceTensors](/StressDivergenceTensors.md) kernel must be modified
from the default by setting the parameter `use_displaced_mesh = true`. This setting
is required to maintain consistency in the test function gradients and the
strain formulation. For a complete discussion of the stress divergence kernel
settings and the corresponding strain classes, see the section on
[Consistency Between Stress and Strain](/solid_mechanics/StressDivergence.md#consistency_stress_strain_use_displaced_mesh)
in the SolidMechanics module overview. In addition, be aware of the loading
cycle limitations while using finite strains as outlined in the section
[Large Strain Closed Loop Loading Cycle](/solid_mechanics/Strains.md#large_strain_closed_loop_loading_cycle).






### Compute Finite Strain Elastic Stress


#### Description

This material, `ComputeFiniteStrainElasticStress` computes the elastic stress for an incremental formulation, both incremental small ([ComputeIncrementalStrain](/ComputeIncrementalStrain.md) type) and incremental finite ([ComputeFiniteStrain](/ComputeFiniteStrain.md) type) strain formulations.
This stress class is compatible with both Cartesian and non-Cartesian strain calculators, including [Axisymmetric](/ComputeAxisymmetricRZFiniteStrain.md) and [RSpherical](/ComputeRSphericalFiniteStrain.md).

Elastic materials do not experience permanent deformation, and all elastic strain and elastic stress is recoverable. Elastic stress is related to elastic strain through the elasticity tensor
\begin{equation}
  \label{eq:incremental_stress_calculator}
  \sigma_{ij} = C_{ijkl} \Delta \epsilon_{kl}
\end{equation}
where $\Delta \boldsymbol{\epsilon}$ is the strain increment; this strain measure is also the sum of the mechanical elastic strain and any eigenstrains in the system.


#### Example Input File Syntax





### ComputeGlobalStrain


#### Description

This `Material` extracts the values from the scalar variables solved by [GlobalStrain](/ScalarKernels/GlobalStrain) and stores them as a strain tensor.
Global strain calculated here is added to the total strain.

Objects that use `use_displaced_mesh = true` will operate on a displaced mesh that does not include the global strain contribution!

#### Example Input File Syntax

         block=Materials/global_strain




### Compute Incremental Beam Strain


#### Description

This class computes the small (and finite) displacement and rotational strain increments for beam elements. Please refer to [C0 Timoshenko Beam](/C0TimoshenkoBeam.md) for details. 




### Compute Incremental Strain


#### Description

The material `ComputeIncrementalStrain` is designed for linear elasticity problems formulated
within an incremental framework.  As with [ComputeSmallStrain](/ComputeSmallStrain.md), this material
is useful for verifying material models with hand calculations because of the simplified strain
calculations.  As in the small strain material, the incremental small strain class assumes the
gradient of displacement with respect to position is much smaller than unity, and the squared
displacement gradient term is neglected in the small strain definition to give:
\begin{equation}
\epsilon = \frac{1}{2} \left( u \nabla + \nabla u \right) \quad when \quad \frac{\partial u}{ \partial x} << 1
\end{equation}
As the class name suggests, `ComputeIncrementalStrain` is an incremental formulation.  The
stress increment is calculated from the current strain increment at each time step.  In this class,
the rotation tensor is defined to be the rank-2 Identity tensor: no rotations are allowed in the
model. Stateful properties, including `strain_old` and `stress_old`, are stored. This incremental
small strain material is useful as a component of verifying more complex finite incremental
strain-stress calculations.

#### Example Input File Syntax

The incremental small strain calculator can be activated in the input file through the use of the
Solid Mechanics Physics, as shown below.


The [Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md) is designed to
automatically determine and set the strain and stress divergence parameters correctly for the
selected strain formulation.  We recommend that users employ the
[Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md) whenever possible
to ensure consistency between the test function gradients and the strain formulation selected.

Although not recommended, it is possible to directly use the `ComputeIncrementalStrain` material
in the input file.





### ComputeInstantaneousThermalExpansionFunctionEigenstrain


#### Description

This model computes the eigenstrain tensor resulting from isotropic thermal expansion where the
temperature-dependent thermal expansion is defined by a user-supplied function that describes the
instantaneous thermal expansion coefficient $\alpha$ as a function of temperature, $T$.  Using a
trapezoidal rule to perform time integration of this function, the current value of the thermal
eigenstrain tensor, $\boldsymbol{\epsilon}^{th}_{t+1}$ is computed at a given time as:
\begin{equation}
\boldsymbol{\epsilon}^{th}_{t+1} = \boldsymbol{\epsilon}^{th}_{t} + \frac{1}{2}(\alpha_{(T_t)} + \alpha_{(T_{t+1})}) (T_{t+1}-T_{t}) \boldsymbol{I}
\end{equation}
where $t+1$ denotes quantities at the new step, and $t$ denotes quantities at the previous step, $T$
is the temperature, $\alpha_{(T)}$ is the instantaneous thermal expansion at a given temperature, and
$\boldsymbol{I}$ is the identity matrix. On the first step, the stress-free temperature is used as the
previous step's temperature.

#### Example Input File Syntax

         block=Materials/thermal_expansion_strain1

The `eigenstrain_name` parameter value must also be set for the strain calculator, and an example
parameter setting is shown below:

         block=Physics/SolidMechanics/QuasiStatic




### Compute Interface Stress


#### Description

The resulting stress tensor has the property of having one Eigenvector in the
direction of the order parameter gradient, with an Eigenvalue of zero, and two
Eigenvectors perpendicular to that direction, with an Eigenvalue $\sigma_i\cdot|\nabla\eta|$,
where the scalar $\sigma_i$ (`stress`) is a supplied parameter and $\eta$ (`v`) is a given order
parameter.
\begin{equation}
\vec e_1 = \frac{\nabla\eta}{|\nabla\eta|}
\end{equation}

Then two more linearly independent vectors $\vec e_2$ and $\vec e_3$ are generated
by determining the component $m$ of $\vec e_1$ with the largest magnitude. $\vec e_2$
and $\vec e_3$ are then set to unit vectors from the set
\begin{equation}
\vec u_1 = (1,0,0), \vec u_2 = (0,1,0), \vec u_3 = (0,0,1)
\end{equation}
such that
\begin{equation}
\vec e_2 = \vec u_{(m+1) \backslash{3}}, \vec e_3 = \vec u_{(m+2)\backslash{3}},
\end{equation}
where the $\backslash$ operator represents integer modulo. The basis $\vec e_i$
is then orthonormalized using the modified Gram-Schmidt procedure,
holding $\vec e_1$ constant. We construct two matrices
\begin{equation}
\boldsymbol{M} = \left( \begin{matrix}
  0 & 0 & 0 \\
  0 & \sigma_i & 0 \\
  0 & 0 & \sigma_i
  \end{matrix}  \right),
\boldsymbol{S}= \left( \begin{matrix}
  \vec e_1 & \vec e_2 & \vec e_3
  \end{matrix}
  \right),
\end{equation}
and set the stress tensor $\boldsymbol{\sigma}$ to
\begin{equation}
\boldsymbol{\sigma} = \left(S\cdot M\cdot S^{-1}\right)\cdot|\nabla\eta|,
\end{equation}
which is a basis transformation from the Eigenvector basis into the cartesian basis.
The $|\nabla\eta|$ factor causes the integral over the stress tensor across the interface
to evaluate the same value, regardless of interfacial width (provided the order parameter
range is well defined - commonly 0 and 1 on the two sides of the interface).

#### Example Input File Syntax





### Compute Isotropic Elasticity Tensor


#### Description

The material `ComputeIsotropicElasticityTensor` builds the isotropic elasticity (stiffness) tensor with two user provided elastic constants.

The isotropic elasticity tensor is given, in engineering matrix notation [!citep](malvern1969introduction), as
\begin{equation}
\label{eq:isotropic_fill_method}
C_{ijkl}^{isotropic} = \begin{bmatrix}
              \lambda + 2 \mu & \lambda & \lambda &      0 &      0 &      0 \\
              \lambda & \lambda + 2 \mu & \lambda &      0 &      0 &      0 \\
              \lambda & \lambda & \lambda + 2 \mu &      0 &      0 &      0 \\
                   0 &      0 &      0 &    \mu &      0 &      0 \\
                   0 &      0 &      0 &      0 &    \mu &      0 \\
                   0 &      0 &      0 &      0 &      0 &    \mu
              \end{bmatrix}
\end{equation}

`ComputeIsotropicElasticityTensor` accepts as an argument two of five isotropic elastic constants: lambda $\lambda$, the shear modulus $\mu$, the bulk modulus $K$, the Young's modulus $E$, or the Poisson's ratio $\nu$.
The material includes the conversions into Lame constants, see [!cite](slaughter2012linearized) for the conversion equations among the isotropic elastic constants.

An automatic differentiation version of this object is available as `ADComputeIsotropicElasticityTensor`.

#### Example Input File Syntax






### ComputeLayeredCosseratElasticityTensor


Both the elasticity tensor and the elasticity flexural rigidity tensors are simply set as constants computed from the
Young modulus and Poisson ratio of the layered materials, the thickness of the joints and the normal and shear stiffness of the joints.
The derivation can be found in the 3D layered Cosserat elasticity chapter of the theory manual.

Note that the elasticity tensor can still be made to vary in space and time using the [!param](/Materials/ComputeLayeredCosseratElasticityTensor/elasticity_tensor_prefactor) [Function](Functions/index.md) parameter. The elasticity rigidity tensor is constant.

This object is part of the layered Cosserat mechanics model. See the theory manual  (at [solid_mechanics/doc/theory/cosserat.pdf](https://github.com/idaholab/moose/tree/next/modules/solid_mechanics/doc/theory/cosserat.pdf))
for more explanation.




### Compute Linear Elastic Phase Field Fracture Stress

#### Description

This material implements the unified phase-field model for mechanics of damage and quasi-brittle failure from Jian-Ying Wu [!cite](JYWu2017). The pressure on the fracture surface can be optionally applied as described in [!cite](CHUKWUDOZIE2019957) and [!cite](Mikelic2019).

#### Crack Surface Energy

The regularized functional $A_d$ is given as

\begin{equation}
A_d(d):= \int_{\mathcal{B}}\gamma(d,\nabla d) dV
\end{equation}

The crack surface density function $\gamma(d,\nabla d)$ is expressed in terms of the crack phase-field $d$ and its spatial gradient $\nabla d$ as
\begin{equation}
\gamma(d,\nabla d) = \frac{1}{c_0}(\frac{1}{l}\alpha(d) + l|\nabla d|^2)~~~~~~~\text{with}~~~~~~~c_0 = 4\int_0^1\sqrt{\alpha(\beta)}d\beta
\end{equation}
where the geometric function $\alpha(d)$ characterizes homogeneous evolution of the crack phase-field. $l$ is an internal length scale regularizing the sharp crack. $c_0$ is a scaling parameter such that the regularized functional $A_d(d)$ represents the crack surface.

The crack geometric function $\alpha(d)$ generally satisfies the following properties,
\begin{equation}
\alpha(0) = 0~~~~~~~~,~~~~~~~~\alpha(1) = 1
\end{equation}

In the classical phase-field models the modeling crack geometric function have been widely adopted for brittle fracture_energy
\begin{equation}
\alpha(d) = \begin{cases} d~~~~\text{Linear function} \\ d^2~~~\text{Quadratic function}\end{cases}
\end{equation}

#### Elastic Energy

The elastic energy is defined as
\begin{equation}
\Psi(\varepsilon,d) = \omega(d)\Psi_0(\varepsilon)
\end{equation}

The monotonically decreasing energetic function $w(d)\in[0,1]$ describes degradation of the initial strain energy $\Psi_0(\varepsilon)$ as the crack phase-field evolves, satisfying the following properties [!cite](Miehe2015)
\begin{equation}
\omega'(d) < 0~~~~~\text{and}~~~~~\omega(0)=1,~~~~~\omega(1) = 0,~~~~~\omega'(1)=0
\end{equation}

The variation of the elastic energy gives constitutive relations
\begin{equation}
\boldsymbol{\sigma} = \omega(d)\frac{\partial{\Psi_0}}{\partial{\varepsilon}},~~~~~~~~Y=-\frac{\partial\Psi}{\partial d} = -\omega'(d)\mathcal{Y}
\end{equation}
where the thermodynamic force $Y$ drives evolution of the crack phase-field with the reference energy $\mathcal{Y}$ related to the strain field $\varepsilon$.

##### Energetic Degradation Function

A genetic expression for degradation function $\omega(d)$ is given as
\begin{equation}
\omega(d) = \frac{1}{1+\phi(d)} = \frac{(1-d)^p}{(1-d)^p + Q(d)},~~~~~~\phi(d) = \frac{Q(d)}{(1-d)^p}
\end{equation}
for $p>0$ and continuous function Q(d) > 0. Jian-Ying Wu considers following polynomials
\begin{equation}
Q(d) = a_1d + a_1a_2d^2 + a_1a_2a_3d^3 + ...
\end{equation}
where the coefficients $a_i$ are calibrated from standard material properties.

The energetic function recovers some particular examples used in the literature, such as $\omega(d) = (1-d)^2$ when $p=2$ and $Q(d) = 1 - (1-d)^p$.

##### Decomposition Approaches

The elastic energy is usually decomposed additively to distinguish between tensile and compressive contributions. Three decomposition approaches are implemented.

###### Strain Spectral Decomposition

The total strain energy density is defined as
\begin{equation}
\Psi = \omega(d) \Psi^{+} +\Psi^{-},
\end{equation}
where $\psi^{+}$ is the strain energy due to tensile stress, $\psi^{-}$ is the strain energy due to compressive stress.
\begin{equation}
\Psi^{\pm} = \lambda \left< \varepsilon_1 + \varepsilon_2 + \varepsilon_3 \right>^2_{\pm}/2 + \mu \left(\left< \varepsilon_1 \right>_{\pm}^2 + \left< \varepsilon_1 \right>_{\pm}^2 + \left< \varepsilon_1 \right>_{\pm}^2 \right),
\end{equation}
where $\epsilon_i$ is the $i$th eigenvalue of the strain tensor and $\left< \right>_{\pm}$ is an
operator that provides the positive or negative part.

To be thermodynamically consistent, the stress is related to the deformation energy density according
to
\begin{equation}
\boldsymbol{\sigma} = \frac{\partial \Psi}{\partial \boldsymbol{\varepsilon}}.
\end{equation}
Thus,
\begin{equation}
\boldsymbol{\sigma}^{\pm} = \frac{\partial \Psi^{\pm}}{\partial \boldsymbol{\varepsilon}} = \sum_{a=1}^3 \left( \lambda \left< \varepsilon_1 + \varepsilon_2 + \varepsilon_3 \right>_{\pm} + 2 \mu \left< \varepsilon_a \right>_{\pm} \right) \boldsymbol{n}_a \otimes \boldsymbol{n}_a,
\end{equation}
where $\boldsymbol{n}_a$ is the $a$th eigenvector.
The stress becomes
\begin{equation}
\boldsymbol{\sigma} = \left[(1-c)^2(1-k) + k \right] \boldsymbol{\sigma}^{+} - \boldsymbol{\sigma}^{-}.
\end{equation}

###### Strain Volumetric and Deviatoric Decomposition

The approach is based on the orthogonal decomposition of the linearized strain tensor in its spherical and deviatoric components:
\begin{equation}
\varepsilon = \varepsilon_S + \varepsilon_D,~~~~\varepsilon_D = \frac{1}{n}tr(\varepsilon)I,~~~~\varepsilon_D = \varepsilon - \frac{1}{n}tr(\varepsilon)I
\end{equation}
where $I$ denotes the n-dimensional identity tensor.

$\psi^{+}$ and $\psi^{-}$ is defined as
\begin{equation}
\psi^{+} = \frac{1}{2}\kappa\left<tr(\varepsilon)^2\right>_{+} + \mu\varepsilon_{D}\cdot\varepsilon_{D}
\end{equation}
\begin{equation}
\psi^{-} = \frac{1}{2}\kappa\left<tr(\varepsilon)^2\right>_{-}
\end{equation}

The stress is defined as
\begin{equation}
\boldsymbol{\sigma}^- = \kappa \left<tr(\varepsilon) \right>
\end{equation}
and
\begin{equation}
\boldsymbol{\sigma}^+ = \boldsymbol{\mathcal{C}}\varepsilon -\boldsymbol{\sigma}^-
\end{equation}

###### Stress Spectral Decomposition

$\psi^{+}$ and $\psi^{-}$ is defined as
\begin{equation}
\psi^{+} = \frac{1}{2} \boldsymbol{\sigma}^{+} : \boldsymbol{\varepsilon}
\end{equation}
\begin{equation}
\psi^{-} = \frac{1}{2} \boldsymbol{\sigma}^{-} : \boldsymbol{\varepsilon}.
\end{equation}

The compressive and tensile parts of the stress are computed from positive and negative projection tensors (computed from the spectral decomposition) according to
\begin{equation}
	\boldsymbol{\sigma}^+ = \mathbf{P}^+ \boldsymbol{\sigma}_0
\end{equation}
\begin{equation}
	\boldsymbol{\sigma}^- = \mathbf{P}^- \boldsymbol{\sigma}_0,
\end{equation}

To be thermodynamically consistent, the stress is related to the deformation energy density according
to
\begin{equation}
  \boldsymbol{\sigma} = \frac{\partial \psi_e}{\partial \boldsymbol{\varepsilon}} = \omega{d}\frac{\partial \psi^+}{\partial \boldsymbol{\varepsilon}} + \frac{\partial \psi^-}{\partial \boldsymbol{\varepsilon}}.
\end{equation}
Since
\begin{equation}
	\frac{\partial \psi^+}{\partial \boldsymbol{\varepsilon}} = \boldsymbol{\sigma}^+
\end{equation}
\begin{equation}
	\frac{\partial \psi^-}{\partial \boldsymbol{\varepsilon}} = \boldsymbol{\sigma}^-,
\end{equation}
then,
\begin{equation}
	\boldsymbol{\sigma} = \omega(d)\boldsymbol{\sigma}^+ + \boldsymbol{\sigma}^-
\end{equation}

The Jacobian matrix for the stress is
\begin{equation}
  \boldsymbol{\mathcal{J}} = \frac{\partial \boldsymbol{\sigma}}{\partial \boldsymbol{\varepsilon}} = \left((\omega(d) \boldsymbol{\mathcal{P}}^+ + \boldsymbol{\mathcal{P}}^- \right) \boldsymbol{\mathcal{C}},
\end{equation}
where $\boldsymbol{\mathcal{C}}$ is the elasticity tensor.


Note that stress spectral decomposition approach can be used for anisotropic elasticity tensor.

#### Evolution Equation (Allen-Cahn)

To avoid crack healing, a history variable $H$ is defined that is the maximum energy density over the
time interval $t=[0,t_0]$, where $t_0$ is the current time step, i.e.
\begin{equation}
H = \max_t (\Psi^{+})
\end{equation}

Now, the total free energy is redefined as:
\begin{equation}
\begin{aligned}
F =& \omega(d) H +\Psi^{-} + \frac{1}{c_0}(\frac{g_c}{l}\alpha(d) + l|\nabla d|^2) \\
  =& f_{elastic} + f_{fracture} + \frac{g_c l}{c_0} {|{\nabla d}|}^2
\end{aligned}
\end{equation}
with
\begin{equation}
f_{loc} = f_{elastic} + f_{fracture}
\end{equation}
and
\begin{equation}
f_{fracture} = \frac{1}{c_0}\frac{g_c}{l}\alpha(d),~~~~~f_{elastic} = \omega(d)H +\Psi^{-}.
\end{equation}

Its derivatives are
\begin{equation}
\begin{aligned}
\frac{\partial f_{elastic}}{\partial d} =& \omega'(d)H\\
\frac{\partial^2 f_{elastic}}{\partial d^2} =& \omega''(d)H \\
\frac{\partial f_{fracture}}{\partial d} =& \frac{1}{c_0}\frac{g_c}{l} \alpha'(d) \\
\frac{\partial^2 f_{fracture}}{\partial d^2} =& \frac{1}{c_0}\frac{g_c}{l} \alpha''(d).
\end{aligned}
\end{equation}

To further avoid crack phase-field going to negative, $H$ should overcome a barrier energy. The barrier energy $f_{barrier}$ is determined by
\begin{equation}
f_{barrier} = -\frac{f_{fracture}}{\omega(d)}~/text{at}~d=0
\end{equation}
and the $H$ is modified as
\begin{equation}
H = \max_t (\Psi^{+}, f_{barrier})
\end{equation}

The evolution equation for the damage parameter follows the Allen-Cahn equation
\begin{equation}
\dot{d} = -L \frac{\delta F}{\delta d} = -L \left( \frac{\partial f_{loc}}{\partial d} - \nabla \cdot \kappa \nabla d \right),
\end{equation}
where $L = (g_c \tilde\eta)^{-1}$ and $\kappa = 2g_cl/c_0$.The $\tilde\eta = \eta/g_c$ is scaled by the $g_c$ which is consistent with the definition given by Miehe at.al [!cite](Miehe2015).

This equation follows the standard Allen-Cahn and thus can be implemented in MOOSE using the standard
Allen-Cahn kernels, TimeDerivative, AllenCahn, and ACInterface. There is now an action that automatically generates these kernels:
NonconservedAction. See the +PhaseField module documentation+ for more information.

#### Pressure on the fracture surface

As suggested by [!cite](CHUKWUDOZIE2019957), the work of pressure forces acting along each side of the cracks that is added to the total free energy can be approximated by
\begin{equation}
\int_{\Gamma}p(\mathbf{u}\cdot \mathbf{n})ds \approx \int_{\Omega}p(\mathbf{u}\cdot\nabla d)
\end{equation}

Integration by parts yields
\begin{equation}
-\int_{\Omega}p(\mathbf{u}\cdot\nabla d) = \int_{\Omega}pd\nabla\cdot\mathbf{u}-\int_{\partial{\Omega}}pd(\mathbf{u}\cdot\mathbf{n})
\end{equation}

The boundary integral term can be neglected as in most applications $d=0$ on $\partial\Omega$. Some authors [!cite](Mikelic2019) have proposed to replace the indicator function $d$ with $d^2$ in the first term in order to make the functional convex. The indicator function is implemented as a generic material object that can be easily provided and modified in an input file.
The stress equilibrium and damage evolution equations are also modified to account for the pressure contribution.

#### PETSc SNES variational inequalities solver option

Alternatively, the damage irreversibility condition can be enforced by using PETSc's SNES variational inequalities (VI) solver. In order to use PETSc's VI solver, upper and lower bounds for damage variable should be provided. Specifically, [`ConstantBounds`](/ConstantBounds.md) can be used to set the upper bound to be 1. [`VariableOldValueBounds`](/VariableOldValueBounds.md) can be used to set the lower bound to be the old value. Note that in order for these bounds to have an effect, the user has to specify the
PETSc options `-snes_type vinewtonssls` or `-snes_type vinewtonrsls`.

#### Example Input File

         block=Materials/damage_stress

#### Example Input File with pressure

         block=Materials/damage_stress

				 block=Materials/pfbulkmat






### Compute Linear Elastic Stress


#### Description

This material, `ComputeLinearElasticStress` computes the elastic stress for a total and small strain formulation: this stress class is compatible with the [ComputeSmallStrain](/ComputeSmallStrain.md) type of strain calculators, including those for non-Cartesian coordinate systems.
This stress calculator class can be used with any coordinate system to calculate the elastic stress response for a small total formulation strain.

Elastic materials do not experience permanent deformation, and all elastic strain and elastic stress is recoverable. Elastic stress is related to elastic strain through the elasticity tensor
\begin{equation}
\sigma_{ij} = C_{ijkl} \epsilon_{kl}^{total}
\end{equation}
where $\boldsymbol{\epsilon}^{total}$ is the total strain formulation; this strain measure is also the sum of the mechanical elastic strain and any eigenstrains in the system.

#### Example Input File Syntax






### Compute Linear Viscoelastic Stress


#### Description

This computes the stress of a linear viscoelastic material using a total small strain approximation. The stress is calculated from the mechanical strain and the creep strain as:
\begin{equation}
\sigma_{ij} = C_{ijkl} \left( \epsilon^{mech}_{kl} - \epsilon^{creep}_{kl} \right)
\end{equation}

#### Example Input File Syntax


The mechanical strain must be computed with a [ComputeSmallStrain](/ComputeSmallStrain.md) material.


The creep strain itself is computed by a linear viscoelastic material such as a [GeneralizedKelvinVoigtModel](/GeneralizedKelvinVoigtModel.md) or a [GeneralizedMaxwellModel](/GeneralizedMaxwellModel.md) material. The elasticity tensor $C_{ijkl}$ is also provided by the same linear viscoelastic material.


For the creep strains to be updated properly, the simulation must also include a [LinearViscoelasticStressUpdate](/LinearViscoelasticStressUpdate.md) user object:






### ComputeMeanThermalExpansionFunctionEigenstrain


#### Description

This model computes the eigenstrain tensor resulting from isotropic thermal expansion where the
temperature-dependent thermal expansion is defined by a user-supplied function that describes the
mean thermal expansion coefficient $\bar{\alpha}$ as a function of temperature, $T$. This function is
defined relative to a reference temperature, $T_{ref}$, such that the total expansion at a given
temperature relative to the reference temperature is $\bar{\alpha}(T-T_{ref})$.  Following the
notation of [!cite](niffenegger2012proper), $\bar{\alpha}_{(T_{ref},T)}$ is defined as:

\begin{equation}
\bar{\alpha}_{(T_{ref},T)} = \frac{L_{(T)} - L_{(T_{ref})}}{L_{(T_{ref})}(T-T_{ref})}
\end{equation}
where $L_{T}$ is the length of a body at the current temperature, and $L_{T_{ref}}$ is the length of
that body at the reference temperature.

It is important to emphasize that this reference temperature is tied to the definition of the thermal
expansion function, and differs in general from the stress-free temperature for a specific
simulation.  For the general case where the stress-free temperature, $T_{sf}$, differs from the
reference temperature, the total thermal expansion eigenstrain is computed as:

\begin{equation}
\boldsymbol{\epsilon}^{th} = \frac{\bar{\alpha}_{(T_{ref},T)}(T-T_{ref}) - \bar{\alpha}_{(T_{ref},T_{sf})}(T_{sf}-T_{ref})}
{1 + \bar{\alpha}_{(T_{ref},T_{sf})}(T_{sf}-T_{ref})} \cdot \boldsymbol{I}
\end{equation}
where $T$ is the current temperature and $\boldsymbol{I}$ is the identity matrix.  Note that the
denominator in this equation is a correction to account for the ratio of $L_{(T_{sf})}$ to
$L_{(T_{ref})}$. As discussed in [!cite](niffenegger2012proper), that ratio is very close to 1, so it
is not strictly necessary to include that correction, but it is done here for completeness.

#### Example Input File Syntax

         block=Materials/thermal_expansion_strain1

The `eigenstrain_name` parameter value must also be set for the strain calculator, and an example
parameter setting is shown below:

         block=Physics/SolidMechanics/QuasiStatic







### ComputeMultipleInelasticCosseratStress


The `ComputeMultipleInelasticCosseratStress` performs the same functions as the [ComputeMultipleInelasticStress.md]
material, but additionally computes:

- the coupled Cosserat elastic stress $\boldsymbol{\sigma}_c$
- the derivative tensor of the coupled Cosserat elastic stress with regards to strain

These two terms are computed in the same way as [ComputeCosseratLinearElasticStress.md].
If finite strain rotations are considered, then the these two terms are further modified with the rotation increment $R$:

\boldsymbol{\sigma}_c := R \boldsymbol{\sigma}_c R^T

The derivative tensor of the coupled Cosserat elastic stress with regards to strain is rotated by the rotation increment.

This object is part of the Cosserat mechanics model. See the theory manual (at [solid_mechanics/doc/theory/cosserat.pdf](https://github.com/idaholab/moose/tree/next/modules/solid_mechanics/doc/theory/cosserat.pdf))
for more explanation.




### Compute Multiple Inelastic Stress


#### Description

`ComputeMultipleInelasticStress` computes the stress, the consistent tangent
operator (or an approximation), and a decomposition of the strain
into elastic and inelastic components for a series of different inelastic
material models (e.g. creep and plasticity) which inherit from `StressUpdateBase`.
By default finite strains are assumed.
The elastic strain is calculated by subtracting the computed inelastic strain
increment tensor from the mechanical strain increment tensor.
\begin{equation}
  \label{cmis_elastic_strain_definition}
  \Delta \boldsymbol{\epsilon}^{el} = \Delta \boldsymbol{\epsilon}^{mech} - \Delta \boldsymbol{\epsilon}^{inel}
\end{equation}
Mechanical strain, $\epsilon^{mech}$, is considered to be the sum of the elastic
and inelastic (e.g. plastic and creep) strains.

This class uses the finite incremental strain formulation as a default. Users may
elect to use a small incremental strain formulation and set
+`perform_finite_strain_rotations = false`+ if the simulation will only ever use
small strains.
This class is not intended for use with a total small linearize strain formulation.

`ComputeMultipleInelasticStress` is designed to be used in conjunction with a
separate model or set of models that computes the inelastic strain for a given
stress state. These inelastic models must derive from the `StressUpdateBase` class.
The Solid Mechanics module contains a wide variety of such models, including

- [LinearViscoelasticStressUpdate](/LinearViscoelasticStressUpdate.md)
- `MultiParameterPlasticityStressUpdate`
- [RadialReturnStressUpdate](/RadialReturnStressUpdate.md)

All of the inelastic material models that are compatible with
+`ComputeMultipleInelasticStress`+ follow the nomenclature convention of +`StressUpdate`+
as a suffix to the class name.

`ComputeMultipleInelasticStress` can accommodate as few as zero inelastic models (in which case the
algorithm from [ComputeFiniteStrainElasticStress](/ComputeFiniteStrainElasticStress.md)
is applied) to as many inelastic material models as is required by the physics.
If more than one inelastic material model is supplied to `ComputeMultipleInelasticStress`,
it is recommended that all of the inelastic models inherit from the same base class.


#### Multiple Inelastic Models

       id=fig:multiple_materials
       style=width:55%;margin-left:2%;float:right
       caption=The `ComputeMultipleInelasticStress` algorithm for calculating the
               strains and stresses for multiple inelastic material models.

The algorithm used to compute the stress for multiple inelastic models is shown
in [fig:multiple_materials].

When multiple inelastic models are given, `ComputeMultipleInelasticStress` iterates
over the specified inelastic models until the change in stress is within
a user-specified tolerance.

##### Inner Iteration over Inelastic Models

The inner iteration over the multiple inelastic material models is shown in the
green components in [fig:multiple_materials].

When each inelastic model is evaluated, a trial stress is computed using the
current elastic strain, which is the total mechanical strain minus the current
summation of inelastic strain for all inelastic models. This trial stress can be
expressed as
\begin{equation}
  \label{eqn:trial_stress}
  \sigma^{tr}_i = \begin{cases}
                    C_{ijkl} \cdot \left( \epsilon^{el}_{old} + \Delta \epsilon^{el}_i \right) & \text{if $C_{ijkl}$ is isotropic}  \\
                    \sigma_{old} + C_{ijkl} \cdot \left( \Delta \epsilon^{el}_i \right) & \text{if $C_{ijkl}$ is anisotropic}
                  \end{cases}
\end{equation}
where $C_{ijkl}$ is the elasticity tensor for the material.

The $i^{th}$ inelastic material model, represented by the blue element
[fig:multiple_materials], is then called. The inelastic material model calculates
the inelastic strain increment necessary to produce an admissible stress, as a
function of the trial stress. The total inelastic strain increment is updated
for each model's contribution. The details of this calculation vary by model
and can include the effects of plasticity or creep.

The elastic and inelastic strain increments,
stress, and, optionally, the consistent tangent operator are returned to
`ComputeMultipleInelasticStress` from the $i^{th}$ inelastic material model.

##### Outer Iteration over Stress Difference

After each inelastic model is called to compute an update to the stress tensor,
the minimum and maximum values of each component of the stress tensor, over the
course of those iterations, are stored to two tensors denoted as
$\boldsymbol{\sigma}_{max}$ and $\boldsymbol{\sigma}_{min}$, respectively. An
$L^2$ norm of the difference of these two tensors is then computed as
\begin{equation}
  \label{eqn:l2_norm_stress}
  L^2 \left(\Delta \boldsymbol{\sigma} \right) = \sqrt{\Delta \sigma_{ij} \Delta \sigma_{ij}}
    \text{, where } \Delta \boldsymbol{\sigma} = \boldsymbol{\sigma}_{max} - \boldsymbol{\sigma}_{min}
\end{equation}
The $L^2$ norm of the stress difference is compared to the absolute and relative
tolerances to determine if the solution from the combined inelastic material
models is converged
\begin{equation}
  \label{eqn:l2_norm_convergence}
  L^2 \left(\Delta \boldsymbol{\sigma} \right) < \text{absolute tolerance, or }
  \frac{L^2 \left(\Delta \boldsymbol{\sigma} \right)}{L^2 \left(\Delta \boldsymbol{\sigma}_o \right)} < \text{relative tolerance}
\end{equation}
where $L^2 \left(\Delta \sigma_o \right)$ is the $L^2$ norm from the very first
outer iteration over all of the inelastic material models.
The solution will not converge if the outer iteration loop, shown in the top half
of [fig:multiple_materials], exceeds the maximum number of iterations set by the
user.

##### Finalize Strains and the Jacobian Multiplier

Once convergence on the stress is obtained, the calculation of the inelastic
strains is finalized by applying a weighting factor, as shown in
[fig:multiple_materials]. This weighting factor has a default value of unity.

###### Jacobian Multiplier and the Consistent Tangent Operator

The Jacobian multiplier, which is used in the [StressDivergenceTensors](/StressDivergenceTensors.md)
kernel to condition the Jacobian calculation, must be calculated from the combination
of all the different inelastic material models. There are three options used to
calculate the combined Jacobian multiplier: Elastic, Partial, and Nonlinear, which
are set by the individual elastic material models.
\begin{equation}
  \label{eqn:combined_jacobian_mult}
  \boldsymbol{J}_m = \begin{cases}
                  \boldsymbol{C} & \text{Elastic option} \\
                  \boldsymbol{A}^{-1} \cdot \boldsymbol{C} \text{, where }
                      \boldsymbol{A} = \boldsymbol{I} + \sum_i \boldsymbol{H}^{cto}_i & \text{Partial option} \\
                  \prod_i \boldsymbol{H}^{cto}_i \cdot \boldsymbol{C}^{-1}  & \text{Nonlinear option}
                 \end{cases}
\end{equation}
where $\boldsymbol{J}_m$ is the Jacobian multiplier, $\boldsymbol{C}$ is the elasticity
tensor, $\boldsymbol{I}$ is the Rank-4 identity tensor, and $\boldsymbol{H}^{cto}$ is the
consistent tangent operator.

The consistent tangent operator, defined in [eqn:elastic_cto] provides the information
on how the stress changes with respect to changes in the displacement variables.
\begin{equation}
  \label{eqn:elastic_cto}
  \delta \sigma_{ij} = H_{ijkl} \delta \epsilon_{kl}
\end{equation}
where $\delta \epsilon_{kl}$ is an arbitrary change in the total strain
(which occurs because the displacements are changed) and $\delta \sigma_{ij}$
is the resulting change in the stress.
In a purely elastic situation $H_{ijkl} = C_{ijkl}$ (the elasticity tensor), but
the inelastic mapping of changes in the stress as a result of changes in the
displacement variables is more complicated.
In a plastic material model, the proposed values
of displacements for the current time step were used to calculate a trial
inadmissible stress, $\sigma_{trial}$, [eqn:trial_stress], that was brought back
to the yield surface through a radial return algorithm. A slight change in the
proposed displacement variables will produce a slightly different trial stress
and so on.
Other inelastic material models follow a similar pattern.

The user can chose to force all of the inelastic material models to use the elasticity
tensor as the consistent tangent operator by setting `tangent_operator = elastic`.
This setting will reduce the computational load of the inelastic material models
but may hamper the convergence of the simulation.
By default, the inelastic material models are allowed to compute the consistent
tangent operator implemented in each individual inelastic model with the
`tangent_operator = nonlinear` option.

###### Material Time Step Size Limitations

Prior to calculating the final strain values, the algorithm checks the size of
the current time step against any limitations on the size of the time step as
optionally defined by the inelastic material models.
As described in the Material Time Step Limiter section, the time step size
involves a post processor to ensure that the current time step size is reasonable
for each of the inelastic material models used in the simulation.

At the end of the algorithm, the final value of the elastic and inelastic
strain tensors are calculated as shown in the last element of [fig:multiple_materials].


#### Single Inelastic Model

`ComputeMultipleInelasticStress` can also be used to calculate the inelastic
strain and the stress when only a single inelastic material model is provided.

       id=fig:single_material
       style=width:40%;margin-right:2%;float:left
       caption=The optimized algorithm for calculating the strains and stress
               in the case when only a single inelastic material model is specified.

The algorithm, shown in [fig:single_material], used for a single inelastic material
model is an optimized version of the multiple materials algorithm.
With no need to iterate over multiple inelastic models, both the inner and outer
iterations from [fig:multiple_materials] are removed from the algorithm in [fig:single_material].

The initial elastic strain increment guess is assumed to be the initial mechanical
strain increment, and the trial stress for the single inelastic model is calculated
from that elastic strain increment as in [eqn:trial_stress].
These stress and strain values are passed directly to the inelastic material model.

The material model computes the admissible stress and strain states, as indicated
by the blue element in [fig:single_material]. An optional consistent tangent
operator matrix is also returned by the inelastic material model.
As in the multiple inelastic models algorithm, the user may force the use of the
Elastic option by setting `tangent_operator = elastic`.
By default, the inelastic material model is allowed to compute the consistent
tangent operator implemented in each individual inelastic model with the
`tangent_operator = nonlinear` option.

The consistent tangent operator is then used to find the Jacobian multiplier with
\begin{equation}
  \label{eqn:single_model_jacobian_mult}
  \boldsymbol{J}_m = \begin{cases}
                  \boldsymbol{C} & \text{Elastic option} \\
                  \left(\boldsymbol{I} + \boldsymbol{H}^{cto}\right)^{-1} \cdot \boldsymbol{C} & \text{Partial option} \\
                  \boldsymbol{H}^{cto}  & \text{Nonlinear option}
                 \end{cases}
\end{equation}
where $\boldsymbol{J}_m$ is the Jacobian multiplier, $\boldsymbol{C}$ is the elasticity
tensor, $\boldsymbol{I}$ is the Rank-4 identity tensor, and $\boldsymbol{H}^{cto}$ is the
consistent tangent operator, as discussed in the multiple inelastic material
models section.

The maximum size of the allowable time step is then optionally calculated by the
inelastic material model, as described in the section below on the Material Time
Step Limiter. At the conclusion of the algorithm, the value of the elastic and
inelastic strain states are updated as shown in [fig:single_material].

##### Cycle Through One Inelastic Model per Time Step

`ComputeMultipleInelasticStress` also includes an option to run a series of inelastic
models in a rotating fashion such that only a single inelastic model is run on a
timestep. This option uses the same algorithm as in [fig:single_material] to determine
the strains and stress value based on the rotated single inelastic model.
A separate method is then employed to propagate the strain and stress values to
the other inelastic material models for storage as old material property values.

#### Other Calculations Performed by `StressUpdate` Materials

The `ComputeMultipleInelasticStress` material relies on two helper calculations
to aid the simulation in converging.
These helper computations are defined within the specific inelastic models, and
only a brief overview is given here.
These methods are represented within the blue inelastic material model boxes in
[fig:multiple_materials] and [fig:single_material].
For specific details of the implementations, see the documentation pages for the
individual inelastic `StressUpdate` materials.

The first helper computation, the consistent tangent operator, is an optional
feature which is implemented for only certain inelastic
stress material models, and the material time step limiter is implemented in the
models which use the [Radial Return Stress Update](/RadialReturnStressUpdate.md)
algorithm.

##### Consistent Tangent Operator

The consistent tangent operator is used to improve the convergence of mechanics
problems (see a reference such as [!cite](simo1985cto) for an introduction to
consistent tangent operators).
The Jacobian matrix, [eqn:combined_jacobian_mult] and [eqn:single_model_jacobian_mult],
is used to capture how the change in the residual calculation changes with respect
to changes in the displacement variables.
To calculate the Jacobian, MOOSE relies on knowing how the stress changes with
respect to changes in the displacement variables.

Because the change of the stress with respect to the change in displacements is
material specific, the value of the consistent tangent operator
is computed in each inelastic material model. By default the consistent tangent
operator is set equal to the elasticity tensor (the option Elastic in
[eqn:combined_jacobian_mult] and [eqn:single_model_jacobian_mult]).
Inelastic material models which use either the Partial or Nonlinear options in
[eqn:combined_jacobian_mult] or [eqn:single_model_jacobian_mult] define a material
specific consistent tangent operator.

Generally Partial consistent tangent operators should be implemented for
non-yielding materials (e.g. volumetric swelling) and Full consistent tangent
operators should be implemented for yielding material models (e.g. plasticity).

##### Include Damage Model

Optionally, the effect of damage on the stress calculation can be included in
the model. Another material that defines the evolution of damage should be
coupled using parameter `damage_model`. Here, first the inelastic strains and
corresponding effective stresses are calculated based on the undamaged
properties. Afterwards, the damage index is applied on the effective stress to
calculate the damaged stress. This captures the effect of damage in a material
undergoing creep or plastic deformation.

##### Material Time Step Limiter

In some cases, particularly in creep, limits on the time step are required by
the material model formulation. Each inelastic material model is responsible for
calculating the maximum time step allowable for that material model. The
[MaterialTimeStepPostprocessor](/MaterialTimeStepPostprocessor.md) finds the
minimum time step size limits from the entire simulation domain. The
postprocessor then interfaces with the
[IterationAdaptiveDT](/IterationAdaptiveDT.md) to restrict the time step size
based on the limit calculated in the previous time step. When the damage model
is included, the timestep is limited by the minimum timestep between the
inelastic models and the damage model.


#### Example Input Files

The input settings for multiple inelastic material models and a single inelastic
model are similar, and examples of both are shown below.

##### Multiple Inelastic Models

For multiple inelastic models, all of the inelastic material
model names must be listed as arguments to the `inelastic_models` parameter.
The inelastic material blocks must also be present.


##### Single Inelastic Model

For a single inelastic material model the input syntax is simply condensed


and only a single inelastic material model is included in the input. This example
includes the `max_inelastic_increment` parameter which is used to limit the time
step size.






### Compute Plane Finite Strain



#### Description

The material `ComputePlaneFiniteStrain` calculates the finite strain for 2D
plane strain problems. It can be used for classical
[plane strain or plane stress](https://en.wikipedia.org/wiki/Plane_stress)
problems, or in
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md) simulations.

#### Out of Plane Strain

In the classical plane strain problem, it is assumed that the front and back
surfaces of the body are constrained in the out-of-plane direction, and that
the displacements in that direction on those surfaces are zero. As a 
result, the strain and deformation gradient components in the out-of-plane
direction are held constant at zero:
\begin{equation}
  \label{eqn:classical_dop_deform_grad}
  F|^{dop} = 0 \text{  and  } \epsilon|^{dop} = 0
\end{equation}
$F|^{dop}$ is the deformation gradient tensor diagonal component for the
direction of the out-of-plane strain and $\epsilon|^{dop}$ is the corresponding
strain component.

##### Plane Stress and Generalized Plane Strain

In the cases of the plane stress and generalized plane strain assumptions, the
component of strain and the deformation gradient in the out-of-plane direction
is non-zero. To solve for this out-of-plane strain, we invoke the approximation
of the stretch rate tensor
\begin{equation}
  \label{eqn:stretch_tensor_approx}
  \boldsymbol{D} = \log \left( \sqrt{\hat{\boldsymbol{F}}^T \cdot \hat{\boldsymbol{F}}} \right) \cdot \frac{1}{dt}
\end{equation}
and define the deformation gradient component in the out-of-plane direction as
\begin{equation}
  \label{eqn:dop_deform_grad}
  F|^{dop} = \exp \left( \epsilon|^{op} - 1.0  \right)
\end{equation}
where $F|^{dop}$ is the deformation gradient tensor diagonal component for the
direction of the out-of-plane strain and $\epsilon|^{op}$ is a prescribed
out-of-plane strain value: this strain value can be given either as a scalar
variable or a nonlinear field variable.

For the case of plane stress, the [WeakPlaneStress](WeakPlaneStress.md) kernel
is used to integrate the out-of-plane component of the stress over the area of
each element, and assemble that integral to the residual of the out-of-plane
strain field variable. This results in a weak enforcement of the condition that
the out-of-plane stress is zero, which allows for re-use of the same constitutive
models for models of all dimensionality.

The [Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
problems use scalar variables. Multiple scalar variables can be provided such
that one strain calculator is needed for multiple generalized plane strain
models on different subdomains.


#### Strain and Deformation Gradient Formulation

The incremental deformation gradient for the 2D planar system is defined as
\begin{equation}
  \label{eqn:incremental_deformation_grad}
  \hat{\boldsymbol{F}} = \boldsymbol{A} : \bar{\boldsymbol{F}}^{-1} + \boldsymbol{I}
\end{equation}
where $\boldsymbol{I}$ is the Rank-2 identity tensor, $\boldsymbol{A}$ is the deformation
gradient, and $\bar{\boldsymbol{F}}$ is the old deformation gradient.

###### $Z$-Direction of Out-of-Plane Strain (Default)

The default out-of-plane direction is along the $z$-axis. For this direction
the current and old deformation gradient tensors, used in
[eqn:incremental_deformation_grad], are given as
\begin{equation}
  \label{eqn:deform_grads}
  \boldsymbol{A} = \begin{bmatrix}
                u_{x,x} & u_{x,y} & 0 \\
                u_{y,x} & u_{y,y} & 0 \\
                0 & 0 & F|^{dop}
              \end{bmatrix} + \boldsymbol{I}
  \qquad \text{  and  } \qquad
  \bar{\boldsymbol{F}} = \begin{bmatrix}
                u_{x,x}|_{old} & u_{x,y}|_{old} & 0 \\
                u_{y,x}|_{old} & u_{y,y}|_{old} & 0 \\
                0 & 0 & F|^{dop}_{old}
              \end{bmatrix} + \boldsymbol{I}
\end{equation}
where $F|^{dop}$ is defined in [eqn:dop_deform_grad].
Note that $\bar{\boldsymbol{F}}$ uses the values of the strain expressions from
the previous time step.
As in the classical presentation of the strain tensor in plane strain problems,
the components of the deformation tensor associated with the $z$-direction are
zero; these zero components indicate no coupling between the in-plane displacements
and the out-of-plane strain variable.

###### $X$-Direction of Out-of-Plane Strain

If the user selects the out-of-plane direction as along the $x$-direction, the
current and old deformation gradient tensors from [eqn:incremental_deformation_grad]
are formulated as
\begin{equation}
  \label{eqn:deform_grads_xdirs}
  \boldsymbol{A} = \begin{bmatrix}
                F|^{dop} & 0 & 0 \\
                0 & u_{y,y} & u_{z,y} \\
                0 & u_{y,z} & u_{z,z}
              \end{bmatrix} + \boldsymbol{I}
  \qquad \text{  and  } \qquad
  \bar{\boldsymbol{F}} = \begin{bmatrix}
                F|^{dop}_{old} & 0 & 0 \\
                0 & u_{y,y}|_{old} & u_{y,z}|_{old} \\
                0 & u_{z,y}|_{old}& u_{z,z}|_{old}
              \end{bmatrix} + \boldsymbol{I}
\end{equation}
so that the off-diagonal components of the deformation tensors associated with
the $x$-direction are zeros.

###### $Y$-Direction of Out-of-Plane Strain

If the user selects the out-of-plane direction as along the $y$-direction, the
current and old deformation gradient tensors from [eqn:incremental_deformation_grad]
are formulated as
\begin{equation}
  \label{eqn:deform_grads_ydirs}
  \boldsymbol{A} = \begin{bmatrix}
                u_{x,x} & 0 & u_{z,x} \\
                0 & F|^{dop} & 0 \\
                u_{x,z} & 0 & u_{z,z}
              \end{bmatrix} + \boldsymbol{I}
  \qquad \text{  and  } \qquad
  \bar{\boldsymbol{F}} = \begin{bmatrix}
                u_{x,x}|_{old} & 0 & u_{x,z}|_{old} \\
                0 & F|^{dop}_{old} & 0 \\
                u_{z,x}|_{old} & 0 & u_{z,z}|_{old}
              \end{bmatrix} + \boldsymbol{I}
\end{equation}
so that the off-diagonal components of the deformation tensors associated with
the $y$-direction are zeros.


##### Finalized Deformation Gradient

If selected by the user, the incremental deformation gradient is conditioned with
a $\bar{B}$ formulation to mitigate volumetric locking of the elements.
The volumetric locking correction is applied to both the incremental deformation
gradient
\begin{equation}
  \label{eqn:vlc_fhat}
  \hat{\boldsymbol{F}}|_{vlc} = \left( \frac{1}{det(\hat{\boldsymbol{F}})} \frac{\hat{\boldsymbol{F}}_{avg}}{V_{elem}} \right)^{1/3}
\end{equation}
and the total deformation gradient. For more details about the theory behind
[eqn:vlc_fhat] see the
[Volumetric Locking Correction](/solid_mechanics/VolumetricLocking.md)
documentation.

Once the incremental deformation gradient is calculated for the specific 2D geometry,
the deformation gradient is passed to the strain and rotation methods used by the
3D Cartesian simulations, as described in the [Finite Strain Class](ComputeFiniteStrain.md)
documentation.

#### Example Input Files

##### Plane Stress

The solid mechanics [QuasiStatic Physics](/Physics/SolidMechanics/QuasiStatic/index.md)
can be used to create the `ComputePlaneFiniteStrain` class by setting
`planar_formulation = WEAK_PLANE_STRESS` and `strain = FINITE` in the
QuasiStatic Physics block.


Note that for plane stress analysis, the `out_of_plane_strain` parameter must be
defined, and is the name of the out-of-plane strain field variable.


In the case of this example, `out_of_plane_strain` is defined in the `GlobalParams` block.

##### Generalized Plane Strain

The use of this plane strain class for
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
simulations uses the scalar out-of-plane strains. The solid mechanics
[QuasiStatic Physics](/Physics/SolidMechanics/QuasiStatic/index.md) is used to create the
`ComputePlaneFiniteStrain` class with the `planar_formulation = GENERALIZED_PLANE_STRAIN`
and the `strain = FINITE` settings.


Note that the argument for the `scalar_out_of_plane_strain` parameter is the
name of the scalar strain variable






### Compute Plane Incremental Strain


#### Description

The material `ComputePlaneIncrementalStrain` calculates the small incremental
strain for 2D plane strain problems. It can be used for classical
[plane strain or plane stress](https://en.wikipedia.org/wiki/Plane_stress)
problems, or in
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md) simulations.

#### Out of Plane Strain

In the classical plane strain problem, it is assumed that the front and back
surfaces of the body are constrained in the out-of-plane direction, and that
the displacements in that direction on those surfaces are zero. As a 
result, the strain and deformation gradient components in the out-of-plane
direction are held constant at zero:
\begin{equation}
  \label{eqn:classical_dop_deform_grad}
  F|^{dop} = 0 \text{  and  } \epsilon|^{dop} = 0
\end{equation}
$F|^{dop}$ is the deformation gradient tensor diagonal component for the
direction of the out-of-plane strain and $\epsilon|^{dop}$ is the corresponding
strain component.

##### Generalized Plane Strain

In the cases of the generalized plane strain and weak plane stress models, the
component of strain and the deformation gradient in the out-of-plane direction
is non-zero. To solve for this out-of-plane strain, we use the out-of-plane
strain variable as the deformation gradient component
\begin{equation}
  \label{eqn:dop_deform_grad}
  F|^{dop} = \epsilon|^{op}
\end{equation}
where $F|^{dop}$ is the deformation gradient tensor diagonal component for the
direction of the out-of-plane strain and $\epsilon|^{op}$ is a prescribed
out-of-plane strain value: this strain value can be given either as a scalar
variable or a nonlinear field variable.
The [Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
problems use scalar variables. Multiple scalar variables can be provided such
that one strain calculator is needed for multiple generalized plane strain
models on different subdomains.

For the case of plane stress, the [WeakPlaneStress](WeakPlaneStress.md) kernel
is used to integrate the out-of-plane component of the stress over the area of
each element, and assemble that integral to the residual of the out-of-plane
strain field variable. This results in a weak enforcement of the condition that
the out-of-plane stress is zero, which allows for re-use of the same constitutive
models for models of all dimensionality.

#### Strain and Deformation Gradient Formulation

The small strain increment is calculated with the form
\begin{equation}
  \label{eqn:strain_increment}
  \Delta \boldsymbol{\epsilon} = \frac{1}{2} \left( \boldsymbol{D} + \boldsymbol{D}^T \right)
  \text{ where } \boldsymbol{D} = \boldsymbol{A} - \bar{\boldsymbol{F}} + \boldsymbol{I}
\end{equation}
where $\boldsymbol{I}$ is the Rank-2 identity tensor, $\boldsymbol{A}$ is the deformation
gradient, and $\bar{\boldsymbol{F}}$ is the old deformation gradient.

###### $Z$-Direction of Out-of-Plane Strain (Default)

The default out-of-plane direction is along the $z$-axis. For this direction
the current and old deformation gradient tensors, used in
[eqn:strain_increment], are given as
\begin{equation}
  \label{eqn:deform_grads}
  \boldsymbol{A} = \begin{bmatrix}
                u_{x,x} & u_{x,y} & 0 \\
                u_{y,x} & u_{y,y} & 0 \\
                0 & 0 & F|^{dop}
              \end{bmatrix} + \boldsymbol{I}
  \qquad \text{  and  } \qquad
  \bar{\boldsymbol{F}} = \begin{bmatrix}
                u_{x,x}|_{old} & u_{x,y}|_{old} & 0 \\
                u_{y,x}|_{old} & u_{y,y}|_{old} & 0 \\
                0 & 0 & F|^{dop}_{old}
              \end{bmatrix} + \boldsymbol{I}
\end{equation}
where $F|^{dop}$ is defined in [eqn:dop_deform_grad].
Note that $\bar{\boldsymbol{F}}$ uses the values of the strain expressions from
the previous time step.
As in the classical presentation of the strain tensor in plane strain problems,
the components of the deformation tensor associated with the $z$-direction are
zero; these zero components indicate no coupling between the in-plane displacements
and the out-of-plane strain variable.

###### $X$-Direction of Out-of-Plane Strain

If the user selects the out-of-plane direction as along the $x$-direction, the
current and old deformation gradient tensors from [eqn:strain_increment] are
formulated as
\begin{equation}
  \label{eqn:deform_grads_xdirs}
  \boldsymbol{A} = \begin{bmatrix}
                F|^{dop} & 0 & 0 \\
                0 & u_{y,y} & u_{z,y} \\
                0 & u_{y,z} & u_{z,z}
              \end{bmatrix} + \boldsymbol{I}
  \qquad \text{  and  } \qquad
  \bar{\boldsymbol{F}} = \begin{bmatrix}
                F|^{dop}_{old} & 0 & 0 \\
                0 & u_{y,y}|_{old} & u_{y,z}|_{old} \\
                0 & u_{z,y}|_{old}& u_{z,z}|_{old}
              \end{bmatrix} + \boldsymbol{I}
\end{equation}
so that the off-diagonal components of the deformation tensors associated with
the $x$-direction are zeros.

###### $Y$-Direction of Out-of-Plane Strain

If the user selects the out-of-plane direction as along the $y$-direction, the
current and old deformation gradient tensors from [eqn:strain_increment] are
formulated as
\begin{equation}
  \label{eqn:deform_grads_ydirs}
  \boldsymbol{A} = \begin{bmatrix}
                u_{x,x} & 0 & u_{z,x} \\
                0 & F|^{dop} & 0 \\
                u_{x,z} & 0 & u_{z,z}
              \end{bmatrix} + \boldsymbol{I}
  \qquad \text{  and  } \qquad
  \bar{\boldsymbol{F}} = \begin{bmatrix}
                u_{x,x}|_{old} & 0 & u_{x,z}|_{old} \\
                0 & F|^{dop}_{old} & 0 \\
                u_{z,x}|_{old} & 0 & u_{z,z}|_{old}
              \end{bmatrix} + \boldsymbol{I}
\end{equation}
so that the off-diagonal components of the deformation tensors associated with
the $y$-direction are zeros.

##### Finalized Deformation Gradient

Once the incremental deformation gradient is calculated for the specific 2D geometry,
the deformation gradient is passed to the strain and rotation methods used by the
3D Cartesian simulations, as described in the
[Compute Incremental Small Strain](ComputeIncrementalStrain.md) documentation.

If selected by the user, the incremental strain tensor is conditioned with
a $\bar{B}$ formulation to mitigate volumetric locking of the elements.
The volumetric locking correction is applied to the total strain
\begin{equation}
  \label{eqn:vlc_strain}
  \Delta \boldsymbol{\epsilon}|_{vlc} = \boldsymbol{\epsilon} + \frac{\left( \boldsymbol{\epsilon}_V - tr(\boldsymbol{\Delta \epsilon}) \right)}{3} \cdot \boldsymbol{I}
\end{equation}
where $\boldsymbol{\epsilon}_V$ is the volumetric strain and $\boldsymbol{I}$
is the Rank-2 identity tensor. For more details about the theory
behind [eqn:vlc_strain] see the
[Volumetric Locking Correction](/solid_mechanics/VolumetricLocking.md)
documentation.

#### Example Input Files

##### Plane Stress

The solid mechanics [QuasiStatic Physics](/Physics/SolidMechanics/QuasiStatic/index.md)
can be used to create the `ComputePlaneIncrementalStrain` class by setting
`planar_formulation = WEAK_PLANE_STRESS`, `strain = SMALL`, and `incremental = true` in the
QuasiStatic Physics block.


Note that for plane stress analysis, the `out_of_plane_strain` parameter must be
defined, and is the name of the out-of-plane strain field variable.


In the case of this example, `out_of_plane_strain` is defined in the `GlobalParams` block.

##### Generalized Plane Strain

The use of this plane strain class for
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
simulations uses the scalar out-of-plane strains. The solid mechanics
[QuasiStatic Physics](/Physics/SolidMechanics/QuasiStatic/index.md) is used to create the
`ComputePlaneIncrementalStrain` class with the `planar_formulation = GENERALIZED_PLANE_STRAIN`,
`strain = SMALL`, and `incremental = true` settings.


Note that the argument for the `scalar_out_of_plane_strain` parameter is the
name of the scalar strain variable







### Compute Plane Small Strain


#### Description

The material `ComputePlaneSmallStrain` calculates the small total
strain for 2D plane strain problems. It can be used for classical
[plane strain or plane stress](https://en.wikipedia.org/wiki/Plane_stress)
problems, or in
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md) simulations.

#### Out of Plane Strain

In the classical plane strain problem, it is assumed that the front and back
surfaces of the body are constrained in the out-of-plane direction, and that
the displacements in that direction on those surfaces are zero. As a
result, the strain and deformation gradient components in the out-of-plane
direction are held constant at zero:
\begin{equation}
  \label{eqn:classical_dop_deform_grad}
  \epsilon|^{dop} = 0
\end{equation}
$\epsilon|^{dop}$ is the strain tensor diagonal component for the
direction of the out-of-plane strain.

##### Plane Stress and Generalized Plane Strain

In the cases of the plane stress and generalized plane strain assumptions, the
component of strain and the deformation gradient in the out-of-plane direction
is non-zero. To solve for this out-of-plane strain, we use the out-of-plane
strain variable as the strain tensor component
\begin{equation}
  \label{eqn:dop_deform_grad}
  \epsilon|^{dop} = \epsilon|^{op}
\end{equation}
where $\epsilon|^{dop}$ is the strain tensor diagonal component for
the direction of the out-of-plane strain and $\epsilon|^{op}$ is a
prescribed out-of-plane strain value: this strain value can be
given either as a scalar variable or a nonlinear field variable.
The [Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
problems use scalar variables. Multiple scalar variables can be provided such
that one strain calculator is needed for multiple generalized plane strain
models on different subdomains.

For the case of plane stress, the [WeakPlaneStress](WeakPlaneStress.md) kernel
is used to integrate the out-of-plane component of the stress over the area of
each element, and assemble that integral to the residual of the out-of-plane
strain field variable. This results in a weak enforcement of the condition that
the out-of-plane stress is zero, which allows for re-use of the same constitutive
models for models of all dimensionality.

#### Strain and Deformation Gradient Formulation

The definition of a small total linearized strain is
\begin{equation}
  \label{eqn:def_small_total_strain}
  \epsilon_{ij} = \frac{1}{2} \left( u_{i,j} + u_{j,i}  \right)
\end{equation}
The values of each of the strain tensor components depends on the direction
selected by the user as the out-of-plane direction.

###### $Z$-Direction of Out-of-Plane Strain (Default)

The default out-of-plane direction is along the $z$-axis. For this direction
the strain tensor, [eqn:def_small_total_strain], is given as
\begin{equation}
  \label{eqn:strain_tensor}
  \boldsymbol{\epsilon} = \begin{bmatrix}
                u_{x,x} & \frac{1}{2} \left(u_{x,y} + u_{y,x} \right) & 0 \\
                \frac{1}{2} \left(u_{x,y} + u_{y,x} \right) & u_{y,y} & 0 \\
                0 & 0 & \epsilon|^{dop}
              \end{bmatrix}
\end{equation}
where $\epsilon|^{dop}$ is defined in [eqn:dop_deform_grad].
As in the classical presentation of the strain tensor in plane
strain problems, the components of the strain tensor associated
with the $z$-direction are zero; these zero components indicate no
coupling between the in-plane and the out-of-plane strains.

###### $X$-Direction of Out-of-Plane Strain

If the user selects the out-of-plane direction as along the
$x$-direction, the strain tensor from [eqn:def_small_total_strain]
is given as
\begin{equation}
  \label{eqn:deform_grads_xdirs}
  \boldsymbol{\epsilon} = \begin{bmatrix}
                \epsilon|^{dop} & 0 & 0 \\
                0 & u_{y,y} & \frac{1}{2} \left(u_{y,z} + u_{z,y} \right) \\
                0 & \frac{1}{2} \left(u_{y,z} + u_{z,y} \right) & u_{z,z}
              \end{bmatrix}
\end{equation}
so that the off-diagonal components of the strain tensor associated
with the $x$-direction are zeros.

###### $Y$-Direction of Out-of-Plane Strain

If the user selects the out-of-plane direction as along the
$y$-direction, the strain tensor from [eqn:def_small_total_strain]
is given as
\begin{equation}
  \label{eqn:deform_grads_ydirs}
  \boldsymbol{\epsilon} = \begin{bmatrix}
                u_{x,x} & 0 & \frac{1}{2} \left(u_{x,z} + u_{z,x} \right) \\
                0 & \epsilon|^{dop} & 0 \\
                \frac{1}{2} \left(u_{x,z} + u_{z,x} \right) & 0 & u_{z,z}
              \end{bmatrix}
\end{equation}
so that the off-diagonal components of the strain tensor associated
with the $y$-direction are zeros.

##### Volumetric Locking Correction for Strain Tensor

If selected by the user, the strain tensor is conditioned with
a $\bar{B}$ formulation to mitigate volumetric locking of the elements.
The volumetric locking correction is applied to the total strain
\begin{equation}
  \label{eqn:vlc_strain}
  \boldsymbol{\epsilon}|_{vlc} = \boldsymbol{\epsilon} + \frac{\left( \boldsymbol{\epsilon}_V - tr(\boldsymbol{\epsilon}) \right)}{3} \cdot \boldsymbol{I}
\end{equation}
where $\boldsymbol{\epsilon}_V$ is the volumetric strain and $\boldsymbol{I}$
is the Rank-2 identity tensor. For more details about the theory
behind [eqn:vlc_strain] see the
[Volumetric Locking Correction](/solid_mechanics/VolumetricLocking.md)
documentation.

#### Example Input Files

##### Plane Stress

The solid mechanics [QuasiStatic Physics](/Physics/SolidMechanics/QuasiStatic/index.md)
can be used to create the `ComputePlaneSmallStrain` class by setting
`planar_formulation = WEAK_PLANE_STRESS` and `strain = SMALL` in the
QuasiStatic Physics block.


Note that for plane stress analysis, the `out_of_plane_strain` parameter must be
defined, and is the name of the out-of-plane strain field variable.


In the case of this example, `out_of_plane_strain` is defined in the `GlobalParams` block.

##### Generalized Plane Strain

The use of this plane strain class for
[Generalized Plane Strain](solid_mechanics/generalized_plane_strain.md)
simulations uses the scalar out-of-plane strains. The solid mechanics
[QuasiStatic Physics](/Physics/SolidMechanics/QuasiStatic/index.md) is used to create the
`ComputePlaneSmallStrain` class with the `planar_formulation = GENERALIZED_PLANE_STRAIN`
and `strain = SMALL` settings.


Note that the argument for the `scalar_out_of_plane_strain` parameter is the
name of the scalar strain variable


##### $Y$-Direction of Out-of-Plane Strain

This plane strain class is used to model plane strain with an out-of-plane strain
in directions other than in the $z$-direction. As an example, the solid mechanics
[QuasiStatic Physics](/Physics/SolidMechanics/QuasiStatic/index.md) can be used to create
the `ComputePlaneFiniteStrain` class for a $y$-direction out-of-plane strain with
the `planar_formulation = PLANE_STRAIN` and the `out_of_plane_direction = y`
settings.






### ComputePlasticHeatEnergy


The `ComputePlasticHeatEnergy` computes the energy dissipated through heat during plastic deformation.
The plastic heat energy $P$ is:

P = \boldsymbol{\sigma}::(\boldsymbol{\epsilon}_p - \boldsymbol{\epsilon}_{p,old}) / dt

where:

- $P$ is the plastic heat energy
- $\boldsymbol{\sigma}$ is the stress tensor
- $\boldsymbol{\epsilon}_p$ is the plastic strain tensor
- $\boldsymbol{\epsilon}_{p,old}$ is the plastic strain tensor at the previous time step
- $dt$ is the time step

The derivatives of the plastic heat energy with regards to the strain is computed by differentiating
the equation above.

The derivatives of the plastic heat energy are only computed during the computation of the Jacobian,
as an optimization.

The computation of the plastic heat energy assumes a first order Euler time integration scheme.




### Compute Reduced Order Eigenstrain


#### Description

Since strain is a function of the derivative of displacements, the strain field is one order lower than the displacement field.  If the element is linear, the strain field will be constant; if the element is quadratic, the strain field will be linear.

This being the case, eigenstrains that affect the strain need to be of the same order as the strain.  A thermal strain taken from temperatures at nodes will vary according to the order of the temperature and not the strain field.  Using a thermal strain one order higher than the strain field can lead to oscillations in the overall strain and stress.

This class accepts eigenstrains and computes a reduced order eigenstrain.  If the primary solution variable field is linear, the resulting eigenstrain will be constant in an element using volume weighting.  If the primary solution variable field is quadratic, the resulting eigenstrain will be linear in an element using a least squares procedure.

[`ComputeReducedOrderEigenstrain`](ComputeReducedOrderEigenstrain.md) object for
RankTwoTensor eigenstrains with the
[QuasiStaticSolidMechanicsPhysics](SolidMechanics/QuasiStatic/index.md) setting
`automatic_eigenstrain_names = true`, eigenstrains listed as MaterialADConverter
input  tensors will not be included in the `eigenstrain_names` list passed. Set
the automatic/_eigenstrain/_names = false and populate this list manually if
these components need to be included.

#### Example Input File syntax


The `eigenstrain_name` parameter value must also be set for the strain calculator, and an example parameter setting is shown below:





### Compute R-Spherical Finite Strain


#### Description

The material `ComputeRSphericalFiniteStrain` calculates the small incremental strain for 1D
R-Spherical systems.

The 1D RSpherical materials and kernel are designed to model sphere geometries with 1D models.
Symmetry in the polar ($\theta$) and azimuthal ($\phi$) directions is assumed, and the model is
considered to revolve in both of these directions.  In the 1D R-Spherical code, the material
properties, variables (e.g. temperature), and loading conditions are all assumed to be spherically
symmetric: these attributes only depend on the axial position.

The `COORD_TYPE` in the Problem block of the input file must be set to RSPHERICAL.

As in the plane strain and axisymmetric cases, the stress and strain tensors are modified in the
spherical problem; only the diagonal components are non-zero in this 1D problem.
\begin{equation}
\begin{bmatrix}
\epsilon_{rr} & 0 & 0 \\
0 & \epsilon_{\theta \theta} & 0 \\
0 & 0 & \epsilon_{\phi \phi}
\end{bmatrix}
\end{equation}
where the value of the normal strain components in the polar and azimuth directions $\epsilon_{\theta
\theta}$ and $\epsilon_{\phi \phi}$ depends on the displacement and position in the radial direction
\begin{equation}
  \label{eq:polar_azimuthal_rspherical_strains}
  \epsilon_{\theta \theta} = \epsilon_{\phi \phi} = \frac{u_r}{X_r}.
\end{equation}
Although axisymmetric problems solve for 3D stress and strain fields, the problem is mathematically
1D.  In the cylindrical coordinate axisymmetric system, the values of stress and strain in the
$\theta$ and $\phi$ directions do not depend on the $\theta$ or $\phi$ coordinates.

Once the deformation gradient is calculated for the 1D geometry, the deformation gradient is passed
to the strain and rotation methods used by default 3D Cartesian simulations, as described in the
[Finite Strain Class](ComputeFiniteStrain.md) page.

#### Example Input File Syntax

The finite incremental R-spherical strain calculator can be activated in the input file through the
use of the Solid Mechanics Physics, as shown below.

         block=Physics/SolidMechanics/QuasiStatic

The [Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md) is designed to
automatically determine and set the strain and stress divergence parameters correctly for the
selected strain formulation.  We recommend that users employ the
[Solid Mechanics Physics](syntax/Physics/SolidMechanics/QuasiStatic/index.md) whenever possible
to ensure consistency between the test function gradients and the strain formulation selected.




### Compute R-Spherical Incremental Strain


#### Description

The material `ComputeRSphericalIncrementalStrain` calculates the small incremental strain for 1D
R-Spherical systems.

The 1D RSpherical materials and kernel are designed to model sphere geometries with 1D models.
Symmetry in the polar ($\theta$) and azimuthal ($\phi$) directions is assumed, and the model is
considered to revolve in both of these directions.  In the 1D R-Spherical code, the material
properties, variables (e.g. temperature), and loading conditions are all assumed to be spherically
symmetric: these attributes only depend on the axial position.

The `COORD_TYPE` in the Problem block of the input file must be set to RSPHERICAL.

As in the plane strain and axisymmetric cases, the stress and strain tensors are modified in the
spherical problem; only the diagonal components are non-zero in this 1D problem.
\begin{equation}
\begin{bmatrix}
\epsilon_{rr} & 0 & 0 \\
0 & \epsilon_{\theta \theta} & 0 \\
0 & 0 & \epsilon_{\phi \phi}
\end{bmatrix}
\end{equation}
where the value of the normal strain components in the polar and azimuth directions $\epsilon_{\theta
\theta}$ and $\epsilon_{\phi \phi}$ depends on the displacement and position in the radial direction
\begin{equation}
  \label{eq:polar_azimuthal_rspherical_strains}
  \epsilon_{\theta \theta} = \epsilon_{\phi \phi} = \frac{u_r}{X_r}.
\end{equation}
Although axisymmetric problems solve for 3D stress and strain fields, the problem is mathematically
1D.  In the cylindrical coordinate axisymmetric system, the values of stress and strain in the
$\theta$ and $\phi$ directions do not depend on the $\theta$ or $\phi$ coordinates.

The RSpherical specific `ComputeRSphericalIncrementalStrain` class calculates the radial strain as
normally done for an incremental small total strain material:
\begin{equation}
  \epsilon_{rr} = \frac{1}{2} \left( \nabla u_r + u_r \nabla \right)
\end{equation}
while the calculation of the total strain components $\epsilon_{\theta \theta}$ and $\epsilon_{\phi
\phi}$ are found with [eq:polar_azimuthal_rspherical_strains].

#### Example Input File Syntax

The incremental small R-spherical strain calculator can be activated in the input file through the
use of the Solid Mechanics Physics.

The [Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md) is designed to
automatically determine and set the strain and stress divergence parameters correctly for the
selected strain formulation.  We recommend that users employ the
[Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md) whenever possible
to ensure consistency between the test function gradients and the strain formulation selected.




### Compute R-Spherical Small Strain


#### Description

The material `ComputeRSphericalSmallStrain` calculates the small total strain for 1D R-Spherical
systems.

The 1D RSpherical materials and kernel are designed to model sphere geometries with 1D models.
Symmetry in the polar ($\theta$) and azimuthal ($\phi$) directions is assumed, and the model is
considered to revolve in both of these directions.  In the 1D R-Spherical code, the material
properties, variables (e.g. temperature), and loading conditions are all assumed to be spherically
symmetric: these attributes only depend on the axial position.

The `COORD_TYPE` in the Problem block of the input file must be set to RSPHERICAL.

As in the plane strain and axisymmetric cases, the stress and strain tensors are modified in the
spherical problem; only the diagonal components are non-zero in this 1D problem.
\begin{equation}
\begin{bmatrix}
\epsilon_{rr} & 0 & 0 \\
0 & \epsilon_{\theta \theta} & 0 \\
0 & 0 & \epsilon_{\phi \phi}
\end{bmatrix}
\end{equation}
where the value of the normal strain components in the polar and azimuth directions $\epsilon_{\theta
\theta}$ and $\epsilon_{\phi \phi}$ depends on the displacement and position in the radial direction
\begin{equation}
  \label{eq:polar_azimuthal_rspherical_strains}
  \epsilon_{\theta \theta} = \epsilon_{\phi \phi} = \frac{u_r}{X_r}.
\end{equation}
Although axisymmetric problems solve for 3D stress and strain fields, the problem is mathematically 1D.
In the cylindrical coordinate axisymmetric system, the values of stress and strain in the $\theta$
and $\phi$ directions do not depend on the $\theta$ or $\phi$ coordinates.

The RSpherical specific `ComputeRSphericalSmallStrain` class calculates the radial strain as normally
done for a small total strain material:
\begin{equation}
  \epsilon_{rr} = \nabla u_r
\end{equation}
while the calculation of the total strain components $\epsilon_{\theta \theta}$ and $\epsilon_{\phi
\phi}$ are found with [eq:polar_azimuthal_rspherical_strains].

#### Example Input File Syntax

The small R-spherical strain calculator can be activated in the input file through the use of the
Solid Mechanics Physics, as shown below.

         block=Physics/SolidMechanics/QuasiStatic

The [Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md) is designed to
automatically determine and set the strain and stress divergence parameters correctly for the
selected strain formulation.  We recommend that users employ the
[Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md) whenever possible
to ensure consistency between the test function gradients and the strain formulation selected.




### Compute Small Strain


#### Description

The material `ComputeSmallStrain` is designed for linear elasticity problems, which calculates the
small, total strain.  This material is useful for verifying material models with hand calculations
because of the simplified strain calculations.

Linearized small strain theory assumes that the gradient of displacement with respect to position is
much smaller than unity, and the squared displacement gradient term is neglected in the small strain
definition to give:
\begin{equation}
\epsilon = \frac{1}{2} \left( u \nabla + \nabla u \right) \quad when \quad \frac{\partial u}{ \partial x} << 1
\end{equation}
For more details on the linearized small strain assumption and derivation, see a Continuum Mechanics text such as [!cite](malvern1969introduction) or [!cite](bower2009applied), specifically [Chapter 2](http://solidmechanics.org/Text/Chapter2_1/Chapter2_1.php#Sect2_1_7).

Total strain theories are path independent: in MOOSE, path independence means that the total strain,
from the beginning of the entire simulation, is used to calculate stress and other material
properties.  Incremental theories, on the other hand, use the increment of strain at timestep to
calculate stress.  Because the total strain formulation `ComputeSmallStrain` is path independent, no
old values of strain or stress from the previous timestep are stored in MOOSE.
For a comparison of total strain vs incremental strain theories with experimental data, see [!cite](shammamy1967incremental).

#### Example Input File Syntax

The small strain calculator can be activated in the input file through the use of the SolidMechanics
QuasiStatic Physics, as shown below.


The [Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md) is designed to
automatically determine and set the strain and stress divergence parameters correctly for the
selected strain formulation.  We recommend that users employ the
[Solid Mechanics Physics](/Physics/SolidMechanics/QuasiStatic/index.md) whenever possible
to ensure consistency between the test function gradients and the strain formulation selected.

Although not recommended, it is possible to directly use the `ComputeSmallStrain` material in an
input file.

         block=Materials/strain





### Compute Smeared Cracking Stress


#### Description

This class implements a fixed smeared cracking model, which represents cracking
as a softening stress-strain law at the material points as opposed to introducing
topographic changes to the mesh, as would be the case with a discrete cracking model.

In this model, principal stresses are compared to a critical stress.  If one of
the principal stresses exceeds the critical stress, the material point is considered
cracked in that direction, and the model transitions to an orthotropic model, in
which the stress in the cracked direction is decreased according to a softening
law. Material behavior in the cracking direction is affected in two ways: reduction
of the stiffness in that direction, and adjusting the stress to follow the softening
curve.

##### Interaction with Inelastic Models

This class derives from [ComputeMultipleInelasticStrain](ComputeMultipleInelasticStress.md),
and prior to cracking, allows multiple inelastic models to be active. Once cracking
occurs, the inelastic strains at that material point are preserved, but those models
are no longer called for the duration of the simulation, and inelastic strains from
those other models are no longer permitted to evolve.

##### Cracking Direction Determination

The orientation of the principal coordinate system is determined from the eigenvectors
of the elastic strain tensor.  However, once a crack direction is determined, that
direction remains fixed and further cracks are considered in directions perpendicular
to the original crack direction.  Note that for axisymmetric problems, one crack
direction is known *a priori*.  The theta or out-of-plane direction is not coupled
to the $r$ and $z$ directions (i.e., no $r\theta$ or $z\theta$ shear strain/stress
exists) and is therefore a known or principal direction.

If we store a scalar value, $c_i$, for each of the three possible crack directions
at a material point, these in combination with the principal directions (eigenvectors
or rotation tensor) provide a convenient way to eliminate stress in cracked directions.
A value of 1 for $c_i$ indicates that the material point has not cracked in that
direction.  A value very close to zero (not zero for numerical reasons) indicates
that cracking has occurred.

We define a cracking tensor in the cracked orientation as $\boldsymbol{c}$:
\begin{equation}
\boldsymbol{c}=
\begin{bmatrix}
c_1 & & \\
& c_2 & \\
& & c_3
\end{bmatrix}.
\end{equation}
The rotation tensor $\boldsymbol{R}$ is defined in terms of the eigenvectors $e_i$:
\begin{equation}
\boldsymbol{R}=
\begin{bmatrix}
e_1 & e_2 & & e_3
\end{bmatrix}.
\end{equation}
This leads to a transformation operator $\boldsymbol{T}$:
\begin{equation}
\boldsymbol{T}=\boldsymbol{R}\boldsymbol{c}\boldsymbol{R}^T.
\end{equation}

$\boldsymbol{T}$ is useful for transforming uncracked tensors in the global frame
to cracked tensors in the same frame.  For example, the cracked stress
$\boldsymbol{\sigma}_{cg}$ in terms of the stress $\boldsymbol{\sigma}_g$ is
(subscript $c$ indicates cracked, $l$ local frame, and $g$ global frame):
\begin{equation}
\begin{aligned}
\boldsymbol{\sigma}_{cg} & = \boldsymbol{T}\boldsymbol{\sigma}_g\boldsymbol{T}^T \\
                         & = \boldsymbol{RcR}^T\boldsymbol{\sigma}_g\boldsymbol{RcR}^T \\
                         & = \boldsymbol{Rc}\boldsymbol{\sigma}_l\boldsymbol{cR}^T \\
                         & = \boldsymbol{R}\boldsymbol{\sigma}_{cl}\boldsymbol{R}^T.
\end{aligned}
\end{equation}

There are two options on how the elasticity tensor is modified to account for the
effects of cracking, controlled by the `cracked_elasticity_type` parameter. If 
that parameter is set to `DIAGONAL`, when a crack forms in a given direction the
diagonal entry in the local tensor is set to the product of the Young's modulus
and $c_i$ for that direction, and the off-diagonal coupling terms that define the
interaction between that and the other directions are set to 0. This was historically
the way this was handled, but is somewhat problematic because upon cracking the 
transverse stress due to Poisson's affect is abruptly removed. Alternatively,
the `FULL` option scales down the existing on- and off-diagonal entries in the
elasticity tensor by $c_i$, which scales down the transverse stresses at the same
rate as stresses in the crack opening direction, resulting in smoother behavior.

When many material points have multiple cracks, the solution becomes difficult to
obtain numerically.  For this reason, controls are available to limit the number
and direction of cracks that are allowed. Also, there are options to control the
amount of shear retention and amount of stress correction during softening, both
of which can significantly affect convergence.

#### Example Input File Syntax





### Compute Strain Increment Based Stress


#### Description

This stress calculator finds the value of the stress as a function of the elastic
strain increment when a series of inelastic strains are specified in the input file.
The stress is calculated as
\begin{equation}
  \label{eqn:stress}
  \sigma_{ij} = \sigma_{ij}^{old} + C_{ijkl} \Delta \epsilon_{jk}^{el}
\end{equation}
where $\sigma_{ij}$ is the stress and $C_{ijkl}$ is the elasticity tensor of the
material.
The elastic strain increment, $\Delta \epsilon_{jk}^{el}$ is found by subtracting
the sum of the inelastic strains from the mechanical strain:
\begin{equation}
  \label{eqn:elastic_strain_incr}
  \Delta \boldsymbol{\epsilon}^{el} = \boldsymbol{\epsilon}^{mech} - \boldsymbol{\epsilon}^{mech-old}
      - \sum_n \left( \boldsymbol{\epsilon}^{inel}_n - {\boldsymbol{\epsilon}^{inel-old}}_n \right)
\end{equation}
where $\boldsymbol{\epsilon}^{mech}$ is the mechanical strain and
$\boldsymbol{\epsilon}^{inel}$ is the inelastic strain.
In the solid mechanics module mechanical strain is defined as the sum of the
elastic and inelastic (e.g. creep and/or plasticity) strains.

#### Example Input File






### Compute Surface Tension KKS


#### Description

This material generates a surface tension tensor in the interface between two phases
in the Kim-Kim-Suzuki (KKS) phase-field model ([!cite](kim_phase-field_1999)).
The surface tension consists of two orthogonal principal components lying in plane
of the interface. The approach is based on the formulation described in [!cite](Levitas2011).
(For solid surfaces where the surface stress is to be specified rather than surface tension,
  use the [ComputeInterfaceStress](ComputeInterfaceStress.md) kernel instead.)

The surface tension tensor $\mathbf{\sigma}_{st}$ is given by
\begin{equation}
\mathbf{\sigma}_{st} = \left[W g(\eta) + \frac \kappa 2 |\nabla \eta|^2 \right]
\bf{I} - \kappa \nabla \eta \otimes \nabla \eta
\end{equation}
where $W$ is the free energy barrier between phases, $g(\eta)$ is the double-well
function, $\eta$ is the order parameter, $\kappa$ is the gradient energy
coefficient, $\bf{I}$ is the identity tensor, and $\otimes$ denotes the dyadic product.

#### Example Input File Syntax






### Compute Thermal Expansion Eigenstrain


#### Description

This model computes the eigenstrain tensor resulting from isotropic thermal
expansion where the constant thermal expansion is defined by a user-supplied
scalar linear thermal-expansion coefficient, $\alpha$. The thermal expansion
eigenstrain is then computed as

\begin{equation}
\boldsymbol{\epsilon}^{thermal} = \alpha \cdot \left( T - T_{stress\_free} \right) \boldsymbol{I}
\end{equation}

where $T$ is the current temperature, $T_{stress\_free}$ is the stress free
temperature, and $\boldsymbol{I}$ is the identity matrix.

An automatic differentiation version of this object is available as `ADComputeThermalExpansionEigenstrain`.

#### Example Input File Syntax


The `eigenstrain_names` parameter value must also be set for the strain calculator, and an example parameter setting is shown below:





### Compute Thermal Expansion Eigenstrain Beam


#### Description

`ComputeBeamThermalExpansionEigenstrain` calculates the thermal strain due to a change in temperature (from the stress-free temperature) using a constant thermal expansion coefficient. This thermal strain is applied only along the axial direction of the beam.

#### Example Input File Syntax





### Compute Variable Base EigenStrain



#### Description

The material `ComputeVariableBaseEigenStrain` calculates a Rank-2 tensor eigenstrain
as a function of a Rank-2 tensor base and a scalar material property.
\begin{equation}
  \label{eqn:variable_base_eigenstrain}
  \boldsymbol{\epsilon}_{eigen} = p \boldsymbol{T} + \boldsymbol{A}
\end{equation}
where $\boldsymbol{\epsilon}_{eigen}$ is the calculated eigenstrain,
$p$ is a scalar material property, $\boldsymbol{T}$ is the tensor selected by
the user as the base of the eigenstrain, and $\boldsymbol{A}$ is the offset, or
constant initial, eigenstrain tensor.
The material property $p$ is used to introduce dependence of the eigenstrain on
the user-specified variable.

#### Example Input File


where the argument for the `base_tensor_property_name` parameter in the eigenstrain
is the same as the property parameter `gb_tensor_prop_name` argument as shown


and the argument for the `prefactor` parameter in the eigenstrain material matches
the function name (`f_name` parameter) in the [DerivativeParsedMaterial](/DerivativeParsedMaterial.md)


Finally, the `eigenstrain_name` parameter value must also be set for the strain calculator, and an example parameter setting is shown below:






### Compute Variable Eigenstrain


#### Description

`ComputeVariableEigenstrain` calculates the eigenstrain as a function of a specified
variable as well as the contributions of the eigenstrain to the first and second
order derivatives of the elastic strain.
This class is most often only used in phase field simulations where first and
second derivatives are required and the limitation on elastic only strains is
not overly restrictive.

The Rank-2 tensor eigenstrain is calculated as a function of a Rank-2 tensor base
and a scalar material property.
\begin{equation}
  \label{eqn:variable_base_eigenstrain}
  \boldsymbol{\epsilon} = p \boldsymbol{T}
\end{equation}
where $\boldsymbol{\epsilon}_{eigen}$ is the computed eigenstrain,
$p$ is a scalar material property, and $\boldsymbol{T}$ is the tensor selected by
the user as the base of the eigenstrain.
The material property $p$ is used to introduce dependence of the eigenstrain on
the user-specified variable.

The contributions of the eigenstrain to the first and second elastic strain
derivatives are calculated with use of the MOOSE
[DerivativeMaterialInterface](materials/DerivativeMaterialInterface.md)
applied to the prefactor variables.
\begin{equation}
  \label{eqn:derivatives}
  \begin{aligned}
  \nabla \cdot \boldsymbol{\epsilon} & = \left( \nabla \cdot p \right) \boldsymbol{T} \\
  \nabla^2 \cdot \boldsymbol{\epsilon} & = \left( \nabla^2 \cdot p \right) \boldsymbol{T}
  \end{aligned}
\end{equation}
where $\nabla \cdot \boldsymbol{\epsilon}$ and $\nabla^2 \cdot \boldsymbol{\epsilon}$ are
the first and second derivatives of the elastic strain contributions due to the
eigenstrain.

This class assumes the presence of only elastic strain in the computation of the
first and second derivatives.

#### Example Input File


where the argument for the `args` parameter in the eigenstrain matches the name
of the coupled variable, here shown as an auxvariable


and the argument for the `prefactor` parameter in the eigenstrain material matches
the function name (`f_name` parameter) in the [DerivativeParsedMaterial](/DerivativeParsedMaterial.md)


Finally, the `eigenstrain_name` parameter value must also be set for the strain calculator, and an example parameter setting is shown below:






### Compute Variable Isotropic Elasticity Tensor


#### Description

This model computes an elasticity tensor for which the elastic moduli, prescribed in terms of the
Young's modulus and Poisson's ratio, vary as defined by user-specified material properties. Every
time this material is evaluated, the full tensor is updated to reflect the current values of those
elastic constants.

#### Example Input File Syntax





### ComputeVolumetricDeformGrad


#### Description

This class sets the volumetric deformation gradient to identity and transforms the total deformation gradient using this volumetric deformation gradient.





### Compute Volumetric Eigenstrain


#### Description

This material computes the eigenstrain tensor based on a set of scalar material properties
which when summed together define the volumetric strain. The materials taken as input to this
model specify the ratio $V/V_0$, where $V$ is the current volume and $V_0$ is the initial
volume.

In models that use finite strain formulations, the volume change resulting from
this eigenstrain will exactly equal the specified volumetric strain.

#### Example Input File Syntax

         block=Materials/volumetric_eigenstrain

where the volumetric material is defined as a separate material model

         block=Materials/volumetric_change

The `eigenstrain_name` parameter value must also be set for the strain calculator. When the
[SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md) Action is used, it automatically creates the strain
calculator. In that case, the `eigenstrain_name` is specified in the QuasiStatic block, and
passed in to the strain calculator as shown:

         block=Physics/SolidMechanics/QuasiStatic




### Density Scaling


#### Description

The material `DensityScaling` computes the extra element density required
in every element to allow explicit dynamics solves to be solved with a time
step prescribed by a user (see [CriticalTimeStep](/CriticalTimeStep.md)).
The addition of mass can alter the dynamics of the system, so usage of mass
scaling is particularly recommended when the finite element mesh contains a
handful of small finite elements or when system fundamental frequencies do not
have a key influence on the simulation output metrics.

#### Example Input File






### EigenDecompositionMaterial


#### Description

This class reads in a symmetric `RankTwoTensor` material given by [!param](/Materials/EigenDecompositionMaterial/rank_two_tensor) and performs an eigendecomposition on it.  The results of the decomposition are scalar materials named `max_eigen_value`, `mid_eigen_value`, and `min_eigen_value` and the corresponding vector material properties named `max_eigen_vector`, `mid_eigen_vector`, and `min_eigen_vector`. These names can be preceeded by the [!param](/Materials/EigenDecompositionMaterial/base_name) to allow for more than one `EigenDecompositionMaterial` per block.  These material properties can be output using the Material Outputs system with the [!param](/Materials/EigenDecompositionMaterial/output_properties) as shown in the below example.  This material is useful for visualizing the elemental maximum principal stress and direction as a vector.  An error will be produced if an unsymmetric `RankTwoTensor` is decomposed which can happen for the deformation gradient.

#### Example Input File Syntax





### Eshelby Tensor


#### Description

This model computes the Eshelby energy-momentum tensor $\Sigma$ [!citep](eshelby_energy_1999),
used in fracture integral calculations:
\begin{equation}
\boldsymbol{\Sigma} = W\boldsymbol{I} - \boldsymbol{H}^T\boldsymbol{P}
\end{equation}
where W is the strain energy density in the original configuration, $\boldsymbol{I}$
is the identity matrix, $\boldsymbol{H}$ is the displacement gradient, and
$\boldsymbol{P}$ is the first Piola-Kirchhoff stress tensor.

It is necessary to include this material within the input file when computing
fracture integrals.

#### Example Input File Syntax




### Exponential Softening


#### Description

The material `ExponentialSoftening` computes the reduced stress and stiffness
in the direction of a crack according to a exponential function. The computed
cracked stiffness ratio softens the tensile response of the material once the
principle stress exceeds the cracking stress threshold of the material.

As with the other smeared cracking softening models, which all follow the
nomenclature convention of using the `Softening` suffix, this model is intended
to be used with the [ComputeSmearedCrackingStress](/ComputeSmearedCrackingStress.md)
material.

##### Softening Model

The tensile stress response to cracking is calculated as an exponential function
of the crack strain
\begin{equation}
  \label{eqn:exp_crack_stress}
  \sigma = \sigma_c \cdot \left( \sigma_{res} + (1 - \sigma_{res}) \cdot
       \exp \left[ \frac{\alpha \beta}{\sigma_c} \cdot \left( \epsilon_c^{max}
       - \epsilon_c^{init} \right) \right] \right)
\end{equation}
where the calculated stress, $\sigma$ is the principle stress along the direction
of the crack, $\sigma_c$ is the stress threshold beyond which cracking occurs,
$\sigma_{res}$ is the residual stress retained after full softening due to the
crack is completed, $\alpha$ is the initial slope of the exponential curve,
$\beta$ is a fitting parameter, $\epsilon_c^{max}$ is the maximum strain in the
direction of crack, and $\epsilon_c^{init}$ is the strain in direction of crack
when crack initiation occurred.
The ratio of the current stiffness to the original material stiffness is
computed using the result of [eqn:exp_crack_stress]
\begin{equation}
  \label{eqn:exp_stiffness_ratio}
  R = \sigma \cdot \frac{\epsilon_c^{init}}{\epsilon_c^{max}\sigma_c}
\end{equation}
where the definitions for the variables are the same here as in
[eqn:exp_crack_stress]. The stiffness ratio is passed back to the
[ComputeSmearedCrackingStress](/ComputeSmearedCrackingStress.md)
to compute the softened cracked material stiffness.


#### Example Input File


`ExponentialSoftening` must be run in conjunction with the fixed smeared cracking material model as shown below:










### FluxBasedStrainIncrement


The strain is computed from flux instead of the displacements. The gradient of the flux is
first computed from the gradient of each component of the flux specified by the user:

\nabla F = (\nabla F_x, \nabla F_y, \nabla F_z)

where:

- $F_x$ is the x-component of the flux specified with the [!param](/Materials/FluxBasedStrainIncrement/xflux) parameter
- $F_y$ is the y-component of the flux, optionally specified with the [!param](/Materials/FluxBasedStrainIncrement/yflux) parameter
- $F_z$ is the z-component of the flux, optionally specified with the [!param](/Materials/FluxBasedStrainIncrement/zflux) parameter

The strain increment tensor is then computed as:

\boldsymbol{\epsilon}_{inc} = -\dfrac{1}{2}(\nabla F + ^T(\nabla F)) *  (1.0 - G) * \text{dt};

where $G$ is the grain boundary order parameter.

The computation of the flux based strain increment assumes a first order Euler time integration scheme.




### GBRelaxationStrainIncrement


The strain increment from the relaxation of the grain boundaries $\boldsymbol{\epsilon}_{inc}$ is computed from the time step, the tensor of the normal to the grain boundaries $\boldsymbol{N}_{gb}$, and a user-specified pre-factor Real-value material property $f$.

\boldsymbol{\epsilon}_{inc} = f * dt * \boldsymbol{N}_{gb}




### Generalized Kelvin-Voigt Model


#### Description

The `GeneralizedKelvinVoigtModel` material represents a generalized Kelvin-Voigt model, that is, a
material composed of $N$ Kelvin-Voigt units assembled in series.  The material obeys to the following
constitutive equation:
\begin{equation}
\sigma_{ij} = C_{ijkl} \left( \epsilon^{mech}_{kl} - \sum\limits_{n=1}^{N} \alpha^{n}_{kl} \right)
\end{equation}

The $\alpha^{n}$ are the internal strains associated to each Kelvin-Voigt unit and obey the following
time-dependent differential equation:
\begin{equation}
\forall n \in [1, N]: \sigma_{ij} = C^{n}_{ijkl} \left( \alpha^{n} + \eta^{n} \dot{\alpha}^{n} \right)
\end{equation}
$C^{n}$ is the stiffness of the $n^{th}$ spring in the chain (a fourth-order tensor, identical in
symmetry and dimensions to a standard elasticity tensor), while $\eta^{n}$ is the viscosity of the
associated dashpot (a scalar with the dimension of time).

#### Internal Time-Stepping Scheme

The constitutive equations are solved using a semi-implicit single-step first-order finite difference
scheme. The internal strains at time step $t+\Delta t$ are computed from their values at the previous
time step $t$:
\begin{equation}
\alpha^{n}(t+\Delta t) = \alpha^{n}(t) + \Delta t \left[ \theta^n \dot{\alpha}^n (t+\Delta t) + \left( 1 - \theta^n \right) \dot{\alpha}^n (t)  \right]
\end{equation}
$\theta$ is a scalar between 0 (fully explicit) and 1 (fully implicit) that controls the
time-stepping scheme (default value: 1). The value $\theta$ is determined by the "integration_rule"
input parameter, which can take one of the forms shown in [theta_formulations_gkvm].

| Integration Rule | Value of $\theta$  | Unconditional Convergence |
|------------------|--------------------|---------------------------|
| BackwardEuler    | 1                  | yes                       |
| MidPoint         | 0.5                | yes                       |
| Newmark          | user-defined       | $\theta \geq 0.5$         |
| Zienkiewicz      | $\frac{1}{1 - e^{-\Delta t / \eta^n}} - \eta^n / \Delta t$ | yes |

The scheme is not valid for $\theta = 0$, so this value is forbidden.

Using this formalism, the stress-strain constitutive equation, which depends on the $\alpha^{n}(t +
\Delta t)$ (unknown) can be rewritten so that it only depends on the $\alpha^{n}(t)$ and
$\dot{\alpha}^{n}(t)$ (both being known).

For efficiency reasons, the $\alpha^{n}(t)$ and $\dot{\alpha}^{n}(t)$ are not stored separately, but
as a single variable $\alpha^{n}(t) + \Delta t \theta^{n} \dot{\alpha}^{n}(t)$.

For the time-stepping scheme to be properly updated, a
[LinearViscoelasticityManager](/LinearViscoelasticityManager.md) object must be included in the input
file, and linked to the material

#### Stress-Strain Computation

The material is compatible with either the total small strain approximation, or either of the
incremental strain approximation (incremental small strains or finite strains). The model requires
the stress calculators listed in [stress_calculators_gkvm].

| Strain | Stress | Additional Materials |
|--------|--------|----------------------|
| [ComputeSmallStrain](/ComputeSmallStrain.md) | [ComputeLinearViscoelasticStress](/ComputeLinearViscoelasticStress.md) | none |
| [ComputeIncrementalStrain](/ComputeIncrementalStrain.md) | [ComputeMultipleInelasticStress](/ComputeMultipleInelasticStress.md) | [LinearViscoelasticStressUpdate](/LinearViscoelasticStressUpdate.md) |
| [ComputeFiniteStrain](/ComputeFiniteStrain.md) | [ComputeMultipleInelasticStress](/ComputeMultipleInelasticStress.md) | [LinearViscoelasticStressUpdate](/LinearViscoelasticStressUpdate.md) |

The stress calculators use the actual elasticity tensor of the material $C_{ijkl}$, which is provided
by the material itself.

##### Driving Eigenstrain (Optional)

If the user defines a driving eigenstrain, then the stress induced by this eigenstrain is added to
the creep calculation. Essentially, this replaces the differential relation in each material module
with:
\begin{equation}
\forall n \in [1, N]: \sigma_{ij} + C_{ijkl} \epsilon^{driving}_{kl} = C^{n}_{ijkl} \left( \alpha^{n} + \eta^{n} \dot{\alpha}^{n} \right)
\end{equation}

#### Example Input File Syntax


with the required strain calculator


the required stress calculator


and the additional material to define the viscoelastic behavior


and the required Linear Viscoelasticity Manager User Object:





### Generalized Maxwell Model


#### Description

The `GeneralizedMaxwellModel` class represents a generalized Maxwell model, that is, a material
composed of $N$ Maxwell units assembled in series.

##### Constitutive Equations

The material obeys to the following constitutive equation:
\begin{equation}
\sigma_{ij} = C_{ijkl} \epsilon^{mech}_{kl} - \sum\limits_{n=1}^{N} C^{n}_{ijkl} \alpha^{n}_{kl}
\end{equation}

The $\alpha^{n}$ are the internal strains associated to each Maxwell unit, and $C^{n}$ the stiffness
of the corresponding spring (a fourth-order tensor, identical in symmetry and dimensions to a
standard elasticity tensor). The $\alpha^{n}$ obey the following time-dependent differential
equation:
\begin{equation}
\forall n \in [1, N]: \epsilon^{mech} - \alpha^{n} = \eta^{n} \dot{\alpha}^{n}
\end{equation}
With $\eta^{n}$ is the viscosity of the associated dashpot (a scalar with the dimension of time).

#### Internal Time-Stepping Scheme

The constitutive equations are solved using a semi-implicit single-step first-order finite difference
scheme. The internal strains at time step $t+\Delta t$ are computed from their values at the previous
time step $t$:
\begin{equation}
\alpha^{n}(t+\Delta t) = \alpha^{n}(t) + \Delta t \left[ \theta^n \dot{\alpha}^n (t+\Delta t) + \left( 1 - \theta^n \right) \dot{\alpha}^n (t)  \right]
\end{equation}
$\theta$ is a scalar between 0 (fully explicit) and 1 (fully implicit) that controls the
time-stepping scheme (default value: 1). The value $\theta$ is determined by the "integration_rule"
input parameter, which can take one of the forms shown in [theta_formulations_gkvm].

| Integration Rule | Value of $\theta$  | Unconditional Convergence |
|------------------|--------------------|---------------------------|
| BackwardEuler    | 1                  | yes                       |
| MidPoint         | 0.5                | yes                       |
| Newmark          | user-defined       | $\theta \geq 0.5$         |
| Zienkiewicz      | $\frac{1}{1 - e^{-\Delta t / \eta^n}} - \eta^n / \Delta t$ | yes |

The scheme is not valid for $\theta = 0$, so this value is forbidden.

Using this formalism, the stress-strain constitutive equation, which depends on the $\alpha^{n}(t +
\Delta t)$ (unknown) can be rewritten so that it only depends on the $\alpha^{n}(t)$ and
$\dot{\alpha}^{n}(t)$ (both being known).

For efficiency reasons, the $\alpha^{n}(t)$ and $\dot{\alpha}^{n}(t)$ are not stored separately, but
as a single variable $\alpha^{n}(t) + \Delta t \theta^{n} \dot{\alpha}^{n}(t)$.

For the time-stepping scheme to be properly updated, a
[LinearViscoelasticityManager](/LinearViscoelasticityManager.md) object must be included in the input
file, and linked to the material

#### Stress-Strain Computation

The material is compatible with either the total small strain approximation, or either of the
incremental strain approximation (incremental small strains or finite strains). The model requires
the stress calculators listed in [stress_calculators_gkvm].

| Strain | Stress | Additional Materials |
|--------|--------|----------------------|
| [ComputeSmallStrain](/ComputeSmallStrain.md) | [ComputeLinearViscoelasticStress](/ComputeLinearViscoelasticStress.md) | none |
| [ComputeIncrementalStrain](/ComputeIncrementalStrain.md) | [ComputeMultipleInelasticStress](/ComputeMultipleInelasticStress.md) | [LinearViscoelasticStressUpdate](/LinearViscoelasticStressUpdate.md) |
| [ComputeFiniteStrain](/ComputeFiniteStrain.md) | [ComputeMultipleInelasticStress](/ComputeMultipleInelasticStress.md) | [LinearViscoelasticStressUpdate](/LinearViscoelasticStressUpdate.md) |

The stress calculators use the actual elasticity tensor of the material $C_{ijkl}$, which is provided by the material itself.

##### Driving Eigenstrain (Optional)

If the user defines a driving eigenstrain, then the stress induced by this eigenstrain is added to
the creep calculation. Essentially, this replaces the differential relation in each material module
with:
\begin{equation}
\forall n \in [1, N]: \sigma_{ij} + C_{ijkl} \epsilon^{driving}_{kl} = C^{n}_{ijkl} \left( \alpha^{n} + \eta^{n} \dot{\alpha}^{n} \right)
\end{equation}

#### Example Input File Syntax


with the required strain calculator


the required stress calculator


the additional material to define the viscoelastic behavior


and the required Linear Viscoelasticity Manager User Object:





### Generalized Radial Return Stress Update with automatic differentiation

Base class which computes the solution of a generalized radial return mapping algorithm.
The generalization of the isotropic radial return mapping to Hill plasticity allows for
computing the return to the yield surface through a scalar variable when computed
in a proper subspace.

Anisotropic (Hill) creep and plasticity classes such as `HillCreepStressUpdate` and
`HillPlasticityStressUpdate` inherit from the generalized radial return mapping. For
details on the anisotropic plasticity and anisotropic elasto-plasticity algorithms, consult
[!cite](versino2018generalized).


### Hill Constants


#### Description

The `HillConstants` material transforms the user specified hill constants from global co-ordinates to the material co-ordinates and stores them as a material property. It rotates the hill constants during the initial time step only. This class does not rotate the hill tensor during the simulation.  The initial rotation is performed based of the user defined rotation angle parameters. The rotated Hill tensor is obtained as [!cite](stewart2011anisotropic):

\begin{equation}
\label{eq:rotate_hill_tensor}
  H_{rot} = T_m H T_m^T
\end{equation}

Here, $H_{rot}$ is the transformed hill tensor, $H$ is the initial Hill tensor and $T_m$ is the transformation matrix. The transformation matrix $T_m$ is formed from the components of the total rotation matrix due to initial rotation and the orientation change due to large deformation.

#### Temperature dependency and large deformation kinematics

The Hill's tensor varies depending on temperature (due to texture) and depending on the material's rotation. To that effect, the user can create functions describing the evolution of the coefficients with temperature and provide it to the material, as follows:


where six piecewise linear functions are created to define the material directional creep dependency with temperature.

In addition, the code accounts for finite strain rotation to update the Hill's tensor by default. For simple problems, the user can deactivate this feature by setting the input argument `use_large_rotation` to false. Updating of directional coefficients with finite strain rotation kinematics is strongly encouraged when the material Similarly, use of the transformed Hill's tensor would need to be disabled in the creep model, i.e. the following input file's command line needs to be passed: `use_transformation = false`.


Temperature coupling and large deformation updates have only been tested on creep models.

##### Example Input File Syntax






### Hill Creep Stress Update


#### Description

This class computes a creep strain rate based on an equivalent deviatoric stress function (${\sigma_e}$) that
is calculated as a function of Hill's function anisotropy parameters $F$, $G$, $H$, $L$, $M$, and $N$:
\begin{equation}
\sigma_e = \tilde{q}(\boldsymbol{\sigma}) = {[F(\sigma_{22} - \sigma_{33})^2 + G(\sigma_{33} - \sigma_{11})^2 + H(\sigma_{11} - \sigma_{22})^2
+ 2L\sigma_{23}^2 + 2M\sigma_{13}^2 + 2N\sigma_{12}^2]}^{1/2}
\label{hill_stress_function}
\end{equation}

where $\boldsymbol{\sigma}$ and $\sigma_{ij}$ are the stress tensor and its component, respectively. The [!eqref](hill_stress_function) is also called Hill stress function and accounts for anisotropy through the anisotropy parameters. The equivalent creep strain rate function may then be obtained as
\begin{equation}
\dot{\epsilon} = A {\sigma_e}^{n}
\label{creep_law}
\end{equation}

where $A$ is a creep coefficient and $n$ the creep exponent.

The effective creep strain increment is obtained within the framework of a generalized (Hill plasticity) radial return mapping, see
[GeneralizedRadialReturnStressUpdate](/GeneralizedRadialReturnStressUpdate.md). This class computes the
generalized radial return inelastic increment. More details on the Hill-type creep material model may be found in [!cite](stewart2011anisotropic).


##### Creep strain integration scheme

Newton iteration is performed for computing the effective creep strain increment $\Delta \gamma$ with increment in the $\Delta \gamma$ (d$\Delta \gamma$) for each Newton iteration computed as:

\begin{equation}
d{\Delta \gamma}_{n+1} = - \frac{R({\Delta \gamma}_n)}{R'({\Delta \gamma}_n)} \\
{\Delta \gamma}_{n+1} = {\Delta \gamma}_{n} + d{\Delta \gamma}_{n+1}
\label{newtons_iteration}
\end{equation}

where $R$ is the residual and $R'$ is the derivative of residual with respect to the ${\Delta \gamma}$. The residual and its derivative are computed as:

\begin{equation}
R = {\dot{\epsilon_c}} \times \Delta t - \Delta \gamma
\label{residual}
\end{equation}

\begin{equation}
\frac{\partial R}{\partial \Delta \gamma} = \frac{\partial {\dot{\epsilon_c}}} {\Delta \gamma} \times \Delta t - 1.0
\label{residual_derivative}
\end{equation}

Substituting [!eqref](creep_law) in [!eqref](residual) and [!eqref](residual_derivative), we obtain:

\begin{equation}
R = A {\mathbf{\sigma_e}}^n \times \Delta t - \Delta \gamma
\label{residual2}
\end{equation}

\begin{equation}
\frac{\partial R}{\partial \Delta \gamma} = A n {\sigma_e}^{n-1} \frac{\partial \sigma_e}{\partial \Delta{\gamma}} \times \Delta t - 1.0
\label{residual_derivative2}
\end{equation}

We need expressions for $\sigma_e$ and $\frac {\partial \sigma_e} {\partial \Delta{\gamma}}$ in terms of trial stress $\mathbf{\sigma^{tr}}$ and $\Delta \gamma$, which are then substituted in [!eqref](residual2) and [!eqref](residual_derivative2).

###### Isotropic Elasticity

\begin{equation}
\sigma_e = {\sigma^{tr}_e} - 3G\Delta \gamma
\label{isotropic_sigma_e}
\end{equation}

\begin{equation}
\frac{\partial \sigma_e}{\partial \Delta \gamma} = - 3G
\label{isotropic_sigma_e_derivative}
\end{equation}

where $G$ is the shear modulus. For details of [!eqref](isotropic_sigma_e) and [!eqref](isotropic_sigma_e_derivative) see [!cite](dunne2005introduction).

###### Anisotropic Elasticity

For cases with anisotropic elasticity [!eqref](isotropic_sigma_e) is not valid. The stress tensor after radial return for the case with anisotropic elasticity is expressed as:

\begin{equation}
\boldsymbol{\sigma} = \boldsymbol{\sigma^{tr}} - \boldsymbol{C} \Delta \boldsymbol{\epsilon_c}
\label{anisotropic_sigma}
\end{equation}

where $\boldsymbol{\epsilon_c}$ is the creep strain tensor and $\boldsymbol{C}$ is the elasticity tensor. Rewriting [!eqref](hill_stress_function):

\begin{equation}
\sigma_e = \tilde{q}(\boldsymbol{\sigma})
\label{anisotropic_sigma_e}
\end{equation}

\begin{equation}
\frac{\partial \sigma_e}{\partial \Delta{\gamma}} = \frac{\partial \tilde{q}(\boldsymbol{\sigma^{tr}} - \boldsymbol{C} \Delta \boldsymbol{\epsilon_c})}{\partial \Delta \gamma} = \frac{\partial \tilde{q}(\boldsymbol{\sigma^{tr}} - \boldsymbol{C} \Delta \boldsymbol{\epsilon_c})}{\partial \Delta \boldsymbol{\epsilon_c}} \frac{\partial \Delta \boldsymbol{\epsilon_c}}{\partial \Delta{\gamma}}
\label{anisotropic_sigma_e_derivative}
\end{equation}

Note that [!eqref](anisotropic_sigma_e_derivative) uses chain rule. Normality hypothesis is expressed as:

\begin{equation}
\Delta \boldsymbol{\epsilon_c} = \Delta \gamma \frac{\partial \tilde{q}}{\partial \boldsymbol{\sigma}}
\label{normality_hypothesis}
\end{equation}

and the last term of [!eqref](anisotropic_sigma_e_derivative) is obtained by taking derivative of [!eqref](normality_hypothesis) as:

\begin{equation}
\frac{\partial \Delta \boldsymbol{\epsilon_c}}{\partial \Delta{\gamma}} = \frac{\partial \tilde{q}}{\partial \boldsymbol{\sigma}}
\label{normality_hypothesis_derivative}
\end{equation}

##### Numerical time integration error

The return mapping algorithm used to solve for elastic and inelastic strains relies on an additive decomposition. The stress increment can be determined, assuming a one-dimensional problem, as $\Delta\sigma = E \Delta\epsilon^{elastic} = E (\Delta\epsilon^{total} - \Delta\epsilon^{creep})$, where $E$ is a representative value of the Young's modulus. One way of limiting the error incurred in the numerical time integration is to compare it with the elastic strain increment during such an increment. Namely, we want to ensure that $err_{creep} \ll \frac{\Delta\sigma}{E}$. Estimating the creep numerical integration error as proportional to the increment of creep strain rates: $err_{creep} = (\Delta\dot{\epsilon}_{t+\Delta t} - \Delta\dot{\epsilon}_{t}) \cdot \Delta t$, the recommended time step is

\begin{equation}
\Delta t_{limit} = \frac{\Delta t \cdot E \cdot userTolerance}{\Delta\sigma},
\label{eq_num_time}
\end{equation}

where $\Delta t_{limit}$ is the computed time step limit, $\Delta t$ is the current time step, $\Delta\sigma$ denotes a stress time increment scalar, and $userTolerance$ is the maximum numerical time integration error selected by the user. As Eq. (1) suggests, the creep error depends on the material stiffness and the given stress increment. For complex simulation scenarios, controlling this error by only prescribing a maximum inelastic strain increment may not be sufficient to limit creep error. Furthermore, too conservative selection of the maximum inelastic strain may lead to a large increase in the number of time steps required to finish the simulation.

It is recommended to choose a `max_inelastic_increment` that guarantees that creep strain increments are well within the small strain increment assumption. Complementarily, `max_integration_error` must be selected such that the numerical time integration will not significantly affect the creep results. Usually, for most applications, values on the order of $1.0\cdot10^{-3}$ - $1.0\cdot10^{-5}$ will suffice. For better results, these time integration limits may be combined with a soft [Terminator](/Terminator.md).

For three-dimensional problems, a norm of the stress difference and a representative value for the Young's modulus is used internally.

#### Example Input File Syntax






### Hill Elasto-Plasticity Stress Update


#### Description

This class computes Hill plasticity via a generalized radial return mapping algorithm [!cite](versino2018generalized). This object implements an algorithm indicated for anisotropic elastoplasticity, i.e. a combination of elastic anisotropy plus a yield function where each stress component has its own yield value.

The Hill yield function can be defined as:
\begin{equation}
f := \frac{1}{2} \boldsymbol{s}^{\boldsymbol{T}} \boldsymbol{A} \boldsymbol{s} - {s_y}^2 \left(\alpha, \dot{\alpha}, T \right)
\label{eq:yield_condition}
\end{equation}
where $\boldsymbol{s}$ is the deviatoric stress tensor in Voigt form, $\boldsymbol{A}$ is the anisotropy (Hill) tensor, $T$ is the temperature and $\alpha$ is an internal parameter that can be used, for example, to prescribe strain hardening through a plasticity modulus. Hill's tensor is defined as a six by six matrix using the unitless constants $F$, $G$, $H$, $L$, $M$ and $N$ as following:

\begin{equation}
\boldsymbol{A} :=
  \begin{bmatrix}
  G+H & -H & -G & 0 & 0 & 0\\
  -H & F+H & -F & 0 & 0 & 0\\
  -G & -F & F+G & 0 & 0 & 0\\
  0 & 0 & 0 & 2N & 0 & 0\\
  0 & 0 & 0 & 0 & 2L & 0\\
  0 & 0 & 0 & 0 & 0 & 2M\\
  \end{bmatrix}
  \label{eq:Hill_tensor_definition}
\end{equation}

The model currently uses power law hardening:

\begin{equation}
\sigma_y = \sigma_{yo} + K \alpha^n
\label{eq:power_law_hardening}
\end{equation}

where $K$ is the hardening constant and $n$ is the hardening exponent. The hardening exponent has a default value of 1.0 and this value can be modified by the user by setting the parameter [!param](/Materials/HillElastoPlasticityStressUpdate/hardening_exponent). The [!param](/Materials/HillElastoPlasticityStressUpdate/yield_stress) ($\sigma_{yo}$) and [!param](/Materials/HillElastoPlasticityStressUpdate/hardening_constant) ($K$) are the required parameters to be supplied by the user.

#### Usage for 3D models

When this model is used for curved 3D geometry (currently limited to only cylindrical geometry) with anisotropic plasticity, the model requires rotation of the stresses (global coordinate system (Cartesian) to local coordinate system (cylindrical)) and strains (local to global coordinate system). For cylindrical geometry, the user should set the parameter [!param](/Materials/HillElastoPlasticityStressUpdate/local_cylindrical_csys) to 'true' along with [!param](/Materials/HillElastoPlasticityStressUpdate/axis) (= x for x-axis y for y-axis and z for z-axis) used as axis of rotation. The option for using this material model for 3D spherical geometry will be added sometime in the future.

The stress and strain tensors $T$ are rotated according to the following equation:

\begin{equation}
[T'] = [Q'] [T] [Q_{transpose}]
\end{equation}

where $T$ is a tensor in the old coordinate system and $T'$ is the tensor in the new coordinate system. The square brackets $[$ $]$ denote matrix form (3x3) of the tensor. The basis vectors of old coordinate system should be arranged column wise to construct the rotation matrix $Q$.


#### Verification

With $f$ being the yield condition, $\boldsymbol{s}$ the deviatoric stress and $\gamma$ the plastic multiplier, the plastic strain rate is given as:

\begin{equation}
\dot{\boldsymbol{\epsilon}}^{\boldsymbol{p}} = \dot{\gamma}\frac{\partial f}{\partial \boldsymbol{s}}
\label{eq:normality_condition}
\end{equation}

[eq:normality_condition] is a statement of normality condition, i.e., the associative flow rule. Using [eq:yield_condition], the associative flow rule in [eq:normality_condition] can be written as:

\begin{equation}
\dot{\boldsymbol{\epsilon}}^{\boldsymbol{p}} = \dot{\gamma} \boldsymbol{A} \boldsymbol{s}
\label{eq:normality_condition2}
\end{equation}

which can be written in incremental form as:

\begin{equation}
\Delta\boldsymbol{\epsilon}^{\boldsymbol{p}} = \Delta\gamma \boldsymbol{A} \boldsymbol{s}
\label{eq:normality_condition2_incremental}
\end{equation}

If $\alpha$ is the internal state variable associated with isotropic hardening, and $\beta$ is the energy conjugate to the $\dot{\alpha}$, the $\dot{\alpha}$ is written as:

\begin{equation}
\dot{\alpha} = - \dot{\gamma}\frac{\partial f}{\partial \beta}
\label{eq:alpha_dot}
\end{equation}

The thermodynamic variable $\beta$ is $s_y$ here (see [!cite](versino2018generalized) for details). Equation [eq:alpha_dot] can be written in integrated incremental form as:

\begin{equation}
\Delta\alpha = 2 s_y \Delta\gamma
\label{eq:delta_alpha}
\end{equation}

Using [eq:delta_alpha] in [eq:normality_condition2_incremental], taking the partial derivative of $\Delta\boldsymbol{\epsilon}^{\boldsymbol{p}}$ with respect to $\boldsymbol{s}$, and applying chain rule, we obtain:

\begin{equation}
\frac{\partial \Delta\boldsymbol{\epsilon}^{\boldsymbol{p}}}{\partial \boldsymbol{s}} = \frac{\partial \Delta\boldsymbol{\epsilon}^{\boldsymbol{p}}}{\partial \Delta\alpha} \frac{\partial \Delta\alpha}{\partial \boldsymbol{s}} = \frac{\boldsymbol{A} \boldsymbol{s}}{2s_y} \frac{\partial \Delta\alpha}{\partial \boldsymbol{s}}
\label{eq:inverse_slope}
\end{equation}

\begin{equation}
\Rightarrow \frac{\partial \boldsymbol{s}}{\partial \Delta\boldsymbol{\epsilon}^{\boldsymbol{p}}} = \frac{2s_y}{\boldsymbol{A} \boldsymbol{s}} \frac{\partial \boldsymbol{s}}{\partial \Delta\alpha}
\label{eq:slopeA}
\end{equation}

For the case where flow rule involves linear hardening with hardening constant $K$:

\begin{equation}
\frac{\partial \boldsymbol{s}}{\partial \Delta\alpha} = K
\label{eq:slopeB}
\end{equation}

Substituting [eq:slopeB] in [eq:slopeA] we obtain:

\begin{equation}
\Rightarrow \frac{\partial \boldsymbol{s}}{\partial \Delta\boldsymbol{\epsilon}^{\boldsymbol{p}}} = \frac{2s_y}{\boldsymbol{A} \boldsymbol{s}} K
\label{eq:slopeC}
\end{equation}

The left hand side of [eq:slopeC] gives the slope of the stress vs plastic strain curve. This equation can be written for the direct components of stress ($s_{ii}$) as:

\begin{equation}
\Rightarrow \frac{\partial s_{xx}}{\partial \Delta\epsilon^p_{xx}} = \frac{2s_y}{(G+H) s_{xx}} K
\label{eq:slope_componentx}
\end{equation}

For a uniaxial tensile test with monotonically increasing load, the stress always lies on the yield surface once the plastic deformation starts (for loading in x-direction $s_{xx}$ = $s_y$) which simplifies [eq:slope_componentx] to:

\begin{equation}
\Rightarrow \frac{\partial s_{xx}}{\partial \Delta\epsilon^p_{xx}} = \frac{2K}{(G+H)}
\label{eq:slope_componentx2}
\end{equation}

Similarly, for uniaxial loading in y-direction we obtain:

\begin{equation}
\Rightarrow \frac{\partial s_{yy}}{\partial \Delta\epsilon^p_{yy}} = \frac{2K}{(F+H)}
\label{eq:slope_componenty}
\end{equation}

These simplified equations ([eq:slope_componentx2] & [eq:slope_componenty]) have been used in the verification tests for this material model.

The combination of elastic isotropy and plastic anisotropy should be solved by the more efficient [HillPlasticityStressUpdate](/HillPlasticityStressUpdate.md) class.

The effective plastic strain increment is obtained within the framework of a generalized (Hill plasticity) radial return mapping, see
[GeneralizedRadialReturnStressUpdate](/GeneralizedRadialReturnStressUpdate.md).

#### Example Input File Syntax







### Hill Plasticity Stress Update


#### Description

This class computes Hill plasticity via a generalized radial return mapping algorithm [!cite](versino2018generalized). It
requires that the elastic behavior of the material is isotropic, whereas any departure from the yield function is anisotropic.
The Hill yield function can be defined as:
\begin{equation}
f := \frac{1}{2} \boldsymbol{s}^{\boldsymbol{T}} \boldsymbol{A} \boldsymbol{s} - {s_y}^2 \left(\alpha, \dot{\alpha}, T \right)
\label{eq:yield_condition}
\end{equation}
where $\boldsymbol{s}$ is the deviatoric stress tensor in Voigt form, $\boldsymbol{A}$ is the anisotropy (Hill) tensor, $T$ is the temperature and $\alpha$ is an internal parameter that can be used, for example, to prescribe strain hardening through a plasticity modulus. Hill's tensor is defined as a six by six matrix using the unitless constants $F$, $G$, $H$, $L$, $M$ and $N$ as following:

\begin{equation}
\boldsymbol{A} :=
  \begin{bmatrix}
  G+H & -H & -G & 0 & 0 & 0\\
  -H & F+H & -F & 0 & 0 & 0\\
  -G & -F & F+G & 0 & 0 & 0\\
  0 & 0 & 0 & 2N & 0 & 0\\
  0 & 0 & 0 & 0 & 2L & 0\\
  0 & 0 & 0 & 0 & 0 & 2M\\
  \end{bmatrix}
  \label{eq:Hill_tensor_definition}
\end{equation}

The model currently uses power law hardening:

\begin{equation}
\sigma_y = \sigma_{yo} + K \alpha^n
\label{eq:power_law_hardening}
\end{equation}

where $K$ is the hardening constant and $n$ is the hardening exponent. The hardening exponent has a default value of 1.0 and this value can be modified by the user by setting the parameter [!param](/Materials/HillPlasticityStressUpdate/hardening_exponent). The [!param](/Materials/HillPlasticityStressUpdate/yield_stress) ($\sigma_{yo}$) and [!param](/Materials/HillPlasticityStressUpdate/hardening_constant) ($K$) are the required parameters to be supplied by the user.

#### Verification

With $f$ being the yield condition, $\boldsymbol{s}$ the deviatoric stress and $\gamma$ the plastic multiplier, the plastic strain rate is given as:

\begin{equation}
\dot{\boldsymbol{\epsilon}}^{\boldsymbol{p}} = \dot{\gamma}\frac{\partial f}{\partial \boldsymbol{s}}
\label{eq:normality_condition}
\end{equation}

[eq:normality_condition] is a statement of normality condition, i.e., the associative flow rule. Using [eq:yield_condition], the associative flow rule in [eq:normality_condition] can be written as:

\begin{equation}
\dot{\boldsymbol{\epsilon}}^{\boldsymbol{p}} = \dot{\gamma} \boldsymbol{A} \boldsymbol{s}
\label{eq:normality_condition2}
\end{equation}

which can be written in incremental form as:

\begin{equation}
\Delta\boldsymbol{\epsilon}^{\boldsymbol{p}} = \Delta\gamma \boldsymbol{A} \boldsymbol{s}
\label{eq:normality_condition2_incremental}
\end{equation}

If $\alpha$ is the internal state variable associated with isotropic hardening, and $\beta$ is the energy conjugate to the $\dot{\alpha}$, the $\dot{\alpha}$ is written as:

\begin{equation}
\dot{\alpha} = - \dot{\gamma}\frac{\partial f}{\partial \beta}
\label{eq:alpha_dot}
\end{equation}

The thermodynamic variable $\beta$ is $s_y$ here (see [!cite](versino2018generalized) for details). Equation [eq:alpha_dot] can be written in integrated incremental form as:

\begin{equation}
\Delta\alpha = 2 s_y \Delta\gamma
\label{eq:delta_alpha}
\end{equation}

Using [eq:delta_alpha] in [eq:normality_condition2_incremental], taking the partial derivative of $\Delta\boldsymbol{\epsilon}^{\boldsymbol{p}}$ with respect to $\boldsymbol{s}$, and applying chain rule, we obtain:

\begin{equation}
\frac{\partial \Delta\boldsymbol{\epsilon}^{\boldsymbol{p}}}{\partial \boldsymbol{s}} = \frac{\partial \Delta\boldsymbol{\epsilon}^{\boldsymbol{p}}}{\partial \Delta\alpha} \frac{\partial \Delta\alpha}{\partial \boldsymbol{s}} = \frac{\boldsymbol{A} \boldsymbol{s}}{2s_y} \frac{\partial \Delta\alpha}{\partial \boldsymbol{s}}
\label{eq:inverse_slope}
\end{equation}

\begin{equation}
\Rightarrow \frac{\partial \boldsymbol{s}}{\partial \Delta\boldsymbol{\epsilon}^{\boldsymbol{p}}} = \frac{2s_y}{\boldsymbol{A} \boldsymbol{s}} \frac{\partial \boldsymbol{s}}{\partial \Delta\alpha}
\label{eq:slopeA}
\end{equation}

For the case where flow rule involves linear hardening with hardening constant $K$:

\begin{equation}
\frac{\partial \boldsymbol{s}}{\partial \Delta\alpha} = K
\label{eq:slopeB}
\end{equation}

Substituting [eq:slopeB] in [eq:slopeA] we obtain:

\begin{equation}
\Rightarrow \frac{\partial \boldsymbol{s}}{\partial \Delta\boldsymbol{\epsilon}^{\boldsymbol{p}}} = \frac{2s_y}{\boldsymbol{A} \boldsymbol{s}} K
\label{eq:slopeC}
\end{equation}

The left hand side of [eq:slopeC] gives the slope of the stress vs plastic strain curve. This equation can be written for the direct components of stress ($s_{ii}$) as:

\begin{equation}
\Rightarrow \frac{\partial s_{xx}}{\partial \Delta\epsilon^p_{xx}} = \frac{2s_y}{(G+H) s_{xx}} K
\label{eq:slope_componentx}
\end{equation}

For a uniaxial tensile test with monotonically increasing load, the stress always lies on the yield surface once the plastic deformation starts (for loading in x-direction $s_{xx}$ = $s_y$) which simplifies [eq:slope_componentx] to:

\begin{equation}
\Rightarrow \frac{\partial s_{xx}}{\partial \Delta\epsilon^p_{xx}} = \frac{2K}{(G+H)}
\label{eq:slope_componentx2}
\end{equation}

Similarly, for uniaxial loading in y-direction we obtain:

\begin{equation}
\Rightarrow \frac{\partial s_{yy}}{\partial \Delta\epsilon^p_{yy}} = \frac{2K}{(F+H)}
\label{eq:slope_componenty}
\end{equation}

These simplified equations ([eq:slope_componentx2] & [eq:slope_componenty]) can be used in the verification tests for this material model.

The combination of elastic isotropy and plastic anisotropy should be solved by the more efficient [HillPlasticityStressUpdate](/HillPlasticityStressUpdate.md) class.

The effective plastic strain increment is obtained within the framework of a generalized (Hill plasticity) radial return mapping, see
[GeneralizedRadialReturnStressUpdate](/GeneralizedRadialReturnStressUpdate.md).

#### Example Input File Syntax






### Hyperbolic Viscoplasticity Stress Update


#### Description


This uniaxial viscoplasticity class computes the plastic strain as a stateful material property.  The
constitutive equation for scalar plastic strain rate used in this model is
\begin{equation}
\dot{p} = \phi (\sigma_e , r) = \alpha sinh \beta (\sigma_e -r - \sigma_y)
\end{equation}

This class is based on the implicit integration algorithm in [!cite](dunne2005introduction)
pg. 162--163.

#### Example Input File Syntax

         block=Materials/viscoplasticity

`HyperbolicViscoplasticityStressUpdate` must be run in conjunction with the inelastic strain return
mapping stress calculator as shown below:

         block=Materials/radial_return_stress









### Isotropic Plasticity Stress Update


#### Description


In isotropic linear hardening plasticity, with the hardening function $r = hp$, the effective
plastic strain increment has the form:
\begin{equation}
 d \Delta p = \frac{\sigma^{trial}_{effective} - 3 G \Delta p - r - \sigma_{yield}}{3G + h}
\end{equation}
where $G$ is the isotropic shear modulus, and $\sigma^{trial}_{effective}$ is the scalar von Mises
trial stress.

This class calculates an effective trial stress, an effective scalar plastic strain increment, and
the derivative of the scalar effective plastic strain increment; these values are passed to the
[RadialReturnStressUpdate](/RadialReturnStressUpdate.md) to compute the radial return stress
increment.  This isotropic plasticity class also computes the plastic strain as a stateful material
property.

This class is based on the implicit integration algorithm in [!cite](dunne2005introduction)
pg. 146--149.  

The `ADIsotropicPlasticityStressUpdate` version of this class uses forward mode automatic
differentiation to provide all necessary material property derivatives to
assemble a perfect Jacobian (this replaces the approximated tangent operator).

#### Example Input File Syntax


`IsotropicPlasticityStressUpdate` must be run in conjunction with the inelastic strain return mapping
stress calculator as shown below:






### Isotropic Power Law Hardening Stress Update


#### Description


This class models power law hardening by using the relation
\begin{equation}
\sigma = \sigma_y + K \epsilon^n
\end{equation}
where $\sigma_y$ is the yield stress. This class solves for the yield stress as the intersection of
the power law relation curve and Hooke's law:
\begin{equation}
\epsilon_y = \frac{\sigma_y}{E} = \left( \frac{\sigma_y}{K} \right)^n
\end{equation}
where $\epsilon_y$ is the total strain at the yield point and the stress $\sigma_y$ is the von Mises
stress. Parameters from the parent class,
[IsotropicPlasticityStressUpdate](/IsotropicPlasticityStressUpdate.md), are suppressed to enable this
class to solve for yield stress:
\begin{equation}
\sigma_y = \left( \frac{E^n}{K} \right)^{1/(n-1)}
\end{equation}

#### Example Input File Syntax

         block=Materials/power_law_hardening

`IsotropicPowerLawHardeningStressUpdate` must be run in conjunction with the inelastic strain return
mapping stress calculator as shown below:

         block=Materials/radial_return_stress




### LAROMANCEPartitionStressUpdate


#### Description

The `LAROMANCEStressUpdate` computes the creep rate of materials by sampling a Los
Alamos Reduced Order Model Applied to Nonlinear Constitutive Equations (LAROMANCE)
formulated via calibration with lower-length scale simulations.

A detailed explanation is given in [the LAROMANCE documentation](/LAROMANCE.md).





### LAROMANCEStressUpdate


#### Description

The `LAROMANCEStressUpdate` computes the creep rate of materials by sampling a Los
Alamos Reduced Order Model Applied to Nonlinear Constitutive Equations (LAROMANCE)
formulated via calibration with lower-length scale simulations.

A detailed explanation is given in [the LAROMANCE documentation](/LAROMANCE.md).





### LinearElasticTruss


#### Description

This class computes the elastic stretch for a truss element by removing the stretch due to thermal expansion from the total stretch. This elastic stretch and Young's modulus are then used to compute the axial stress for the truss element in the truss local coordinate system.





### Linear Viscoelastic Stress Update


#### Description

This computes the inelastic strain increment resulting from a linear viscoelastic material such as a [GeneralizedKelvinVoigtModel](/GeneralizedKelvinVoigtModel.md) or a [GeneralizedMaxwellModel](/GeneralizedMaxwellModel.md) material. It uses an incremental strain approximation (either incremental small strains, or finite strains), and needs to be used in conjunction with [ComputeMultipleInelasticStress](/ComputeMultipleInelasticStress.md) or a similar stress calculator.

#### Example Input File Syntax


`LinearViscoelasticStressUpdate` must be run in conjunction with the inelastic strain return mapping stress calculator as shown below:





### SymmetricRankTwoTensorToRankTwoTensor

The SymmetricRankTwoTensorToRankTwoTensor has not been documented. The content listed below should be used as a starting point for
documenting the class, which includes the typical automatic documentation associated with a
MooseObject; however, what is contained is ultimately determined by what is necessary to make the
documentation clear for users.


#### Overview


#### Example Input File Syntax





### MultiParameterPlasticityStressUpdate

`MultiParameterPlasticityStressUpdate` is a base class to the following stress update materials:


#### Yield functions smoothing id=sec:smoothing

The three yield functions shown in [TensileStressUpdate.md] are smoothed in the
`MultiParameterPlasticityStressUpdate` class.

An example is shown [tensile_3D]
and [tensile_oct]. [tensile_oct] shows slices
of the yield surface at three values of the mean stress, and the
triangular-pyramid nature of the yield surface is evident.  The slices
are taken near the tip region only, to highlight: (1) the smoothing;
(2) that the smoothing is unsymmetric.

The unsymmetric nature of the
yield surface only occurs near the tip region where the smoothing
mixes the three yield surfaces.  For instance, the black line in
[tensile_oct] is symmetric, while the blue and red
lines are unsymmetric.  The amount of asymmetry is small, but it is
evident that the red curve is not concentric with the remainder of the
curves shown in [tensile_oct].  The order of the yield
functions has been chosen so that the curves
intersect the $\sigma_{III}=\sigma_{II}$ line at $90^{\circ}$, but not
on the $\sigma_{II}=\sigma_{I}$ line near the pyramid's tip.  The
asymmetry does not affect MOOSE's convergence, and of course it is
physically irrelevant (since there is no one ``correct'' smoothed
yield surface).



The principal stress directions are shown with black lines, and the mean stress direction is shown with a blue line.  The three planes extend infinitely (there is no base to the triangular pyramid) but these pictures show the tip region only.


In this example $T=1$, the smoothing
tolerance is 0.5, and the values of mean stress shown are: black,
0.7; blue, 0.8, red 0.85.  An unusually large amount of smoothing
has been used here to highlight various features: in real
simulations users are encouraged to use smoothing approximately
$T/10$.  The whole octahedral plane is shown in this figure, but
only one sextant is physical, which is indicated by the solid green
lines.

#### Flow rules and hardening

This plasticity is associative: the flow potential is

\begin{equation}
  g = f = max(f_{0}, f_{1}, f_{2}) + \text{smoothing} \ .
\end{equation}

Here `smoothing` indicates the smoothing mentioned in the previous section.

The flow rules are

\begin{equation}
  s_{a} = s_{a}^{\mathrm{trial}} - \gamma E_{ab} \frac{\partial
    g}{\partial s_{a}} \ ,
  \label{eqn.flow.rules}
\end{equation}

where $s_{a}=\{\sigma_{I}, \sigma_{II}, \sigma_{III}\}$ and

\begin{equation}
  E_{ab} = \frac{\partial s_{a}}{\partial \sigma_{ij}} E_{ijkl}
  \frac{\partial s_{b}}{\partial \sigma_{kl}} \ .
\end{equation}

In this equation $E_{ijkl}$ is the elasticity tensor.

An assumption that is made is that
$E_{ab}$ is independent of the stress parameters, $s_{a}$ and the
internal variables.  In this case,

\begin{equation}
  \frac{\partial s_{a}}{\partial \sigma_{ij}} = v_{i}^{a}v_{j}^{a} \ ,
\end{equation}

Special precautions are taken when the eigenvalues are equal, as described in the documentation for `RankTwoTensor`.

where $v^{a}$ is the eigenvector corresponding to the eigenvalue
$s^{a}$ (of the stress tensor) and there is no sum over $a$ on the
right-hand side.  Recall that the eigenvectors are fixed during the
return-map process, so the RHS is fixed, meaning that $E_{ab}$ is
indeed independent of the stress parameters.  Also recall that the
eigenvectors induce a rotation (to the principal-stress frame), so
assuming that $E_{ijkl}$ is isotropic

\begin{equation}
  E_{ab} = E_{aabb} \ .
\end{equation}

The assumption of isotropy is appropriate for this type of isotropic
plasticity.

It is assumed that there is just one internal parameter, $i$, and that
it is defined by

\begin{equation}
  i = i_{\mathrm{old}} + (\sigma_{III}^{\mathrm{trial}} - \sigma_{III})
  / E_{22} \ ,
\end{equation}

during the return-map process.  The tensile strength is a function of
this single internal parameter

#### Return-map considerations

##### Unknowns and the convergence criterion

The return-map problem involves solving the four equations: $f=0$ (smoothed yield function
should be zero) and the flow [eqn.flow.rules].  The
unknowns are the 3 stress parameters $s_{a}=\{\sigma_{I}, \sigma_{II},
\sigma_{III}\}$ and the plasticity multiplier $\gamma$.  Actually, to
make the units consistent the algorithm uses $\gamma E_{22}$ instead of
simply $\gamma$.  Convergence
is deemed to be achieved when the sum of squares of the residuals of
these 4 equations is less than a user-defined tolerance.

##### Iterative procedure and initial guesses

A Newton-Raphson process is used, along with a cubic line-search.  The
process may be initialized with the solution that is correct for
perfect plasticity (no hardening) and no smoothing, if the user
desires.  Smoothing adds nonlinearities, so this initial guess will
not always be the exact answer. For hardening, it is not
always advantageous to initialize the Newton-Raphson process in this
way, as the yield surfaces can move dramatically during the return
process.

##### Sub-stepping the strain increments

Because of the difficulties encountered during the Newton-Raphson
process during rapidly hardening/softening moduli, it is possible to
subdivide the applied strain increment, $\delta\epsilon$, into smaller
sub-steps, and do multiple return-map processes.  The final returned configuration may then
be dependent on the number of sub-steps.  While this is simply
illustrating the non-uniqueness of plasticity problems, it has been observed not to adversely affect MOOSE's nonlinear convergence as some residual calculations will take more sub-steps than other residual
calculations: in effect this is reducing the accuracy of the Jacobian.

##### The consistent tangent operator

MOOSE's Jacobian depends on the derivative

\begin{equation}
H_{ijkl} = \frac{\delta\sigma_{ij}}{\delta \epsilon_{kl}} \ .
\end{equation}

The quantity $H$ is called the consistent tangent operator.  For pure
elasticity it is simply the elastic tensor, $E$, but it is more
complicated for plasticity.  Note that a small $\delta\epsilon_{kl}$
simply changes $\delta\sigma^{\mathrm{trial}}$, so $H$ is capturing the
change of the returned stress ($\delta\sigma$) with respect to a
change in the trial stress ($\delta\sigma^{\mathrm{trial}}$).  In formulae:

\begin{equation}
  H_{ijkl} = \frac{\delta\sigma_{ij}}{\delta
    \sigma_{mn}^{\mathrm{trial}}}
  \frac{\delta\sigma_{mn}^{\mathrm{trial}}}{\delta\epsilon_{kl}} =\frac{\delta\sigma_{ij}}{\delta
    \sigma_{mn}^{\mathrm{trial}}} E_{mnkl} \ .
\end{equation}

In the case at hand,

\begin{equation}
  \sigma_{ij} = \sum_{a}R_{ia}s_{a}R_{aj}^{\mathrm{T}} \ .
\end{equation}

In this formula $\sigma_{ij}$ is the returned stress, $s_{a}$ are the
returned stress parameters (eigenvalues), and $R$ is the rotation
matrix, defined through the eigenvectors, $v^{a}$ ($a=1,2,3$) of the
trial stress:

\begin{equation}
  R_{ia} = v^{a}_{i} \ .
\end{equation}

The three eigenvectors remain unchanged during the return-map
process.  However, of course they change under a change in
$\sigma^{\mathrm{trial}}$.  The relevant formulae are

\begin{equation}
\begin{split}
  \frac{\delta s_{a}^{\mathrm{trial}}}{\delta \sigma_{kl}^{\mathrm{trial}}} & = v^{a}_{i}v^{a}_{j} \ , \\
  \frac{\delta v^{a}_{i}}{\delta \sigma_{kl}^{\mathrm{trial}}} & = \sum_{b\neq a}\frac{v_{i}^{b}(v_{k}^{b}v_{l}^{a} + v_{l}^{b}v_{k}^{a})}{2(s_{a}-s_{b})} \ . \\
\end{split}
\end{equation}

On the RHS of these equations there is no sum over $a$.

The final piece of information is

\begin{equation}
  \frac{\delta s_{b}}{\delta s_{a}^{\mathrm{trial}}} \ .
\end{equation}

`MultiParameterPlasticityStressUpdate` computes this after each
Newton step, for any arbitrary plasticity model.

The nontrivial part to the consistent tangent operator is therefore

\begin{equation}
  \frac{\delta \sigma_{ij}}{\delta\sigma_{mn}^{\mathrm{trial}}} =
\sum_{a}  \frac{\delta
    R_{ia}}{\delta\sigma_{mn}^{\mathrm{trial}}}s_{a}R_{aj}^{\mathrm{T}}
  + \sum_{a}\sum_{b} R_{ia}\frac{\delta s_{a}}{\delta s_{b}^{\mathrm{trial}}}
  \frac{\delta s_{b}^{\mathrm{trial}}}{\delta
    \sigma_{mn}^{\mathrm{trial}}}R_{aj}^{\mathrm{T}} +
  \sum_{a} R_{ia}s_{a}\frac{\delta
    R_{aj}^{\mathrm{T}}}{\delta\sigma_{mn}^{\mathrm{trial}}} \ .
\end{equation}

All the components of this equation have been provided above.

### MultiPhaseStressMaterial


The `MultiPhaseStressMaterial` is used in coupled phase field - solid mechanics calculations to compute
the mechanical deformation of multi-phase regions.

The switching (mixing) coefficients which blends the phases' stresses together must be provided
as a vector of material properties, using the [!param](/Materials/MultiPhaseStressMaterial/h) parameter.
A vector of material properties has a syntax similar to "h1 h2 h3 h4" if those are the names of the material properties.

The global stress is then defined as

\boldsymbol{\sigma}_g(\vec{r}) = \sum_i^N h_i(\vec{r}) \boldsymbol{\sigma}_{i}(\vec{r})

where $h_i$ are the switching function material properties, $\boldsymbol{\sigma}_{i}$ the phase stresses for each phase, $N$ the number of
phases considered, and $\vec{r}$ denotes the spatial dependence.

The material also defines the (rank four tensor of) derivatives of the stress with regards to the strain, accounting
for each phases' derivatives.




### NonlocalDamage


#### Description

`NonlocalDamage` is a model to define the effect of damage on the stress and stiffness in a continuum damage mechanics setting. It does not directly compute the stress, but must be used in conjunction with [ComputeDamageStress](/ComputeDamageStress.md).


The damage variable $d$ itself is computed as a nonlocal extension of an
external scalar damage model defined by the `local_damage_model`
and `average_UO` input parameters. The `average_UO` is a [RadialAverage](/RadialAverage) user
object that defines the nonlocal averaging properties. The damage value is
delayed by a single `execte_on` (timestep or nonlinear).






### Plastic Truss


#### Description

The `PlasticTruss` model implements J2 plasticity for 1D truss elements. The axial elongation of the element is obtained from
\begin{equation}
\varepsilon = \frac{\Delta l}{l_0} = \frac{(l-l_0)}{l_0} \, ,
\end{equation}
where $\delta l$ is the total stretch computed from the updated length $l$ and the old length $l_0$ of the truss element.
In case of linear elastic material, the axial stress $\sigma_a$ is computed as
\begin{equation}
\sigma_a = E \frac{\Delta l}{l_0} \, .
\end{equation}
Here, the nonlinear behavior of the truss is implemented using a simple J2 plasticity model that can use either simple linear hardening or a user-defined function to define the hardening behavior. The strain increment is obtained from the total stretch update
\begin{equation}
\Delta \varepsilon = \varepsilon  - \varepsilon_{old} \, .
\end{equation}
The trial stress is estimated as
\begin{equation}
\sigma^{tr} = \sigma_{old} + E \Delta \varepsilon \, .
\end{equation}

The yield condition is determined as
\begin{equation}
f = |\tilde \sigma^{tr}| - E \Delta \varepsilon^p - r -\sigma_y = 0 \, ,
\end{equation}
where $E$ is the Young's modulus, $r$ is the hardening function and $\sigma_y$ is the yield stress. When the trial stress is outside of the yield envelop the stresses are brought down using the iterative Newton method.
In the case of linear hardening, the hardening function is defined as $r=h |\varepsilon^p|$ with $h$ being the hardening constant. In this case, the hardening variable at the beginning of the iterative process is obtained as
\begin{equation}
r^{(k)} = r_{old} + h  (\Delta \varepsilon^p)^{(k)} \, .
\end{equation}
The plastic strain increment is computed as
\begin{equation}
d\Delta \varepsilon^p = \frac{f}{\frac{df}{d\Delta \varepsilon^p}} = \frac{(|\tilde \sigma^{tr}| - E (\Delta \varepsilon^p)^{(k)} - r^k -\sigma_y)}{E + h} = 0 \, .
\end{equation}
The plastic strain for the next iteration is updated
\begin{equation}
(\Delta \varepsilon^p)^{(k+1)} = (\Delta \varepsilon^p)^{(k)} + d\Delta \varepsilon^p \, .
\end{equation}
The iterative process continues until the updated stress lies on the yield curve.
Then the elastic strain is updated as
\begin{equation}
\Delta \varepsilon^e = \Delta \varepsilon - \Delta \varepsilon^p \, .
\end{equation}
The updated axial stress is calculated
\begin{equation}
\sigma_a = \sigma_{old} + E \Delta \varepsilon^e \, .
\end{equation}

#### Example Input Syntax





### PorosityFromStrain


#### Description

`PorosityFromStrain` computes the porosity, $f$, from the combined inelastic strain, $\epsilon_{in}$:
\begin{equation}
  f = (1.0 - f^{old}) * ({\epsilon}_{in} - {\epsilon}_{in}^{old}).\text{tr} + f^{old};
\end{equation}

Here, $\epsilon_{in}$ is typically computed by [ComputeMultipleInelasticStress](ComputeMultipleInelasticStress.md).

#### Example Input Files






### Power Law Creep Stress Update


#### Description


The increment of inelastic strain is computed from the creep rate in this class.

\begin{equation}
  \label{eq:power_law_creep}
  \dot{\epsilon} = \left( \sigma^{trial}_{effective} - 3 G \Delta p \right)^n exp \left( \frac{-Q}{RT} \right) \left(t - t_o \right)^m
\end{equation}

where $\sigma^{trial}_{effective}$ is the scalar von Mises trial stress, $G$ is
the isotropic shear modulus, $Q$ is the activation energy, $R$ is the universal
gas constant, $T$ is the temperature, $t$ and $t_o$ are the current and initial
times, respectively, and $n$ and $m$ are exponent values.

This class calculates an effective trial stress, an effective creep strain rate
increment and the derivative of the creep strain rate, and an effective scalar
inelastic strain increment; these values are passed to the
[ADRadialReturnStressUpdate](/ADRadialReturnStressUpdate.md) to compute the radial
return stress increment. This isotropic plasticity class also computes the
plastic strain as a stateful material property.

This class is based on the implicit integration algorithm in
[!cite](dunne2005introduction) pg. 146 - 149.

`PowerLawCreepStressUpdate` must be run in conjunction with an inelastic
strain return mapping stress calculator such as
[ADComputeMultipleInelasticStress](ADComputeMultipleInelasticStress.md)





### Power Law Softening


#### Description

The material `PowerLawSoftening` computes the reduced stress and stiffness along
the direction of a crack according to a power law equation. The computed
reduced stiffness softens the tensile response of the material once the principle
stress applied to a material exceeds the cracking stress threshold of the material.

As with the other smeared cracking softening models, which all follow the
nomenclature convention of using the `Softening` suffix, this model is intended
to be used with the [ComputeSmearedCrackingStress](/ComputeSmearedCrackingStress.md)
material.

##### Softening Model

The tensile stress response to cracking is calculated as a function of the number
cracks, where the number of cracks reduces the stress response of the cracked material.
The calculated stress is the principle stress in the single direction of the crack.
\begin{equation}
  \label{eqn:power_law_softening_stress}
  \sigma = k E \epsilon_{principle}
\end{equation}
where $k$ is the reduction factor applied to the initial stiffness each time a
new crack initiates, $E$ is the Young's modulus, and $\epsilon_{principle}$ is the
strain along the direction of the crack.
The reduction factor in [eqn:power_law_softening_stress] is a function of the
number of cracks
\begin{equation}
  \label{eqn:reduction_factor}
  k = k_0 \left( k_r\right)^n
\end{equation}
where $k_0$ is the initial cracking reduction factor and $n$ is the number of cracks.
The form of [eqn:reduction_factor] gives the `PowerLawSoftening` model its name.

In the context of the smeared cracking modeling approach, individual cracks are
not tracked; therefore, [eqn:reduction_factor] is approximated by a single
constant input parameter.
The user should consult additional resources to determine a reasonable value for
the initial stiffness reduction factor.


#### Example Input File


`PowerLawSoftening` must be run in conjunction with the fixed smeared cracking material model as shown below:






### Radial Return Stress Update

Base class which calculates the effective inelastic strain increment required to return the isotropic
stress state to a J2 yield surface.  This class is intended to be a parent class for classes with
specific constitutive models.


##### Algorithm References

The radial return mapping method, introduced by Simo and Taylor (1985), uses a von Mises yield
surface to determine the increment of plastic strain necessary to return the stress state to the
yield surface after a trial stress increment takes the computed stress state across the yield
surface.  Because the von Mises yield surface in the deviatoric stress space has the shape of a
circle, the _plastic correction stress_ is always directed towards the center of the yield surface
circle.

In addition to the [!cite](simo2006computational) textbook, [!cite](dunne2005introduction) is an excellent reference for users working
with the `RadialReturnStressUpdate` materials; several of the isotropic plasticity and creep
effective plastic strain increment algorithms are taken from [!cite](dunne2005introduction).

##### The Radial Return Stress Update Description

The stress update materials are not called by MOOSE directly but instead only by other materials
using the `computeProperties` method.  For the `RadialReturnStressUpdate` materials, this calling
material is [ComputeMultipleInelasticStress](ComputeMultipleInelasticStress.md).  Separating the call
to the stress update materials from MOOSE allows us to iteratively call the stress update materials
as is required to achieve convergence.

#### Radial Return Algorithm Overview

       style=width:30%;margin-left:2%;float:right
       caption=A trial stress is shown outside of the deviatoric yield surface and the radial return
                 stress which is normal to the yield surface.


In the case of isotropic linear hardening plasticity, with the hardening
function $r = hp$ , the effective plastic strain increment has the form:
\begin{equation}
 d \Delta p = \frac{\sigma^{trial}_{effective} - 3 G \Delta p - r - \sigma_{yield}}{3G + h}
\end{equation}
where G is the isotropic shear modulus, and $\sigma^{trial}_{effective}$ is the scalar von Mises trial stress.

Once convergence has been reached on the scalar inelastic strain increment, the full inelastic strain
tensor is calculated.
\begin{equation}
\Delta \epsilon^{inelastic}_{ij} = \frac{3}{2} \Delta p^{(t+1)} \frac{dev(\sigma^{trial}_{ij})}{\sigma^{trial}_{effective}}
\end{equation}

The elastic strain is calculated by subtracting the return mapping inelastic
strain increment tensor from the mechanical strain tensor.  Mechanical strain is
considered as the sum of the elastic and inelastic (plastic, creep, etc)
strains.
\begin{equation}
\epsilon_{total} = \epsilon_{mechanical} + \epsilon_{eigenstrain}
= \left( \epsilon_{elastic} + \epsilon_{inelastic} \right) + \epsilon_{eigenstrain}
= \epsilon_{elastic} + \left( \epsilon_{plastic} + \epsilon_{creep} + \epsilon_{damage}  \right) + \epsilon_{eigenstrain}
\end{equation}

The final inelastic strain is returned from the radial return stress update
material, and `ComputeMultipleInelasticStress` computes the stress, with a
return mapping stress increment following elasticity theory for finite strains.
The final stress is calculated from the elastic strain increment.
\begin{equation}
\sigma^{new}_{ij} = C_{ijkl} \left( \Delta \epsilon^{elastic}_{kl} + \epsilon^{old-elastic}_{kl} \right)
\end{equation}

When more than one radial recompute material is included in the simulation, as
in Combined Power Law Creep and Linear Strain Hardening,
`ComputeMultipleInelasticStress` will iterate over the change in the calculated
stress until the return stress has reached a stable value.

Users can print out any of these strains and stresses using the `RankTwoAux` as
described on the [Visualizing Tensors](/solid_mechanics/VisualizingTensors.md)
page.

#### Substepping capability

Regular use of the radial return mapping triggers one instance of the return to the yield surface that spans
the entire system wide time step. While the material time step limiter discussed in [ComputeMultipleInelasticStress](ComputeMultipleInelasticStress.md) can
effectively limit the time step size to achieve the desired convergence or integration error properties, it does so at
the expense of global solves and discarded time steps. An alternative to the material time step limiter is
"substepping", which subdivides the current time step into substeps which are solved sequentially within `ComputeMultipleInelasticStress`.

To enabled substepping, the user needs to set the `use_substepping` parameter to `INCREMENT_BASED` or `ERROR_BASED`. Note, not all inelastic models support substepping, but
it is expected that this capability to be gradually extended to more models.

`INCREMENT_BASED` substepping calculates the number of substeps by comparing the effective elastic strain increment to the `max_inelastic_increment` and using
that ratio to determine the number of substeps. In essence:

\begin{equation}
\text{number of substeps} = \frac{\Delta \epsilon^{\text{elastic}}}{\text{max\_inelastic\_increment} \cdot \text{substep\_tolerance}}
\end{equation}

where substep_strain_tolerance` and `max_inelastic_increment` are user parameters.

With `ERROR_BASED` substepping the following formula will be uses to compute the number of substeps:

\begin{equation}
\text{number of substeps} = \frac{\Delta \epsilon^{\text{elastic}}}{\text{substep\_tolerance}}
\end{equation}

This latest formula is directly based on the creep numerical integration error. The `substep_strain_tolerance` can be considered as the maximum creep numerical integration error
allowed by substepping. A value of $1.0\cdot10^4$ will work for many cases. An example of this option looks as follows:

```
    use_substepping = ERROR_BASED
    substep_strain_tolerance = 1.0e-4
```

The `adaptive_substepping` parameter enables adaptive substepping, where the number of substeps is successively doubled until the
return mapping model successfully converges or the doubled number of substeps exceeds the user specified maximum number of substeps.

#### Writing a New Stress Update Material

New radial return models must inherit from `RadialReturnStressUpdate` and must
overwrite the six virtual methods.

- +initQpStatefulProperties+: Set the initial values for all new material properties that are not
  initialized by an input parameter; generally the material properties initialized in this method are
  all set to zero.
- +computeStressInitialize+: Calculate the initial trial stress state, the yield surface value, and
  any hardening or softening parameters at the start of the simulation time increment.
- +computeResidual+: In each iteration over the inelastic strain increment, calculate the value of
  the effective scalar trial stress subtracted by the yield surface function.
- +computeDerivative+: In each iteration over the inelastic strain increment, calculate the
  derivative of the yield surface function with respect to the inelastic strain increment.
- +iterationFinalize+: Store the value of the inelastic strain increment at the end of each
  iteration.
- +computeStressFinalize+: Update the stress after convergence on the inelastic strain increment has
  been reached.

Additionally, new radial return methods must also overwrite a single method from
the MOOSE `Material` class.

- +resetQpProperties+: Set the material property used in the iteration, usually $\Delta p$, to zero
  at the start the iteration.  This method is necessary to avoid incorrect material property values.

More details on how to write the equivalent yield surface equation for a creep
model are given in Dunne and Petrinic.

<!-- !syntax children /Materials/RadialReturnStressUpdate -->


### Rank Two Tensor Component


#### Description

This is a Material model used to extract components of a rank-2 tensor in a
Cartesian coordinate system. This can be used regardless of the coordinate
system used by the model.

This Material model is set up by
[SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md) automatically
when stress components are requested in the generate_output parameter, but can
also be set up directly by the user.  

The `RankTwoCartesianComponent` takes as arguments the values of the
`index_i` and the `index_j` for the single tensor component to save into an
MaterialProperty.  [eq:rank2tensor_component_indices] shows the index values
for each Rank-2 tensor component.

\sigma_{ij} \implies \begin{bmatrix}
                      \sigma_{00} & \sigma_{01} & \sigma_{02} \\
                      \sigma_{10} & \sigma_{11} & \sigma_{12} \\
                      \sigma_{20} & \sigma_{21} & \sigma_{22}
                      \end{bmatrix}




### Rank Two Cylindrical Component


#### Description

This is a Material model used to extract components of a rank-2 tensor in a
cylindrical coordinate system. This can be used regardless of the coordinate
system used by the model.

This Material model is set up by
[SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md) automatically
when stress components are requested in the generate_output parameter, but can
also be set up directly by the user.  This class provides the ability to compute
hoop, radial, and axial stress ($\boldsymbol{\sigma}$) and strain
($\boldsymbol{\epsilon}$)quantities for a Rank-2 tensor, as described in
[RankTwoScalarTools](RankTwoScalarTools.md).  

The component of the rank-2 tensor extracted is stored as a scalar material
property, which allows for it to be more accurately represented in calculations
that use this quantity at quadrature points than would be possible using the
related [RankTwoScalarAux](RankTwoScalarAux.md)




### Rank Two Directional Component


#### Description

This is a Material model used to extract components of a rank-2 tensor in a
Cartesian coordinate system based on an input direction. This can be used
regardless of the coordinate system used by the model.

This Material model is set up by
[SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md) automatically
when stress components are requested in the generate_output parameter, but can
also be set up directly by the user. This class calculates the component of a
Rank-2 tensor, $T$, in the direction selected by the user as shown by, as
described in [RankTwoScalarTools](RankTwoScalarTools.md).  


The component of the rank-2 tensor extracted is stored as a scalar material
property, which allows for it to be more accurately represented in calculations
that use this quantity at quadrature points than would be possible using the
related [RankTwoScalarAux](RankTwoScalarAux.md)




### Rank Two Invariant


#### Description

This is a Material model used to extract an invariant of a rank-2 tensor in a
Cartesian coordinate system. This can be used regardless of the coordinate
system used by the model.

This Material model is set up by
[SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md) automatically
when stress components are requested in the generate_output parameter, but can
also be set up directly by the user. This class provides the ability to compute
VonMises, Effective, Hydrostatic, L2norm, Volumetric, Triaxiality, MaxShear,
StressIntensity, First, Second, and Third Invariant as well as Max, Mid, and Min
Primary stresses ($\boldsymbol{\sigma}$) and strains
($\boldsymbol{\epsilon}$)quantities for a Rank-2 tensor, as described in
[RankTwoScalarTools](RankTwoScalarTools.md).  


The component of the rank-2 tensor extracted is stored as a scalar material
property, which allows for it to be more accurately represented in calculations
that use this quantity at quadrature points than would be possible using the
related [RankTwoScalarAux](RankTwoScalarAux.md)




### Rank Two Spherical Component


#### Description

This is a Material model used to extract components of a rank-2 tensor in a
Spherical coordinate system. This can be used regardless of the coordinate
system used by the model.

This Material model is set up by
[SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md) automatically
when stress components are requested in the generate_output parameter, but can
also be set up directly by the user.  This class provides the ability to compute
spherical_hoop and spherical_radial ($\boldsymbol{\sigma}$) and strain
($\boldsymbol{\epsilon}$)quantities for a Rank-2 tensor, as described in
[RankTwoScalarTools](RankTwoScalarTools.md).  

The component of the rank-2 tensor extracted is stored as a scalar material
property, which allows for it to be more accurately represented in calculations
that use this quantity at quadrature points than would be possible using the
related [RankTwoScalarAux](RankTwoScalarAux.md)




### Scalar Material Damage


#### Description

`ScalarMaterialDamage` is a model to define the effect of damage on the stress and stiffness in a continuum damage mechanics setting. It does not directly compute the stress, but must be used in conjunction with [ComputeDamageStress](/ComputeDamageStress.md).

This model is a scalar damage model that does not compute the evolution of damage by itself, but relies on another material model to supply a scalar damage index, which can vary between 0 (undamaged) and 1 (fully damaged). This model is mostly intended for use in testing the continuum damage mechanics system, but could be used for modeling physical behavior if that were included in the model supplying the damage index.





### Strain Energy Density


#### Description

This material computes the strain energy density, $u$, which is defined as the
area underneath the stress-strain curve:
\begin{equation}
  \label{eqn:sed_integral_def}
  u = \int_x \frac{1}{2} \sigma : d \epsilon
\end{equation}
where $\sigma$ is the stress and $\epsilon$ is the mechanical strain. In the
solid mechanics module we define the mechanical strain as the sum of the
elastic and inelastic (e.g. plastic, creep) strain without the eigenstrains.

The strain energy density can be calculated either in total or in incremental
form, based on the strain measured applied.
In the incremental form the strain energy density integral takes the form
\begin{equation}
  \label{eqn:incremental_sed}
  u = u_{old} + \frac{1}{2} \sigma : \Delta \epsilon +
      \frac{1}{2}\sigma_{old} : \Delta \epsilon
\end{equation}
where $\Delta \epsilon$ is the mechanical strain increment.

The +`StrainEnergyDensity`+ class is formulated only for monotonic loading and
should not be used to calculate the strain energy density for cyclic loading cases.

#### Example Input File






### Strain Energy Rate Density


#### Description

This material computes the strain energy rate density, $\dot{u}$, which is defined as the
time rate of the strain energy density (see [`StrainEnergyDensity`](/StrainEnergyDensity.md)):
\begin{equation}
  \label{eqn:sed_integral_def}
  \dot{u} = \int \boldsymbol{\sigma} : \textrm{d}\dot{\boldsymbol{\epsilon}}
\end{equation}
where $\boldsymbol{\sigma}$ is the stress tensor and $\dot{\boldsymbol{\epsilon}}$ is the strain rate. This expression is multiplied by $\frac{n}{n+1}$, where $n$ is the power law exponent of the material provided though the `inelastic_models` input parameter. This factor decreases the strain energy rate density to better capture the strain rate field around a crack under steady-state creep growth. This factor is primarily used to compute the C(t) integral, see [`FractureIntegrals`](/FractureIntegrals.md).

The strain rate here is the sum of the elastic and inelastic (e.g. plastic, creep) strain rates.

This class is available both for manually coded Jacobian and automatic differentiation strategies.

#### Example Input File






### StressBasedChemicalPotential


The chemical potential $\mu$ is computed from the previous time step value of the stress tensor $\boldsymbol{\sigma}_{old}$,
the direction tensor $\boldsymbol{D}$ and a user-specified prefactor Real-value material property $f$.

\mu = -\boldsymbol{\sigma}_{old}::\boldsymbol{D} * f

The derivative of the chemical potential with regards to a concentration variable $c$ is only computed
if the [!param](/Materials/StressBasedChemicalPotential/c) parameter for the concentration variable is passed,
and only captures the dependency of $f$ on $c$.

\dfrac{\partial \mu}{\partial c} = -\boldsymbol{\sigma}_{old}::\boldsymbol{D} * \dfrac{\partial f}{\partial c}

Because the previous time step value of the stress is used, this coupling is naturally explicit and first order in time
with regards to the stress.




### Sum Tensor Increments


#### Descriptions

The `SumTensorIncrements` material updates a strain tensor by summing coupled
strain increments as specified by the user.
\begin{equation}
  \label{eqn:sum_increment_tensor}
  \boldsymbol{T} = \boldsymbol{T}_{old} + \sum_n \Delta D_n
\end{equation}
where $\boldsymbol{T}$ is the calculated tensor and $\boldsymbol{D}_n$ are the coupled tensor
increments.

#### Example Input File


where the argument for the `coupled_tensor_increment_names` parameter in the
`SumTensorIncrements` material is the same as the property parameter
`property_name` argument as shown






### Temperature Dependent Hardening Stress Update


#### Description


#### Isotropic Plasticity

`TemperatureDependentHardeningStressUpdate` is formulated in the same manner as
[IsotropicPlasticityStressUpdate](/IsotropicPlasticityStressUpdate.md) such that
the effective plastic strain increment has the form
\begin{equation}
  \label{eqn:effective_strain_incr}
  d \Delta p = \frac{\sigma^{trial}_{effective} - 3 G \Delta p - r - \sigma_y}{3G + h}
\end{equation}
where $G$ is the isotropic shear modulus, $\sigma^{trial}_{effective}$ is the
scalar von Mises trial stress, $\sigma_y$ is the yield stress, $r$ is the
hardening function, and $h$ is the derivative of the hardening function with
respect to the trial stress.

##### Temperature Dependent Hardening

The temperature dependence in [eqn:effective_strain_incr] is captured in the
hardening function and the hardening function derivative.
\begin{equation}
  \label{eqn:hardening_function}
  \begin{aligned}
    r & = \left(1 - T_{hf} \right) \cdot \mathit{f} \left( i_{low}, \Delta p \right)
          + T_{hf} \cdot \mathit{f} \left( i_{upper}, \Delta p \right) - \sigma_y \\
    h & = \left(1 - T_{hf} \right) \cdot \mathit{f} \left( i_{low}, \Delta p_{old} \right)
          + T_{hf} \cdot \mathit{f} \left( i_{upper}, \Delta p_{old} \right)
  \end{aligned}
\end{equation}
where $T_{hf}$ is the relative temperature fraction within the lower and upper
temperature bounds of the current piecewise function section, $i_{low}$ is the
index of the lower temperature bound and its corresponding hardening function, and
$i_{upper}$ is the upper temperature bound and hardening function index, and
$\Delta p$ and $\Delta p_{old}$ are the current and old effective strain
increments, respectively.
The relative temperature fraction is defined as
\begin{equation}
  \label{eqn:temperature_fraction}
  T_{hf} = \frac{T - T(i_{low})}{T(i_{upper}) - T(i_{low})}
\end{equation}
where $T$ is the current temperature, and $i_{low}$ and $i_{high}$ are the same
indices as defined for [eqn:hardening_function].
The $T_{hf}$ value is used in [eqn:hardening_function] to interpolate the
hardening values.

This class, `TemperatureDependentHardeningStressUpdate`, calculates an effective
trial stress, an effective scalar plastic strain increment, and the derivative
of the scalar effective plastic strain increment; these values are passed to the
[RadialReturnStressUpdate](/RadialReturnStressUpdate.md) to compute the radial
return stress increment.  The plastic strain as a stateful material property.


#### Example Input File


where the arguments for the `hardening_functions` parameter are defined in the
`Functions` block of the input file:



`TemperatureDependentHardeningStressUpdate` must be run in conjunction with the
inelastic strain return mapping stress calculator as shown below:






### Tensile Stress Update


#### Theory

Tensile, or Rankine, plasticity is designed to simulate a material
that fails when the maximum principal stress exceeds the material's tensile
strength.  Its yield function is therefore

\begin{equation}
  f =  \sigma_{III} - T \ ,
\end{equation}

where $\sigma_{III}$ is the maximum principal
stress (the largest eigenvalue of the stress tensor) and $T$ is the
tensile strength.

Often the maximum principal is denoted by $\sigma_{I}$, but the notation used in this document is motivated by the C++ code.  The code uses the `dsymmetricEigenvalues` method of `RankTwoTensor` and this orders the eigenvalues from smallest to greatest.

One yield function is sufficient because of the definition
$\sigma_{I}\leq\sigma_{II}\leq\sigma_{III}$.  For instance, if during
the return-map process both $\sigma_{II}$ and $\sigma_{III}$ exceed
$T$ the corresponding admissible configuration is that both of them
are equal to $T$.  While one yield function is sufficient, it is
convenient to use three yield functions in total:

\begin{equation}
\begin{split}
  f_{0} & = \sigma_{III} - T \\
  f_{1} & = \sigma_{II} - T  \\
  f_{2} & = \sigma_{I} - T   \\
\end{split}
\end{equation}


The return-map algorithm first rotates $\sigma$ from the physical
frame to the
principal-stress frame (where $\sigma = \text{diag}(\sigma_{I}, \sigma_{II},
\sigma_{III})$).  The rotation matrices used are assumed not to change
during the return-map process: only $\sigma_{I}$, $\sigma_{II}$ and
$\sigma_{III}$ change.  Therefore, at the end of the
return-map process these rotation matrices may be used to find the
final stress in the physical frame.

The three yield functions are smoothed using the
method encoded in [MultiParameterPlasticityStressUpdate.md].

Additional considerations can be found in the [MultiParameterPlasticityStressUpdate.md]
or in the theory manual  (at [solid_mechanics/doc/theory/tensile.pdf](https://github.com/idaholab/moose/modules/solid_mechanics/doc/theory/tensile.pdf)).





### ThermalFractureIntegral


#### Description

This model computes the summation of the derivative of the eigenstrains with respect to temperature. This quantity is used in the computation of fracture integrals in the presence of temperature. This object is not typically defined by a user, but is set up automatically using the [DomainIntegralAction](/DomainIntegralAction.md) when temperature is a coupled variable.




### TwoPhaseStressMaterial


The `TwoPhaseStressMaterial` is used in coupled phase field - solid mechanics calculations to compute
the mechanical deformation of two phase regions.

The switching (mixing) coefficient which blends the two phase stresses together must be provided
as a material property, using the [!param](/Materials/TwoPhaseStressMaterial/h) parameter.

The global stress is then defined as

\boldsymbol{\sigma}_g(\vec{r}) = h(\vec{r}) \boldsymbol{\sigma}_{b}(\vec{r}) + (1 - h(\vec{r})) \boldsymbol{\sigma}_{a}(\vec{r}) + \boldsymbol{\sigma}_{g,extra}(\vec{r})

where $h$ is the switching function, $\boldsymbol{\sigma}_{b}$ and $\boldsymbol{\sigma}_{a}$ the stresses in the phase B and A respectively,
$\boldsymbol{\sigma}_{g,extra}$ an extra global stress, and $\vec{r}$ denotes the spatial dependence.

The material also defines the (rank four tensor of) derivatives of the stress with regards to the strain, accounting
for both phases' derivatives but neglecting any dependence of the extra global stress.




### VolumeDeformGradCorrectedStress


#### Description

This class takes the stress from the previous configuration and the deformation gradient as input, and computes the stress in the current configuration. The jacobian in the current configuration is same as that in the previous configuration.





### Wave Speed


#### Description

The material `WaveSpeed` computes an approximate local
wave speed for use in explicit dynamic simulations.





## neml2

## nodalkernels

### Nodal Gravity


### Description

This NodalKernel computes the gravitational force proportional to nodal mass in the coordinate direction corresponding to the assigned variable. A constant gravitational acceleration can be provided using `gravity_value` parameter and an acceleration varying in space and time can be provided using the `function` parameter. A constant mass for all the nodes in the given boundary can be provided using the `mass` parameter. Otherwise, a CSV file containing nodal positions and the corresponding nodal masses can also be provided using the `nodal_mass_file` parameter.

For example, the below csv file has two rows with 4 columns. The first three columns correspond to the nodal positions in the global coordinate system and the last column corresponds to the nodal mass. Each row contains position and mass information for one node.





### Nodal Rotational Inertia


### Description

This class computes the $i^{th}$ component of the torque due to rotational inertia. Inertia proportional Rayleigh damping is also computed by this NodalKernel. Please refer to [C0TimoshenkoBeam](/C0TimoshenkoBeam.md) for details.




### Nodal Translational Inertia


### Description

This NodalKernel computes the $i^{th}$ component of translational inertial force proportional to nodal mass. Mass proportional Rayleigh damping is also computed by this NodalKernel. A constant mass for all the nodes in the given boundary can be provided using the `mass` parameter. Otherwise, a CSV file containing nodal positions and the corresponding nodal masses can also be provided using the `nodal_mass_file` parameter. Please refer to [C0TimoshenkoBeam](/C0TimoshenkoBeam.md) for details.

For example, the below csv file has two rows with 4 columns. The first three columns correspond to the nodal positions in the global coordinate system and the last column corresponds to the nodal mass. Each row contains position and mass information for one node.






## physics

### SolidMechanics Dynamic Physics


#### Description

This action creates the [DynamicStressDivergenceTensors](/DynamicStressDivergenceTensors.md) kernel input blocks in all coordinate directions. More information about the usage of this action can be found at [Dynamics](/Dynamics.md)


### Solid Mechanics QuasiStatic Physics

#### Description

The solid mechanics QuasiStatic Physics simplifies the input file syntax for creating a solid mechanics model. See the description, example use, and parameters on the [SolidMechanics/QuasiStatic](/Physics/SolidMechanics/QuasiStatic/index.md) action system page.

## postprocessors

### AsymptoticExpansionHomogenizationElasticConstants


#### Description

This `PostProcessor` computes
\begin{equation}
D_{ijkl}^\text{H} = \frac{1}{\left|\text{Y}\right|}\int_\text{Y}D_{ijkl} \left(\bm{I}+\frac{\partial\chi^{mn}_\kappa}{\partial y_l}\right)\;d\bm{y}.
\end{equation}
where $D_{ijkl}^\text{H}$ is the homogenized elasticity tensor.  It is used in conjunction with the [Stress Divergence](StressDivergenceTensors.md) `Kernel` and the [Asymptotic Expansion Homogenization Elastic Constants](AsymptoticExpansionHomogenizationKernel.md) `Kernel` to compute homogenized elasticity tensor values according to
\begin{equation}
\int_\text{Y}\frac{\partial v_i}{\partial y_j} D_{ijkl} \frac{\partial\chi_\kappa^{mn}}{\partial y_l}\text{d}\bm{y} = \int_\text{Y} \frac{\partial v_i}{\partial y_j}D_{ijkl}\;\text{d}\bm{y}
\end{equation}
where $D_{ijkl}$ is the elasticity tensor.  See [!cite](hales15homogenization).

#### Example Input File Syntax







### Cavity Pressure Postprocessor


#### Description

The `CavityPressurePostprocessor` is used to store the value of the initial moles or the current pressure for an internal volume.

These quantities are calculated by the [CavityPressureUserObject](/CavityPressureUserObject.md). `CavityPressurePostprocessor` is built by [CavityPressurePPAction](/BCs/CavityPressure/index.md).




### Crack Front Data


#### Description

This object is a utility function used to output values of nodal variables at nodes along a crack front used in a fracture domain integral calculation. This is useful for tying information about solution variables to the computed fracture integrals at specific points. The definition of the crack points must be provided using a [CrackFrontDefinition](/CrackFrontDefinition.md) object, which is typically set up automatically using a [DomainIntegralAction](/DomainIntegralAction.md).

#### Example Input File Syntax





### Critical Time Step Postprocessor


#### Description

The `CriticalTimeStep` postprocessor is used to compute the value of the minimum
time step for explicit integration scheme. Please refer to
[CriticalTimeStepMath](/CriticalTimeStepMath.md) for the theoretical details.




### Mass


The `ADMass` postprocessor may be used with a density [AD](automatic_differentiation/index.md) material
property.




### Material Tensor Average


#### Description

The `MaterialTensorAverage` postprocessor computes the volume average of the
Rank-2 tensor component specified by the user.
\begin{equation}
  \label{eqn:volume_integal_tensor_comp}
  S^{avg} = \int_V T_{ij} dV / \int_V dv
\end{equation}
where $S^{avg}$ is the computed volume average quantity and $T_{ij}$ is the
tensor component selected by the user.
The tensor component indices, $i$ and $j$, range from 0 to 2 as shown in the
reference tensor
\begin{equation}
  \label{eqn:ref_tensor}
  T_{ij} = \begin{bmatrix}
            0,0 & 0,1 & 0,2 \\
            1,0 & 1,1 & 1,2 \\
            2,0 & 2,1 & 2,2
            \end{bmatrix}
\end{equation}

The parameter `use_displaced_mesh` controls the volume utilized to compute the average. If `use_displaced_mesh=true` the average is compute utilizing the deformed volume, if `use_displaced_mesh=false` (default) the average is compute utilizing the initial volume.

#### Example Input File





### Material Tensor Integral


#### Description

The `MaterialTensorIntegral` postprocessor computes the volume integral of the
Rank-2 tensor component specified by the user.
\begin{equation}
  \label{eqn:volume_integal_tensor_comp}
  S^{int} = \int_V T_{ij} dV
\end{equation}
where $S^{int}$ is the computed volume integral quantity and $T_{ij}$ is the
tensor component selected by the user.
The tensor component indices, $i$ and $j$, range from 0 to 2 as shown in the
reference tensor
\begin{equation}
  \label{eqn:ref_tensor}
  T_{ij} = \begin{bmatrix}
            0,0 & 0,1 & 0,2 \\
            1,0 & 1,1 & 1,2 \\
            2,0 & 2,1 & 2,2
            \end{bmatrix}
\end{equation}

This class is most often used in
[Generalized Plane Strain](modules/solid_mechanics/generalized_plane_strain.md)
simulations to calculate the out-of-plane stress component.

#### Example Input File





### Material Time Step Postprocessor


#### Description

The `MaterialTimeStepPostprocessor` works in conjunction with material models to
compute the appropriate maximum time step allowed by individual material models.
For creep or plasticity models, this maximum time step size is governed by an
allowable inelastic strain increment, but a variety of methods could be used by
individual material models to compute their acceptable time step. For continuum
damage models, the maximum time step size is governed by the allowable increment
of damage over a single time step.

##### Creep Strain Example

The maximum time step size is a numerical tool used to ensure the calculation of
physically reasonable inelastic strains and to improve convergence of the inelastic
material model. As an example, the maximum allowable time step computation for
a creep model has the form
\begin{equation}
  \label{eqn:limiting_ts}
  \Delta t |_{limit} = \Delta t \cdot \frac{\Delta \epsilon^{inel}_{max}}{\Delta \epsilon^{inel}}
\end{equation}
where $\Delta \epsilon^{inel}_{max}$ is the maximum effective inelastic strain
increment (a default value of 1e-4), set by the user, and $\Delta \epsilon^{inel}$
is the current scalar effective inelastic strain increment.

##### Mesh-Wide Evaluation

The `MaterialTimeStepPostprocessor` collects the time step limitations from all
of the quadrature points in the simulation mesh and stores the minimum value.
This minimum allowable time step size value is then used by the
[IterationAdaptiveDT](/IterationAdaptiveDT.md)
to restrict the time step size based on the limit calculated in the previous
time step.

Note that the [IterationAdaptiveDT](/IterationAdaptiveDT.md)
will apply the limiting time step size value from the `MaterialTimeStepPostprocessor`
only if that value is less than maximum time step size value calculated by the
internal [IterationAdaptiveDT](/IterationAdaptiveDT.md)
adaptive time step size algorithm.

The value of the maximum allowable time step as collected by the +`MaterialTimeStepPostprocessor`+
is enforced in the next simulation time step.

##### Minimum Time Step Calculated in Material Models

The calculation of the maximum allowable timestep is dependent on each individual
material: both the maximum allowable inelastic strain increment and the method of
calculating the current inelastic strain, [eqn:limiting_ts], are defined separately
for each material.
Given this material dependent nature, the maximum time step value is calculated
separately by the [RadialReturnStressUpdate](/RadialReturnStressUpdate.md)
materials at each quadrature point.
The `MaterialTimeStepPostprocessor` then determines the minimum time step size
value from all of the quadrature points in the simulation.

Initially the value of the maximum time step size is set to `std::numeric_limits<Real>::max()`.
Once the inelastic material model begins to calculate inelastic strain, the value
of the allowable time step size varies with the inelastic strain computation.

The limiting time step size is stored within a material property called `material_timestep_limit`.
This material property can be set up either by the
[ComputeMultipleInelasticStress](/ComputeMultipleInelasticStress.md) model (for creep
or plastic strains) or the [ComputeDamageStress](/ComputeDamageStress.md) for
continuum damage models.

##### Minimum Time Step Size Based on Number of Elements in which a Property Changes

The allowable time step size can also be controlled by the total number of elements in which a
material property changes over the course of the time step. This can be used in the context
of continuum damage to limit the number of elements damaged at a single time step. To do so,
the user needs to define a scalar material property with the input parameter
`elements_changed_property` as well as the maximum acceptable number of elements changed
using the `elements_changed` input parameter. When these are defined, the
`MaterialTimeStepPostprocessor` will sweep over the entire mesh and count the number of
elements in which the selected property has changed at at least one quadrature point.
The limiting time step is then calculated using the ratio between the current number of
elements changed $N_{changed}$ and the maximum value $N_{max}$.

\begin{equation}
  \label{eqn:limiting_ts_count}
  \Delta t |_{limit} = \Delta t \cdot \frac{N_{changed}}{N_{max}}
\end{equation}

The user can define a `elements_changed_threshold` to detect a change in property.
This can be for example used to count the number of elements in which the damage increases
by at least a specific amount.

This method is optional and is only active if both `elements_changed_property`
and `elements_changed` are defined. The `MaterialTimeStepPostprocessor` then uses the
minimum between the value provided by the material model (see above) or by the number of elements
changed. If the input parameter `use_material_timestep_limit` is set to `false`, only the number
of elements changed is used.


#### Example Input File


The name of the `MaterialTimeStepPostprocessor` is passed to the `IterationAdaptiveDT`
as the argument for the `timestep_limiting_postprocessor` parameter


and the `max_inelastic_increment` parameter in the inelastic material model(s)
must be set to run the time step limit calculation.





### NormalBoundaryDisplacement


#### Description

`NormalBoundaryDisplacement` computes average or maximum normal displacement on a boundary.
It permits modes: `average absolute_average max absolute_max` which are as follows:

`average`:
\begin{equation}
  I = \frac{1}{S}\int_{\partial S} \vec{n}^T ~ \vec{d}  dS,
\end{equation}
where $S$ is the surface area, $\vec{n}$ is the normal vector, and $\vec{d}$ is the displacement vector.

`absolute_average`:
\begin{equation}
  I = \frac{1}{S} \int_{\partial S} \left | \vec{n}^T ~ \vec{d} \right|  dS.
\end{equation}

`max`:
\begin{equation}
  I = \max\limits_{S}  \vec{n}^T ~ \vec{d}  .
\end{equation}

`absolute_max`:
\begin{equation}
  I = \max\limits_{S}  \left | \vec{n}^T ~ \vec{d} \right|  .
\end{equation}




### PolarMomentOfInertia


#### Overview

This postprocessor computes the *polar moment of inertia* $J$ (or $I_z$) of a
surface with respect to a reference point (`origin`) and an axis of rotation
(`direction`). Its result is needed by the [Torque](Torque.md) boundary
condition.

#### Example Input File Syntax




### Side Reaction Postprocessor


#### Description

`SidesetReaction` computes the integral of the force $F$ along vector $\vec{e}$ acting on a sideset $\partial S$:

\begin{equation}
  F = \int_{\partial S} \vec{n}^T ~ \underline{\sigma}  \vec{e}  dS,
\end{equation}

where $\underline{\sigma}$ is the stress tensor.




### Torque Reaction


#### Description

The postprocessor `TorqueReaction` calculates the applied torque from the reaction forces, coupled as
AuxVariables, about a user specified axis of rotation.

TorqueReaction takes a scalar approach to calculating the sum of the acting torques by projecting
both the reaction force vector and the position vector (the coordinates of the node upon which the
force is applied) onto the axis of rotation and applying the Pythagorean theorem, as in a statics
course.  This scalar approach allows the postprocessor to accept any axis of rotation direction.

The torque from the reaction forces is calculated, as shown in [eq:calculate_torque_vector]
relative to the user specified axis of rotation origin and direction.
\begin{equation}
\label{eq:calculate_torque_vector}
  \begin{aligned}
    \boldsymbol{\tau} & = \hat{P}_n \times \mathcal{f} \\
    \hat{P}_n & = \left( P_c - P_o \right) - \frac{\left( P_c - P_o \right) \ cdot d}{|d|^2} \cdot d
  \end{aligned}
\end{equation}
where $\mathcal{f}$ is the applied reaction force vector, $P_c$ is the current node position, $P_o$
is the origin of the axis of rotation, and $d$ is the direction vector of the axis of rotation.  The
component of the torque acting along the user specified axis of rotation vector, $\tau_c$ is
calculated as [eq:calculate_torque_component]:
\begin{equation}
\label{eq:calculate_torque_component}
  \tau_c = \frac{\boldsymbol{\tau} \cdot d}{|d|^2} \ cdot d
\end{equation}
where $\boldsymbol{\tau}$ is the torque vector calculated in [eq:calculate_torque_vector] and
$d$ is the axis of rotation direction vector.

#### Example Input File Syntax

         block=Postprocessors/torque

A list of the AuxVariables which save the reaction forces must be provided to the `TorqueReaction` block.

         block=AuxVariables/saved_x

         block=AuxVariables/saved_y

The reaction force AuxVariables must also be computed using the tagging system to save the reactions to a separate vector in the stress divergence kernel, which is handled in this case using the `extra_vector_tags` parameter in the QuasiStatic Physics:

         block=Physics/SolidMechanics/QuasiStatic

The `TagVectorAux` AuxKernel is used to extract the saved components of the reaction vector from a tagged vector and put them in an AuxVariable. This shows how the $x$ component of this is extracted, and the others are handled in a similar manner:

         block=AuxKernels/saved_x




## scalarkernels

### Generalized Plane Strain Scalar Kernel


The `GeneralizedPlaneStrain` ScalarKernel assembles components of the residual and diagonal jacobian corresponding to a given scalar variable. The values of the residual and diagonal jacobian components are fetched from the [GeneralizedPlaneStrainUserObject](/GeneralizedPlaneStrainUserObject.md). This object is usually set up by the [GeneralizedPlaneStrainAction](SolidMechanics/GeneralizedPlaneStrain/index.md).

The equilibrium condition when the out-of-plane direction is the $x$-direction is given as
\begin{equation}
	\int_{A}{\sigma_{xx}dA} = \bar{N}_{xx}
\end{equation}

The equilibrium condition when the out-of-plane direction is the $y$-direction is given as
\begin{equation}
	\int_{A}{\sigma_{yy}dA} = \bar{N}_{yy}
\end{equation}

The equilibrium condition when the out-of-plane direction is the $z$-direction is given as
\begin{equation}
	\int_{A}{\sigma_{zz}dA} = \bar{N}_{zz}
\end{equation}


A detailed description of generalized plane strain formulation can be found in [here](solid_mechanics/generalized_plane_strain.md).





### GlobalStrain


#### Description

`GlobalStrain` solves the ODE equation setting the integral of the stress generated by applied load or volume change unrelated to deformation to zero. It stores the strain components into scalar variables of different order. Strain components calculated from this scalar kernel contributes towards the periodic strain. Combined with periodic displacements, this helps maintaining full strain periodicity.

It requires an input of the `UserObject` that calculates the integral value and corresponding jacobians.

Please refer to [GlobalStrainUserObject](/GlobalStrainUserObject.md) for information about the residual and jacobian calculation.


#### Example Input File Syntax





## timeintegrators

### DirectCentralDifference


#### Overview

`DirectCentralDifference` applies a time integrator for central difference in which the acceleration used for the solution update is calculated directly from the residual forces.

\begin{equation}
    \begin{aligned}
        \mathbf{a}_n &= \mathbf{M}^{-1}\mathbf{F}_n \\
        \mathbf{v}_{n+\frac{1}{2}} &= \mathbf{v}_{n-\frac{1}{2}} + \frac{\Delta t_{n-1}+\Delta t_n}{2}\mathbf{a}_n \\
        \mathbf{d}_{n+1} &= \mathbf{d}_{n-1} + \Delta t \mathbf{v}_{n+\frac{1}{2}}
    \end{aligned}
\end{equation}

The formulation assumes a constant acceleration between midpoints. An average between the old and current time step is used to increment midpoint velocity to account for changing time steps, which is the same [method used in Abaqus](https://classes.engineering.wustl.edu/2009/spring/mase5513/abaqus/docs/v6.6/books/gsx/default.htm?startat=ch03s02.html).

For example if,
\begin{equation}
    \begin{aligned}
         t_{n-1}&=1\\
         t_{n}&=2\\
         t_{n+1}&=2.5
    \end{aligned}
\end{equation}
then,
\begin{equation}
    \begin{aligned}
         t_{n-\frac{1}{2}}+\frac{\Delta t_{n-1} + \Delta t_{n}}{2} = 1.5+\frac{1+0.5}{2} = 2.25 = t_{n+\frac{1}{2}}
    \end{aligned}
\end{equation}

When using Dirichlet BCs, one must use the ([DirectDirichletBC](source/bcs/DirectDirichletBC.md),[DirectFunctionDirichletBC](source/bcs/DirectFunctionDirichletBC.md)) variations to enforce Dirichlet BC's properly.

Additionally, the time integrator must be used with `MassMatrix`, with a properly tagged mass matrix.

#### Example Input File Syntax

An example input file is shown below:

```

[GlobalParams]
    displacements = 'disp_x disp_y'
[]

[Kernels]
    [DynamicSolidMechanics]
        displacements = 'disp_x disp_y'
    []
    [massmatrix]
        type = MassMatrix
        density = 1
        matrix_tags = 'system'
        variable = disp_x
    []
    [massmatrix_y]
        type = MassMatrix
        density = 1
        matrix_tags = 'system'
        variable = disp_y
    []
[]

[Executioner]
    type = Transient

    [TimeIntegrator]
        type = CentralDifferenceDirect
        mass_matrix_tag = 'system'
    []
[]

```





## userobjects

### AbaqusUExternalDB


#### Description

The `AbaqusUExternalDB` user object is used to execute an _Abaqus UEXTERNALDB_
user function at various stages of the simulation. The functions can be coded in
Fortran (`.f` and `.f90` file extensions) or C/C++  (`.c` and `.C` file
extensions) and must be located in the `plugins` directory of the app.

Data exchange between UEXTERNALDB and UMAT may require to put both functions in
the same translation unit (source file).

A description of the input and output parameters of the UEXTERNALDB user subroutines
can be found in the Abaqus user manual.

MOOSE steps need to be defined in a [StepUserObject](/StepUserObject.md) and passed to
the `AbaqusUExternalDB` user object to correctly inform user routines.




### AbaqusUserElement


#### Description

The `AbaqusUserElement` user object is used to execute Abaqus UEL plugins that
users code with the purpose of building finite element kinematics (i.e.
interpolation functions), numerical treatments (e.g. locking correction),
Jacobian of the forces with respect to the displacements and the forces
themselves. These plug-ins can be coded in Fortran (`.f` and `.f90` file
extensions) or C/C++  (`.c` and `.C` file extensions) and can be located in the
`plugins` directory of the app or another appropriate directory such as
`examples`.

Note that one can combine a UEL routine with UMAT routines such that the UEL
coder is responsible for calling a UMAT routine compiled within the same
plugin.

When state variables are needed, the user is responsible for prescribing them
in the input files via `num_state_vars =` in the `AbaqusUserElement` user
object.

Various forms of verification of this interface have been carried out. The most
general is that defined by a beam subjected to external loading. The internal
forces are a function of strain-dependent state variables and two external
fields that vary spatially. Results between a UEL of triangular elements and
the corresponding model set up in MOOSE with a call to an equivalent UMAT routine
match to a relative tolerance of $10^{-6}$.

The input file that calls the UEL does so from the `AbaqusUserElement` block:


The equivalent input file that performs all the setup in MOOSE, except the computation
of internal forces, uses the `AbaqusUMATStress` plugin.


#### Interface

The UEL plugin entry function signature is defined in the `AbaqusUserElement.h` header file


##### Output parameters

The UEL routine sets `RHS`, `AMATRX`, `SVARS`, `ENERGY`, and `PNEWDT`

- `RHS` is the residual contribution for the DOFs associated with the current element
- `AMATRX` are the Jacobian contributions for the DOFs associated with the current element
- `SVARS` are stateful properties (persistent across timesteps) that are managed by the user object similar to stateful material properties in MOOSE
- `ENERGY` array of 6 energy quantities (currently not used by MOOSE)

  1. Kinetic energy.
  2. Elastic strain energy.
  3. Creep dissipation.
  4. Plastic dissipation.
  5. Viscous dissipation.
  6. Artificial strain energy stemming from e.g. artificial stiffness to control singular modes
  7. Electrostatic energy
  8. Incremental work done by loads applied through the UEL routine

- `PNEWDT` is a new recommended simulation time step (currently not used by MOOSE)

##### Input parameters

Please consult the Abaqus user manual for more documentation on the UEL plugin parameters.




### Cavity Pressure UserObject


#### Description

The `CavityPressureUserObject` is used to compute: both the number of initial moles from a gas
contained in an internal volume and the pressure exerted by a gas on the cavity boundary.  This
postprocessor is suitable only for ideal gases, which obey the ideal gas law:
\begin{equation}
  \label{eq:ideal_gas_law}
  P=\frac{nRT}{V}
\end{equation}
where $P$ is the internal pressure, $n$ is the moles of gas, $R$ is the ideal gas constant, $T$ is
the temperature, and $V$ is the volume of the cavity.  To compute the initial number of moles,
[eq:ideal_gas_law] is rearranged to solve for moles from an initial pressure.

The moles of gas, the temperature, and the cavity volume in [eq:ideal_gas_law] are free to
change with time.  The moles of gas $n$ at any time is the original amount of gas (computed based on
original pressure, temperature, and volume) plus the amount in the cavity due to any gas injected
during the simulation.  The volume $V$ is provided by a single postprocessor value or a vector of
postprocessor values that are summed together before being used in [eq:ideal_gas_law].

There is an option to specify additional, unmeshed volumes with corresponding temperatures that communicate directly with the cavity. In this case the pressure becomes:
\begin{equation}
  P=\frac{nR}{\sum_{i=1}^N \frac{V_i}{T_i}}
\end{equation}

where $N$ is the number of additional volumes.  




### Crack Front Definition


#### Description

This object is used in the computation of fracture domain integrals. It is used to store information about the location of the crack front, and provides functions used by other objects involved in fracture integral calculation. It is not necessary to define this block in the input file, as it can be set up using the [DomainIntegralAction](/DomainIntegralAction.md).

#### Example Input File Syntax





### CrystalPlasticitySlipRateGSS

#### Description

`CrystalPlasticitySlipRateGSS` derives from `CrystalPlasticitySlipRate` which calculates slip rate in the [crystal plasticity system](FiniteStrainUObasedCP.md). The slip system is read into this class. The Schmid tensor is generated in this class and the flow direction is calculated by `calcFlowDirection()`. The slip rate $\dot{g} = g(T, s\cdots, y\cdots)$ is a function of PK2 stress $T$, slip resistance $s$ and state variables $y$.






### CrystalPlasticitySlipResistanceGSS

#### Description

`CrystalPlasticitySlipResistanceGSS` derives from `CrystalPlasticitySlipResistance` which calculates slip resistance in [crystal plasticity system](FiniteStrainUObasedCP.md). The slip resistance $s=s(y,\cdots)$ can be a function of state variables $y$.






### CrystalPlasticityStateVariable

#### Description

`CrystalPlasticityStateVariable` represents a state variable, such as dislocation density in [crystal plasticity system](FiniteStrainUObasedCP.md). The initial values of this state variable are either provided in the input file `readInitialValueFromInline()` or read from the file `readInitialValueFromFile()`. The state variable evolves as $y_{n+1} = y_n + \dot{y}\cdot dt $ where $\dot{y}$ is the state variable evolution rate. The $\dot{y}$ can have multiple components, such as $\dot{y} = a_1 r_1 + a_2 r_2 + \cdots$ where "$a_1, a_2, \cdots$" are the `scale_factor` and $r_1, r_2, \cdots$ are the individual rate components.






### CrystalPlasticityStateVarRateComponentGSS

#### Description

`CrystalPlasticityStateVarRateComponentGSS` derives from `CrystalPlasticityStateVarRateComponent` which calculates individual components of the state variable evolution rate in [crystal plasticity system](FiniteStrainUObasedCP.md). The rate component $r = r(y,\cdots, \dot{g}, \cdots)$ can be a function of state variables $y$ and slip rate $\dot{g}$.  





### Crystal Plasticity State Var Rate Component Voce


#### Description

This UserObject is meant to be used within the user object base crystal
plasticity framework as a Voce hardening rule.

\begin{equation}
\label{eq:self_hardening_rate}
h^\alpha = h_0^\alpha\left(1-\frac{\tau^{\alpha}_{CRSS}-\tau_0^\alpha}{\tau_{Sat}^\alpha-\tau_0^\alpha} \right)^{m^\alpha}
\end{equation}

with

\begin{equation}
\label{eq:slip_system_hardening_rate}
\dot\tau^\alpha_{CRSS} = \sum_{\beta=1}^N \lvert \dot\gamma^\beta \rvert h^\beta q^{\alpha \beta}
\end{equation}

where $\tau^\alpha_{CRSS}$ is the current critical resolved shear stress,
$\tau^{\alpha}_{0}$ is initial critical resolved shear stress,
$\tau_{Sat}^\alpha$ is the saturation resolved shear stress, $q^{\alpha
\beta}$ is the matrix containing self and latent hardening coefficients;
$h_0^\alpha$ and $m^\alpha$ are hardening parameters.

Like for the others crystal plasticity routines values of all the parameters can
be specified by groups of slip systems.

This UserObject assumes that slip systems are provided in a well defined order
and are grouped by planes (see
`modules/solid_mechanics/test/tests/cp_user_object/input_slip_sys_bcc48.txt` for
BCC crystals and
`modules/solid_mechanics/test/tests/cp_user_object/input_slip_sys.txt` for FCC)

Seven variables need to be specified and one value is required for each group:

- `groups` in which groups of slip systems are listed
- `h0_group_values` $h_0$ value for each slip system group
- `tau0_group_values` $\tau_0$ value for each slip system group
- `tauSat_group_values` = $\tau_{Sat}$ value for each slip system group
- `hardeningExponent_group_values` $m$ value for each slip system group
- `selfHardening_group_values` $q^{\alpha\alpha}$
- `coplanarHardening_group_values` $q^{\alpha\beta}$ for co-planar slip systems
  in the same group
- `GroupGroup_Hardening_group_values` $q^{\alpha\beta}$ This parameter requires
  NxN values with N being the number of groups. Values are listed as $value_ij$
  (e.g. ij=11,12,21,22) with $i$ being the actual group and $j$ the secondary
  group. For $i=j$ the value represents the latent hardening coefficient
  between one slip system and all the non co-planar ones belonging to the same
  group. For $i\neq j$, the value represents the latent hardening coefficient
  between all the slip systems belonging to group $i$ and $j$. Note that,
  usually, the matrix associated with `GroupGroup_Hardening_group_values` is
  symmetric.

#### Example Input File Syntax


In this example illustrate a BCC in which slip systems have been grouped by slip system class.






### Generalized Plane Strain User Object


The `GeneralizedPlaneStrainUserObject` calculates the values of residual and diagonal jacobian components for each given scalar out-of-plane strain variable. This object is usually set up by the [GeneralizedPlaneStrainAction](SolidMechanics/GeneralizedPlaneStrain/index.md).

For a given scalar out-of-plane strain variable, the equilibrium condition in the out-of-plane direction (e.g. $z$-direction) is given as
\begin{equation}
	\int_{A}{\sigma_{zz}dA} = \bar{N}_{zz}
\end{equation}
where $\bar{N}_{zz}$ is an externally applied force.  Thus, the residual corresponding to the scalar out-of-plane strain variable is
\begin{equation}
	R = \int_{A}{\sigma_{zz}dA} - \bar{N}_{zz}
\end{equation}
and the corresponding diagonal jacobian is
\begin{equation}
	K_{zz} = \frac{\partial R_{zz}}{\partial \epsilon_{zz}} = \int_{A}{\frac{\partial \sigma_{zz}}{\partial \epsilon_{zz}}dA} = \int_{A}{C_{2222}dA}
\end{equation}

The externally applied force, $\bar{N}_{zz}$, can be imposed as the integral of a pressure applied over the area. This pressure can be imposed using either a function (using the `out_of_plane_pressure_function` parameter), or a material property (using the `out_of_plane_pressure_material` parameter).

The reference residual value used by [GeneralizedPlaneStrainReferenceResidual](/GeneralizedPlaneStrainReferenceResidual.md) is computed as
\begin{equation}
	R_{ref} = \int_{A}{|\sigma_{zz}|dA}
\end{equation}

This formulation is also used when the out-of-plane direction is the $x$-direction or $y$-direction with the subscripts in the preceding equations being changed from $zz$ to $xx$ or $yy$, respectively.

A detailed description of generalized plane strain model can be found in the [formulation](solid_mechanics/generalized_plane_strain.md) page.




### GlobalStrainUserObject


#### Description

`GlobalStrainUserObject` calculates the residual and the jacobian values corresponding to the integral of the stress tensor. In this case, the stress is generated due to global strain or any applied stress on the whole simulation domain.

`ScalarKernel` [GlobalStrain](/GlobalStrain.md) extracts the residual and jacobian values from this `UserObject`.

#### Example Input File Syntax















### Linear Viscoelasticity Manager


#### Description

This updates the internal time-stepping scheme for linear viscoelastic materials (such as a [GeneralizedKelvinVoigtModel](/GeneralizedKelvinVoigtModel.md) or a [GeneralizedMaxwellModel](/GeneralizedMaxwellModel.md) material) at the beginning of each time step. Including a LinearViscoelasticStressUpdate in the simulation is required for the linear viscoelastic strains to be updated properly.

#### Example Input File Syntax















































### StepUserObject


#### Description

`StepUserObject` is a general user object that performs basic computations to provide a
loading step given a simulation time step value or a simulation time step value given a
loading step. This user object is used to interface with [AbaqusUMATStress](/AbaqusUMATStress.md)
and [AbaqusUExternalDB](/AbaqusUExternalDB.md) to provide step information to user routines.
`StepUserObject` can also interface with [StepPeriod](/StepPeriod.md) to enable/disable
boundary conditions and constraints according the user-defined loading steps.


#### Example Input File Syntax





## utils

### Rank Two Scalar Tools

#### Description

This is a set of functions to compute scalar
quantities such as invariants and components in specified directions from rank-2
tensors such as stress or strain. These functions are not directly invoked in the
input file, but are called by several other classes such as:
[RankTwoCylindricalComponent](/RankTwoCylindricalComponent.md),
[RankTwoDirectionalComponent](/RankTwoDirectionalComponent.md),
[RankTwoCartesianComponent](/RankTwoCartesianComponent.md),
[RankTwoInvariant](/RankTwoInvariant.md),
[RankTwoScalarAux](/RankTwoScalarAux.md),
and [RankTwoAux](/RankTwoAux.md).

The scalar quantities that can be computed include:

#### Axial Stress

`AxialStress` calculates the scalar value of a Rank-2 tensor,
$T$, in the direction of the axis specified by the user.  The user should give
the starting point, $P^1$, and the end point, $P^2$ which define the axis.

\begin{equation}
\label{eq:axial_stress_scalar_type}
s = \hat{a}_i T_{ij} \hat{a}_j \quad \text{ where } \quad \hat{a}_i = \frac{P^2_i - P^1_i}{\left| P^2_i - P^1_i \right|}
\end{equation}
where $\hat{a}$ is the normalized direction vector for the axis defined by the points $P^1$ and $P^2$.

#### Direction

`Direction` calculates the scalar value of a Rank-2 tensor, $T$,
in the direction selected by the user as shown by [eq:direction_scalar_type]:
\begin{equation}
\label{eq:direction_scalar_type}
s = D_i T_{ij} D_j
\end{equation}
where $D$ is the direction vector specified in the input file.


#### Effective Strain Increment

Effective plastic strain or effective creep strain, which are computed as
integrals over the history of the inelastic strain as
\begin{equation}
s = \int_t\sqrt{\frac{2}{3} \dot{\epsilon}^p_{ij} \dot{\epsilon}^p_{ij}} \mathrm{d}t
\end{equation}
can be computed with the help of the `effectiveStrain` method.
The integration of the effective increment is performed in [RankTwoInvariant.md],
yielding the effective strain.

#### Hoop Stress in Cylindrical System

`HoopStress` calculates the value of a Rank -2 tensor along the
hoop direction of a cylinder, shown in [eq:hoop_stress_scalar_type].  The
cylinder is defined with a normal vector from the current position to the
cylinder surface and a user specified axis of rotation.The user defines this
rotation axis with a starting point, $P^1$, and the end point, $P^2$.

\begin{equation}
\label{eq:hoop_stress_scalar_type}
s = \hat{n}^h_i T_{ij} \hat{n}^h_j
\end{equation}
where $\hat{n}^h$ is the hoop direction normal, defined as
\begin{equation}
\label{eq:hoop_direction_normal}
  \begin{aligned}
    \hat{n}^h & = \hat{n}^c \times \hat{a} \\
    \hat{n}^c & = \frac{P^c - \hat{n}^r}{\left| P^c - \hat{n}^r \right|} \\
    \hat{a} & = \frac{P^2 - P^1}{\left| P^2 - P^1 \right|}
  \end{aligned}
\end{equation}
where $P^c$ is the current sampling position point, and $\hat{n}^r$ is the direction normal to the plane defined by the cylinder axis of rotation vector and the direction normal to the axis of rotation at the current position $P^c$.

#### Hoop Stress in Spherical System

<!-- // Given normal vector N=(n1,n2,n3) and current point C(c1,c2,c3), the tangential plane is then
// defined as n1(x-c1 + n2(y-c2) + n3(z-c3)=0. Let us assume n1!=0, the arbitrary point P on this
// plane can be taken as P(x,c2+r,c3+r) where r is the radius. The x can be solved as x =
// -r(n2+n3)/n1 + c1. The tangential vector PC is given as P-C. -->

`HoopStress` calculates the value of a Rank -2 tensor along the
tangential direction of a sphere, shown in [eq:hoop_stress_scalar_type_spherical].  The spherical system is defined by the center point $C(c_1,c_2,c_3)$. The radial direction $R(r_1,r_2,r_3)$ at current point $P(p_1,p_2,p_3)$ is calculated as $(P-C)$. The tangential plane at the Point $P$ is given as $r_1(x-p_1) + r_2(y-p_2) + r_3(z-p_3)=0$. Any vector that passes through $P$ on this plane is tangential to the spherical surface. To find a point $Q(q_1,q_2,q_3)$ on the tangential plane, we can freely set the values of two coordinates and the solve for last one using the equation of the plane. For example, we set $q_1=p_1+r$ and $q_2=p_2+r$ where $r$ is the norm of the radial direction vector. Then the $q_3$ is calculated as $q_3 = -(r_1+r_2)r/r_3+p_3$. The tangential vector $\hat{t}$ is defined as $Q-P$.

\begin{equation}
\label{eq:hoop_stress_scalar_type_spherical}
s = \hat{t}_i T_{ij} \hat{t}_j
\end{equation}


#### Hydrostatic Stress

`Hydrostatic` calculates the hydrostatic scalar of a Rank-2
tensor, $T_{ij}$, as shown in [eq:hydrostatic_scalar_type].

\begin{equation}
\label{eq:hydrostatic_scalar_type}
s = \frac{Tr \left( T_{ij} \right)}{3} = \frac{T_{ii}}{3}
\end{equation}


#### Invariant Values

##### First Invariant

`FirstInvariant` calculates the first invariant of the specified
Rank-2 tensor, $T_{ij}$, according to [eq:first_invariant_scalar_type] from
[!cite](malvern1969introduction).
\begin{equation}
\label{eq:first_invariant_scalar_type}
I_T = Tr \left( T_{ij} \right) = T_{ii}
\end{equation}


##### Second Invariant

`SecondInvariant` finds the second invariant of the
Rank-2 tensor, $T_{ij}$, as shown in [eq:second_invariant_scalar_type].  This
method is defined in [!cite](hjelmstad2007fundamentals).
\begin{equation}
\label{eq:second_invariant_scalar_type}
II_T = T_{ii} T_{jj} - \frac{1}{2} \left( T_{ij} T_{ij} + T_{ji} T_{ji} \right)
\end{equation}


##### Third Invariant

`ThirdInvariant` computes the value of the Rank-2 tensor,
$T_ij$, third invariant as given in [eq:third_invariant_scalar_type] from
[!cite](malvern1969introduction).

\begin{equation}
\label{eq:third_invariant_scalar_type}
III_T = det \left( T_{ij} \right)  = \frac{1}{6} e_{ijk} e_{pqr} T_{ip} T_{jq} T_{kr}
\end{equation}
where $e$ is the Rank-3 permutation tensor.


#### L2 Norm

`L2Norm` calculates the L2 normal of a Rank-2 tensor, $T_{ij}$,
as shown in [eq:l2_norm_scalar_type].

\begin{equation}
\label{eq:l2_norm_scalar_type}
s = \sqrt{T_{ij} T_{ij}}
\end{equation}

#### Maximum Shear Stress

`MaxShear` calculates the maximum shear stress for a Rank-2
tensor, as shown in [eq:maxshear_scalar_type].
\begin{equation}
\label{eq:maxshear_scalar_type}
\sigma_{max}^{shear} = \frac{\sigma_{max}^{principal} - \sigma_{min}^{principal}}{2}
\end{equation}


#### Principal Values

##### Maximum Principal Quantity

`MaxPrincipal` calculates the largest principal value for a
symmetric tensor, using the calcEigenValues method from the Rank Two Tensor
utility class.


##### Middle Principal Quantity

`MidPrincipal` finds the second largest principal
value for a symmetric tensor, using the calcEigenValues method from the Rank Two
Tensor utility class.


##### Minimum Principal Quantity

`MinPrincipal` computes the smallest principal value for a
symmetric tensor, using the calcEigenValues method from the Rank Two Tensor
utility class.


#### Radial Stress in Cylindrical System

`RadialStress` calculates the scalar component for a Rank-2
tensor, $T_{ij}$, in the direction of the normal vector from the user-defined
axis of rotation, as shown in [eq:radial_stress_scalar_type_cylindrical].
\begin{equation}
\label{eq:radial_stress_scalar_type_cylindrical}
s = \hat{n}^r_i T_{ij} \hat{n}^r_j
\end{equation}
where $\hat{n}^r$ is the direction normal to the plane defined by the cylinder axis of rotation
vector and the direction normal to the axis of rotation at the current position $P^c$.

#### Radial Stress in Spherical System

`RadialStress` calculates the scalar component for a Rank-2
tensor, $T_{ij}$, in the direction of the normal vector from the user-defined
center point, as shown in [eq:radial_stress_scalar_type_spherical].
\begin{equation}
\label{eq:radial_stress_scalar_type_spherical}
s = \hat{n}^r_i T_{ij} \hat{n}^r_j
\end{equation}
where $\hat{n}^r$ is the direction defined by center point and current position $P^c.

#### Stress Intensity

`StressIntensity` calculates the stress intensity for a Rank-2
tensor, as shown in [eq:sint_scalar_type].
\begin{equation}
\label{eq:sint_scalar_type}
s = 2 \sigma_{max}^{shear} = \sigma_{max}^{principal} - \sigma_{min}^{principal}
\end{equation}

This quantity is useful in evaluating whether a Tresca failure criteria has been
met and is two times the MaxShear quantity.


#### Triaxiality Stress

`TriaxialityStress` finds the ratio of the hydrostatic measure,
$T_{hydrostatic}$, to the von Mises measure, $T_{vonMises}$, as shown in
[eq:triaxiality_scalar_type].  As the name suggests, this scalar measure is most
often used for stress tensors.
\begin{equation}
\label{eq:triaxiality_scalar_type}
s = \frac{T_{hydrostatic}}{T_{vonMises}} = \frac{\frac{1}{3} T_{ii}}{\sqrt{\frac{3}{2} S_{ij} S_{ij}}}
\end{equation}
where $S_{ij}$ is the deviatoric tensor of the Rank-2 tensor $T_{ij}$.

#### olumetric Strain

`VolumetricStrain` computes the volumetric strain, defined as
\begin{equation}
\label{eq:volumetric_strain}
\varepsilon_{vol} = \frac{\Delta V}{V}
\end{equation}
where $\Delta V$ is the change in volume and $V$ is the original volume.

This calculation assumes that the strains supplied as input($T$) are logarithmic
strains, which are by definition $log(L / L_0) $, where $L$ is the current
length and $L_0$ is the original length of a line segment in a given
direction.The ratio of the volume change of a strained cube to the original
volume is thus :
\begin{equation}
\label{eq:volumetric_strain_from_tensor}
s = \frac{\Delta V}{V} = \exp(T_{11}) * \exp(T_{22}) * \exp(T_{33}) - 1
\end{equation}
This is the value computed as the volumetric strain.


This calculation assumes that the supplied Rank-2 tensor $T_{ij}$ is a
logarithmic strain, which is the strain quantity computed for finite strain
calculations. The small-strain equivalent of this calculation would be
\begin{equation}
\label{eq:volumetric_strain_small_strain}
s = T_{11} + T_{22} + T_{33}
\end{equation}
which assumes that engineering strains are supplied and ignores higher-order
terms. There is currently no option to compute this small-strain form of the
volumetric strain because at small strains, the differences between the finite
strain form used and the small strain approximation is small.

#### Von Mises Stress

`VonMisesStress` calculates the vonMises measure for a Rank-2
tensor, as shown in [eq:vonmises_scalar_type].  This quantity is usually applied
to the stress tensor.
\begin{equation}
\label{eq:vonmises_scalar_type}
s = \sqrt{\frac{3}{2} S_{ij} S_{ij}}
\end{equation}
where $S_{ij}$ is the deviatoric tensor of the Rank-2 tensor $T_{ij}$.

## vectorpostprocessors

### AverageSectionValueSampler


#### Description

This computes the average value of specified nodal variables at nodes located within cross-sectional planes
at locations along the axis of a mesh.  Those locations can either be defined by the user (through the [!param](/VectorPostprocessors/AverageSectionValueSampler/positions) parameter),
or automatically determined by the axial positions of the nodes in the mesh if [!param](/VectorPostprocessors/AverageSectionValueSampler/positions) is not specified.
For example, this is designed to work on bodies whose mesh discretization
is created by extrusion, so that sets of nodes that make up the mesh lie within planes regularly.

The location of the nodes is given by a direction and an
associated set of positions. This postprocessor is particularly indicated for structural components that deform in
a way analogous to beams, thereby freeing the user from performing additional postprocessing tasks on a
different software. One use case of this postprocessor is the definition of cross sections in ducts that
bend or bow (see [disp_cross]).

    id=disp_cross
    caption=Undeformed and deformed configurations of a duct with a cross section defined by
    nodes in a regularly meshed geometry.
    style=display:block;margin-left:auto;margin-right:auto;width:60%

This postprocessor should only be used for regularly meshed geometries as it relies on nodes having the
same weights on the cross section. There is no check within the code for this condition, so the user must
ensure that the mesh is reasonably uniform.

Because this VectorPostprocessor is intended to be applied to geometries with extruded meshes, with layers
of nodes that all occupy the same axial position, it will generate an error if the numbers of nodes located
at the various axial positions vary. However, there are valid scenarios when this is not the case. For example,
if part of the extruded mesh is refined, the number of nodes per layer will differ along the axis of the
extruded section. The [!param](/VectorPostprocessors/AverageSectionValueSampler/require_equal_node_counts) parameter can be set to `false` in such situations to skip
that check. The number of nodes per axial position is reported in the ouputs as the `node_count` vector to allow the
user to ensure that each layer contains all expected nodes.

The optional [!param](/VectorPostprocessors/AverageSectionValueSampler/symmetry_plane) parameter is intended to be used when there is a symmetry plane passing through
the extruded section being evaluated. If there is volumetric expansion in the section and this is used to 
compute displacements, the results will be skewed because only the expansion on one side of the symmetry plane
is considered, when it should be balanced out by an expansion in the opposite direction on the other side of
that symmetry plane. To account for this, if [!param](/VectorPostprocessors/AverageSectionValueSampler/symmetry_plane) is specified, the set of variables is treated as a size-three vector, and the component of that vector in the direction of the specified symmetry plane is removed. The [!param](/VectorPostprocessors/AverageSectionValueSampler/symmetry_plane) parameter defines the normal to the symmetry plane, and when this option is used, a set of
three variables must be provided in [!param](/VectorPostprocessors/AverageSectionValueSampler/variables). These are assumed to be the x, y, and z components of a vector, in that order.

#### Example Syntax

See below an input file excerpt which locates the cross section along the $Z$ direction at distances of 10 and 18.


Additionally, if multiple structural components share the same mesh block, one can set the input parameters
[!param](/VectorPostprocessors/AverageSectionValueSampler/reference_point) and [!param](/VectorPostprocessors/AverageSectionValueSampler/cross_section_maximum_radius) to point to the structural component's local frame
and the maximum in-cross-section-plane distance within. These parameters disambiguate which structural
component the nodes belong. An example of computing average section variables for multiple strucutral
components sharing the same mesh block is given below:





### CrackFrontNonlocalScalarMaterial


#### Description

This object computes the average of a scalar material property in the region of the crack front points defined by  [CrackFrontDefinition.md].  The main use case for this `VectorPostprocessor` is to compute an average fracture toughness or $K_c$ at the crack front for use with the `MeshCut2DFractureUserObject` to grow cracks. This allows for spatially varying $K_c$ values defined by a `Material`.

`CrackFrontNonlocalScalarMaterial` computes an average of the material property over a box-shaped domain at each crack tip point that is centered on the crack tip and extends [!param](/VectorPostprocessors/CrackFrontNonlocalScalarMaterial/box_length) in front of the crack tip.  The [!param](/VectorPostprocessors/CrackFrontNonlocalScalarMaterial/box_height) is the dimension normal to the crack face, and [!param](/VectorPostprocessors/CrackFrontNonlocalScalarMaterial/box_width) is the dimension tangential to the crack face.  [!param](/VectorPostprocessors/CrackFrontNonlocalScalarMaterial/box_width) is not used in 2D problems.

In the following input file example, the mesh consists of a 3D plate with a hole in the middle. The CrackFrontDefinition defines crack points around the center line of the hole, `boundary=1001`. This `CrackFrontNonlocalScalarMaterial` averages a material property named `scalar_kcrit` over each 3D box at each crack front point.





### CrackFrontNonlocalStress


#### Description

This object computes the average scalar stress normal to the crack extension direction defined by the [CrackFrontDefinition.md] given by the equation:
\begin{equation}
\sigma_{nn} = \boldsymbol{n} \cdot\boldsymbol{\sigma}\cdot \boldsymbol{n}
\end{equation}

where $\boldsymbol{n}$ is the normal direction vector and $\boldsymbol{\sigma}$ is the stress tensor.

Data produced by this VectorPostprocessor is used in conjunction with the [InteractionIntegral.md] in the XFEM module by the `MeshCut2DFractureUserObject` to grow cracks. The `CrackFrontNonlocalStress` is useful for extending cracks that are approaching free surfaces because the interaction integrals computing `KI` and `KII` are affected when the integration domain intersects the free surface.  `CrackFrontNonlocalStress` computes an average of the stress over a box-shaped domain at each crack tip point that is centered on the crack tip and extends [!param](/VectorPostprocessors/CrackFrontNonlocalStress/box_length) in front of the crack tip.  The [!param](/VectorPostprocessors/CrackFrontNonlocalStress/box_height) is the dimension normal to the crack face, and [!param](/VectorPostprocessors/CrackFrontNonlocalStress/box_width) is the dimension tangential to the crack face.  [!param](/VectorPostprocessors/CrackFrontNonlocalStress/box_width) is not used in 2D problems.  Unlike the other stress integrals, like the [InteractionIntegral.md], that use the [CrackFrontDefinition.md], `CrackFrontNonlocalStress` is not set-up by the [/DomainIntegralAction.md].

In the following input file example, the mesh consists of a 3D plate with a hole in the middle. The CrackFrontDefinition defines crack points around the center line of the hole, `boundary=1001`. The `CrackFrontNonlocalStress` averages a generic stress field over the box-shaped region at each crack front point, with dimensions defined in the input file.





### Interaction Integral


#### Description

This is used for the computation of interaction integrals at the points along a crack front within the solid_mechanics system. This object is not typically defined by a user, but is set up automatically using the [DomainIntegralAction](/DomainIntegralAction.md).

#### Theory

Details on the theory behind the computation of the various fracture integrals, including the interaction integral, are provided [here](FractureIntegrals.md).




### J-Integral


#### Description

This is used for the computation of $J$-integrals at the points along a crack front. This object is not typically defined by a user, but is set up automatically using the [DomainIntegralAction](/DomainIntegralAction.md).

#### Theory

Details on the theory behind the computation of the various fracture integrals, including the $J$-Integral, are provided [here](FractureIntegrals.md).




### Line Material Rank Two Sampler


#### Description

The postprocessor `LineMaterialRankTwoSampler` is used to output specific components of Rank-2 tensors along a user-defined line in the mesh.
The postprocessor uses indices, similar to the AuxKernel [RankTwoAux](/RankTwoAux.md), to determine the component of the Rank-2 tensor to output along a line.

The user must supply the start and end points of the line along which the Rank-2 tensor component should be tracked.
Often this class is used to track stress or strain along an exterior or interior edge of the mesh.

#### Example Input File Syntax





### Line Material Rank Two Scalar Sampler


#### Description

The postprocessor `LineMaterialRankTwoScalarSampler` is used to output common scalar quantities computed from Rank-2 tensors along a user-defined line in the mesh.
The postprocessor computes the same set of scalar quantities as the AuxKernel [RankTwoScalarAux](/RankTwoScalarAux.md); for a full list of the available scalar quantities refer to the [RankTwoScalarAux](/RankTwoScalarAux.md) page.

The user must supply the start and end points of the line along which the Rank-2 tensor scalar quantity should be tracked.
Often this class is used to track stress or strain along an exterior or interior edge of the mesh.

#### Example Input File Syntax





### MixedModeEquivalentK


#### Description

This class computes an equivalent stress intensity factor $K_{eq}$ for a crack under mixed-mode loading as a function of the stress intensity factors for the individual modes ($K_{I}$, $K_{II}$, and $K_{III}$ for modes $I$, $II$, and $III$, respectively):
\begin{equation}
K_{eq}=\sqrt{K_I^2 + K_{II}^2 + \frac{1}{1-\nu}K_{III}^2}
\end{equation}
where $\nu$ is the Poisson's ratio. This object is a VectorPostprocessor, and the individual stress intensity factors are computed by individual VectorPostprocessors.

This object is not typically defined directly by a user, but is set up automatically using the `equivalent_K` parameter in [DomainIntegralAction](/DomainIntegralAction.md).




# Solid Properties Module

The Solid Properties module provides a consistent interface to solid properties. Unlike
fluid properties that are oftentimes only a function of pressure and temperature
(or two other state variables), solid properties are frequently a function of many
other parameters in addition to temperature, such as accumulated radiation damage,
oxidation state, and microstructure. Some commonly-used properties in physics
simulations include thermal
properties such as specific heat, thermal conductivity, and emissivity; and
mechanical properties such as elastic modulus and Poisson ratio.

This module provides a consistent interface to define solid material properties.
A flexible design permits extension by other applications to include custom
properties. This module allows different solids
to be used in a physics simulation by simply swapping the name of the solid properties
userobject in a plug-and-play manner.

Always verify that the material properties provided in this module agree with
the system you are modeling. The selection of particular correlations here does not
constitute an endorsement of the accuracy of those correlations.

This module provides solid properties for different solids, organized according to
the overall type of property. The overall design of this module is as follows:

1. *UserObjects* contain functions to compute various solid properties in terms
   of dependent quantities (temperature, porosity, etc.). Different "categories" of
   solid properties are grouped together into different userobjects. For example,
   common solid properties used in thermal simulations (specific heat, thermal conductivity),
   are provided by derived classes of the [ThermalSolidProperties](/solidproperties/ThermalSolidProperties.md)
   userobject. Mechanics properties (Young's modulus, Poisson ratio), would be provided by
   a separate "family" of userobjects.
2. *Materials* call these userobject functions to compute the material properties at
   quadrature points. Like the userobjects, these materials are grouped into "categories."
   For example, common solid properties for thermal simulations are evaluated by the
   [ThermalSolidPropertiesMaterial](/materials/ThermalSolidPropertiesMaterial.md).

## Thermal properties

Thermal properties (density, specific heat, and thermal conductivity) are computed by
userobjects inheriting from the [ThermalSolidProperties](/solidproperties/ThermalSolidProperties.md) base class. This class
defines functions to compute these properties as a function of temperature:

- compute isobaric specific heat - `Real cp_from_T(const Real & T)`
- compute thermal conductivity - `Real k_from_T(const Real & T)`
- compute density - `Real rho_from_T(const Real & T)`

Functions to compute derivatives of these properties as a function of temperature
are also available:

- compute isobaric specific heat and its temperature derivative - `void cp_from_T(const Real & T, Real & cp, Real & dcp_dT)`
- compute thermal conductivity and its temperature derivative - `void k_from_T(const Real & T, Real & k, Real & dk_dT)`
- compute density and its temperature derivative - `void rho_from_T(const Real & T, Real & rho, Real & drho_dT)`

Userobjects available in the Solid Properties module that provide thermal properties are:

- [graphite](/ThermalGraphiteProperties.md)
- [monolithic silicon carbide](/ThermalMonolithicSiCProperties.md)
- [composite silicon carbide](/ThermalCompositeSiCProperties.md)
- [stainless steel alloy 316](/ThermalSS316Properties.md)
- [using functions](/ThermalFunctionSolidProperties.md)

An example will be provided later on this page for creating a new solid userobject.

On their own, these userobjects do not execute; their functions must be called from other
objects. Some potentially useful classes that call them are:

- [ThermalSolidPropertiesFunctorMaterial.md]: A functor material that declares
  functor material properties for density, thermal conductivity, isobaric specific heat,
  and specific internal energy. An option is provided for using a constant density.
  This functor material can have its functor material properties converted to
  regular AD or non-AD material properties by using it in conjunction with
  [(AD)MaterialFunctorConverter](MaterialFunctorConverter.md).
- [ThermalSolidPropertiesMaterial.md] and [ConstantDensityThermalSolidPropertiesMaterial.md],
  which declare AD or non-AD material properties for density, thermal conductivity, and isobaric specific heat,
  using variable density and constant density, respectively.
- [ThermalSolidPropertiesPostprocessor.md] evaluates density, thermal conductivity,
  or isobaric specific heat at a single temperature value.

## Usage

The solid properties material can be accessed in MOOSE objects through the usual Material
interface. Here, we show an example where thermal conductivity is needed in a kernel
named `HeatDiffusion`.

### Source

To access the properties defined in the Solid Properties module in a MOOSE object,
add the desired material properties to the class members:


In the header file of the MOOSE object where a solid material property is needed,
`const` references to the material properties are required:


The name `_k` is arbitrary, and may be selected as desired per application.
Then, material properties are used just as other MOOSE materials are used. For example, the
weak residual for the heat diffusion kernel grabs the value of thermal conductivity at the
present quadrature point.


### Input file syntax

The userobjects defining the material properties are set up in the `UserObjects` block.  For
example, to use stainless steel 316 thermal properties to provide the thermal conductivity in
the `HeatDiffusion` kernel above, the input file syntax would be:

```
[Modules]
  [SolidProperties]
    [steel]
      type = ThermalSS316Properties
    []
  []
[]

[Materials]
  [sp_mat]
    type = ThermalSolidPropertiesMaterial
    temperature = T
    sp = steel
  []
[]
```

Due to the consistent interface for solid properties, a different solid can be substituted in the
input file by changing the type of the userobject. For example, to set thermal properties
with a general functional dependence instead, the solid property module section of
the input file is:

```
[Modules]
  [SolidProperties]
    [func]
      type = ThermalFunctionSolidProperties
      rho = '1000.0'
      cp = '200*t+150.0'
      k = '2.0*exp(-100.0/(2.0+t))+1.0'
    []
  []
[]

[Materials]
  [sp_mat]
    type = ThermalSolidPropertiesMaterial
    sp = func
    temperature = u
  []
[]
```

## Creating additional solids

New solids can be added by inheriting from the userobject base class appropriate
to the formulation and overriding the methods that describe the solid properties.

For example, suppose new thermal solid properties were desired for granite.
The first step is to create a userobject named `ThermalGraniteProperties` by
inheriting from [ThermalSolidProperties](/solidproperties/ThermalSolidProperties.md) and
overriding all methods that you would like to implement.
The header file for your new userobject indicates all methods that will be defined.

#pragma once

#include "ThermalSolidProperties.h"

class ThermalGraniteProperties : public ThermalSolidProperties
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Woverloaded-virtual"
public:
  static InputParameters validParams();

  ThermalGraniteProperties(const InputParameters & parameters);

  virtual Real k_from_T(const Real & T) const override;
  virtual void k_from_T(const Real & T, Real & k, Real & dk_dT) const override;

  virtual Real cp_from_T(const Real & T) const override;
  virtual void cp_from_T(const Real & T, Real & cp, Real & dcp_dT) const override;

  virtual Real rho_from_T(const Real & T) const override;
  virtual void rho_from_T(const Real & T, Real & rho, Real & drho_dT) const override;
};

#pragma GCC diagnostic pop

Next, implement those methods in a `ThermalGraniteProperties` userobject. You can provide
a class description to make it clear what properties this new material provides.

#include "ThermalGraniteProperties.h"

registerMooseObject("SolidPropertiesApp", ThermalGraniteProperties);

InputParameters
ThermalGraniteProperties::validParams()
{
  InputParameters params = ThermalSolidProperties::validParams();
  params.addClassDescription("Granite thermal properties.");
  return params;
}

ThermalGraniteProperties::ThermalGraniteProperties(const InputParameters & parameters)
  : ThermalSolidProperties(parameters)
{
}

Then, the remainder of the source file includes the material-specific implementations
of the methods defined in the header file for granite.

## Objects, Actions, and Syntax


## actions

### AddSolidPropertiesAction

This action adds a [solid properties](modules/solid_properties/index.md) object.
It is an [/AddUserObjectAction.md] registered to the `add_solid_properties` task.


### AddSolidPropertiesDeprecatedAction

Does the same as [AddSolidPropertiesAction.md] but also adds deprecation warning.


## functormaterials

### ThermalSolidPropertiesFunctorMaterial

#### Description

`ThermalSolidPropertiesFunctorMaterial` declares functor material properties for
density, specific heat, and thermal conductivity, and specific internal energy.

The parameter [!param](/FunctorMaterials/ThermalSolidPropertiesFunctorMaterial/use_constant_density)
can be used to specify that the density should be constant, evaluated at the temperature
[!param](/FunctorMaterials/ThermalSolidPropertiesFunctorMaterial/T_ref). This is
useful because for fixed-sized domains, mass/energy conservation errors result
from using a variable density.




## materials

### ConstantDensityThermalSolidPropertiesMaterial

#### Description

This material is the same as [ThermalSolidPropertiesMaterial.md], except that
it uses a constant density, evaluated at a user-given reference temperature.

This is useful because when using a fixed-size domain with conservation equations
such as transient heat conduction, conservation errors result from using a variable
density, since by changing density without changing the domain volume, the
mass (and thus thermal energy, for example) are changed, which violates the
governing conservation laws.





### ThermalSolidPropertiesMaterial

#### Description

The `ThermalSolidPropertiesMaterial` material declares
density, specific heat, and thermal
conductivity as material properties and computes them in
`computeQpProperties()`.

Using a variable density can lead to mass/energy conservation errors if using
a fixed-size domain. If this is a concern, it is recommended to use
[ConstantDensityThermalSolidPropertiesMaterial.md] instead, which uses a constant
density.





## postprocessors

### ThermalSolidPropertiesPostprocessor

This post-processor computes a given property from a [ThermalSolidProperties.md]
object at a temperature given by another post-processor.




## solidproperties

All units are given in SI, such that the input temperature is Kelvin,
and the output units of the thermal conductivity $k$ are W/m$\cdot$K,
the output units of the isobaric specific heat capacity $C_p$ are J/kg$\cdot$K,
and the output units of the density $\rho$ are kg/m$^3$.

### ThermalCompositeSiCProperties


#### Description

This userobject provides
thermal properties for composite silicon carbide as a function of temperature.


Isobaric specific heat is calculated from [!cite](snead) as

\begin{equation}
C_p=925.65 + 0.3772 * T - 7.9259\times10^{-5} * T^2 - 3.1946\times 10^7 * T^{-2};
\end{equation}

The uncertainty is $\pm$ 7% in the range 200 K $\le$ T $\le$ 1000 K and $\pm$ 4% in the range
1000 K $\le$ T $\le$ 2400 K.

Thermal conductivity is calculated from [!cite](stone) as

\begin{equation}
k=-1.71\times 10^{-11} T^4+7.35\times 10^{-8}T^3 - 1.10\times 10^{-4}T^2+0.061T+7.97
\end{equation}

The density is assumed constant because the thermal expansion coefficient
of silicon carbide is very small.
A default value is provided as an average
over four different crystal structures at room temperature [!cite](snead) as

\begin{equation}
\rho=3216.0
\end{equation}

#### Range of Validity

This userobject is valid for estimating isobaric
specific heat over 200 K $\le$ T $\le$ 2400 K, and for estimating thermal conductivity
over an unspecified range [!cite](stone).





### ThermalFunctionSolidProperties


#### Description

This userobject provides
thermal properties for an arbitrary solid as a function of temperature.
Parsed function inputs are provided for density, thermal conductivity, and
specific heat by parameterizing the time variable `t` as temperature.
This userobject can also be used to specify constant properties by
excluding any dependence on temperature.

#### Range of Validity

The range of validity of this userobject depends on the correlations provided
by the user. Note that arbitrary units can be specified with this userobject
as long as they are consistent with the units of the other objects (e.g. kernels,
boundary conditions, etc.) where the userobject functions are used.





### ThermalGraphiteProperties


#### Description

This userobject provides thermal properties for graphite
as a function of temperature. Because there are many different
grades of graphite, this userobject computes properties individually
for each grade. Because many grades are encapsulated in this
userobject, the applicability ranges of the correlations are unique to
each grade.

Many of the graphite grades encapsulated in this userobject are coke-based.
Because many coke-based graphite grades show approximately the same specific heat,
it is a reasonable approximation to use the same $C_p$ correlation from
[!cite](butland) for many different grades [!cite](baker).


##### H-451

H-451 graphite is a near-isotropic, artificial graphite based on
petroleum coke. H-451 graphite is commonly used for reflectors in nuclear
applications.

Isobaric specific heat is calculated from [!cite](butland) as

\begin{equation}
C_p=4184\left\lbrack 0.54212-2.42667e-6T-90.2725 T^{-1}-43449.3 T^{-3}+1.59309\times 10^7 T^{-3}-1.43688\times 10^9T^{-4}\right\rbrack
\end{equation}

with a validity range of 200 K $\le T \le$ 3500.

The thermal conductivity is calculated from [!cite](nea2018) as

\begin{equation}
k=3.28248\times 10^{-5}T^2-1.24890\times 10^{-1}T+1.69214\times 10^2
\end{equation}

with a validity range of 500 K $\le T \le$ 1800 K.

Density is taken as a constant value; a default value is provided based on
[!cite](nea2018) as

\begin{equation}
\rho=1850.0
\end{equation}





### ThermalMonolithicSiCProperties


#### Description

This userobject provides
thermal properties for monolithic silicon carbide as a function of temperature.


Isobaric specific heat is calculated from [!cite](snead) as

\begin{equation}
C_p=925.65 + 0.3772 * T - 7.9259\times10^{-5} * T^2 - 3.1946\times 10^7 * T^{-2};
\end{equation}

The uncertainty is $\pm$ 7% in the range 200 K $\le$ T $\le$ 1000 K and $\pm$ 4% in the range
1000 K $\le$ T $\le$ 2400 K.

Two methods are available for computing thermal conductivity from
[!cite](snead) and [!cite](stone) as

\begin{equation}
k=\begin{cases}
\frac{1.0}{-0.0003 + 1.05\times 10^{-5} * T} & \text{Snead correlation}\\
-3.70\times 10^{-8}T^3+1.54\times 10^{-4}T^2-0.214T+153.1 & \text{Stone correlation}\\
\end{cases}
\end{equation}

The density is assumed constant because the thermal expansion coefficient
of silicon carbide is very small.
A default value if provided as an average
over four different crystal structures at room temperature [!cite](snead) as

\begin{equation}
\rho=3216.0
\end{equation}

#### Range of Validity

This userobject is valid for estimating isobaric
specific heat over 200 K $\le$ T $\le$ 2400 K; and for estimating thermal
conductivity over 300 K $\le$ T $\le$ 1800 K with the Snead correlation
[!cite](snead) and over an unspecified range for the Stone correlation
[!cite](stone).





### ThermalSolidProperties

This is the base class for providing thermal solid properties
as a function of temperature.
This class defines functions to compute the following thermal properties,
which are all assumed to be functions of temperature only:

- `cp`: isobaric specific heat, $c_p$
- `e`: specific internal energy, $e$
- `k`: thermal conductivity, $k$
- `rho`: density, $\rho$

For each of these, the following methods are available, where `y` should be
replaced by the respective property name given in the list above:

```
Real y_from_T(const Real & T) const
```

provides the value $y(T)$ using a `Real` input value for $T$.

```
void y_from_T(const Real & T, Real & y, Real & dy_dT) const
```

provides the value $y(T)$ and its derivative $y'(T)$ using a `Real` input value for $T$.

```
ADReal y_from_T(const ADReal & T) const
```

provides the value $y(T)$ and its derivative $y'(T)$ using an `ADReal` input value for $T$.

Thus both AD and non-AD interfaces are available. Derived classes are only responsible
for overriding the non-AD interfaces for each property. The AD interfaces are
implemented by default by combining the two non-AD interfaces.

Note that the `e_from_T` interfaces should not be overridden because they have
generic implementations, and the non-AD interfaces are not even virtual.
Instead, derived classes must override the following:

```
Real cp_integral(const Real & T) const
```

which corresponds to the indefinite integral $C(T)$ of $c_p(T)$, minus the
constant of integration:

C(T) = \int c_p(T) dT \,.

Due to the definition of the isobaric specific heat capacity,

c_p \equiv \left.\frac{\partial e}{\partial T}\right|_v \,,

the specific internal energy can be expressed as

e(T) - e(T_0) = \int\limits_{T_0}^T c_p(T') dT' = C(T) - C(T_0) \,,

where $T_0$ is the temperature at which the specific internal energy is assumed
to be zero. This is a convention supplied by the user using the parameter
[!param](/SolidProperties/ThermalSS316Properties/T_zero_e). By default, this
is taken to be at standard temperature, 273.15 K. Note that this is important
for comparing specific internal energy values to external sources, which may
be based on different reference temperatures.


### ThermalSS316Properties


#### Description

This userobject provides thermal properties for
stainless steel 316 as a function of temperature using curve fits
of data in [!cite](mills).


Thermal conductivity is given as

\begin{equation}
k=-7.301\times 10^{-6}T^2+0.02716T+6.308
\end{equation}

Uncertainty on the original tabulated
data for thermal conductivity is $\pm$ 10%, and the $R^2$ value of the curve fit is 0.9960.

Isobaric specific heat capacity is given as

\begin{equation}
C_p=0.1816T+428.46
\end{equation}

Uncertainty on the original tabulated data
for isobaric specific heat capacity is $\pm$ 5%, and the $R^2$ value of the curve fit is 0.9926.

Density is given as

\begin{equation}
\rho=-4.454\times 10^{-5}T^2-0.4297T+8089.4
\end{equation}

Uncertainty on the original
tabulated data for density is $\pm$ 3%, and the $R^2$ value of the curve
fit is 0.9995.

#### Range of Validity

The properties are valid for 25$\degree$C $\le$ T $\le$ 1300$\degree$C.





### ThermalUCProperties


#### Description

This `SolidProperties` object provides thermal properties for Uranium monocarbide as a function of temperature.


Isobaric specific heat is calculated from [!cite](iaea) as

\begin{equation}
C_p= 239.7 - 5.068\times 10^{-3} * T + 1.7604\times10^{-5} * T^2 - 3488100 * T^{-2}
\end{equation}


This is valid for estimating isobaric specific heat over 298 K $\le$ T $\le$ 2838 K

Thermal conductivity is calculated from [!cite](Vasudevamurthy2022) as:

For 323 K $\le$ T $\le$ 923 K
\begin{equation}
k=21.7-3.04\times 10^{-3} * T+3.61\times 10^{-6} * T^2
\end{equation}

And for 924 K $\le$ T $\le$ 2573 K, the thermal conductivity is:
\begin{equation}
k=20.2+1.48\times 10^{-3} T
\end{equation}

The density is assumed constant.
A default value is provided [!cite](Vasudevamurthy2022) as

\begin{equation}
\rho= 13824.7
\end{equation}






# Stochastic Tools Module

The stochastic tools module is a toolbox designed for performing stochastic analysis for MOOSE-based
applications. The following sections detail the various aspects of this module that can be
used independently or in combination to meet the needs of the application developer.

## Examples


## Performance

The stochastic tools module is optimized in two ways for memory use. First, sub-applications can be
executed in batches and all objects utilizing sample data do so using a distributed sample
matrix. For further details refer to the following:

- [batch_mode.md]
- [distributed_samples.md]

## Linking MOOSE with external Machine Learning libraries

The stochastic tools module provides neural network-based surrogate modeling capabilities
as well. However, to enable it one needs to compile MOOSE with the C++ APIs of
[pytorch](https://pytorch.org/). For this, follow the appropriate installation guide below:

- [enable_pytorch.md]

## Objects, Actions, and Syntax

The following is a complete list of all objects available in the stochastic tools module.


## actions

### AdaptiveSamplerAction


#### Overview

This action automatically adds the necessary objects to terminate the simulation if an adaptive sampler is used.
This is done by creating a [Terminator](Terminator.md) and an [AdaptiveSamplingCompletedPostprocessor](AdaptiveSamplingCompletedPostprocessor.md).
The simulation is terminated by the former whenever the latter indicates that the adaptive sampler has completed its sampling.
Currently, the two adaptive samplers are [AdaptiveImportanceSampler](AdaptiveImportanceSampler.md) and [ParallelSubsetSimulation](ParallelSubsetSimulation.md).



### AddCovarianceAction

This action adds `CovarianceFunctionBase` [asds](Covariance/index.md) objects contained within the `[Covariance]` block. For example,
the following block adds a [SquaredExponentialCovariance.md] covariance function.



### AddLikelihoodAction

This action adds [LikelihoodFunctionBase](Likelihood/index.md) objects contained within the `[Likelihood]` block. For example,
the following block adds a [Gaussian.md] likelihood function.



### AddSurrogateAction

This action adds `SurrogateModel` objects contained within the `[Surrogates]` block. For example,
the following block adds a [PolynomialChaos.md] surrogate model.



### AddVariableMappingAction

This action adds `VariableMappingBase` objects contained within the `[VariableMappings]` block. For example,
the following block adds a [PODMapping.md] mapping object.



### LoadCovarianceDataAction

This action operates on existing `GaussianProcess` objects contained within the `[Surrogates]` block.
If the model provides a filename (as shown below), a `[Covariance]` object equivalent to the function used in the training phase is reconstructed for use in model evaluation.

#### Example Input File Syntax

In the training input file we setup a GaussianProcessTrainer, with a SquaredExponential covariance function.


In the surrogate input file, the GaussianProcess surrogate recreates the covariance function used in training and links to it.


### LoadSurrogateDataAction

This action operates on existing `SurrogateModel` objects contained within the `[Surrogates]` block.
If the model provides a filename (as shown below) the training data is initialized and the model is
ready for use via the evaluate method.



### ParameterStudyAction

This class defines the behavior of the ParameterStudy input block, please refer to
[syntax/ParameterStudy/index.md] for more information.


### StochasticToolsAction

This class defines the behavior of the StochasticTools input block, please refer to
[syntax/StochasticTools/index.md] for more information.


## auxkernels

### SurrogateModelArrayAuxKernel


#### Overview

This aux-kernel is the same as [SurrogateModelAuxKernel.md], except it sets values of array variables. As such, [!param](/AuxKernels/SurrogateModelArrayAuxKernel/parameters) may include names of array variables, which need to be listed in [!param](/AuxKernels/SurrogateModelArrayAuxKernel/coupled_array_variables).




### SurrogateModelAuxKernel


#### Overview

This aux-kernel sets the value of an auxiliary variable by evaluating a [surrogate model](Surrogates/index.md). The parameter values used during the evaluation are specified using [!param](/AuxKernels/SurrogateModelAuxKernel/parameters). These values can be constant numbers, [post-processors](Postprocessors/index.md), [functions](Functions/index.md), or field variables. Post-processor and function values must be indicated by listing them in [!param](/AuxKernels/SurrogateModelAuxKernel/scalar_parameters). Variable values should be listed in [!param](/AuxKernels/SurrogateModelAuxKernel/coupled_variables).




### SurrogateModelScalarAux


This auxiliary scalar kernel takes a vector of scalar variables,
postprocessors, and real numbers in [!param](/AuxScalarKernels/SurrogateModelScalarAux/parameters)
and evaluates the surrogate model provided in [!param](/AuxScalarKernels/SurrogateModelScalarAux/model)
at these values.




## controls

### MultiAppSamplerControl


#### Description

Depending on the type of stochastic analysis being performed, it may be necessary to pass command
line arguments to the MultiApp objects being created. For example, if a the domain is required to be
altered statistically in the x-direction the `Mesh/xmax` parameter in the sub-application must be
altered. However, this value cannot be altered from within sub-application input file via a Control
object because the `xmax` parameter is applied to the mesh when it is created. In this case, the
`MultiAppSamplerControl` can be used to pass custom values to the arguments of a MultiApp that
are generated from Sampler and Distribution objects.

#### Example Use

Consider a stochastic problem that is executing 3 simulations, but those simulations
require the maximum x and y coordinates of a generated mesh be varied between 5 and 10.

First, the MultiApps block is defined to execute the desired simulations.


Second, a [Uniform](distributions/Uniform.md) distribution
object must be created:


A sampling scheme must be defined for capturing values from the uniform distribution. In
this example, since there are two pieces of data to be controlled ("xmax" and "ymax") the
uniform distribution is sampled twice. Since this sampled data will only be used during
"PRE_MULTIAPP_SETUP" execution, so the "execute_on" parameter is setup to match.


Finally, the `MultiAppSamplerControl` is used to apply the sampled data to the
desired Mesh settings.


#### Vector Parameter

The vector parameter can be altered statistically with `MultiAppSamplerControl`. To illustrate its usage, we consider an input file listed below:


In this input file, the `param_names` includes a vector parameter with 4 entries called `Materials/const/prop_values` and two scalar parameters called `Mesh/xmax` and `Mesh/ymax`.

Several cases exist for modifying the vector parameter:

1. All four entries will be altered: set `param_names = Materials/const/prop_values[0,1,2,3]`. The `[0,1,2,3]` is the global column index of the provided distributions which implies that each entry corresponds to a different distribution.  

2. The third and fourth entry will be altered with a same distribution: set `param_names = Materials/const/prop_values[0,1,2,2]`. The repeated index "2" means that their values are the same and will be sampled from a same distribution.

3. The second entry will not be altered: set `param_names = Materials/const/prop_values[0,(0.5),1,2]`. In this case, the second entry will be set as 0.5 while the first, third and last entries will be altered statistically. In general, a constant value will be provided inside the parentheses bracket.

If `[]` is used, it must be provided to every parameter. By default, if the `[]` is not provided it is assumed that values are scalar and captured in order.





### SamplerReceiver


The use of this object is explained in detail in stochastic_tools module
example: [Monte Carlo Example](stochastic_tools/examples/monte_carlo.md).




## covariances

### ExponentialCovariance


#### Overview

A simple exponential covariance function can be constructed as

k(x,x^\prime) = \sigma_f^2 \, exp \left(- r_\ell(x,x^\prime)^\gamma \right) + \sigma_n^2 \, \delta_{x,x^\prime},

which is valid for $0 < \gamma \leq 2$. $r_\ell(x,x^\prime)$ is a scaled distance based on the length factor $\vec{\ell}$, defined as

r_\ell(x,x^\prime) = \sqrt{ \sum_n \left( \frac{x_i - x^\prime_i}{\ell_i} \right)^2}.

When $\gamma = 2$ is equivalent to [](SquaredExponentialCovariance.md), save a factor of $2$ (which can be absorbed into $\vec{\ell}$).

#### Hyperparameters

| Variable | Domain| Description |
| - | - | - |
| $\vec{\ell}$ | $\mathbb{R}_{> 0}^n$ | Length factors corresponding to input parameters\* |
| $\sigma_f$ | $\mathbb{R}_{\geq 0}$ | Signal variance\* |
| $\sigma_n$ | $\mathbb{R}_{\geq 0}$ | Noise variance\* |
| $\gamma$ | $(0,2]$ | Exponential factor |

\*See the [Gaussian Process Trainer](GaussianProcessTrainer.md) documentation for more in depth explanation of $\vec{\ell}$, $\sigma_f$, and $\sigma_n$ hyperparameters.

#### Example Input File Syntax





### LMC


The linear model of co-regionalization (LMC) distinctly models the covariances
between the $N$ inputs and the $M$ outputs. Mathematically, the LMC is defined as
[!citep](Liu2018gp,Cheng2020gp):

\begin{equation}
    \label{eqn:mogp_3}
    \bar{\pmb{K}} = \sum_{q=1}^Q \bar{\pmb{B}}_q \otimes \pmb{K}_q
\end{equation}

where, $q$ denotes the latent basis index, $\bar{\pmb{B}}_q$ output covariance
matrix of size $M \times M$ for the $q$-th covariate, $\pmb{K}_q$ is
the input covariance matrix of size $N \times N$ for the $q$-th
covariate, $Q$ is the total number of basis functions, and $\otimes$ denotes
the Kronecker product. $\bar{\pmb{B}}_q$ is further defined as the sum of
two matrices of weights [!citep](Cheng2020gp):

\begin{equation}
    \label{eqn:mogp_4}
    \bar{\pmb{B}}_q = \pmb{A}_q \pmb{A}_q^\intercal + \textrm{diag}\Big(\pmb{\lambda}_q\Big)
\end{equation}

where, $\pmb{A}_q$ and $\pmb{\lambda}_q$ are vectors (size $M\times 1$)
of hyper-parameters, both for the $q$-th basis.
The size $Q$ is user-defined and it can be greater than or equal to 1. The
larger the $Q$, the more sophisticated the multi-output Gaussian Process in
modeling complex outputs.

If $Q=1$, the LMC reduces to the intrinsic co-regionalization model (ICM).

#### Example Input File Syntax





### MaternHalfIntCovariance


#### Overview

A special case of the Matern class of covariance functions, in which the $\nu$ hyperparameter takes on a half integer value. Substituting a positive integer $p$ for $\nu$ using $\nu = p + 1/2$ the covariance function is given as

k(x,x^\prime) = \sigma_f^2 \, exp \left(- \sqrt{2p+1} r_\ell(x,x^\prime) \right) \frac{p!}{(2p)!} \sum_{i=0}^p \left[ \frac{(p+i)!}{i! (2p-i)!} \left( 2 \sqrt{2p+1} r_\ell(x,x^\prime) \right)^{p-i}  \right]   + \sigma_n^2 \, \delta_{x,x^\prime}.

$r_\ell(x,x^\prime)$ is a scaled distance based on the length factor $\vec{\ell}$, defined as

r_\ell(x,x^\prime) = \sqrt{ \sum_n \left( \frac{x_i - x^\prime_i}{\ell_i} \right)^2}.

#### Hyperparameters

| Variable | Domain| Description |
| - | - | - |
| $\vec{\ell}$ | $\mathbb{R}_{>0}^n$ | Length factors corresponding to input parameters\* |
| $\sigma_f$ | $\mathbb{R}_{\geq 0}$ | Signal variance\* |
| $\sigma_n$ | $\mathbb{R}_{\geq 0}$ | Noise variance\* |
| $p$ | $\mathbb{N}$ |  |

\*See the [Gaussian Process Trainer](GaussianProcessTrainer.md) documentation for more in depth explanation of $\vec{\ell}$, $\sigma_f$, and $\sigma_n$ hyperparameters.

#### Example Input File Syntax





### SquaredExponentialCovariance


#### Overview

A widely used, general purpose isotropic covariance function is

k(x,x^\prime) = \sigma_f^2 \, exp \left(- \frac{r_\ell(x,x^\prime)^2}{2} \right) + \sigma_n^2 \, \delta_{x,x^\prime}.

$r_\ell(x,x^\prime)$ is a scaled distance based on the length factor $\vec{\ell}$, defined as

r_\ell(x,x^\prime) = \sqrt{ \sum_n \left( \frac{x_i - x^\prime_i}{\ell_i} \right)^2}.

#### Hyperparameters

| Variable | Domain| Description |
| - | - | - |
| $\vec{\ell}$ | $\mathbb{R}_{>0}^n$ | Length factors corresponding to input parameters\* |
| $\sigma_f$ | $\mathbb{R}_{\geq 0}$ | Signal variance\* |
| $\sigma_n$ | $\mathbb{R}_{\geq 0}$ | Noise variance\* |

\*See the [Gaussian Process Trainer](GaussianProcessTrainer.md) documentation for more in depth explanation of $\vec{\ell}$, $\sigma_f$, and $\sigma_n$ hyperparameters.

#### Example Input File Syntax






## distributions

### Beta Distribution


#### Overview

This object defines a [beta distribution](https://en.wikipedia.org/wiki/Beta_distribution) with two shape parameters: [!param](/Distributions/Beta/alpha) ($\alpha$) and [!param](/Distributions/Beta/beta) ($\beta$). The probability density function, cumulative distribution function, and quantile are defined in [eq:beta_pdf], [eq:beta_cdf], and [eq:beta_q], respectively.

f(x;\alpha,\beta) = \frac{x^{\alpha-1}(1-x)^{\beta-1}}{\Beta(\alpha,\beta)},

F(x;\alpha,\beta) = I_x(\alpha,\beta),

F^{-1}(p; \alpha,\beta) = I_x^{-1}(\alpha, \beta, p),

where $\alpha,\beta > 0$ and $0\leq x,p \leq 1$. $\Beta(a,b)$ is the beta function defined in [eq:beta_fun], $I_x(a,b)$ is the regularized incomplete beta function defined in [eq:ibeta], and $I_x^{-1}(a, b, p)$ is the inverse of the incomplete beta function. Each of these quantities are computed using a custom iterative procedure [!citep](teukolsky1992numerical), which obtains an accuracy of about $10^{-14}$.

\Beta(a,b) = \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)} = \int_0^1 x^{a-1}(1-x)^{b-1}dx

I_x(a,b) = \frac{1}{\Beta(a,b)}\int_0^x t^{a-1}(1-t)^{b-1}dt




### F-Distribution


#### Overview

This object defines a [F-distribution](https://en.wikipedia.org/wiki/F-distribution) with two degree of freedom parameters: [!param](/Distributions/FDistribution/df1) ($d_1$) and [!param](/Distributions/FDistribution/df2) ($d_2$). The probability density function and cumulative distribution function are defined in [eq:f_pdf] and [eq:f_cdf], respectively.

f(x; d_1, d_2) = \frac{1}{\Beta\left(\frac{d_1}{2},\frac{d_2}{2}\right)} \left(\frac{d_1}{d_2}\right)^{\frac{d_1}{2}} x^{\frac{d_1}{2}-1} \left(1+\frac{d_1}{d_2}x\right)^{-\frac{d_1-d_2}{2}},

F(x; d_1, d_2) = I_{z(x)}\left(\frac{d_1}{2},\frac{d_2}{2}\right), \quad z(x) = \frac{d_1x}{d_1x+d_2},

where $d_1,d_2 \in \mathbb{Z} > 0$ and $x > 0$. $\Beta(a,b)$ is the beta function and $I_z(a,b)$ is the regularized incomplete beta function, see [Beta.md] for more details.




### Gamma Distribution


#### Overview

This object defines a [gamma distribution](https://en.wikipedia.org/wiki/Gamma_distribution) with [!param](/Distributions/Gamma/shape) parameter ($k$ or $\alpha$) and [!param](/Distributions/Gamma/scale) parameter ($\theta$ or $1/\beta$). The probability density function, cumulative distribution function, and quantile are defined in [eq:gamma_pdf], [eq:gamma_cdf], and [eq:gamma_q], respectively.

f(x; \alpha, \beta) = \frac{\beta^\alpha x^{\alpha-1} e^{-\beta x}}{\Gamma(\alpha)},

F(x; \alpha, \beta) = \Gamma(\alpha, \beta x),

F^{-1}(p; \alpha, \beta) = \frac{\Gamma^{-1}(\alpha, p)}{\beta},

where $x,\alpha,\beta > 0$ and $0\leq p \leq 1$. $\Gamma(a)$ is the gamma function defined by [eq:gamma_fun], $\Gamma(a, x)$ is the lower incomplete gamma function defined by [eq:igamma], and $\Gamma^{-1}(a, p)$ is the inverse of the incomplete gamma function. $\Gamma$ and $\Gamma^{-1}$ are computed using a custom iterative procedure, which obtains an accuracy of about $10^{-14}$.

\Gamma(a) = \int_0^\infty x^{a-1}e^{-x}dx

\Gamma(a, x) = \frac{1}{\Gamma(a)}\int_0^x t^{a-1}e^{-t}dt




### JohnsonSB


#### Description

The Johnson Special Bounded (SB) distribution [!cite](johnson1994continuous)
is related to the normal distribution. Four parameters
are needed: $\gamma$, $\delta$, $\lambda$, and $\epsilon$. It is a continuous distribution defined on
bounded range $\epsilon \leq x \leq \epsilon + \lambda$, and the distribution can be symmetric or
asymmetric.

Probability Density Function:

f(x) = \tfrac{\delta}{\lambda\sqrt{2\pi} z(1-z)} exp(-\tfrac{1}{2}(\gamma + \delta ln(\tfrac{z}{1-z}))^2),\,\textrm{where}\, z \equiv \tfrac{x-\zeta}{\lambda}

Cumulative Density Function:

F(x) = \Phi(\gamma + \delta ln \tfrac{z}{1-z}),\,\textrm{where}\, z = \tfrac{x-\epsilon}{\lambda}





### Kernel density estimation in 1D


#### Description

The kernel density distribution in 1D object defines a [kernel density](https://en.wikipedia.org/wiki/Kernel_density_estimation) with the provided data vector $\mathbf{x}$, the kernel function $K(.)$,
 and the bandwidth $h$. The probability density of a kernel density is given by:

\begin{equation}
\label{eqn:kernel1d}
\hat{f}_h(x) = \frac{1}{nh} \sum_{i=1}^{n} K(\frac{x-x_i}{h})
\end{equation}

where $n$ is the number of data points in the data vector. Currently, the Gaussian and
the Uniform kernel functions are implemented. For the bandwidth, the user can either
provide a value or request an automatic computation using the data standard deviation or
the [Silverman's rule](https://en.wikipedia.org/wiki/Kernel_density_estimation).

#### Example Input Syntax

The following input file defines a kernel density distribution with `kernel_density_1D_input.csv` as
 an example data input, `Gaussian` as the kernel function, and `Silverman's rule` for the bandwidth.
The data in `kernel_density_1D_input.csv` were drawn from a Normal distribution with a mean and
standard deviation of unity.





### Logistic


#### Description

The logistic distribution is a continuous distribution defined with a location ($\alpha$) and
shape ($\beta$) parameters.

Probability Density Function:

z(x) = \exp{-\frac{(x - \alpha)}{\beta}}
f(x) = \frac{z(x)}{(\alpha * (1.0 + z)^2)}

Cumulative Density Function:

F(x) = \frac{1}{1+z(x)}





### Lognormal

#### Description

The lognormal distribution object defines a
[lognormal distribution](https://en.wikipedia.org/wiki/Log-normal_distribution) function with the
provided `location` and `scale` parameters. The location parameter is equal to the median of the
underlying normal distribution (equal to ${\ln}\theta$, where $\theta$ is the median of the lognormal
distribution) and the scale parameter is equal to the standard deviation of the underlying normal
distribution. The probability density function (PDF) of the lognormal distribution is given by the
[eq:lognormal].

f(x \; | \; m, s) =
\begin{cases}
\frac{1}{xs\sqrt{2\pi}}e^{\frac{-\left( {\ln} x-m \right)^2}{2s^2}} & x>0 ,\\
0 & x\leq0,
\end{cases}

where $m$ is the location parameter and $s$ is the scale parameter ($s > 0$).

#### Example Input Syntax

The following input file defines a lognormal distribution with the location parameter -0.371 and the
scale parameter 0.52.





### Normal


#### Description

The normal (or Gaussian) distribution object defines a
[normal distribution](https://en.wikipedia.org/wiki/Normal_distribution) function with the provided
`mean` and `standard_deviation` parameters. The probability density function (PDF) of the normal
distribution is given by the [eq:normal].

f(x \; | \; \mu, \sigma^2) = \frac{1}{\sqrt{2\pi\sigma^2} } \; e^{ -\frac{(x-\mu)^2}{2\sigma^2} }

where $\mu$ is the mean and $\sigma$ is the standard deviation ($\sigma > 0$) of the distribution.

This implementation of a normal distribution uses a numerical approximation described in
[!cite](kennedy2018statistical).

#### Example Input Syntax

The following input file defines a normal distribution with a mean of 0 and a standard deviation of 1.






### Student t-distribution


#### Overview

This object defines a [student t-distribution](https://en.wikipedia.org/wiki/Student%27s_t-distribution) with one degree of freedom parameter [!param](/Distributions/StudentT/dof) ($\nu$). The probability density function and cumulative distribution function are defined in [eq:t_pdf] and [eq:t_cdf], respectively.

f(x; \nu) = \frac{1}{\sqrt{\nu}\Beta\left(\frac{1}{2},\frac{\nu}{2}\right)} \left(1+\frac{x^2}{\nu}\right)^{-\frac{\nu+1}{2}},

F(x; \nu) = 1 - \frac{1}{2}I_{z(x)}\left(\frac{\nu}{2},\frac{1}{2}\right), \quad z(x) = \frac{\nu}{x^2+\nu},

where $\nu \in \mathbb{Z} > 0$. $\Beta(a,b)$ is the beta function and $I_z(a,b)$ is the regularized incomplete beta function, see [Beta.md] for more details.




### TruncatedNormal


#### Description

The truncated normal (or Gaussian) distribution object defines a
[normal distribution](https://en.wikipedia.org/wiki/Normal_distribution) function with the provided
`mean`, `standard_deviation` and truncation range (`lower_bound` and `upper_bound`) parameters. The probability density function (PDF) of the truncated normal
distribution is given by the [eq:truncated_normal].

\psi(x \; | \; \mu, \sigma^2, a, b) = \begin{cases}
    \frac{\phi((x \; | \; \mu, \sigma^2)}{\Phi(x\;|\;\mu,\sigma^2,b)-\Phi(x\;|\;\mu,\sigma^2,a)},& \text{if } a<x<b\\
    0,              & \text{otherwise}
\end{cases}

The parameters $\mu$ and $\sigma$ are the mean and standard deviation of the general normal PDF. The $\phi((x \; | \; \mu, \sigma^2)$ and $\Phi((x \; | \; \mu, \sigma^2)$ are the general normal PDF and cumulative distribution function (CDF).

#### Example Input Syntax

The following input file defines a normal distribution with a mean of 100, a standard deviation of 25, and truncation range (50,150).






### Uniform


#### Description

The uniform distribution is a probability distribution that has constant probability.
This is a continuous uniform distribution with the probability density function:

if $a < x < b$, then
f(x) = 1/(b - a)

if $x > b$ or $x < a$, then
f(x) = 0

where $a$ and $b$ are the lower bound and upper bound for the uniform distribution, respectively.

#### Example Input Syntax





### Weibull


#### Description

The Weibull object defines a translated Weibull distribution which
has a probability density function (PDF) defined as

f(x;\lambda,k,\theta) =
\begin{cases}
\frac{k}{\lambda}\left(\frac{x-\theta}{\lambda}\right)^{k-1}e^{-(\frac{x-\theta}{\lambda})^{k}} & x\geq0 ,\\
0 & x<0,
\end{cases}

where $k > 0$ and defines the shape parameter, $\lambda > 0$ and defines the scale parameter and $\theta$ is the location parameter of the distribution.

#### Example Input Syntax





## functions

### ScaledAbsDifferenceDRLRewardFunction


#### Overview

Function describing the reward of for a Deep Reinforcement Learning algorithm in the form of:

r = C_1 |x_{target}-x_{current}| + C_2

where $C_1$ and $C_2$ constants can be determined by the user. Furthermore, 
$x_{current}$ is a measured data, typically supplied by a postprocessor. 
For an example on how to use it in a DRL setting, see [LibtorchDRLControlTrainer.md].




## libtorch

## likelihoods

### ExtremeValue


#### Overview

The ExtremeValue (Gumbel) likelihood function is given by:

\begin{equation}
    \label{eqn:triso_likelihood}
    \begin{aligned}
        &\mathcal{L}(\pmb{\theta}, \sigma | \Theta_i, \mathcal{M}, \mathcal{D}_i) = \frac{1}{\beta} \exp{\big(-(z+\exp{(-z)})\big)}\\
        &\text{where,}~z = \frac{M(\pmb{\Theta}_i) - \hat{M}(\pmb{\theta},~\Theta_i)}{\beta}\\
    \end{aligned}
\end{equation}

where, $\hat{M}(\pmb{\theta},~\pmb{\Theta}_i)$ is the model prediction given model parameters $\pmb{\theta}$ and the $i^{\text{th}}$ experimental configuration $\pmb{\Theta}_i$ and $M(\pmb{\Theta}_i)$ is the $i^{\text{th}}$ experimental data point. $\beta$ above the scale of the distribution representing the model inadequacy and experimental noise uncertainties.




### Gaussian


#### Overview

The Gaussian likelihood function considering $N$ experimental configurations is given by:

\begin{equation}
    \label{eqn:triso_likelihood}
    \mathcal{L} = \prod_{i=1}^N \mathcal{N}\big(\hat{M}(\pmb{\theta},~\pmb{\Theta}_i) - M(\pmb{\Theta}_i),~\sigma \big)
\end{equation}

where, $\hat{M}(\pmb{\theta},~\pmb{\Theta}_i)$ is the model prediction given model parameters $\pmb{\theta}$ and the $i^{\text{th}}$ experimental configuration $\pmb{\Theta}_i$ and $M(\pmb{\Theta}_i)$ is the $i^{\text{th}}$ experimental data point. $\sigma$ above is the scale of the distribution representing the model inadequacy and experimental noise uncertainties, while $\mathcal{N}$ represents a Gaussian distribution.

#### Example Input File Syntax





### TruncatedGaussian


#### Overview

The truncated Gaussian likelihood function considering $N$ experimental configurations is given by:

\begin{equation}
    \label{eqn:triso_likelihood}
    \mathcal{L} = \prod_{i=1}^N \mathcal{TN}\big(\hat{M}(\pmb{\theta},~\pmb{\Theta}_i) - M(\pmb{\Theta}_i),~\sigma,~lb,~ub \big)
\end{equation}

where, $\hat{M}(\pmb{\theta},~\pmb{\Theta}_i)$ is the model prediction given model parameters $\pmb{\theta}$ and the $i^{\text{th}}$ experimental configuration $\pmb{\Theta}_i$ and $M(\pmb{\Theta}_i)$ is the $i^{\text{th}}$ experimental data point. $\sigma$ above the scale of the distribution representing the model inadequacy and experimental noise uncertainties.  $\mathcal{TN}$ represents a truncated Gaussian distribution with $lb$ and $ub$ lower and upper bounds, respectively.




## multiapps

### PODFullSolveMultiApp

This object is responsible for producing snapshots and residuals for [PODReducedBasisTrainer.md].
When the object is executed for the first time, it operates as a [SamplerFullSolveMultiApp.md]
to generate snapshots with different parameter samples. When it is called for the second time,
it generates residuals for given vector tags in each sub-application using the POD modes from
a [PODReducedBasisTrainer.md] object.

#### Example Syntax

This MultiApp type needs a [!param](/MultiApps/PODFullSolveMultiApp/trainer_name)
 parameter which allows to access certain
data members of a [PODReducedBasisTrainer.md]. Otherwise, the input syntax is
the same as in case of [SamplerFullSolveMultiApp.md].





### SamplerFullSolveMultiApp


#### Overview

The [SamplerFullSolveMultiApp](#) simply creates a full-solve type sub application (see [MultiApps])
for each row of each matrix returned from the [Sampler](stochastic_tools/index.md#samplers) object.

This object is capable of running in batch mode by setting the 'mode' parameter. For more
information refer to [batch_mode.md].

#### Dealing with Failed Solves

When performing stochastic analysis with many perturbations of a sub-application,
it is sometimes the case where the app receives a set of parameters that makes the
solve difficult to converge. With the default configuration of this object, if one
of sub-applications' solve fails, the main application will abort. This will cause
the main application to stop sampling the sub-application and all the transfers
and processing will fail as well. To prevent this, setting the parameter
[!param](/MultiApps/SamplerFullSolveMultiApp/ignore_solve_not_converge) to true
will allow the main application to continue, despite there being a failed solve.
For options on how failed solve results get transferred to the main application,
see [SamplerPostprocessorTransfer](SamplerPostprocessorTransfer.md). If the
sub-application is a [transient](Transient.md) simulation, the parameter
[!param](/Executioner/Transient/error_on_dtmin) +must+ be set to false in the
`Executioner` block.


#### Defining Minimum Processors Per App

It is often useful to define the minimum processors to use when running sub-applications.
Typically this is done for large models in batch mode to avoid excessive memory usage.
The [!param](/MultiApps/SamplerFullSolveMultiApp/min_procs_per_app) will utilize this
capability, however it is +required+ that the [!param](/Samplers/MonteCarlo/min_procs_per_row)
parameter in the `Samplers` block be set to the same value. This is to ensure that
the sampler partitioning is equivalent to the multiapp partitioning.


#### Skipping Sample Solves

The parameter [!param](/MultiApps/SamplerFullSolveMultiApp/should_run_reporter)
allows for an inputted reporter value to determine whether the sub-app should
be run for a certain sample. And example of using this parameter can be found in
[ConditionalSampleReporter.md].

#### Example Syntax





### SamplerTransientMultiApp

The [SamplerTransientMultiApp](#) simply creates a transient-type sub application (see [MultiApps]) for each row of
each matrix returned from the [Sampler](stochastic_tools/index.md#samplers) object.

This object is capable of running in batch mode by setting the 'mode' parameter. For more
information refer to [batch_mode.md].


#### Example Syntax





## outputs

### MappingOutput


#### Overview

[Mapping objects](VariableMappings/index.md), once trained, can be output to a binary file for later
use by using this object. All data within the model that was declared using
`RestartableModelInterface::declareModelData()` is automatically stored in the generated file.

#### Example Input File Syntax


#### Syntax




### SurrogateTrainerOutput


#### Overview

[Surrogate models](Surrogates/index.md), once trained, can be output to a binary file for later
use by using the SurrogateTrainerOutput object. All data within the model that was declared using
`declareTrainerData` is automatically stored in the generated file.

#### Example Input File Syntax

The following snippet includes a surrogate model that is being trained and after the training is
complete the model data is output using the SurrogateTrainerOutput object.





## postprocessors

### AdaptiveSamplingCompletedPostprocessor


#### Overview

This object reports whether an adaptive sampler has completed its sampling.
It is automatically built by [AdaptiveSamplerAction](AdaptiveSamplerAction.md) if an adaptive sampler is used.




## reporters

### ActiveLearningGPDecision


#### Description

The `ActiveLearningGPDecision` is a Reporter class that performs the following functions to facilitate the active learning process in a parallelized fashion:

- For every new batch of input samples produced by the [ActiveLearningMonteCarloSampler](ActiveLearningMonteCarloSampler.md), the corresponding Gaussian Process (GP) predictions are made.
- These GP predictions are assessed for their quality by using the uncertainty information. If any of the predictions are of poor quality in the batch, those samples are marked and this information is sent back to the [ActiveLearningMonteCarloSampler](ActiveLearningMonteCarloSampler.md).
- Once a user-specified batch size of inputs for running the high-fidelity model evaluations (i.e., those input samples for which the GP predictions are poor) is met and these evaluations are executed in parallel, re-train the GP model via the [ActiveLearningGaussianProcess](ActiveLearningGaussianProcess.md) Surrogate class.
- Output the GP mean predictions and standard deviations and corresponding inputs to a json file. Also indicate those input samples for which a high-fidelity model evaluation was necessary during the active learning.

#### Why Gaussian Process surrogate for active learning?

A GP is a Bayesian surrogate model. This means, in addition to making predictions of the high-fidelity model outputs, a GP produces uncertainty estimates of its outputs. Higher the uncertainty, lesser the confidence in the GP predictions. An illustration of the GP predictions and associated uncertainties is presented in [!ref](al1_sch). In addition, many studies (e.g., [!cite](xiu2019al) and [!cite](dhulipala2022al)) have found that the uncertainty estimates produced by a GP are robust. This in-built uncertainty information permits us to create an active feedback loop between the training data and GP in that we can use the GP uncertainty estimates to select the next best training data point(s). As such, we can even start the active learning process using a GP that is trained with little data.


Of the spectrum of Bayesian surrogate models, a GP is the most straight-forward to train. First, during active learning, the training data set size would typically be small (in the order of hundreds) for most problems. Therefore, re-training the GP should be associated with a low computational cost. Even in those extreme cases where the training data set size becomes large, we can adopt stochastic optimization methods like Adam optimization [!cite](kingma2014adam) (this feature is available in MOOSE [GaussianProcessTrainer](GaussianProcessTrainer.md)) to select a mini-batch of the training data set and substantially reduce the computational expense.

Owing to these reasons, a GP surrogate is usually preferred for active learning. However, for the sake of completeness, we note that there have been other studies that have used different surrogates like a polynomial chaos expansion for active learning (e.g., [!cite](marelli2019al)).

#### Procedure for active learning in MOOSE

In general, active learning has two phases: (1) initial training phase for the GP; and (2) the active learning phase.

[!ref](al2_sch) presents the initial training phase of the GP surrogate. The [ActiveLearningMonteCarloSampler](ActiveLearningMonteCarloSampler.md) sends a batch of input samples for high-fidelity model executions to the [SamplerFullSolveMultiApp](SamplerFullSolveMultiApp.md). These high-fidelity models executions are performed in parallel using separate sets of processors. Outputs from the model executions will be collected by the `ActiveLearningGPDecision` reporter. Once a required number of training data size is reached, `ActiveLearningGPDecision` will call the [ActiveLearningGaussianProcess](ActiveLearningGaussianProcess.md) to initially train the GP model.


[!ref](al3_sch) presents the subsequent active learning phase. The [ActiveLearningMonteCarloSampler](ActiveLearningMonteCarloSampler.md) sends a batch of input samples to the `ActiveLearningGPDecision` reporter. Then, the [ActiveLearningGaussianProcess](ActiveLearningGaussianProcess.md) is called to make GP predictions. In addition, `ActiveLearningGPDecision` assesses the quality of the GP predictions through user-defined acquisition (or learning) functions. Some popular acquisition functions are currently available, and it is easy to include additional functions in the `ActiveLearningGPDecision` class. If one or more of the GP predictions are poor (as indicated by the acquisition function), the corresponding input samples are marked and this information is communicated to the [ActiveLearningMonteCarloSampler](ActiveLearningMonteCarloSampler.md). This process continues until a user-defined batch size is met for the maximum number of poor quality GP predictions. Once this threshold is reached, the [ActiveLearningMonteCarloSampler](ActiveLearningMonteCarloSampler.md) sends the batch of those book-marked input samples whose GP predictions are poor for high-fidelity model evaluations. The batch of high-fidelity models can be run in parallel. Then, the high-fidelity model outputs are acquired by the `ActiveLearningGPDecision` reporter where the GP model is re-trained. This process then repeats until the user-specified number of Monte Carlo samples is met.


#### Input file syntax

The full input file driver for active learning is presented below. The three main components of the input file are [ActiveLearningMonteCarloSampler](ActiveLearningMonteCarloSampler.md), [ActiveLearningGaussianProcess](ActiveLearningGaussianProcess.md), and `ActiveLearningGPDecision`. These are discussed in detail below.


##### `ActiveLearningMonteCarloSampler`

The Sampler block of the input file is presented below. As with the regular [MonteCarloSampler](MonteCarloSampler.md), this block requires the `distributions` of the input parameters to the subApp. The [!param](/Samplers/ActiveLearningMonteCarloSampler/num_batch) parameter specifies the number of input samples to sample per step and also the number of allowed poor GP predictions before launching the high-fidelity model executions in parallel. The [!param](/Samplers/ActiveLearningMonteCarloSampler/flag_sample) is a Reporter object of type vector bool which indicates which GP predictions in the batch are poor to the Sampler.


##### `ActiveLearningGaussianProcess` and `GaussianProcess`

The surrogate Trainers block of the input file is presented below. As with the regular [GaussianProcessTrainer](GaussianProcessTrainer.md), this block has the required parameters for training a GP model. The key difference with [ActiveLearningGaussianProcess](ActiveLearningGaussianProcess.md) is that it permits re-training of the GP model on the fly; this functionality is used by the `ActiveLearningGPDecision` Reporter. The below block presents [ActiveLearningGaussianProcess](ActiveLearningGaussianProcess.md) relying on Adam optimization for re-training the GP model.


The below block presents [ActiveLearningGaussianProcess](ActiveLearningGaussianProcess.md) relying on TAO optimization for re-training the GP model.


Once the GP model is re-trained, the `GaussianProcess` Surrogate is used by `ActiveLearningGPDecision` Reporter for making the GP predictions and uncertainty quantification. This block of the input file is presented below.


##### `ActiveLearningGPDecision`

The `Reporters` block of the input file is presented below. It requires the name of the [ActiveLearningMonteCarloSampler](ActiveLearningMonteCarloSampler.md) sampler. It also requires the names of the Reporter variables (which are all vectors) [!param](/Reporters/ActiveLearningGPDecision/flag_sample), [!param](/Reporters/ActiveLearningGPDecision/inputs), [!param](/Reporters/ActiveLearningGPDecision/gp_mean), and [!param](/Reporters/ActiveLearningGPDecision/gp_std) which, respectively, correspond to GP predictions being good/poor, input samples, GP mean predictions, and associated standard deviations. The values of these Reporters are all stored in an output json file.

In addition, the [!param](/Reporters/ActiveLearningGPDecision/n_train) parameter specifies the number of initial steps after which the GP model is first trained. [!param](/Reporters/ActiveLearningGPDecision/al_gp) specifies the name of [ActiveLearningGaussianProcess](ActiveLearningGaussianProcess.md) for facilitating GP re-training and [!param](/Reporters/ActiveLearningGPDecision/gp_evaluator) specifies the name of `GaussianProcess` for facilitating GP predictions and uncertainty quantification.

Finally, [!param](/Reporters/ActiveLearningGPDecision/learning_function) specifies the name of the acquisition (or learning) function. [!param](/Reporters/ActiveLearningGPDecision/learning_function_parameter) specifies a parameter for the acquisition (or learning) function; it may or may not be required depending upon the type of the acquisition (or learning) function used. For example, the U acquisition (or learning) function requires [!param](/Reporters/ActiveLearningGPDecision/learning_function_parameter) but the COV acquisition (or learning) function does not. [!param](/Reporters/ActiveLearningGPDecision/learning_function_threshold) specifies the acceptable threshold for the acquisition (or learning) function beyond which the GP predictions are marked as poor.


#### Output format

The recommended output format for using active learning is a json file. For each time step, the json file contains vectors of input samples, `need_sample` bool variables (indicating good/poor GP predictions), GP mean predictions, and associated standard deviations. The total number of samples equals [!param](/Samplers/ActiveLearningMonteCarloSampler/num_samples), including the [!param](/Reporters/ActiveLearningGPDecision/n_train) samples used for training. The total number of times `need_sample` value is `True` is the total samples for which GP re-training is required after the initial training.

When processing the json file, the samples whose `need_sample` value is `True` need to be ignored to avoid repeated results. Therefore, the number of output samples with `need_sample` set to False should be equal to [!param](/Samplers/ActiveLearningMonteCarloSampler/num_samples), as any re-training step does not count as an accepted sample.

#### Other supported sampler types

The following samplers are also supported with the `ActiveLearningGPDecision` reporter:

- +Active Learning in Adaptive Importance Sampling (AIS-AL)+

  See [AISActiveLearning](AISActiveLearning.md) for more information.




### AdaptiveImportanceStats


#### Description

This Reporter class computes the statistics associated with the [AdaptiveImportanceSampler](AdaptiveImportanceSampler.md)
 and [AISActiveLearning](AISActiveLearning).

#### Available statistics

The following statistics have been implemented:

- +Failure probability (pf)+

  This is the number of samples causing model failure divided by the total number evaluation
  samples. For computing this statistic, the samples from the training phase of [AdaptiveImportanceSampler](AdaptiveImportanceSampler.md)
  are not used. The equation for computing pf is given by [!cite](au1999new):

  \hat{P}_f^{\textrm{AIS}} = \frac{1}{N}~\sum_{i=1}^N I\big(F_i(\pmb{x})\geq \mathcal{F}\big)~\frac{q(\pmb{x})}{f(\pmb{x})}

  where, $q(.)$ is the nominal density, $f(.)$ is the importance density, and $I[.]$ is
  the indicator function of model failure.

- +Coefficient of variation (cov)+

  This quantity is computed as the ratio of square root of variance of pf to the
  mean pf. The variance of pf is given by [!cite](au1999new):

  \textrm{Var}(\hat{P}_f^{\textrm{AIS}}) = \frac{1}{N}~\Bigg\{\frac{1}{N}~\sum_{i=1}^{N}\Bigg[I\big(F_i(\pmb{x})\geq \mathcal{F}\big)~\frac{q(\pmb{x})}{f(\pmb{x})}\Bigg]^2-\big(\hat{P}_f^{\textrm{AIS}}\big)^2\Bigg\}

  The cov is given by:

  \hat{\delta}^{\textrm{AIS}} =\frac{\sqrt{\textrm{Var}(\hat{P}_f^{\textrm{AIS}})}}{\hat{P}_f^{\textrm{AIS}}}

  For computing this statistic, the samples from the training phase of [AdaptiveImportanceSampler](AdaptiveImportanceSampler.md)
  are not used.

- +Means of the importance distributions (mu_imp)+

  These are the means of the importance distributions in a standard Normal space.

- +Standard deviations of the importance distributions (std_imp)+

  These are the standard deviations of the importance distributions in a standard Normal space.




### AdaptiveMonteCarloDecision


#### Description

Adaptive Monte Carlo algorithms, generally speaking, work by proposing the next set
of input parameters, performing a model evaluation, and deciding whether or not to
accept the proposed input parameters. Classes derived from the [Sampler](Sampler.md)
class help propose the next set of input parameters and classes derived from the
MultiApp system to evaluate the model. However, an additional
class is needed to make the decision on whether or not to accept the next input parameters
proposed by the sampler class. To this end, `AdaptiveMonteCarloDecision` will help
make such decisions. `AdaptiveMonteCarloDecision` is designed as a reporter class
since a reporter has access to both the sampler objects and the MultiApp system.

#### Available adaptive Monte Carlo samplers

The following adaptive Monte Carlo samplers have been implemented in MOOSE:

- +Adaptive Importance Sampling (AIS)+

  AIS proposes and accepts the next input parameters using a Markov Chain Monte Carlo
  scheme to sample sufficiently in the failure region given a model. See [AdaptiveImportanceSampler](AdaptiveImportanceSampler.md)
  for more information.

- +Parallel Subset Simulation (PSS)+

  PSS can be used for characterizing probabilistic failure or performing optimization under uncertainty
  efficiently when dealing with expensive numerical models. This method works
  by creating intermediate failure thresholds and using hundreds of Markov chains to
  efficiently propagate to regions of the input parameter space that are most significant
  for either failure characterization or optimization. See [ParallelSubsetSimulation](ParallelSubsetSimulation.md) for more information.

- +Active Learning in Adaptive Importance Sampling (AIS-AL)+

  Similar to the AIS method, except that instead of calling the full model every time, a Gaussian Process surrogate is called as part
  of an active learning scheme. See [AISActiveLearning](AISActiveLearning.md) for more information.




### AffineInvariantDifferentialDecision


#### Overview

The `AffineInvariantDifferentialDecision` class derives from [PMCMCDecision](PMCMCDecision.md) and only overrides the `computeTransitionVector` function. This is to implement the acceptance probability computation step defined by the equation [!cite](Braak2006a):

\begin{equation}
    \label{eqn:ens_5}
    t_{\mathcal{S}_{y^{p}_{-1}} \mathcal{S}_{y^p}} = \min{\bigg\{1,~\frac{\mathcal{L}(\mathcal{S}_{y^p}) \mathcal{P}(\mathcal{S}_{y^p})}{\mathcal{L}(\mathcal{S}_{y^{p}_{-1}}) \mathcal{P}(\mathcal{S}_{y^{p}_{-1}})}\bigg\}}
\end{equation}

where $\mathcal{S}_{y^{p}_{-1}}$ the accepted state at index $p$ from the previous step, $\mathcal{S}_{y^{p}}$ the proposed state at index $p$ from the current step, $\mathcal{L}$ is the likelihood function, and $\mathcal{P}$ is the prior distribution.




### AffineInvariantStretchDecision


#### Overview

The `AffineInvariantStretchDecision` class derives from [PMCMCDecision](PMCMCDecision.md) and only overrides the `computeTransitionVector` function. This is to implement the acceptance probability computation step defined by the equation [!cite](Goodman2010a):

\begin{equation}
    \label{eqn:ens_3}
    t_{\mathcal{S}_{y^{p}_{-1}} \mathcal{S}_{y^p}} = \min{\bigg\{1,~(z^p)^{(M+1)-1}~\frac{\mathcal{L}(\mathcal{S}_{y^p}) \mathcal{P}(\mathcal{S}_{y^p})}{\mathcal{L}(\mathcal{S}_{y^{p}_{-1}}) \mathcal{P}(\mathcal{S}_{y^{p}_{-1}})}\bigg\}}
\end{equation}

where $\mathcal{S}_{y^{p}_{-1}}$ the accepted state at index $p$ from the previous step, $\mathcal{S}_{y^{p}}$ the proposed state at index $p$ from the current step, $\mathcal{L}$ is the likelihood function, $\mathcal{P}$ is the prior distribution, and $(M+1)$ is the number of model parameters plus the $\sigma$ term to be inferred.




### BiFidelityActiveLearningGPDecision


#### Description

The `BiFidelityActiveLearningGPDecision` class has a very similar behavior as the [ActiveLearningGPDecision](ActiveLearningGPDecision.md) class. The figure below demonstrates the behavior of active learning with bi-fidelity modeling using Monte Carlo sampling with [ActiveLearningMonteCarloSampler](ActiveLearningMonteCarloSampler.md). Instead of relying on a Gaussian Process (GP) prediction by default, a low-fidelity (LF) model prediction that is cheap to evaluate is used. Then, a GP correction is added to the LF model prediction to improve its quality and also quantify the LF prediction uncertainty. The GP itself is trained on the differences between the high-fidelity (HF) and LF model predictions. If the GP-corrected LF model prediction is not acceptable based on the uncertainty information, only then, the expensive HF model is called. Otherwise, the GP-corrected LF model predictions are used in a Monte Carlo sampler. Moreover, the calls to both the LF and HF model can be parallelized with the `num_batch` option in [ActiveLearningMonteCarloSampler](ActiveLearningMonteCarloSampler.md). When set to 1, it represents a serial Monte Carlo sampling.


#### Input file syntax

The input file syntax is largely similar to GP-based active learning described in [ActiveLearningGPDecision](ActiveLearningGPDecision.md). There are three fundamental differences for leveraging bi-fidelity modeling.

First, the `MultiApps` block needs to have two subApps, one for the LF model and one for the HF model. This is shown in the listing below.


Second, the `Transfers` block needs to transfer the stochastic parameters to both the LF and HF models. Also, the outputs need to be transferred back to the mainApp from both the LF and HF models. This is shown in the listing below.


Third, instead of relying on [ActiveLearningGPDecision](ActiveLearningGPDecision.md) for evaluating the quality of the GP-corrected LF model prediction, we rely on `BiFidelityActiveLearningGPDecision`. This takes into account the LF model predictions, as shown in the listing below.





### ConditionalSampleReporter


#### Description

This object is a type of [StochasticReporter.md], so it can be used in to transfer reporters into using [SamplerReporterTransfer.md]. This object is mainly meant for demonstration for eventual active learning algorithms, but could prove useful. Basically, it enables a inputted function to determine if a multiapp solve is "possible" based on sampler values. The parsed function inputted with the parameter [!param](/Reporters/ConditionalSampleReporter/function) should evaluate to 0 or `false` if multiapp run is not possible/necessary. The variables within the function should be associated with a sampler column, which is defined by the pair of parameters [!param](/Reporters/ConditionalSampleReporter/sampler_vars) and [!param](/Reporters/ConditionalSampleReporter/sampler_var_indices). If the inputted function evaluates to 0 or `false`, the quantity being transferred to this object using [SamplerReporterTransfer.md] with be replaced with [!param](/Reporters/ConditionalSampleReporter/default_value).

#### Example Input Syntax

An example usage of this reporter is to ensure that the sampler values are positive. For demonstration, the following makes sure that the sampler value is greater-than or equal to the current simulation time. If it isn't, the multiapp is not run and the transferred quantity is replaced with a value of `1.0`.





### CrossValidationScores


#### Overview

This reporter outputs the results of the [examples/cross_validation.md] study for each [surrogate model](Surrogates/index.md) specified in [!param](/Reporters/CrossValidationScores/models). The output is a vector of vectors reporter value for each model, where the first index is the response (a single value unless creating a surrogate for a vector of data) and the second index is the study's trial index.




### DirectPerturbationReporter


#### Overview

This reporter is designed to compute direct
perturbation-based sensitivity
coefficients using samples obtained by [DirectPerturbationSampler.md].
The available methods and settings are discussed in
[DirectPerturbationSampler.md] in detail.

#### Example Input Syntax

The following example computes the local sensitivity coefficients of three linear functions that can be described as:

\begin{equation}
  f_1(\mu_1,\mu_2,\mu_2)=\mu_1+2\mu_2+3\mu_3
\end{equation}

\begin{equation}
  f_2(\mu_1,\mu_2,\mu_2)=4\mu_1+5\mu_2+6\mu_3
\end{equation}

\begin{equation}
  f_3(\mu_1,\mu_2,\mu_2)=7\mu_1+8\mu_2+9\mu_3
\end{equation}



The resulting output is a [json file](JSONOutput.md) with the sensitivity coefficients:


We see that the method recovers the expansion coefficients of
the $f_i$ functions exactly.




### EvaluateSurrogate


#### Overview

The EvaluateSurrogate object takes in a sampler and surrogate models and executes the `evaluate` method within each surrogate for each row of the sampler.
See [examples/surrogate_creation.md], [examples/surrogate_training.md], and [examples/surrogate_evaluate.md] for more information regarding surrogate modeling.

#### Example Syntax






### IndependentMHDecision (Independent Metropolis-Hastings Decision)


#### Overview

The `IndependentMHDecision` derives from [PMCMCDecision](PMCMCDecision.md) and overrides both the `computeEvidence` and the `computeTransitionVector` functions. This is due to the fact that Metropolis-Hastings samplers use a single seed to compute the next $P$ proposals and the evidences for all these samples need to be evaluated in reference to the seed sample. As such, any MCMC sampler that follows this single seed principle should derive from `IndependentMHDecision` and should typically only override the `computeTransitionVector` function, depending upon its mathematical construction.

Parallelized Metropolis-Hastings class of samplers is proposed by [!cite](Calderhead2014a). The sampling procedure is similar to that of a serial Metropolis-Hastings sampler with some modifications to account for the parallelization. At each serial step, a seed state $\mathcal{S}_x$ is defined. Using this seed state, $P$ parallel proposals are made using a proposal distribution $\mathcal{G}$. The computational model is evaluated in parallel for these proposals and likelihood function is computed. Then, a transition probability vector $\pmb{t}_{xy}$ is computed whose elements are defined as:

\begin{equation}
    \label{eqn:imh_2}
    \pmb{t}_{xy} = \begin{cases}
  \frac{1}{P} \min{(1,~t_{xy^p})}  & \text{ if } x\neq y  \\
  1-\sum_{x\neq y} \pmb{t}_{xy} & \text{ otherwise}
\end{cases}
\end{equation}

where $t_{xy^p}$ is the transition probability defined as shown in the above equation for the $p^{\text{th}}$ parallel proposal. Each of the $P$ parallel proposals is accepted or rejected with a probability defined by the corresponding index in the vector $\pmb{t}_{xy}$. [!cite](Calderhead2014a) proved the theoretical convergence of this parallelized Metropolis-Hastings construction to the required posterior. In addition, the proposal distribution $\mathcal{G}$ can be defined in a flexible way in that it can be a random-walk proposal, Langevin dynamics [!cite](Cheng2022a) proposal, or Hamiltonian dynamics [!cite](Betancourt2017a) proposal.




### MappingReporter


#### Overview

This object is responsible for mapping high-dimensional solution fields to low-dimensional
vectors. The mapped vectors are then stored within the reporter data storage. The
[!param](/Reporters/MappingReporter/mapping) parameter can be used to specify the
mapping object from the `VariableMappings` block. The variables which need to be mapped can be defined using
[!param](/Reporters/MappingReporter/variables). There are two distinct ways to use this object:

1. +In conjunction with a [ParallelSolutionStorage.md] object:+ In this case, the first time
   this object is executed, it will build the mapping using the available data in the parallel storage.
   Then, using the generated mapping, it maps the solution fields in the parallel storage into the latent space and
   saves the coordinates into the reporter storage. This gives a straightforward pipeline for the training
   of surrogate models for the coordinates of the solutions fields in the latent space. In this case,
   the user is expected to define the [!param](/Reporters/MappingReporter/parallel_storage) and
   [!param](/Reporters/MappingReporter/sampler) parameters.

2. +Without a [ParallelSolutionStorage.md] object:+ This functionality is designed to load an already
   trained mapping object and map a solution variable in a nonlinear system into the latent space and
   store the coordinates in this reporter.


#### Example Input File Syntax

Example for mapping solutions in a [ParallelSolutionStorage.md] object:


Example for mapping solutions:


#### Syntax




### MorrisReporter


#### Overview

This object computes the Morris sensitivity quantities following the procedure defined by
[!cite](saltelli2008global). The MorrisReporter object only operates on result data
generated from Morris-based sampling strategy, which is provided by the [MorrisSampler.md].

#### Elementary Effects

Much of the following information is taken directly from the [GSA module](https://gsa-module.readthedocs.io/en/stable/implementation/morris_screening_method.html), see this documentation for more details.

Given a model with $D$ parameters defined by the vector $\vec{x}$ and a model with response function $f(\vec{x})$ the elementary effect for a given parameter $k$ is defined as [!cite](morris1991factorial):

EE_k = \frac{f(\vec{x} + \vec{\Delta_d}) - f(\vec{x})}{\Delta_d}\,, k=1,...,D ,

where $\Delta_k$ is a perturbation of parameter $x_k$ and $\vec{\Delta_k}$ is a vector of length $D$ of all zeros except the $k$th entry equal to $\Delta_k$. Given a one-at-a-time (OAT) sampling strategy, detailed in [MorrisSampler.md], with $N$ replicates, or trajectories, there will be a total of $N\times D$ elementary effects. The purpose of computing these elementary effects is to evaluate a local sensitivity over these random trajectories, the global sensitivity can then be gleaned by accumulating these local effects. As such, this reporter computes the following statistics of this elementary effect matrix:

\mu_d = \frac{1}{N}\sum_{i=1}^{N}EE_{i,d},

\mu_d^{*} = \frac{1}{N}\sum_{i=1}^{N}|EE_{i,d}|,

\sigma_d = \sqrt{\frac{1}{N-1}\sum_{i=1}^{N}\left(EE_{i,d} - \mu_d\right)^2} .

The $\mu^{*}$ statistic is typically preferred over $\mu$ because it is agnostic to negative effects that could cancel out positive ones when sampling. These statistics can be interpreted as the effect of the parameters on the response in the following ways:

1. $\mu^{*} \approx 0, \sigma \approx 0$: parameter has no influential impact on the response.
1. $\mu^{*} >> 0$: parameter has a significant impact on the response.
1. $\sigma >> 0$: parameter has nonlinear or interactive effects.
1. $\mu^{*} >> 0, \sigma \approx 0$: parameter is additive or linear
1. $\mu^{*} \approx 0, \sigma >> 0$: parameter has a negligible aggregate effect on the response while nonlinear perturbations (perturbing in more than one direction) can be significant.

This reporter can also compute confidence intervals using percentile bootstrapping. This works by randomly sampling replicates, or trajectories, re-computing the statistics, sorting them, then choosing the requested percentile.

##### Trajectory Design

Computing elementary effects from the trajectory design is rather simple. For a single trajectory matrix ($\mathbf{x_{i}}$) and the corresponding response vector ($\vec{y_i}$), the elementary effects ($\vec{EE_{i}}$) can be computed as:

\vec{EE_{i}} = \delta\mathbf{x_i}^{-1}\delta\vec{y_i}\,, i=1,...,N,

where

(\delta\mathbf{x_i})_{j,d} = (\mathbf{x_i})_{j+1,d} - (\mathbf{x_i})_{j,d},\quad  (\delta\vec{y_i})_{j,d} = (\vec{y_i})_{j+1,d} - (\vec{y_i})_{j,d},\quad j,d=1,...,D

Taking the first trajectory in [this sampling](test/tests/samplers/morris/gold/morris_out_data_0000.csv):

\mathbf{x_1} = \begin{bmatrix}
0.4 & 0.0 & 0.2 \\
0.4 & 0.6 & 0.2 \\
0.4 & 0.6 & 0.8 \\
1.0 & 0.6 & 0.8
\end{bmatrix} , \quad
\delta\mathbf{x_i} = \begin{bmatrix}
0 & 0.6 & 0 \\
0 & 0 & 0.6 \\
0.6 & 0 & 0
\end{bmatrix},

\vec{y_1} = \begin{bmatrix}
y_1 \\
y_2 \\
y_3 \\
y_4
\end{bmatrix} , \quad
\delta\vec{y_1} = \begin{bmatrix}
y_2 - y_1 \\
y_3 - y_2 \\
y_4 - y_3
\end{bmatrix},

\vec{EE_1} = \begin{bmatrix}
(y_2 - y_1)/0.6 \\
(y_3 - y_2)/0.6 \\
(y_4 - y_3)/0.6
\end{bmatrix}.

#### Example Input Syntax

The following example computes the elementary effect statistics along with 10% and 90% confidence points for two scalar quantities and one vector quantity:


The resulting output is a [json file](JSONOutput.md) with the statistics and their confidence intervals:


We see that for each vector we have three quantities: `mu` for $\mu$, `mu_star` for $\mu^{*}$, `sigma` for $\sigma$. Each has a pair containing a vector and a vector of vectors of the response value type. The first is the computed value for each parameter. The second has an entry for these values for each confidence point.




### ParallelSolutionStorage


#### Overview

This object serves as a central storage for serialized solution fields in a stochastic
simulation. The solution fields are indexed by variable name (alphabetically) and global sample index.
The solutions are stored in a parallel fashion, distributed based on which process
deposits the serialized solution field.
For time-dependent simulations this object holds multiple solution fields for each
global sample index. External objects can deposit data in this container using the following function:

 start=addEntry
 end=DenseVector
 include-end=true

#### Example Input File Syntax


#### Syntax




### PMCMCDecision (Parallel MCMC Decision)


#### Overview

The `PMCMCDecision` is the base class for performing MCMC decision making in STM and it is a [Reporter](Reporters/index.md) object. `PMCMCDecision` overrides the `execute` function in the [Reporter](Reporters/index.md). `PMCMCDecision` takes as inputs the subApp outputs, the sampler object, and the likelihoods. The `PMCMCDecision` object itself facilitates a regular Monte Carlo sampling, rather than a MCMC sampling by accepting all the proposals made by the sampler class. However, it provides functionalities to perform MCMC sampling through derived classes via several protected and public functions. An overview of these functions is presented in the Table below.

| Function | Description
| - |  - |
| `computeEvidence` |  Computes the logarithmic ratio of likelihood times prior of new to old samples
| `computeTransitionVector` | Computes the vector of acceptance probabilities
| `nextSamples` | Makes accept/reject decisions and transmits the accepted inputs and outputs
| `nextSeeds` | Initializes the next seed input for certain MCMC samplers
| `execute` | Main code block which facilitates evidence and transition probability computations, accept/reject decisions, and transmission of results to JSON. Ideally, this should not be overridden by derived classes. Any changes to this in the base will effect all MCMC decision classes behavior

The `execute` function in `PMCMCDecision` is typically not meant to be overridden by the derived classes, although this can be done. `execute` gathers the MultiApps outputs from all the processors, sets up a matrix of outputs and input parameters, computes the evidence and transition vectors, assembles the accepted samples based on the transition probabilities, and transmits the accepted sample inputs and outputs to a JSON file. For some MCMC samplers like the [IndependentMHDecision](IndependentMHDecision.md) which relies on a single seed to propose the next samples, the `execute` function also calls the `nextSeeds` function which is overridable. Finally, the construction of the `execute` is assumed to uniformly apply to all MCMC samplers and it should be noted that any changes made to it can influence the behavior of existing and future MCMC samplers.

A decision making class for a new MCMC sampler should derive from `PMCMCDecision` and typically only override the `computeTransitionVector` function. The [IndependentMHDecision](IndependentMHDecision.md) sampler is an exception because it relies on a single seed.




### PolynomialChaosReporter


#### Overview

This object is meant to compute relevant statistics and sensitivities from a [PolynomialChaos.md] surrogate and output information about the model. Users can specify multiple models in the [!param](/Reporters/PolynomialChaosReporter/pc_name) parameter.

##### Statistics

To compute statistics from a [PolynomialChaos.md] surrogate, use the [!param](/Reporters/PolynomialChaosReporter/statistics) parameters. So far, mean, standard deviation, skewness, and kurtosis can all be computed. See [PolynomialChaos.md] for more details on the calculation of these statistics. The output from this computation is largely identical to [StatisticsReporter.md].



##### Sobol Sensitivity

Setting the [!param](/Reporters/PolynomialChaosReporter/include_sobol) to `true` will compute sobol indices from the inputted polynomial chaos models. The algorithm is based on computations described in [!cite](sudret2008global). The object will compute total, first-, and second-order indices. The output is largely identical to [SobolReporter.md].



##### Local Sensitivity

Users can compute local sensitivities with this object by including the [!param](/Reporters/PolynomialChaosReporter/local_sensitivity_points) and/or [!param](/Reporters/PolynomialChaosReporter/local_sensitivity_sampler) parameters. The local sensitivity of a quantity of interest $u$, for a parameter $\xi_p$ at a point ($\vec{\xi}$) is defined as:

S_p = \frac{\partial u(\vec{\xi})}{\partial \xi_p} \frac{\xi_p}{u(\vec{\xi})}

For each inputted model, the output will contain a two matrix reporter value corresponding to the points specified by [!param](/Reporters/PolynomialChaosReporter/local_sensitivity_points) and [!param](/Reporters/PolynomialChaosReporter/local_sensitivity_sampler). The row of the matrix corresponds to the point and column corresponds to the derivative with respect to the parameter $\xi_p$.



##### Model Data

Users can output the information on the models inputted by setting the [!param](/Reporters/PolynomialChaosReporter/include_data) parameter to `true`.






### SingularTripletReporter


#### Overview

This object is responsible for outputting singular triplets (left and right singular vectors together
with the corresponding singular values) from a [PODMapping.md]. The process is designed to work with
a JSON format. One can select the variables whose singular triplets shall be printed using
the [!param](/Reporters/SingularTripletReporter/variables) parameter.

#### Example Input File Syntax


#### Syntax




### SobolReporter


#### Overview

This object computes the Sobol sensitivity indices following the procedure defined by
[!cite](saltelli2002making). This includes the first-order and total-effect indices and optionally
the second-order indices as well. The SobolReporter object only operates on result data
generated from Sobol-based sampling strategy, which is provided by the [SobolSampler.md].

#### Example Input File Syntax

The following input snippet uses the GFunction test object, which is defined as:

g(x_1, x_2, \ldots, x_n) = \prod_{i=1}^n\frac{|4x_i-2|+q_i}{1+q_i},

where $\vec{q}$ is defined in the input file, $x$ is the vector of model data, and $n$ is the number
of input variables. The $x$ data is generated by the Sobol sampler object.

##### Sobol Statistics on VectorPostprocessor Data

The following shows the computation of sobol indices on data generated from a VectorPostprocessor.
With the [JSONOutput.md] output object, the resulting computation is outputted to a JSON file.


The resulting JSON output includes general information about the data, including how many parameters
were observed and the indices being computed. This example includes `FIRST_ORDER`,
`SECOND_ORDER`, and `TOTAL` indices. Following the reporter information, the values are shown
as a pair of each set of indices and the associated confidence intervals (if requested).
`FIRST_ORDER` and `TOTAL` indices are vectors with each element corresponding to a parameter.
The `SECOND_ORDER` indices are represented by a matrix, where the row and column correspond to
the parameter correlations.


##### Sobol Statistics on Reporter Data

Along with VectorPostprocessor data, the SobolReporter can compute indices on reporter data,
which includes vector-type quantities of interest. Below shows the syntax required for
reporter data.





### SolutionContainer


#### Overview

This object is responsible for accumulating solution fields over the course of a simulation.
The solution fields are kept distributed using the communicator of the application.

#### Example Input File Syntax


#### Syntax




### StatisticsReporter


#### Description

The `StatisticsReporter` object computes statistical values for each vector of
`VectorPostprocessor` (VPP) objects or support values from Reporters.  The results are output in
values with names based on the input data and the desired statistic calculation. Optionally
confidence level intervals can be computed.

#### Statistics

The statistics to compute are indicated by the [!param](/Reporters/StatisticsReporter/compute)
parameter, which can contain multiple values as listed below. Note that multiple
statistical measures can be computed simultaneously by passing in more than one to the input
parameter.  The current statistical measures the `StatisticsReporter` can compute are:

- +minimum+

  `compute = min`\\
  Computes the minimum value for the supplied vectors.

- +maximum+

  `compute = max`\\
  Computes the maximum value for the supplied vectors.

- +sum+

  `compute = sum`\\
  Computes the sum ($\Sigma$) of the supplied vectors $\vec{v}$, where $N$ is the length of the vector:

  \Sigma = \sum_{i=1}^N{v_i}

- +mean+

  `compute = average`\\
  Computes the average ($\bar{v}$) of the supplied vectors $\vec{v}$:

  \bar{v} = \frac{\sum_{i=1}^{N}{v_i}}{N}

- +standard deviation+

  `compute = stddev`\\
  Computes the standard deviation ($\sigma$) of the supplied vectors $\vec{v}$:

  \sigma = \sqrt{\frac{\sum_{i=1}^{N}{(v_i - \bar{v})^2}}{N-1}}

- +L2-Norm+

  `compute = norm2`\\
  Computes the L2-norm, $|v|_2$ of the supplied vectors $\vec{v}$, this is also known as the
  Euclidean Norm or the "distance":

  |v|_2 = \sqrt{\sum_{i=1}^{N}{{v_i}^2}}

- +standard error+

  `compute = stderr`\\
  Computes the standard error ($\sigma_{\bar{v}}$) of the supplied vectors $\vec{v}$:

  \sigma_{\bar{v}} = \frac{\sigma}{\sqrt{N}}

- +ratio+

  `compute = ratio`\\
  Computes the ratio of the maximum to the minimu of the supplied data.

- +median+

  `compute = median`\\
  Computes the median of the supplied vectors $\vec{v} = [v_1,...,v_N]$:

  \mathrm{median}(\vec{v}) = \left\{ \begin{array}{ll}
    w_{(N+1)/2}, & \text{if } N \text{ is odd} \\
    \frac{w_{N/2} + w_{N/2+1}}{2}, & \text{if } N \text{ is even} \\
    \end{array} \right .

  where

  \vec{w} = \mathrm{sort}(\vec{v})



#### Confidence Levels

Bootstrap confidence level intervals, as defined by [!cite](tibshirani1993introduction), are enabled
by specifying the desired levels using the
[!param](/Reporters/StatisticsReporter/ci_levels) parameter and setting
the method of calculation using the
[!param](/Reporters/StatisticsReporter/ci_method).
The levels listed should be in the range (0, 1). For example, the levels 0.05, 0.95 result in the
computation of the 0.05, 0.95 confidence level intervals.

Enabling the confidence level intervals will compute the intervals for each level and each statistic
and the result will appear in the same output vector as the associated statistic calculation.

The available methods include the following:

- +percentile+: Percentile bootstrap method as defined in Ch. 13 of [!cite](tibshirani1993introduction).

#### Example 1: Statistics

The following input file snippet demonstrates how to compute various statistics using the
`StatisticsReporter` object.


This block results in the following JSON file output.



#### Example 2: Confidence Levels

The following input file snippet demonstrates how to compute various statistics and
confidence levels using the `StatisticsReporter` object.


This block results in the following JSON file.





### StochasticMatrix


#### Overview

The primary purpose of the StochasticMatrix object is to output sampler data alongside stochastic simulation results. The object retrieves the sampler specified with [!param](/Reporters/StochasticMatrix/sampler) and outputs a vector for each column of the sampler matrix. The names of these vectors can be specified using [!param](/Reporters/StochasticMatrix/sampler_column_names). Similarly to [StochasticReporter.md], this object can receive stochastic data from objects like [SamplerReporterTransfer.md]. However, the sampler used in these other objects, like the transfer, must utilize the same sampler as the one specified in [!param](/Reporters/StochasticMatrix/sampler).

#### Example Syntax

The following is an example of using StochasticMatrix to output sampler data and results from stochastic simulations. Here we create an arbitrary matrix using [InputMatrixSampler.md] which used to run stochastic simulations using [SamplerFullSolveMultiApp.md].


The parameters are transferred via a [SamplerParameterTransfer.md] and the results are transferred back with a [SamplerReporterTransfer.md]. This transfers the results in to the StochasticMatrix object named `matrix`.


The input parameters in the StochasticMatrix block specify the column names, and the resulting CSV file looks like:





### StochasticReporter


#### Description

This object is intended to be used directly with [SamplerReporterTransfer](SamplerReporterTransfer.md), see this object for more details.




## samplers

### ActiveLearningMonteCarloSampler


#### Description

The `ActiveLearningMonteCarloSampler` facilitates the following tasks:

- +Propose random samples from distributions+

  For each transient step, `ActiveLearningMonteCarloSampler`, by default, proposes a user-specified batch of sample inputs using the objects defined in the `Distributions` block.

- +Bookkeeping samples whose surrogate output is poor+
 
  With the set of new input samples proposed, a trained surrogate model predicts the model outputs and also assess the quality of its own outputs. This prediction and quality assessment is done in the `ActiveLearningGPDecision` Reporter class. `ActiveLearningMonteCarloSampler` takes information from this Reporter class and keeps a record of the input samples for which the surrogate predictions are poor.

- +Launch batch of model evaluations in parallel+

  Once the number of input samples for which the surrogate predictions are poor equals or exceeds a user specified limit, as indicated by the parameter `num_batch`, the corresponding full model evaluations to these input samples are launched through the `SamplerFullSolveMultiApp`. The advantage of launching these models in a batch mode is that parallel computing can be efficiently utilized. Therefore, this workflow permits what is called as "parallelized active learning."

#### Interaction between `ActiveLearningMonteCarloSampler`, `ActiveLearningGaussianProcess`, and `ActiveLearningGPDecision`


#### Usage of active learning

Please refer to [ActiveLearningGPDecision](ActiveLearningGPDecision.md) on a detailed description on
using active learning.




### Adaptive Importance Sampling (AIS)


#### Description

AIS is used for estimating small failure probabilities ($P_f$) using computationally expensive
finite element models efficiently. When implemented correctly, AIS can result in
2-3 orders of magnitude reduction to the number of calls to the model when compared to
 crude Monte Carlo simulations. For example, if crude Monte Carlo requires 1e6 calls
to the model to estimate $P_f$ with a coefficient of variation (COV) of 10 percent, AIS could
require only about 1e4 calls to the model for the same COV. AIS has two phases:
 (1) a learning phase where the AIS algorithm learns the importance distribution of
 input parameters likely to cause model failure; and (2) a sampling phase to sample
from the learned importance distribution. The version of AIS proposed by [!cite](au1999new) is
implemented in MOOSE with a slight modification. Instead of using kernel density to
 characterize the importance distribution, a Normal density is used due to its simplicity
 and robustness.

#### Brief algorithmic details

For learning the importance distribution of the input parameters, a Markov Chain
Monte Carlo algorithm, specifically the Metropolis algorithm, is used. The user supplies
 a `initial_values` vector of input parameters that would result in a model failure.
 Then, a Markov Chain is initiated to sufficiently sample from the failure region.
 The Markov Chain operates in Standard Normal space where all the input parameters
are transformed to have a Normal distribution with mean 0 and standard deviation 1.
Centered around the current sample ($\mathbf{x}$), a new sample ($\mathbf{x}^*$) is proposed considering the
proposal distribution to be Normal and an acceptance ratio is computed:

\begin{equation}
\label{eqn:ais_1}
\alpha = \frac{N(\mathbf{x}^*)}{N(\mathbf{x})}
\end{equation}

where, $N(.)$ is a standard Normal distribution. The proposed sample is then accepted
with probability $\alpha$. In this manner, sufficient samples are generated from the
failure region.

Once enough samples that result in model failure have been simulated, an importance
 distribution is fit to these samples. A Normal distribution is fit to each
input parameter independently and sampling from this importance distribution is made.
The use of an independent Normal distribution is different from the work by [!cite](au1999new),
who use a multi-dimensional kernel density distribution. However, experience suggests that
a Normal distribution is more robust under a wide variety of cases. Once the samples from the
importance distribution are obtained, equation (2) and equation (19) in [!cite](au1999new)
can be used for estimating the $P_f$ and COV, respectively. Figure [ais_sch] presents
 a schematic of the AIS method.


#### Interaction with the `AdaptiveMonteCarloDecision` class

The AIS algorithm has a proposal step and a decision-making step on whether or not to
 accept the proposed sample. While the `AIS` class proposes a new sample, the `AdaptiveMonteCarloDecision` class
is used for decision-making. Please refer to [AdaptiveMonteCarloDecision](AdaptiveMonteCarloDecision.md)
for more details.

#### Example Input Syntax

The input file for using the AIS algorithm is somewhat similar to the other sampler
 classes except for three differences. First, the `Samplers` block is presented below:


where, `proposal_std` are proposal standard deviations (in Standard Normal space) used during the learning phase,
 `output_limit` is the limiting value greater than which is characterized as model failure
 , `num_samples_train` is the number of samples to learn the importance distribution,
 `num_importance_sampling_steps` is the number of importance sampling steps (after the importance distribution has been trained),
 `std_factor` is the factor multiplied to the standard deviation of the importance samples
while characterizing the importance distribution, `use_absolute_value` can be set to true when failure is defined as a non-exceedance rather than an exceedance. `inputs_reporter` and `output_reporter` are the
reporter values which transfer information between the `AIS` sampler and the
`AdaptiveMonteCarloDecision` reporter.

Second, the `Reporters` block is presented below with the `AdaptiveMonteCarloDecision` reporter:


where, output reporter and the inputs reporter are both initialized.

Third, the `Executioner` block is presented below:


where it is noticed that unlike some other sampler classes, the `type` is transient.
The number of time steps is automatically determined based on `num_samples_train` and `num_importance_sampling_steps`.

#### Output format

The `AIS` sampler can output a csv or a json file. However, a json output is a preferred output format
for post-processing sampler data from adaptive Monte Carlo algorithms. The json file
consists of "inputs" and "output_required" corresponding to each "time_step". "inputs" are
the uncertain input parameters to the model, "output_required" is an indicator function
on whether or not the model output exceeded `output_limit`, and "time_step" is the
sample index. The first `num_samples_train` time steps are the samples during the
learning phase and should not be used for estimating the $P_f$ or COV. The next
`num_steps - num_samples_train` are the required importance samples used for estimating $P_f$ or COV.

#### Failure probability and COV

Statistics such as the $P_f$ and COV can be computed using the [AdaptiveImportanceStats](AdaptiveImportanceStats.md)
Reporter object.




### AffineInvariantDES (AffineInvariantDifferential)


#### Overview

The `proposeSamples` function from the [PMCMCBase](PMCMCBase.md) parent class is overridden. This proposal is the differential evolution move proposed in [!cite](Braak2006a) which defines an implicit probability distribution from the accepted samples in the previous step and draws samples from it. Note that the `AffineInvariantDES` will also infer the variance term (i.e., the model inadequacy plus experimental noise uncertainty) if the associated prior is specified. If lower and upper bounds to the parameters are specified, the proposals are passed through a rejection sampling until specified bounds across all the parameter dimensions are satisfied. Specifically, the new $p^{\text{th}}$ parallel proposal is given by:

\begin{equation}
\label{eqn:des_1}
\mathcal{S}_{y^p} = \mathcal{S}_{y^{p}_{-1}} + \gamma ~(\mathcal{S}_{y^{r1}_{-1}} - \mathcal{S}_{y^{r2}_{-1}}) + \nu
\end{equation}

where $r1$ is a random index defined between $[1,~P]$ excluding the index $p$ and $r2$ is a random index defined between $[1,~P]$ excluding the indices $p$ and $r1$. Also, $\gamma = 2.38 / \sqrt{2M}$ and $\nu \sim \mathcal{N}(0,~1e-6)$.




### AffineInvariantStretchSampler


#### Overview

The `proposeSamples` function from the [PMCMCBase](PMCMCBase.md) parent class is overridden. This proposal is the stretch move proposed in [!cite](Goodman2010a) which defines an implicit probability distribution from the accepted samples in the previous step and draws samples from it. Note that the `AffineInvariantStretchSampler` will also infer the variance term (i.e., the model inadequacy plus experimental noise uncertainty) if the associated prior is specified. If lower and upper bounds to the parameters are specified, the proposals are passed through a rejection sampling until specified bounds across all the parameter dimensions are satisfied. Specifically, the new $p^{\text{th}}$ parallel proposal is given by:

\begin{equation}
\label{eqn:ss_1}
\mathcal{S}_{y^p} = \mathcal{S}_{y^r_{-1}} + z^p~ (\mathcal{S}_{y^{p}_{-1}} - \mathcal{S}_{y^r_{-1}})
\end{equation}

where $\mathcal{S}_{y^{p}_{-1}}$ is the previous state at index $p$, $\mathcal{S}_{y^r_{-1}}$ is the previous state at a random index $r$ defined between $[1,~P]$ excluding the index $p$, and $z^p$ is a random step size corresponding to the index $p$. $z$ is defined to originate from a probability distribution of the form [!cite](Goodman2010a):

\begin{equation}
    \label{eqn:ss_2}
    f(z) = \begin{cases}
  \frac{1}{\sqrt{z}} & \text{ if } z \in [a,~\frac{1}{a}]~\text{with } a > 1 \\
  0 & \text{ otherwise}
\end{cases}
\end{equation}

[!cite](Goodman2010a) recommend an $a$ value of $2$ for most cases.




### AISActiveLearning (AISActiveLearning)


#### Description

As stated in [AdaptiveImportanceSampler](AdaptiveImportanceSampler.md), there are two steps in an
Adaptive Importance Sampler (AIS): (1) usage of a Markov chain Monte Carlo (MCMC) sampler to learn the
importance region; and (2) regular Monte Carlo sampling from the importance region for variance reduction
when estimating a quantity of interest (QoI; like the failure probability). However, each MCMC or Monte Carlo
sample is associated with a full model evaluation in the traditional AIS. While AIS considerably reduces the
computational cost for estimating a QoI compared to a regular Monte Carlo sampler, even more computational gains
are obtained by integrating active learning into AIS.

Active learning is based on the Gaussian process (GP) surrogate; see [ActiveLearningGaussianProcess](ActiveLearningGaussianProcess.md).
Once the GP is trained with a few outputs from the full model, for every new input sample from either MCMC or
Monte Carlo, a GP prediction is first made along with the prediction uncertainty. This prediction and the
uncertainty are used to assess the prediction quality with the aid of active learning functions. If the GP
prediction quality is good, we simply move onto a new input sample. Otherwise, we call the full model and re-train the GP with including the new sample in the training set to improve the future predictive performance.

#### Interaction between `AISActiveLearning`, `ActiveLearningGPDecision`, and `AdaptiveMonteCarloDecision`

Active learning in AIS primarily relies on three objects: `AISActiveLearning`,
[ActiveLearningGPDecision](ActiveLearningGPDecision.md), and [AdaptiveMonteCarloDecision](AdaptiveMonteCarloDecision.md).
The interaction between these objects is presented in [!ref](alais_sch) and is further discussed below.


The interaction between these three objects is straightforward to understand. Once the GP is trained,
`AISActiveLearning` proposes a new input sample, either using MCMC or Monte Carlo.
By default, [ActiveLearningGPDecision](ActiveLearningGPDecision.md) uses a GP to predict the model output
and also assesses the prediction quality.

The details on how the GP is initially trained and subsequently re-trained are discussed in [ActiveLearningGPDecision](ActiveLearningGPDecision.md).

The importance sampling using MCMC does not start until the GP initial training is finished.

#### Input file syntax

Once the interaction between the three objects is understood, the input file syntax is easy to follow.

The `AISActiveLearning` samplers block is largely similar to [AdaptiveImportanceSampler](AdaptiveImportanceSampler.md).
One difference is that the [!param](/Samplers/AISActiveLearning/flag_sample) parameter
is requested to identify whether the GP prediction is good or bad. This dictates the next input proposal.


The `ActiveLearningGPDecision` reporters block is the same as active learning in Monte Carlo sampling. See
[ActiveLearningGPDecision](ActiveLearningGPDecision.md) for the details.


The `AdaptiveMonteCarloDecision` reporters block is also largely similar to [AdaptiveImportanceSampler](AdaptiveImportanceSampler.md).
One difference is, instead of using the full model outputs, the GP mean prediction is used.


#### Adaptive importance statistics reporter

The [AdaptiveImportanceStats](AdaptiveImportanceStats.md) can also be used in AIS with active learning.
The syntax is show below.


#### Output format




### Cartesian1D


#### Overview

Cartesian1D is similar to [CartesianProduct](CartesianProductSampler.md).
But instead of creating a sample for all possible combinations for a set of values,
it samples each set of values one at a time.
For example, given the vectors $\vec{x_0} = (1,2)$, $\vec{x_1} = (11,12,13)$, and $\vec{x_2} = (21,22)$ and nominal values $\bar{x_0} = 1.5$, $\bar{x_1} = 12$, and $\bar{x_2} = 21.5$,
the resulting sampling matrix is:

Z = \begin{bmatrix}
    1, 12, 21.5 \\
    2, 12, 21.5 \\
    1.5, 11, 21.5 \\
    1.5, 12, 21.5 \\
    1.5, 13, 21.5 \\
    1.5, 12, 21 \\
    1.5, 12, 22 \\
    \end{bmatrix}

#### Example Input File Syntax

The following input file snippet demonstrates the creation of a Cartesian1D object
with three variables. The variables are provided using triplets that provide the starting point,
the stepsize, and the number of steps. For example, the triplet of `10 1.5 3` result in
$(10, 11.5, 13)$.


The resulting Cartesian sampling is provided in the output file, as shown below.





### CartesianProductSampler


#### Overview

The Cartesian product creates a sample for all possible combinations for a set of values,
$Z = A \times B \times \cdots \times L \times \ M$. For example, given the vectors
$\vec{x_0} = (1,2)$, $\vec{x_1} = (11,12,13)$, and $\vec{x_2} = (21,22)$. The resulting Cartesian
product (Z) is:

Z = \begin{bmatrix}
    1, 11, 21 \\
    1, 11, 22 \\
    1, 12, 21 \\
    1, 12, 22 \\
    1, 13, 21 \\
    1, 13, 22 \\
    2, 11, 21 \\
    2, 11, 22 \\
    2, 12, 21 \\
    2, 12, 22 \\
    2, 13, 21 \\
    2, 13, 22 \\
    \end{bmatrix}


#### Implementation

The CartesianProductSampler utilizes what is referred to as a "lazy" scheme for the calculation of
the $Z$ matrix, using the algorithm below. This simply means that any given row ($n$) in the matrix
can be computed directly without the need for computing the values prior to the entry. As such the
sampling works efficiently in parallel to create distributed sample data.

Z(n) = \begin{bmatrix}
       A [ [\frac{n}{|B||C|\cdots|L||M|}] \textrm{mod} |A|, \\
       B [ [\frac{n}{|C|\cdots|L||M|}] \textrm{mod} |B|, \\
       \vdots \\
       L [ [\frac{n}{|M|}] \textrm{mod} |L|, \\
       M [ [\frac{n}{1}] \textrm{mod} |M| \\
       \end{bmatrix}

#### Example Input File Syntax

The following input file snippet demonstrates the creation of a CartesianProductSampler object
with three variables. The variables are provided using triplets that provide the starting point,
the stepsize, and the number of steps. For example, the triplet of `10 1.5 3` result in
$(10, 11.5, 13)$.


The resulting Cartesian product is provided in the output file, as shown below.





### CSVSampler

The CSV Sampler object generates samples from a user provided CSV file. The following
assumptions are made about the CSV file:

- All samples are numeric and do not contain strings.
- Each column corresponds to a parameter that is to be sampled. Therefore, multiple
  parameters can be sampled with the same CSV file.
- All columns have the same number of rows.
- The number of rows in the file is the number of samples for each parameter.

The sampler can either read the entire file or can be used to read specific columns
using the `column_indices` or the `column_names` input parameters (see the example
syntax below). `column_indices` refer to the indices of the columns and
`column_names` refer to the header names of the columns in the CSV file.

#### Example Input Syntax

In the example below, the sampler reads a file, `samples.csv`, which contains
samples for various parameters. The input below reads columns 0, 1, and 3 from
the samples file.


In another example below, the sampler reads the columns with the column names,
`a`, `b`, and `d`.


The samples file used in the above examples, `samples.csv`, is listed below.





### DirectPerturbationSampler


#### Overview

The direct perturbation method is the simplest approach for
computing local sensitivity coefficients using the finite
difference approximation of the derivatives at a certain
point in the parameter domain. The coordinates of the reference
location can be supplied through the [!param](/Samplers/DirectPerturbationSampler/nominal_parameter_values) parameter.
The parameter vector holding the parameters can be denoted by:
$\vec{\mu}=\left[\mu_1,\mu_2,\mu_3,...,\mu_{N_p}\right]^T$, where
$N_p$ is the number of parameters. The direct perturbation-based
sensitivity coefficients can then be computed using the
following two methods:

- +Central difference approximation:+
  We assume that the sensitivity coefficient for parameter
   $\mu_i$ can be approximated as:

  \begin{equation}
  S_{\mu_i} =C\frac{\Phi(\vec{\mu}_{i+})-\Phi(\vec{\mu}_{i-})}{\mu_{i+}-\mu_{i-}},
  \end{equation}

  where $\vec{\mu}_{i+/-}$ are the vectors with the $i$-th entries
  perturbed in the positive and negative direction (so they
  are replaced by $\mu_{i+}$ and $\mu_{i-}$), respectively.
  Parameter [!param](/Samplers/DirectPerturbationSampler/relative_perturbation_intervals)
  can be used to specify
  the perturbation interval around the nominal values. For the
  central difference approach a 0.1 value would mean that the
  parameter is perturbed by 5% in both directions making the
  total perturbation centered around the nominal value. This
  approach is more accurate, but needs $2N_p+1$ model evaluations.
  We add an additional model evaluation for the reference point.

- +Forward difference approximation:+
  We assume that the sensitivity coefficient for parameter
   $\mu_i$ can be approximated as:

  \begin{equation}
  S_{\mu_i} =C \frac{\Phi(\vec{\mu}_{i+})-\Phi(\vec{\mu})}{\mu_{i+}-\mu},
  \end{equation}

  where $\vec{mu}_{i+}$ is the vector with the $i$-th entry
  perturbed in the positive direction (i.e. it is
  are replaced by $\mu_{i+}$).
  Parameter [!param](/Samplers/DirectPerturbationSampler/relative_perturbation_intervals) can be used to specify
  the perturbation interval from the nominal values. For the
  forward difference approach a 0.1 value would mean that the
  parameter is perturbed by 10% in one direction. This
  approach is less accurate, but only needs $N_p+1$ model
  evaluations.

The multiplication factor $C$ in the expressions above depends on if the
user requested relative sensitivities in the [DirectPerturbationReporter.md].
If an absolute sensitivity was requested $C=1$, for relative sensitivities
$C=\frac{\mu_{ref}}{\Phi_{ref}}$, where $\mu_{ref}$ and $\Phi_{ref}$
are the parameter value and quantity of interest at the reference point.

This sampler is responsible for creating parameter vectors with
perturbed entries. The computation of the sensitivity
coefficients is done using [DirectPerturbationReporter.md].
The differencing approach can be selected using the
[!param](/Samplers/DirectPerturbationSampler/perturbation_method)
parameter.
The implementation is fully parallelized meaning that the model
evaluations and the sensitivity calculation all happen in
parallel.


#### Example Input Syntax

the following input generates perturbed samples for a
3-dimensional parameter space around a nominal value
using the central difference approach.


This results in the following parameters:


With forward differencing the sample output is the following:





### IndependentGaussianMH (Independent Gaussian Metropolis-Hastings)


#### Overview

The `proposeSamples` function from the [PMCMCBase](PMCMCBase.md) parent class is overridden. This proposal is a simple independent Metropolis-Hastings (M-H) using a Gaussian proposal centered on a seed state. The scale (standard deviation) of this Gaussian is user-specified for each model parameter. Note that the `IndependentGaussianMH` assumes that the noise variance (i.e., uncertainty due to model inadequacy plus experimental noise) is specified by the user. Expanding `IndependentGaussianMH` to infer the noise variance term will be considered in the future. If lower and upper bounds to the parameters are specified, the proposals are generated using a truncated Gaussian. Specifically, the new $p^{\text{th}}$ parallel proposal is given by:

\begin{equation}
\label{eqn:imh_1}
\pmb{\mathcal{S}}_p = \mathcal{N}(\pmb{\mathcal{S}}_{seed},~\pmb{\sigma})
\end{equation}

where $\pmb{\mathcal{S}}_{seed}$ is the seed state selected from the previously accepted proposed states and $\pmb{\sigma}$ is the vector of standard deviations (one standard deviation for each parameter dimension) specified by the user.




### InputMatrix


#### Overview

This sampler simply takes a sampling matrix from input using the [!param](/Samplers/InputMatrix/matrix) parameter.

#### Example Input Syntax

See the following as an example input that creates a matrix with five rows and six columns:


The resulting matrix looks like the following in CSV format:





### LatinHypercube


#### Overview

This sampler implements the Latin hypercube strategy presented in [!cite](mckay1979comparison) as:

> If we wish to ensure also that each of the input variables $X_k$ has all portions of its distribution
> represented by input values, we can divide the range of each $X_k$ into $N$ strata of equal marginal
> probability $l/N$, and sample once from each stratum. Let this sample be
> $X_{kj},\,j=l,\ldots,N$. These form the $X_k$, component, $k=l,\ldots,K$, in $X_i,\,i =
> 1,\ldots,N$. The components of the various $X_k$'s are matched at random.

#### Example Input File Syntax

The following input file creates a Latin hypercube sample from two uniform distributions with
10 samples of each distribution.


The graph in [hypercube] show the Latin hypercube sample generated from the input file snippet where
the grid lines are defined with the associated probability based bins.

      caption=Latin hypercube sampled data with tick marks defined at the probability intervals.
      data=[{'x':'sample_0', 'y':'sample_1', 'mode':'markers'}]
      layout={'xaxis':{'title':'Uniform "a" (100,200)', 'linewidth':1, 'showline':1, 'tickmode':'array', 'tickvals':[100,110,120,130,140,150,160,170,180,190,200]},
              'yaxis':{'title':'Uniform "b" (10,20)', 'linewidth':1, 'showline':1, 'tickmode':'array', 'tickvals':[10,11,12,13,14,15,16,17,18,19,20]},
              'width':775, 'height':800, 'font':{'size':16}, 'margin':{'l':100}}





### MonteCarlo

The MonteCarlo object samples the provided distribution using a traditional
[Monte Carlo](https://en.wikipedia.org/wiki/Monte_Carlo_method) sampling.

#### Example Input Syntax





### Morris


#### Overview

The Morris screening method is a one-at-a-time (OAT) perturbative sampling method for performing global sensitivity analysis [!citep](morris1991factorial, saltelli2008global). The implementation is equivalent to the trajectory design described in the [GSA Module](https://gsa-module.readthedocs.io/en/stable/implementation/morris_screening_method.html) and implemented in [SALib](https://github.com/SALib/SALib). The stochastic tools module implementation is fully parallelized and is meant to be used with the [MorrisReporter.md] to calculate the sensitivity quantities.

#### Trajectory Design

Although multiple sampling strategies exist for Morris screening, this object utilizes the trajectory design. This strategy performs set perturbations in random directions for individual parameters one-at-a-time. A trajectory performs the perturbation for each parameter randomly starting from a random starting point. The number of parameters ($D$) is determined by the number of entries in [!param](/Samplers/MorrisSampler/distributions). The number of trajectories is specified by [!param](/Samplers/MorrisSampler/trajectories). The discretization of the starting point and the perturbation $\Delta$ is determined by [!param](/Samplers/MorrisSampler/levels):

\Delta = \frac{1}{2}\,\frac{\texttt{levels}}{\texttt{levels} - 1} .

The sampling matrix for a single trajectory ($b^{*}$) is given by the following expression:

b^{*} = x^{*} + \frac{\Delta}{2}\left(\left(2bp^{*}-j\right)d^{*}+ j\right) ,

where,

- $b \equiv$ ($D+1$)-by-$D$ strictly lower triangular matrix of 1s,
- $x^{*} \equiv$ ($D+1$)-by-$D$ matrix where each row is the same random starting point $[0, 1]^D$,
- $d^{*} \equiv$ $D$-by-$D$ diagonal matrix with either a $1$ or $-1$ for each row, this determines the direction of the perturbations,
- $p^{*} \equiv$ $D$-by-$D$ matrix where each row has a different column equal to 1 with no repeated columns, this determines which parameter is perturbed, and
- $j \equiv$ ($D+1$)-by-$D$ dense matrix of 1s.

Each row of the resulting $b^{*}$ represents OAT perturbed sample between 0 and 1; each entry of the rows is put through the corresponding [!param](/Samplers/MorrisSampler/distributions)'s quantile to produce a $D+1$ samples. A separate $b^{*}$ is produced for the number specified by [!param](/Samplers/MorrisSampler/trajectories).

#### Example Input Syntax

The following input generates a 3-dimensional sampling matrix with 4 trajectories, which creates $(D+1)\times N = 16$ samples.



    data=[{'x':[0.4,0.4,0.4,1], 'y':[0,0.6,0.6,0.6], 'name':'Trajectory 1'},
          {'x':[0.4,1,1,1], 'y':[0.2,0.2,0.2,0.8], 'name':'Trajectory 2'},
          {'x':[0.6,0.6,0,0], 'y':[0.2,0.2,0.2,0.8], 'name':'Trajectory 3'},
          {'x':[0.2,0.8,0.8,0.8], 'y':[1,1,0.4,0.4], 'name':'Trajectory 4'}]





### NestedMonteCarlo


#### Overview

This sampler is meant to emulate a nested loop of Monte Carlo samples. Columns of the sampling matrix are only sampled with a frequency based on which loop they are a part of. Columns associated with the inner most loop are sampled at each row and columns associated with outer loops are sampled once its inner loop is complete. The number of rows in each loop is defined by the [!param](/Samplers/NestedMonteCarlo/num_rows) parameter, where the first entry is the outer most loop and the last entry is the inner loop. Each of the entries in this parameter must be associated with a set of distributions specified with [!param](/Samplers/NestedMonteCarlo/distributions) which define the sampler columns.

#### Example Input Syntax

The following example defines a Monte Carlo sampler with three nested loops. The outer loop has 10 samples, the middle has 5, and the inner has 2. The columns are defined by 5 distributions, the first three are associated with the outer loop, the second 2 with the middle, and the last one with the inner.


The resulting matrix is 5 columns and 100 rows ($10\times 5 \times 2$), which is shown below. As a result, the fifth column changes every row, the third and fourth column changes every 2 rows, and the firth 3 columns change every 10 rows.





### Parallel Subset Simulation (PSS)


#### Description

PSS is used for efficiently estimating small failure probabilities and for conducting
optimization under uncertainties when dealing with computationally expensive numerical models.
It can result in 2-3 orders of magnitude fewer calls to the numerical model when estimating
failure probabilities or conducting optimization under uncertainty compared to standard
Monte Carlo or Latin Hypercube Sampling. PSS works by creating intermediate failure
thresholds to efficiently transition from sampling from the nominal input space to sampling
from input spaces which optimize the numerical model output. Use of Markov Chain Monte Carlo (MCMC)
is key to the PSS algorithm. In fact, PSS uses hundreds of Markov Chains to efficiently
propagate to the regions of the input space that are most important with respect
to optimizing the model output. Since these Markov chains are independent of each other,
they can be run in parallel on a different set of processors. It should be noted that
parallelization can only be achieved across Markov chains and not within a chain.
That is, a given set of processors should completely run an entire chain composed
of a certain number of samples (this number is usually 10). Coupled with several
Markov chains and massively parallel computing, PSS may require only 1E1 to 1E2
order of magnitude numerical model evaluations for accurately estimating low failure probabilities or
for conducting optimization studies.

#### Brief algorithmic details

Exhaustive algorithmic details of PSS have been presented in [!cite](au2001pss). Only
a brief description of the algorithm is presented here. To efficiently sample from
regions of input parameter spaces that are crucial for optimization and failure
evaluation of the model output, PSS creates intermediate failure thresholds defined
through the equation:

\begin{equation}
\label{eqn:pss_1}
P_f= P_1~\prod_{i=2}^{N_s}~P_{i|i-1}
\end{equation}

where, $P_f$ is the failure probability of interest, $P_1$ and $P_{i|i-1}~~(i \in \{2,\dots,N_s\})$
are the intermediate failure probabilities defining the intermediate failure thresholds, and
$N_s$ is the number of subsets. Through the intermediate failure probabilities $P_1$ and $P_{i|i-1}$
PSS creates intermediate failure thresholds that allow to efficiently transition to sampling
from input spaces which cause numerical model failure or numerical model optimal output. These
intermediate failure thresholds are created with the aid of numerous Markov chains.

In practice, SS is implemented in the following manner. If $N$ is the total number
of numerical model evaluations, each subset will have $M=N/N_s$ samples. An MCS is first used to generate $M$ samples.
If the intermediate failure probabilities (except $P_{N_s|N_{s-1}}$)
are all fixed to 0.1, then the first intermediate failure threshold ${F}_1$
is estimated as the $90^{\textrm{th}}$ percentile value of all the $M$ numerical model outputs.
The outputs that do not exceed $\mathcal{F}_1$ constitute Subset 1. To determine
the next failure threshold $\mathcal{F}_2$, conditional samples should be generated
such that the numerical model outputs always exceed $\mathcal{F}_1$. An MCMC method---in particular,
a component-wise Metropolis method---is used to estimate $\mathcal{F}_2$ by simulating
numerous Markov chains. From the $M$ MCS samples in the first subset, those that exceeded
the threshold $\mathcal{F}_1$ are used as seeds (or starting values) for these Markov chains.
If $M$ samples need to be simulated such that the outputs exceed $\mathcal{F}_1$,
there will be $0.1~M$ Markov chains, with each chain simulating $1/0.1$ samples.
In general, if the intermediate failure probabilities (except $P_{N_s|N_{s-1}}$) are
fixed to $p_o$ instead of 0.1, there will be $p_o~M$ Markov chains, with each chain
simulating $1/p_o$ samples. Once $M$ samples are generated from $p_o~M$
Markov chains, the second intermediate failure threshold ${F}_2$ is the $(1-p_o) \times 100$
percentile value of all the samples' outputs. Samples between ${F}_1$ and ${F}_2$ comprise the second subset.
A similar procedure of simulating $(p_o~M)$ Markov chains is repeated for determining
the subsequent failure thresholds until the final required failure threshold $F$ is reached.
More details on the practical implementation of the PSS method are presented in [!cite](li2016pss).
[!ref](pss_sch) presents a schematic of the PSS method.


#### Parallelization of Parallel Subset Simulation: An example

Since PSS relies of numerous Markov chains, it can be parallelized. Each Markov chain
can be run independently on separate sets of processors in parallel to other Markov chains.
For optimal PSS performance, it is recommended that the number of samples evaluated
by each processor is a multiple of 10. For example, consider that we are interested
in evaluating the small failure probability (of the order $1E-4$) of a numerical model. For this,
we select 4 subsets with 10,000 samples per subset. In total, there will be 40,000
numerical model evaluations. If we use 1000 processors with $0.1$ as the intermediate failure
probability, there will be 1000 Markov chains per subset with each chain making 10 numerical
model evaluations. Therefore each processor evaluates the numerical model 10 times per subset.
With 4 subsets, each processor evaluates the numerical model 40 times. In contrast, if we use
only 100 processors, each processor solves the numerical model 100 times per subset.
With 4 subsets, each processor solves the numerical model 400 times in total.

Alternatively, if we use 2000 processors, a unique set of two processors jointly
solves the numerical model 10 times per subset and 40 times overall. Beyond 1000 processors,
the number of numerical model solves per processor cannot be reduced further. This is due to
the fact that parallelization can only be achieved across Markov chains and not within
a chain. Each processor should solve the numerical model a minimum of 10 times per subset in this
example because the number of samples in a Markov chain are $1/0.1$ with the intermediate
failure probability fixed to 0.1.

In MOOSE, currently, Markov chain proposals are made by transforming all the inputs
  into a standard Normal space and then adding a Gaussian noise to a previously
  accepted sample with a unit standard deviation. Expanding this proposal scheme to
  incorporate other MCMC algorithms is possible and would be of interest in the future.

#### Interaction with the `AdaptiveMonteCarloDecision` class

The PSS algorithm is an adaptive algorithm and it has a proposal step for all the
Markov chains and a decision-making step on whether or not to accept the proposed samples.
While the `ParallelSubsetSimulation` class proposes new samples across multiple Markov
chains, the `AdaptiveMonteCarloDecision` class
is used for decision-making. Please refer to [AdaptiveMonteCarloDecision](AdaptiveMonteCarloDecision.md)
for more details.

If the parameter [!param](/Samplers/ParallelSubsetSimulation/use_absolute_value) is `True`, the absolute
 value of [!param](/Samplers/ParallelSubsetSimulation/output_reporter) will be maximized. 
As such, a least-squares fit optimization can be achieved by passing the negative of the sum-squared error
into the value of [!param](/Samplers/ParallelSubsetSimulation/output_reporter) with
 [!param](/Samplers/ParallelSubsetSimulation/use_absolute_value) set to `True`. Otherwise
the value of [!param](/Samplers/ParallelSubsetSimulation/output_reporter) will be maximized after its absolute value is taken.

#### Example Input Syntax

The input file for using the PSS algorithm is somewhat similar to the other sampler
 classes except for three differences. First, the `Samplers` block is presented below:


where, [!param](/Samplers/ParallelSubsetSimulation/num_samplessub) is the number of samples per subset and 
[!param](/Samplers/ParallelSubsetSimulation/num_subsets) is the number of subsets.
[!param](/Samplers/ParallelSubsetSimulation/inputs_reporter) and [!param](/Samplers/ParallelSubsetSimulation/output_reporter) 
are the reporter values which transfer
information between the `ParallelSubsetSimulation` sampler and the `AdaptiveMonteCarloDecision` reporter. There is an optional
 input parameter [!param](/Samplers/ParallelSubsetSimulation/subset_probability) which has been defaulted to
`0.1`, meaning that there are $1/0.1$ samples per Markov chain. This can, however, be
changed as per the user preference. [!param](/Samplers/ParallelSubsetSimulation/num_parallel_chains) is also an optional parameter
that explicitly specifies the number of Markov chains to be run in parallel per subset.
If [!param](/Samplers/ParallelSubsetSimulation/num_parallel_chains) is not specified, the number of parallel Markov chains per subset
will be equal to the number of processors. Besides, [!param](/Samplers/ParallelSubsetSimulation/use_absolute_value) can be set to true
when failure is defined as a non-exceedance rather than an exceedance.

Second, the `Reporters` block is presented below with the `AdaptiveMonteCarloDecision` reporter:


where, the output and input reporters are both initialized.

Third, the `Executioner` block is presented below:


where it is noticed that unlike some other sampler classes, the `type` is transient.
The number of time steps is automatically determined based on [!param](/Samplers/ParallelSubsetSimulation/num_samplessub), [!param](/Samplers/ParallelSubsetSimulation/num_subsets) and the number of processors used.


#### Output format

The `ParallelSubsetSimulation` sampler can output a csv or a json file. However, a json output is a preferred output format
for post-processing sampler data from adaptive Monte Carlo algorithms. The json file
consists of "inputs" and "output_required" corresponding to each "time_step" across
all the processors.




### PMCMCBase (PMCMCBase)


#### Overview

The `PMCMCBase` is the base class for performing MCMC sampling in STM and it derives from the [MonteCarloSampler](MonteCarloSampler.md) object. `PMCMCBase` overrides the `computeSample` function in the [MonteCarloSampler](MonteCarloSampler.md) which is the link to send new samples to the MultiApps system for execution. `PMCMCBase` takes as inputs the priors, number of parallel proposals, the experimental configurations, upper and lower bounds of the model parameters, and the initial values for the parameters representing the starting state of the Markov chain. The `PMCMCBase` object itself performs a regular Monte Carlo sampling, rather than a MCMC sampling. However, it provides functionalities to perform MCMC sampling through derived classes via several protected and public functions. An overview of these functions is presented in the table below.

| Function | Description
| - | - |
| `proposeSamples` | Proposes new samples
| `sampleSetUp` | Sets up new samples and stores random numbers for later decision making
| `combineWithExperimentalConfig` | Combines the proposed samples with the experimental configurations
| `computeSample` | Sends a sample of a parameter to the MultiApps system
| `getNumberofConfigValues` | Returns the number of experimental configurations
| `getNumberofConfigParams` | Returns the number of experimental configuration parameters
| `getNumberofParallelProposals` | Returns the number of parallel proposals
| `getRandomNumbers` | Returns a vector of random number for decision making
| `getVarSamples` | Returns a vector of samples of variances over the model predictions
| `getPriors` | Returns a vector of distribution objects of priors over the model parameters
| `getVarPrior` | Returns a distribution object of prior over the variance term
| `decisionStep` | Get number of serial steps after which decision making starts

For classes deriving off of the `PMCMCBase`, it would suffice to override the `proposeSamples` function and fill in the protected `_new_samples` vector of vectors with new proposals. Then, the `PMCMCBase` will automatically combine these proposals with the experimental configurations and send the resulting samples to the `MultiApps` system. This treatment of combining the experimental configurations with the proposals only in the base class is very convenient. That is, if a new recipe needs to be implemented for combining experimental configurations and the proposals, this can only be done in the base class and this change will be reflected in all the derived classes. The specific re-definition of the `proposeSamples` function in the derived classes to propose samples can be found in [IndependentGaussianMH](IndependentGaussianMH.md), [AffineInvariantStretchSampler](AffineInvariantStretchSampler.md), or [AffineInvariantDES](AffineInvariantDES.md).




### QuadratureSampler


#### Overview

Numerical quadrature is a method of selecting specific points and weights in integrate a function,

\begin{equation}
\int_{a}^{b}y(x)f(x)dx = \sum_{q=1}^{N_q}w_qy(x_q) ,
\end{equation}

where $y(x)$ is the function being integrated, $f(x)$ is weighting function, $N_q$ is the number of quadrature points, $w_q$ and $x_q$ are quadrature weights and points, respectively. The sampler generates the points and weights based on the weighting function and the desired integration order. A uniform weighting function uses Gauss-Legendre quadrature and a normal weighting function uses Gauss-Hermite quadrature. These two quadratures can exactly integrate a polynomial of order $2N_q-1$.

For multidimensional quadratures, the following options are available by setting [!param](/Samplers/QuadratureSampler/sparse_grid):

- `none` (default): Tensor grid
- `smolyak`: Smolyak sparse grid
- `clenshaw-curtis`: Clenshaw-Curtis sparse grid

In general, a multi-dimensional quadrature grid is a combination of 1-D quadratures. For example, a tensor grid can be describe as

\mathcal{A}(D,N_q) = Q_1^{N_q} \otimes\dots\otimes Q_D^{N_q} ,

where $D$ is the number of dimensions and $Q_d^{j}$ is the one-dimension quadrature set for dimension $d$ with $j$ points. In contrast, the Smolyak and Clenshaw-Curtis grid is described as:

\mathcal{A}(D,N_q) = \sum_{N_q-D \leq |\bm{i}| \leq N_q-1} (-1)^{N_q+D-|\bm{i}|-1} \binom{N_q+D-1}{N_q+D-|\bm{i}|-1} \left(Q_1^{i_1} \otimes\dots\otimes Q_D^{i_D}\right) ,

where $|\bm{i}| = \sum_{d=1}^D i_d$. See [!cite](gerstner1998numerical) for more details regarding sparse grids.

##### Tensor Grid

A tensor grid is created by taking a Cartesian product of the points and a Kronecker product of the weights from each dimensions' full order quadrature set. The resulting number of points is $N_q^D$, where $D$ is the number of dimensions. Currently, only Gauss quadrature types are used with tensor grid. [tensor-npts] shows the number of points several different $D$ and $N_q$. [tensor-grid] shows the points of a tensor grid of Gauss-Legendre quadrature with $D=2$ and $N_q=7$.

| $N_q$ | $D=2$ | $D=5$ | $D=8$ |
| - | - | - | - |
| 2 | 4 | 32 | 256 |
| 3 | 9 | 243 | 6,561 |
| 5 | 25 | 3,125 | 390,625 |
| 7 | 49 | 16,807 | 5,764,801 |


##### Smolyak Sparse Grid

A Smolyak sparse grid is a multidimensional quadrature meant to integrate a complete monomial. This type of grid is effective for use with [PolynomialChaos.md]. The idea is that instead of taking the cartesian product of full order quadratures, it uses a combination of lower order quadratures to complete the monomial space. The Smolyak sparse grid scheme can reduce the number of points significantly in high dimensional space. [smolyak-npts] shows the number of points several different $D$ and $N_q$. [smolyak-grid] shows the points of a Smolyak grid of Gauss-Legendre quadrature with $D=2$ and $N_q=7$.

| $N_q$ | $D=2$ | $D=5$ | $D=8$ |
| - | - | - | - |
| 2 | 5 | 11 | 17 |
| 3 | 14 | 66 | 153 |
| 5 | 55 | 1,001 | 4,845 |
| 7 | 140 | 7,997 | 74,613 |


##### Clenshaw-Curtis Sparse Grid

A Clenshaw-Curtis (CC) grid is very similar to the Smolyak sparse, the only difference is that the Smolyak grid uses gauss quadrature, while (CC) grid appropriately uses (CC) quadrature. In one-dimension, Gauss quadrature is more accurate (with the same convergence rate) but CC has more nesting of points, which means that at high dimensions, CC grid might be more accurate with fewer number of sample points. [cc-npts] shows the number of points several different $D$ and $N_q$. [cc-grid] shows the points of a CC grid with $D=2$ and $N_q=7$

| $N_q$ | $D=2$ | $D=5$ | $D=8$ |
| - | - | - | - |
| 2 | 5 | 11 | 17 |
| 3 | 9 | 51 | 129 |
| 5 | 21 | 301 | 1,937 |
| 7 | 49 | 1,113 | 11,937 |


#### Implementation

The sampler uses inputted distributions to create a multidimensional quadrature of arbitrary order. The sampler can then be used to sample a sub-app. Another object can then use the results of the sampling and the quadrature weights from the sampler to integrate a quantity.

#### Example Input File Syntax

First, distributions are made, which define the weighting function of the integration:


The QuadratureSampler then uses the distributions to create a quadrature with $N_q =$ `order`$+1$ points. The definition of `order` is important for use with polynomial chaos.





### Sobol

The Sobol sampler object generates the necessary matrices of samples to perform a
variance-based sensitivity analysis, refer to [!cite](saltelli2002making) for complete details.





### VectorPostprocessorSampler

#### Overview

The sampler generates samples from [vector-postprocessor](VectorPostprocessors/index.md) and/or [vector reporters](Reporters/index.md). The user is required to provide the names of these vectors in [!param](/Samplers/VectorPostprocessorSampler/vectors_names), which is in the format `<vpp_name>/<vector_name>` for vector-postprocessors and `<reporter_name>/<value_name>` for reporter values.

#### Example Input Syntax

In the example below, a vectorpostprocessor (`[csv]`) are formed using [CSVReaderVectorPostprocessor](/CSVReaderVectorPostprocessor.md):


The VectorPostprocessor Sampler takes vectors `csv/year` and `csv/month` as input to generate samples:


The samples file used in the above examples, `samples.csv`, is listed below.





## surrogates

### ActiveLearningGaussianProcess


#### Description

The theory behind Gaussian Process (GP) is described in [GaussianProcessTrainer](GaussianProcessTrainer.md). `ActiveLearningGaussianProcess` is slightly similar to the `GaussianProcessTrainer` class in that it trains a GP model. However, a key feature of `ActiveLearningGaussianProcess` is that it permits re-training the GP model on-the-fly during the active learning process. This means that the input the inputs and output data set sizes will be dynamic and re-training the GP can be performed several times as dictated by the learning (or acquisition) function during active learning.

Just like the `GaussianProcessTrainer` class, the GP model during active learning can be trained using either of the following options:

- +PETSc/TAO+

  Relies on the TAO optimization library from PETSc. Several optimization algorithms are available from this library. Note that these algorithms perform deterministic optimization.

- +Adaptive moment estimation (Adam)+

  Relies on the pseudocode provided in [!cite](kingma2014adam). Adam permits stochastic optimization, wherein, a batch of the training data can be randomly chosen at each iteration.

#### Interaction between `ActiveLearningMonteCarloSampler`, `ActiveLearningGaussianProcess`, and `ActiveLearningGPDecision`


#### Usage of active learning

Please refer to [ActiveLearningGPDecision](ActiveLearningGPDecision.md) on a detailed description on
using active learning.




### GaussianProcessSurrogate


The theory and use this object is provided within a discussion of the [GaussianProcessTrainer.md] training
object.

A desirable aspect of Gaussian process modeling is that in addition to returning a predicted value at the evaluation point, it can also provide a measure of uncertainty in the form of a standard deviation. To facilitate this an overloaded `evaluate()` function which sets the standard deviation by reference is provided.


#### Evaluation of multi-output Gaussian Processes

For Gaussian Processes that predict multiple outputs the user can evaluate the
the mean and standard deviation estimates using the following function:





### NearestPointSurrogate


#### Overview

The NearestPointSurrogate is arguably the simplest surrogate model that can be implemented. First, the surrogate is trained by collecting sample points and results from the full model. The surrogate's `evaluate` function then takes in a point and finds the training point that has the minimum Euclidean distance:

\vec{x}_{\min} = \argmin_{\vec{x}\in\mathbf{X}}\left(\sum_{d=1}^{D}(x_d - x_{\mathrm{in},d})^2\right)

where $\vec{x}_{\min}$ is the training point closest to the input point $\vec{x}_{\mathrm{in}}$, $\mathbf{X}$ is the array of sample points from the training data, and $D$ is the number of columns in the sampler. The `evaluate` function then returns the full model result associated with $\vec{x}_{\min}$.

#### Example Input File Syntax

See [NearestPointTrainer.md] for details regarding the training phase of the surrogate. The surrogate model first loads the data from the training run:


A sampler is created to create sample points:


A reporter is then used to evaluate the surrogate model with the points taken from the sampler:





### PODReducedBasisSurrogate


#### Overview

This surrogate takes the reduced operators and bases from [PODReducedBasisTrainer.md]
and assembles the reduced equation system for a new parameter sample ($\boldsymbol{\mu^* }$):

\left(\sum \limits_{i=1}^{N_A} f^A_i(\boldsymbol{\mu^* })\textbf{A}_i^r\right)\textbf{c}(\boldsymbol{\mu^* }) =
\sum \limits_{i=1}^{N_b} f^b_i(\boldsymbol{\mu^* })\textbf{b}_i^r.

Following this, the reduced equation system is solved for $\textbf{c}(\boldsymbol{\mu^* })$ and
an approximate solution is reconstructed as

\textbf{u}(\boldsymbol{\mu})
\approx
\boldsymbol{\Phi}\textbf{c}(\boldsymbol{\mu}).

It must be mentioned that in case of Dirichlet boundary conditions (either nodal or in weak form)
there is a contribution in $\textbf{A}_{Dir}^r$ and $\textbf{b}_{Dir}^r$ as well.
However, in this case a penalty parameter ($\gamma$) is used to enforce the boundary condition at
reduced order level. Therefore, the slightly modified equation system can be written as:

\left(\sum \limits_{i=1}^{N_A-1} f^A_i(\boldsymbol{\mu^* })\textbf{A}_i^r+\gamma f^A_{Dir}(\boldsymbol{\mu^* })\textbf{A}_{Dir}^r\right)\textbf{c}(\boldsymbol{\mu^* }) =
\sum \limits_{i=1}^{N_b-1} f^b_i(\boldsymbol{\mu^* })\textbf{b}_i^r+\gamma f^b_{Dir}(\boldsymbol{\mu^* })\textbf{b}_{Dir}^r.

the magnitude of $\gamma$ can be set using the [!param](/Surrogates/PODReducedBasisSurrogate/penalty) parameter in the input file. It is important
to note that by increasing the magnitude of $\gamma$, the condition number of the reduced equation
may deteriorate, therefore the overly high values are not recommended.

It is important to mention that the size of the reduced system can be modified by
changing the number of bases per variable in the input file. To do this one can
use [!param](/Surrogates/PODReducedBasisSurrogate/change_rank) and [!param](/Surrogates/PODReducedBasisSurrogate/new_ranks) input parameters. This feature makes it possible
to test the accuracy of the surrogate with different subspace sizes without the
need of rerunning the training procedure.

#### Details of implementation

The approximate solution given by the POD-RB surrogate can be reconstructed using two different
approaches. Both approaches are implemented by overloading the `evaluateSolution` function:

1. One can call `evaluateSolution` with a simple parameter sample as an input argument:


   In this case, the approximate solution vectors are reconstructed and stored within the surrogate object and
   the QoI-s for a given variable can be acquired using the `getNodalQoI` function.
   A good example for this approach is the implementation of the `execute` function in [/PODSurrogateTester.C].


2. The second option is to supply a reference to an external vector to `evaluateSolution`
   together with a variable name:


   In this case, the surrogate will try to reconstruct the approximate solution for the given variable into
   this vector. This option can be used to couple POD-RB surrogates to other, full-order
   objects.

#### Example Input File Syntax

To create a POD reduced basis surrogate model, one can use the following syntax:


It is visible that the reduced operators and basis vectors from [PODReducedBasisTrainer.md]
have been saved to `trainer_out_pod_rb.rd` and the surrogate model is constructed by
loading the necessary information from it. For the sampling
of the uncertain parameters, the same objects can be used in the [Samplers](Samplers/index.md) block:


Finally, a vector postprocessor of type `PODSurrogateTester` is created to extract
the approximate value of the nodal maximum of variable `u` in this case:







### PolynomialChaos


#### Overview

Polynomial chaos is a surrogate modeling technique where a quantity of interest (QoI) that is dependent on input parameters is expanded as a sum of orthogonal polynomials. Given a QoI $Q$ dependent on a set of parameters $\vec{\xi}$, the polynomial chaos expansion (PCE) is:

Q(\vec{\xi}) = \sum_{i=1}^{P}q_i\Phi_i(\vec{\xi}) ,


where $P$ is the multidimensional polynomial order and $q_i$ are coefficients that are to be computed. These coefficients can be found using intrusive and non intrusive techniques. The intrusive technique is quite difficult to generalize and very computationally demanding. Since the polynomial basis is orthogonal, a non intrusive technique is developed where the coefficients are found by performing a Galerkin projection and integrating:

q_i = \frac{\left\langle Q(\vec{\xi})\Phi_i(\vec{\xi})\right\rangle}{\left\langle\Phi_i(\vec{\xi}),\Phi_i(\vec{\xi})\right\rangle},

where,

\left\langle a(\vec{\xi}) b(\vec{\xi}) \right\rangle = \int_{-\infty}^{\infty}a(\vec{\xi}) b(\vec{\xi}) f(\vec{\xi}) d\vec{\xi} .


The weight function ($f(\vec{\xi})$) and bases ($\Phi_i(\vec{\xi})$) are typically products of one-dimensional functions:

f(\vec{\xi}) = \prod_{d=0}^{D}f_d(\xi_d) ,


Q(\vec{\xi}) = \sum_{i=1}^{P}q_i\prod_{d=0}^{D}\phi^d_{k_{d,i}}(\xi_d) .


The weighting functions are defined by the probability density function of the parameter and the polynomials are based on these distributions, [PolynomialTable] is a list of commonly used distributions and their corresponding orthogonal polynomials.

| Distribution | Density Function ($f_d(\xi)$) | Polynomial ($\phi_i(\xi)$) | Support|
| - | - | - | - |
| Normal | $\frac{1}{2\pi}e^{-\xi^2/2}$ | Hermite | $[-\infty, \infty]$ |
| Uniform | $\frac{1}{2}$ | Legendre | $[-1, 1]$ |
| Beta | $\frac{(1-\xi)^{\alpha}(1+\xi)^{\beta}}{2^{\alpha+\beta+1}B(\alpha+1,\beta+1)}$ | Jacobi | $[-1,1]$ |
| Exponential | $e^{-\xi}$ | Laguerre | $[0,\infty]$ |
| Gamma | $\frac{\xi^{\alpha}e^{-\xi}}{\Gamma(\alpha+1)}$ | Generalized Laguerre | $[0,\infty]$ |

#### Computing Coefficients

There are currently two techniques to compute the coefficients in [!eqref](eq:expansion), the first performs the integration described by [!eqref](eq:coeff). For Monte Carlo sampling, the integration is in the form

q_i = \frac{1}{\left\langle\Phi_i(\vec{\xi}),\Phi_i(\vec{\xi})\right\rangle} \frac{1}{N_{\mathrm{mc}}}\sum_{n=1}^{N_{\mathrm{mc}}} Q(\vec{\xi}_n)\Phi_i(\vec{\xi}_n) .

And for using a [QuadratureSampler.md]

q_i = \frac{1}{\left\langle\Phi_i(\vec{\xi}),\Phi_i(\vec{\xi})\right\rangle}\sum_{n=1}^{N_q} w_n Q(\vec{\xi}_n)\Phi_i(\vec{\xi}_n) .

The numerical quadrature method is typically much more efficient that than the Monte Carlo method and has the added benefit of exactly integrating the polynomial basis. However, the quadrature suffers from the curse of dimensionality. The naive approach uses a Cartesian product of one-dimensional quadratures, which results in $(\max(k^d_i) + 1)^D$ quadrature points to be sampled. Sparse grids can help mitigate the curse of dimensionality significantly.

The other technique is using ordinary least-squares (OLS) regression, like in [PolynomialRegressionTrainer.md]. In the majority of cases, OLS is more accurate than integration for Monte Carlo sampling, as shown in the figure below.

    data=[{'name': 'OLS',
           'type': 'scatter',
           'x': [16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192],
           'y': [81.6696267803207, 8.454300942177698, 4.926398159556231,
                 2.874495194734781, 2.2416013478899863, 1.3479621256735075,
                 1.1574930187341494, 0.6939367594300845, 0.5817680465237121,
                 0.417989501880757]},
           {'name': 'OLS with Regularization (penalty = 1)',
            'type': 'scatter',
            'x': [16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192],
            'y': [4.91600612112163, 3.94911986807379, 3.4242180431008484,
                  2.7094356794174708, 1.6871974555746947, 1.3923862418279123,
                  1.1994658425158664, 1.0696251119444582, 0.9079419204733286,
                  0.8692326803241464]},
           {'name': 'Integration',
            'type': 'scatter',
            'x': [16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192],
            'y': [80.62685305548119, 57.810722889054325, 45.68405898596861,
                  35.58856802819979, 19.925532186155436, 15.879940134036879,
                  11.862525598455559, 8.760052389181865, 4.967900255917786,
                  3.9340295519499127]}]
    layout={'xaxis': {'title': 'Number of Samples', 'type': 'log'},
            'yaxis': {'title': 'Coefficient RRMSE', 'type': 'log'}}

#### Generating a Tuple

In polynomial chaos, a tuple describes the combination of polynomial orders representing the expansion basis ($k_{d,i}$). Again, the naive approach would be to do a tensor product of highest polynomial order, but this is often wasteful since generating a complete monomial basis is usually optimal. Below demonstrates the difference between a tensor basis and a complete monomial basis:

\begin{aligned}
&D=2, \, k_{\max}=2, \, \text{Tensor product:} \\
&\Phi_0 = \phi^1_0\phi^2_0,\, \Phi_1 = \phi^1_1\phi^2_0,\, \Phi_2 = \phi^1_0\phi^2_1,\, \Phi_3 = \phi^1_1\phi^2_1 \\
&\Phi_4 = \phi^1_2\phi^2_0,\, \Phi_5 = \phi^1_0\phi^2_2,\, \Phi_6 = \phi^1_1\phi^2_2,\, \Phi_7 = \phi^1_2\phi^2_1,\, \Phi_8 = \phi^1_2\phi^2_2 ,
\end{aligned}


\begin{aligned}
&D=2, \, k_{\max}=2, \, \text{Complete monomial:} \\
&\Phi_0 = \phi^1_0\phi^2_0,\, \Phi_1 = \phi^1_1\phi^2_0,\, \Phi_2 = \phi^1_0\phi^2_1,\, \Phi_3 = \phi^1_1\phi^2_1
\Phi_4 = \phi^1_2\phi^2_0,\, \Phi_5 = \phi^1_0\phi^2_2 .
\end{aligned}


The tuple is generated and stored as matrix in the userobject, below is an example of this matrix with $D=3$ and $k_{\max}=3$:

k_{d,i} =
\left[
\begin{array}{c|ccc|cccccc|cccccccccc}
0 & 1 & 0 & 0 & 2 & 1 & 1 & 0 & 0 & 0 & 3 & 2 & 2 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 1 & 0 & 2 & 1 & 0 & 0 & 1 & 0 & 2 & 1 & 0 & 3 & 2 & 1 & 0 \\
0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 1 & 2 & 0 & 0 & 1 & 0 & 1 & 2 & 0 & 1 & 2 & 3
\end{array}
\right]


#### Computing Statistical Moments

Statistical moments are based on the expectation of a function of the quantity of interest:

E\left[g\left(Q(\vec{\xi})\right)\right] = \int_{-\infty}^{\infty}g\left(Q(\vec{\xi})\right)f(\vec{\xi})d\vec{\xi} .


The first four statistical moments, and the most common ones, are defined as:

\text{Mean: } \mu = E[Q] ,

\text{Variance: } \, \sigma^2 = E\left[\left(Q-\mu\right)^2\right] = E[Q^2] - \mu^2 ,

\text{Skewness: } \mathrm{Skew} = \frac{E\left[\left(Q-\mu\right)^3\right]}{\sigma^3} = \frac{E[Q^3] - 3\sigma^2\mu - \mu^3}{\sigma^3} ,

\text{Kurtosis: } \mathrm{Kurt} = \frac{E\left[\left(Q-\mu\right)^4\right]}{\sigma^4} = \frac{E[Q^4] - 4E[Q^3]\mu + 6\sigma^2\mu^2 + 3\mu^4}{\sigma^4} .


Because of the orthogonality of the polynomials, mean and variance are trivial to compute:

E\left[Q_{\mathrm{pc}}\right] = q_0 ,

E\left[Q^2_{\mathrm{pc}}\right] = \sum_{i=1}^{P}q_i^2 \prod_{d=1}^{D}\left\langle\phi_{k_{d,i}}^2\right\rangle ,


where $\left\langle\Phi_i^2\right\rangle$ is known analytically. The higher order moments are significantly more taxing to compute since it does not take advantage of orthogonality:

E\left[Q^3_{\mathrm{pc}}\right] = \sum_{i=1}^{P}\sum_{j=1}^{P}\sum_{k=1}^{P}q_iq_jq_k\prod_{d=1}^{D}\left\langle\phi_{k_{d,i}}\phi_{k_{d,j}}\phi_{k_{d,k}}\right\rangle ,

E\left[Q^4_{\mathrm{pc}}\right] = \sum_{i=1}^{P}\sum_{j=1}^{P}\sum_{k=1}^{P}\sum_{\ell=1}^{P}q_iq_jq_kq_{\ell}\prod_{d=1}^{D}\left\langle\phi_{k_{d,i}}\phi_{k_{d,j}}\phi_{k_{d,k}}\phi_{k_{d,\ell}}\right\rangle ,


where the polynomial norms are computed using one-dimensional quadrature. We see here the number of operations required to compute Kurtosis is approximately $DN^{4}$. If the number of coefficients is sufficiently high, these moments would probably be best computed inexactly by sampling the PCE surrogate.


#### Implementation

The PolynomialChaos user object takes in a list of distributions and constructs a polynomial class based on their type. Given a sampler and a vectorpostprocessor of results from sampling, it then loops through the MC or quadrature points to compute the coefficients. The statistical moments are then computed based on user preferences and the model can be evaluated using the `evaluate` function from any other moose object that has the reference. The algorithm uses the parallelization of the sampler to compute the coefficients, no other part of the algorithm is parallelized.

#### Example Input File Syntax

The example involves a homogeneous, one-dimensional diffusion-reaction problem, where the diffusion coefficient ($D$) and reaction coefficient ($\Sigma$) are uncertain with a uniform probability:

-D\frac{d^2u}{dx^2} + \Sigma u = Q ,

where the QoI is the integrated average of $u(x)$.

After the sub-app is set with the diffusion-reaction problem, distributions are set for each uncertain parameter:


A sampler is then defined, either using Monte Carlo,


or quadrature,


It is important that the order in the quadrature sampler input matches the order in the PolynomialChaos input. The sampler is then used by the MultiApp and Transfers to sample the sub-app, the QoI from the app is then put in a reporter:


All this information is ready to be sent to the PolynomialChaos trainer:





### PolynomialRegressionSurrogate


#### Overview

This surrogate model takes the vector containing model coefficients ($\textbf{c}$) from [PolynomialRegressionTrainer.md]
and computes the value of the QoI at a new parameter sample by simply evaluating

\hat{\textbf{y}}(\textbf{x}') = \sum \limits_{k=1}^{N_p}P(\textbf{x}', \textbf{i}_{k})c_k,

where $\textbf{x}'$ denotes the coordinates of the new sample in the parameter space.
It is important to mention that unlike [NearestPointSurrogate.md],
this surrogate model does not require the evaluation of a function (e.g. distance) for
all training points to determine the new value at $\textbf{x}'$. Thus, for large
training data bases, using a `PolynomialRegressionSurrogate` for repeated
runs is faster.

#### Example Input File Syntax

To create a surrogate model which uses polynomial regression, one can use the following syntax:


It is visible that the data from [PolynomialRegressionTrainer.md] has been saved to `train_out_train.rd`
and the surrogate model is constructed by loading the necessary information from it.
If one wants to do the training and evaluation in the same input, the following syntax can be used:


where `train` is the ID of the [PolynomialRegressionTrainer.md] object. For the sampling
of the surrogate model, the same objects can be used in the `Samplers` block:


Finally, a reporter of type [EvaluateSurrogate.md] is created to extract the approximate value of the
QoI(s):





## trainers

### GaussianProcessTrainer

"Gaussian Processes for Machine Learning" [!cite](rasmussen2005gaussian) provides
a well written discussion of Gaussian Processes, and its reading is highly
encouraged. Chapters 1-5 cover the topics presented here with far greater detail,
depth, and rigor. Furthermore, for a detailed overview on Gaussian Processes that
model multiple outputs together (multi-output Gaussian Process or MOGP) we refer
the reader to [!cite](Liu2018gp).

The documentation here is meant to give some practical insight for users to begin creating surrogate models with Gaussian Processes.

Given a set of inputs $X=\lbrace{\vec{x}_1, \cdots, \vec{x}_m \rbrace}$ for which
we have made observations of the correspond outputs $Y=\lbrace{\vec{y}_1, \cdots,
\vec{y}_m \rbrace}$ using the system ($Y = f(X)$). Given another set of inputs
$X_\star=\lbrace{\vec{x}_{\star 1}, \cdots, \vec{x}_{\star n} \rbrace}$ we wish to
predict the associated outputs $Y_\star=f(X_\star)$ without evaluation of $f
(X_\star)$, which is presumed costly.

###### Parameter Covariance

In overly simplistic terms, Gaussian Process Modeling is driven by the idea that
trials which are "close" in their input parameter space will be "close" in their
output space. Closeness in the parameter space is driven by the covariance
function $k(\vec{x},\vec{x'})$ (also called a kernel function, not to be confused
with a MOOSE Framework kernel). This covariance function is used to generate a
covariance matrix between the complete set of parameters $X \cup X_\star = \lbrace
{\vec{x}_1, \cdots, \vec{x}_m, \vec{x}_{\star 1}, \cdots, \vec{x}_{\star n}
\rbrace}$, which can then be interpreted block-wise as various covariance matrices
between $X$ and $X_\star$.

\begin{aligned}
\mathbf{K}(X \cup X_\star,X \cup X_\star) & = \left[
\begin{array}{ccc|ccc}
k(\vec{x}_1,\vec{x}_1) & \cdots & k(\vec{x}_1,\vec{x}_m)  & k(\vec{x}_{1},\vec{x}_{\star 1}) & \cdots & k(\vec{x}_{1},\vec{x}_{\star n}) \\
\vdots &   & \vdots  & \vdots &   & \vdots \\
(\vec{x}_m,\vec{x}_1)  & \cdots & k(\vec{x}_m,\vec{x}_m) & k(\vec{x}_{m},\vec{x}_{\star 1})  & \cdots & k(\vec{x}_{m},\vec{x}_{\star n}) \\ \hline
k(\vec{x}_{\star 1},\vec{x}_{1}) & \cdots & k(\vec{x}_{\star 1},\vec{x}_{m}) &  k(\vec{x}_{\star 1},\vec{x}_{\star 1}) & \cdots & k(\vec{x}_{\star 1},\vec{x}_{\star n}) \\
\vdots &   & \vdots & \vdots &   & \vdots \\
k(\vec{x}_{\star n},\vec{x}_{1})  & \cdots & k(\vec{x}_{\star n},\vec{x}_{m}) & k(\vec{x}_{\star n},\vec{x}_{\star 1})  & \cdots & k(\vec{x}_{\star n},\vec{x}_{\star n})
\end{array}
\right] \\
& =\left[
\begin{array}{c|c}
 \mathbf{K}(X,X) & \mathbf{K}(X,X_\star) \\ \hline
  \mathbf{K}(X_\star,X) & \mathbf{K}(X_\star,X_\star)
\end{array}
\right] \\
& =\left[
\begin{array}{c|c}
 \mathbf{K} & \mathbf{K}_\star \\ \hline
  \mathbf{K}_\star^T  & \mathbf{K}_{\star \star}
\end{array}
\right]
\end{aligned}

The Gaussian Process Model consists of an infinite collection of functions, all of
which agree with the training/observation data. Importantly the collection has
closed forms for 2nd order statistics (mean and variance). When used as a
surrogate, the nominal value is chosen to be the mean value. The method can be
broken down into two step: definition of the prior distribution then conditioning
on observed data.

###### Gaussian processes

A Gaussian Process is a (potentially infinite) collection of random variables,
such that the joint distribution of every finite selection of random variables
from the collection is a Gaussian distribution.

\mathcal{GP}(\mu(\vec{x}),k(\vec{x},\vec{x'}))

In an analogous way that a multivariate Gaussian is completely defined by its mean
vector and its covariance matrix, a Gaussian Process is completely defined by its
mean function and covariance function.

The (potentially) infinite number of random variables within the Gaussian Process
correspond to the (potentially) infinite points in the parameter space our
surrogate can be evaluated at.

###### Prior distribution:

We assume the observations (both training and testing) are pulled from an $m+n$
multivariate Gaussian distribution. The covariance matrix $\Sigma$ is the result
of the choice of covariance function.

Y \cup Y_\star \sim \mathcal{N}(\mu,\Sigma)

Note that $\mu$ and $\Sigma$ are a vector and matrix respectively, and are a
result of the mean and covariance functions applied to the sample points.

+Zero Mean Assumption:+ Discussions of Gaussian Process are typically presented
under assumption that $\mu=0$. This occurs without loss of generality since any
sample can be made $\mu=0$ by subtracting the sample mean (or a variety of other
preprocessing options). Note that in a training\testing paradigm, the testing data
$Y_\star$ is unknown, so determination of what to use as $\mu$ is based on the
information from the training data $Y$ (or some other prior assumption).

###### Conditioning:

With the prior formed as above, conditioning on the available training data $Y$ is
performed. This alters the mean and variance to new values $\mu_\star$ and
$\Sigma_\star$, restricting the set of possible functions which agree with the
training data.

\begin{aligned}
\mu_\star &= \mu + \mathbf{K}_\star \mathbf{K}^{-1}(Y-\mu) \\
\Sigma_\star &= \mathbf{K}_{\star \star} - \mathbf{K}_\star^T \mathbf{K}^{-1} \mathbf{K}_\star
\end{aligned}

Y_\star \sim \mathcal{N}(\mu_\star ,\Sigma_\star)

When used as a surrogate, the nominal value is typically taken as the mean value,
with $diag(\Sigma_\star)$ providing variances which can be used to generate
confidence intervals.

###### Notes on Multi-Output Gaussian Processes (MOGPs)

MOGPs model and predict the outputs which are vectors, each of size $M$. For any
input vector $\vec{x}_i$, the vector of outputs $\vec{y}_i$ and the matrix of $N$
vectors $Y$ is defined as:

\begin{equation}
    \label{eqn:mogp_1}
    \begin{aligned}
    &\vec{y}_i = [f(\vec{x}_i)^1,~f(\vec{x}_i)^2,\dots,~f(\vec{x}_i)^M]^\intercal \\
    &Y = [\vec{y}_1,~\vec{y}_2,\dots,~\vec{y}_N]^\intercal \\
    \end{aligned}
\end{equation}

where $\vec{y}_i$ is of size $M\times 1$ and $Y$ is of size $N\times
M$. The matrix $Y$ is vectorized and represented as $\hat{\mathbf{y}}$
with size $NM \times 1$. $\hat{\mathbf{y}}$ is modeled as a Gaussian distribution
defined as described in [gp-basic].

In a multi-output Gaussian Process, $\mathbf{K}$ captures covariances across
the input variables and the vector of outputs and hence has size $NM \times NM$.
$\mathbf{K}$ can be modeled in several ways as discussed in [!citep](Liu2018gp,
Alvarez2012gp). We will follow the [linear model of coregionalization (LMC)](LMC.md) which introduces latent functions with restrictons on the associated covariances.

#### Common Hyperparameters

While the only apparent decision in the above formulation is the choice of
covariance function, most covariance functions will contain hyperparameters of
some form which need to be selected in some manner. While each covariance function
will have its own set of hyperparameters, a few hyperparameters of specific forms
are present in many common covariance functions.

###### Length Factor $\ell$ or $\vec{\ell}$

Frequently Kernels consider the distance between two input parameters $\vec{x}$
and $\vec{x}^\prime$. For system of only a single parameter this distance often
takes the form of

\frac{|x - x^\prime|}{\ell}.

In this form the $\ell$ factor set a relevant length scale for the distance
measurements.

When multiple input parameters are to be considered, it may be advantageous to
specify $n$ different length scales for each of the $n$ parameters, resulting in a
vector $\vec{\ell}$. For example distance may be calculated as

\sqrt{ \sum_{i=1}^n \left( \frac{x_i - x^\prime_i}{\ell_i} \right)^2}.

When used with standardized parameters, $\ell$ can be interpreted in units of
standard deviation for the relevant parameter.

###### Signal Variance $\sigma_f^2$

This serves as an overall scaling parameter. Given a covariance function $\tilde{k}$
(which is not a function of $\sigma_f^2$), the multiplication of $\sigma_f^2$
yields a new valid covariance function.

k(x,x^\prime,\sigma_f) = \sigma_f^2 \, \tilde{k}(x,x^\prime)

This multiplication can also be pulled out of the covariance matrix formation, and
simply multiply the matrix formed by $\tilde{k}$

\mathbf{K}(x,x^\prime,\sigma_f) = \sigma_f^2 \, \tilde{\mathbf{K}}(x,x^\prime)


###### Noise Variance $\sigma_n^2$

The $\sigma_n^2$ represents noise in the collected data, and is as a additional
$\sigma_n^2$ factor on the variance terms (when $x=x^\prime$).

k(x,x^\prime,\sigma_f, \sigma_n) = \sigma_f^2 \, \tilde{k}(x,x^\prime) +
\sigma_n^2 \, \delta_{x,x^\prime}

In the matrix representation this adds a factor of $\sigma_n^2$ to diagonal of the
noiseless matrix $\tilde{\mathbf{K}}$

\mathbf{K}(x,x^\prime,\sigma_f, \sigma_n) = \sigma_f^2 \, \tilde{\mathbf{K}}(x,x^\prime) + \sigma_n^2 \mathbf{I}

Due to the addition of $\sigma_n^2$ along the diagonal of the $K$ matrix, this
hyperparameter can aid in the inversion of the covariance matrix. For this reason
adding a small amount of $\sigma_n^2$ may be preferable, even when you believe the
data to be noise free.


#### Selected Covariance Functions

| Covariance Function | Description |
| - | - |
| [](SquaredExponentialCovariance.md) | Also referred to as a radial basis function (RBF) this is a widely used, general purpose covariance function. Serves as a common starting point for many. Used for single-output GPs |
| [](ExponentialCovariance.md) | A simple exponential covariance function. Used for single-output GPs |
| [](MaternHalfIntCovariance.md) | Implementation of the Matern class of covariance function, where the $\nu$ parameter takes on half-integer values. Used for single-output GPs |
| [](LMC.md) | Covariance function built using the linear model of coregionalization. Used for multi-output GPs |

#### Hyperparameter tuning options

The following options are available for tuning the hyperparameters:

- +Adaptive moment estimation (Adam)+

  Relies on the pseudocode provided in [!cite](kingma2014adam). Adam permits stochastic optimization, wherein, a batch of the training data can be randomly chosen at each iteration.

The hyper-parameters of the GPs are inferred by optimizing the log-likelihood function. The MOGP log-likelihood function has a general form:

\begin{equation}
    \label{eqn:mogp_opt1}
    \mathcal{L} = -\frac{1}{2}~\ln |\mathbf{K}| - \frac{1}{2}~\hat{\mathbf{y}}^T~\mathbf{K}^{-1}~\hat{\mathbf{y}}-\frac{1}{2}~N~\ln(2\pi)
\end{equation}

The optimization of GPs can be expensive. If there are $N$ training points each
with $M$ outputs, each training iteration of Adam has a cost of $\mathcal{O}
(M^3N^3)$. Adam permits using $n < N$ random training points during each iteration
(mini-batches) which has a cost of $\mathcal{O}(M^3n^3)<<\mathcal{O}(M^3N^3)$.




### NearestPointTrainer


#### Overview

This trainer is meant to produce training data to be used with [NearestPointSurrogate.md]. The data saved (`_sample_points`) is an array of the sample points and the results from the full model:

\texttt{\_sample\_points} =
\begin{bmatrix}
x_{1,1} & x_{1,2} & \dots  & x_{1,N} \\
x_{2,1} & x_{2,2} & \dots  & x_{2,N} \\
\vdots  & \vdots  & \ddots & \vdots  \\
x_{D,1} & x_{D,2} & \dots  & x_{D,N} \\
y_1     & y_2     & \dots  & y_N
\end{bmatrix}

where $x_{i,j}$ is the point from the sampler at column $i$ and sample $j$, $y_j$ is the result of the full model at sample $j$, $N$ is the number of training samples, and $D$ is the number of sampler columns.  [NearestPointSurrogate.md] then uses this array to find the closest point to the given input point and outputs the full model result.

#### Example Input File Syntax

A sampler is created to produce points for the training data:


The example full model is the `GFunction` vector postprocessor, see [SobolStatistics.md] for more details. This vector postprocessor takes in the sampler and evaluates the function at the training points.


The trainer then takes in the data from the sampler and the results from the vector postprocessor to create the `_sample_points` array:


We then output the training data to file:





### PODReducedBasisTrainer


#### Overview

In this trainer, an intrusive Proper Orthogonal Decomposition (POD) based Reduced Basis (RB) method
([!cite](pinnau2008model)) is implemented which, unlike non-intrusive surrogates such as Polynomial Regression or
Polynomial Chaos Expansion, is capable of considering the physics of the full-order problem
at surrogate level. Therefore, it is often referred to as a physics-based but still data-driven approach.
The intrusiveness, however, decreases the range of problems which this method can be used for.
In the current version, this surrogate model can deal with
+Parameterized scalar-valued linear steady-state PDEs with affine parameter dependence+ only.
This class is responsible for two steps in the generation of the surrogate model:

1. [Generation of reduced subspaces](#generation-of-reduced-subspaces)
2. [Generation of reduced operators](#generation-of-reduced-operators)

It must be mentioned that in POD-RB literature, the training phase is often referred to
as offline phase and in the upcoming sections the two expressions are used interchangeably.

#### A parameterized linear steady-state PDE

Before the details of the above-mentioned steps are discussed, a short overview is
given about the problems considered. A +scalar-valued linear steady-state PDE+ can be expressed in
operator notation as:

\mathcal{A}u = \mathcal{b},

where $u$ is the solution, $\mathcal{A}$ is a linear operator and
$\mathcal{b}$ is a source term. The linear operator and the source terms may
depend on uncertain parameters which are denoted by $\mu_i,~i=0,...,N_\mu$ and
organized into a parameter vector $\boldsymbol{\mu} = [\mu_1,...,\mu_{N_\mu}]^T$.
Therefore, [fom_operators] can be expressed as:

\mathcal{A}(\boldsymbol{\mu})u = \mathcal{b}(\boldsymbol{\mu}).

This also means that the solution itself is the function of these parameters
$u=u(\boldsymbol{\mu})$. To make an efficient surrogate, operator
$\mathcal{A}(\boldsymbol{\mu})$ and source $\mathcal{b}(\boldsymbol{\mu})$ should
have an +affine parameter dependence+:

\mathcal{A}(\boldsymbol{\mu})
= \sum \limits_{i=1}^{N_A} f^A_i(\boldsymbol{\mu})\mathcal{A}_i,
\text{\quad and \quad} \mathcal{b}(\boldsymbol{\mu})
= \sum \limits_{i=1}^{N_b} f^b_i(\boldsymbol{\mu})\mathcal{b}_i,

or in other words, the operators have to be decomposable as the sums
of products of parameter-dependent scalar functions and parameter-independent
constituent operators. By plugging the decompositions back to [fom_parameterized],
the problem takes the following form:

\left(\sum \limits_{i=1}^{N_A} f^A_i(\boldsymbol{\mu})\mathcal{A}_i\right)u =
\sum \limits_{i=1}^{N_b} f^b_i(\boldsymbol{\mu})\mathcal{b}_i.

Therefore, before starting the construction of a POD-RB surrogate model,
the user must identify the these decompositions first. At input level, this can
be done by utilizing the `Tagging System`. For each constituent operator a separate
vector tag has to be created and the tags need to be supplied to the trainer object
through the [!param](/Trainers/PODReducedBasisTrainer/tag_names) input parameter. Furthermore, an indicator shall be added
to each tag through the [!param](/Trainers/PODReducedBasisTrainer/tag_types) input to show if the tag corresponds to a
source term ($\mathcal{b}_i$) or an operator ($\mathcal{A}_i$).
As a last step, this system is discretized in space using the finite element method to obtain:

\left(\sum \limits_{i=1}^{N_A} f^A_i(\boldsymbol{\mu})\textbf{A}_i\right)\textbf{u} =
\sum \limits_{i=1}^{N_b} f^b_i(\boldsymbol{\mu})\textbf{b}_i,

where $\textbf{A}_i$  and $\textbf{b}_i$ are finite element matrices and vectors,
while $\textbf{u}$ denotes the vector containing the values of the degrees of freedom.
This model is referred to as Full-Order Model (FOM) in subsequent sections.
Furthermore, let $\textbf{u}(\boldsymbol{\mu}^* )$ denote a solution vector which is
obtained by solving [fom_affine_decomp_discrete] with $\boldsymbol{\mu}=\boldsymbol{\mu}^* ~$.

#### Generation of reduced subspaces

Even though it is not explicitly stated in the previous sub-section, $\textbf{u}$ may
contain solutions for multiple variables, hence it can be expressed as
$\textbf{u}=[\textbf{u}_1;...;~\textbf{u}_{N_v}]$, where $N_v$ is the total number of variables.
It is assumed that each variable has $N_i,~i=1,...,N_v$ spatial degrees of freedom,
thus the size of the full-order system is $\sum\limits_{i=1}^{N_v}N_i$.

As a first step in this process, [fom_affine_decomp_discrete] is solved using $N_s$
different parameter samples and the solution vectors for each variable defined on the  
[!param](/Trainers/PODReducedBasisTrainer/var_names) input parameter are saved into
snapshot matrices

\textbf{S}_i = [\textbf{u}_i(\boldsymbol{\mu}_1),...,\textbf{u}_i(\boldsymbol{\mu}_{N_s})].

In this implementation, the solutions are obtained from a [PODFullSolveMultiApp.md] using a
[PODSamplerSolutionTransfer.md] and the snapshot matrices are stored within the trainer object.
The next step in this process is to use these snapshots to create reduced sub-spaces for
each variable. This can be done by performing POD on the snapshot matrices,
which consists of the following four steps for each variable:

1. +Creation of correlation matrices:+ The correlation matrices ($\textbf{C}_i$) can be computed
   using the snapshot matrices as $\textbf{C}_i=\textbf{S}_i^T \textbf{W}_i \textbf{S}_i$,
   where $\textbf{W}_i$ is a weighting matrix. At this moment only $\textbf{W}_i = \textbf{I}$ is
   supported, where $\textbf{I}$ is the identity matrix.

2. +Eigenvalue decomposition of the correlation matrices:+ The eigenvalue decompositions of the
   correlation matrices is obtained as: $\textbf{C}_i = \textbf{V}_i\boldsymbol{\Lambda}_i\textbf{V}^T_i$,
   where matrix $\textbf{V}_i$ and matrix $\boldsymbol{\Lambda}_i$
   contain the eigenvectors and eigenvalues of $\textbf{C}_i$, respectively.

3. +Determining the dimension of the reduced subspace:+ Based on the magnitude of the
   eigenvalues ($\lambda_{i,k},~k=1,...,N_s$) in $\boldsymbol{\Lambda}_i$, one can compute how many basis functions
   are needed to reconstruct the snapshots with a given accuracy. The rank of the subspace
   ($r_i$) can be determined as:

   r_i = \argmin\limits_{1\leq r_i\leq N_s}
   \left(\frac{\sum_{k=1}^{r_i}\lambda_{i,k}}{\sum_{k=1}^{N_s}\lambda_{i,k}} > 1 - \tau_i\right),

   where $\tau$ is a given parameter describing the allowed error in the reconstruction of the snapshots.
   This can be supplied to the trainer using the [!param](/Trainers/PODReducedBasisTrainer/error_res) input parameter.
   Of course, this rank can be determined manually as well. For more information about this option, see
   [PODReducedBasisSurrogate.md].

4. +The reconstruction of the basis vectors for each variable:+ For this, the eigenvalues and
   eigenvectors of the correlation matrices are used together with the snapshots as:

   \Phi_{i,k}=\frac{1}{\sqrt{\lambda_{i,k}}}\sum\limits_{j=1}^{N_s}\textbf{V}_{i,k,j}S_{i,j},

   where $\Phi_{i,k}$ is the $k$-th ($k=1,...,r_i$) basis function of the reduced subspace for
   variable $\textbf{u}_i$. Moreover, $\textbf{V}_{i,k,j}$ denotes the $j$-th element of
   the $k$-th eigenvector of correlation matrix $\textbf{C}_i$. It is important to remember that
   $\Phi_{i,k}$ has a global support in space, and shall not be mistaken for the local
   basis functions ($\phi$) of the finite element approximation. The global basis vectors can be
   also referred to as POD modes and the two expressions are used interchangeably from here on.

It must be noted that these basis functions are also stored in the trainer object.
Finally, the solutions of different variables in the full-order model can be approximated as the
parameter-dependent linear combination of these basis functions:

\textbf{u}_i(\boldsymbol{\mu})\approx\sum\limits_{k=1}^{r_i}\Phi_{i,k}c_{i,k}(\boldsymbol{\mu}),
\text{\quad or \quad} \textbf{u}_i(\boldsymbol{\mu})\approx\boldsymbol{\Phi}_{i}\textbf{c}_{i}(\boldsymbol{\mu})

where $\boldsymbol{\Phi}_{i}=[\Phi_{i,1},...,\Phi_{i,r_i}]$ is a matrix with the POD modes as
columns and $\textbf{c}_{i}(\boldsymbol{\mu}) = [c_{i,1}(\boldsymbol{\mu}),...,c_{i,r_i}(\boldsymbol{\mu})]^T$
are the expansion coefficients. In essence, these coefficients
describe the coordinates of the approximate solution in the reduced subspace.
To approximate the full solution vector $\textbf{u}(\boldsymbol{\mu})$ using
its components ($\textbf{u}_i(\boldsymbol{\mu})$-s), a segregated
approach is used as follows:

\textbf{u}(\boldsymbol{\mu})
=
\left[
\begin{array}{c}
\textbf{u}_1\\
\vdots \\
\textbf{u}_{N_v}
\end{array}\right]
\approx
\left[
\begin{array}{c}
\boldsymbol{\Phi}_{1}\textbf{c}_{1}(\boldsymbol{\mu})\\
\vdots \\
\boldsymbol{\Phi}_{N_s}\textbf{c}_{N_s}(\boldsymbol{\mu})
\end{array}\right]
=
\left[
\begin{array}{cccc}
\boldsymbol{\Phi}_{1} & 0 & \cdots & 0\\
0 &  \boldsymbol{\Phi}_{2} & \cdots & 0\\
\vdots &  \vdots & \ddots & \vdots\\
0 &  0 & \cdots & \boldsymbol{\Phi}_{N_s}
\end{array}\right]
\left[
\begin{array}{c}
\textbf{c}_{1}(\boldsymbol{\mu})\\
\textbf{c}_{2}(\boldsymbol{\mu})\\
\vdots\\
\textbf{c}_{N_s}(\boldsymbol{\mu})
\end{array}\right]
=
\boldsymbol{\Phi}\textbf{c}(\boldsymbol{\mu}).

It is important to mention that in this approximation the unknowns are the elements
of $\textbf{c}(\boldsymbol{\mu})$ vector.
In most of the cases, the size of this vector ($\sum\limits_{i=1}^{N_v}r_i$) is considerably
smaller than the size of the original solution vector ($\sum\limits_{i=1}^{N_v}N_i$).

#### Generation of reduced operators

To generate reduced opertors, [full_sol_approximation] is plugged into [fom_affine_decomp_discrete] first:

\left(\sum \limits_{i=1}^{N_A} f^A_i(\boldsymbol{\mu})\textbf{A}_i\right)\boldsymbol{\Phi}\textbf{c}(\boldsymbol{\mu}) =
\sum \limits_{i=1}^{N_b} f^b_i(\boldsymbol{\mu})\textbf{b}_i.

Since the size of \textbf{c} is smaller than the size of \textbf{u}, this equation is
underdetermined. To solve this problem, a Galerkin projection is used on the system:

\boldsymbol{\Phi}^T\left(\sum \limits_{i=1}^{N_A} f^A_i(\boldsymbol{\mu})\textbf{A}_i\right)\boldsymbol{\Phi}\textbf{c}(\boldsymbol{\mu}) =
\boldsymbol{\Phi}^T\sum \limits_{i=1}^{N_b} f^b_i(\boldsymbol{\mu})\textbf{b}_i.

By pulling the basis matrices into the summation, the following form is obtained.

\left(\sum \limits_{i=1}^{N_A} f^A_i(\boldsymbol{\mu})\boldsymbol{\Phi}^T\textbf{A}_i\boldsymbol{\Phi}\right)\textbf{c}(\boldsymbol{\mu}) =
\sum \limits_{i=1}^{N_b} f^b_i(\boldsymbol{\mu})\boldsymbol{\Phi}^T\textbf{b}_i,

where the reduced operators $\textbf{A}_i^r=\boldsymbol{\Phi}^T\textbf{A}_i\boldsymbol{\Phi}$ and
source terms $\textbf{b}_i^r=\boldsymbol{\Phi}^T\textbf{b}_i$ can be precomputed once
the basis functions are available. Therefore, the reduced equation system that is solved
to obtain $\textbf{c}(\boldsymbol{\mu})$ is

\left(\sum \limits_{i=1}^{N_A} f^A_i(\boldsymbol{\mu})\textbf{A}_i^r\right)\textbf{c}(\boldsymbol{\mu}) =
\sum \limits_{i=1}^{N_b} f^b_i(\boldsymbol{\mu})\textbf{b}_i^r.

It is important to note that this equation system is of size $\sum\limits_{i=1}^{N_v}r_i \times \sum\limits_{i=1}^{N_v}r_i$,
therefore it can be solved much faster than the original full-order system which is
of size $\sum\limits_{i=1}^{N_v}N_i \times \sum\limits_{i=1}^{N_v}N_i$.
The trainer object only assembles the reduced operators and source terms, which are then
transferred to [PODReducedBasisSurrogate.md] that is responsible for assembling
and solving [rom_affine_decomp_final] and reconstructing the approximate solutions
using [full_sol_approximation] if needed.

The computation of the reduced operators consists of two step in the current implementation:

1. +Computing the effect of the full-order operator on the global basis functions:+ this step
   includes the creation of $\textbf{A}_i\boldsymbol{\Phi}$. In practice, this is done by
   plugging in the basis function into a [PODFullSolveMultiApp.md] object which evaluates the residual for a given
   vector tag (defined using the [!param](/Trainers/PODReducedBasisTrainer/tag_names) input argument). The tagged residual is then
   transferred back to the trainer using a [PODResidualTransfer.md] object. In case when
   the residual from a kernel contains contributions to both the system matrix and the
   source term (e.g. Dirichlet BC or time derivative), certain input-level tricks
   can be used to separate these.

2. +Projection of the residual vectors:+ this step consists of computing the
   $\boldsymbol{\Phi}^T(\textbf{A}_i\boldsymbol{\Phi})$ inner products.

As a final note, it must emphasized that even though obtaining snapshots and creating reduced operators
is a computationally expensive procedure, it has to be carried out only once. After
this initial investment every new evaluation for a new parameter sample involves the summation
and scaling of small dense matrices, which is of low computational cost.

#### Note on parallelism

As of now, the training phase is implemented in a semi-parallel manner. This means that
the snapshot generation, correlation matrix generation, base generation and
the computation of the reduced operators are all executed in parallel. However,
the eigenvalues and eigenvectors of the correlation matrices are obtained in serial.
Therefore, this phase may experience considerable slowdown when the number of
snapshots is large (above ~2000).   

#### Example Input File Syntax

To get the snapshots, four essential blocks have to be added the main input file.
First, a sampler has to be defined in `Samplers` to generate realizations for $\boldsymbol{\mu}$.
These samples are then fed into a [PODFullSolveMultiApp.md] (defined
in the `MultiApps` block) which is capable of running simulations for each parameter.
The solution vectors (snapshots) for each run are added to the trainer by a
[PODSamplerSolutionTransfer.md] defined in the `Transfers` block. It is important to mention
that the multiapp and transfer objects need to know about the trainer. This can be
ensured using the [!param](/Transfers/PODSamplerSolutionTransfer/trainer_name) input argument.
The number of collected snapshots is
defined in the sampler object using the [!param](/Samplers/LatinHypercube/num_rows) parameter.



The global basis functions are then plugged back into the same [PODFullSolveMultiApp.md]
by a new [PODSamplerSolutionTransfer.md] and the residuals are evaluated. The residuals
are transferred back to the trainer using a [PODResidualTransfer.md].


Finally, the [PODReducedBasisTrainer.md] is defined in the `Trainers` block. It requires
the names of the variables ([!param](/Trainers/PODReducedBasisTrainer/var_names)) one wishes to create reduced basis for and the names of the
tags ([!param](/Trainers/PODReducedBasisTrainer/tag_names)) associated with the affine components of the full-order operator.
Additionally, a vector specifying which tag corresponds to a linear operator and which to
a source term needs to be added as well ([!param](/Trainers/PODReducedBasisTrainer/tag_types)). The available tag types are:

| Tag type | Description |
| :- | - |
| op | Operator that acts on the solution vector (i.e. a matrix). |
| src | Operator that does not act on the solution vector (i.e. a source vector). |
| op_dir | Dirichlet operator that acts on the solution vector (i.e. Dirichlet penalty matrix). |
| src_dir | Dirichlet operator that does not act on the solution vector (i.e. Dirichlet penalty source vector). |

To specify the allowed error in the snapshot reconstruction
for reach variable ($\tau_i$), one needs to specify [!param](/Trainers/PODReducedBasisTrainer/error_res).
In the following example the [!param](/Trainers/PODReducedBasisTrainer/execute_on) parameter is set to '`timestep_begin final`' which means
that at the beginning of the training it will create the basis functions while at the
end it will create the reduced operators.





### PolynomialChaosTrainer


The theory and use this object is provided within a discussion of the [PolynomialChaos.md] model
object.




### PolynomialRegressionTrainer


#### Overview

This class is responsible for determining the coefficients of a multi-dimensional polynomial which
approximates the behavior of the Quantity of Interest (QoI) in the parameter space.
For this, the object needs $N$ training points in the parameters space.
These training points can be characterized using their coordinates in the parameter space:

\textbf{X} =
\begin{bmatrix}
x_{1,1} & x_{1,2} & \dots  & x_{1,D} \\
x_{2,1} & x_{2,2} & \dots  & x_{2,D} \\
\vdots  & \vdots  & \ddots & \vdots  \\
x_{N,1} & x_{N,2} & \dots  & x_{N,D}
\end{bmatrix}
=
\begin{bmatrix}
\textbf{x}_{1} \\
\textbf{x}_{2} \\
\vdots  \\
\textbf{x}_{N}
\end{bmatrix}.

where $D$ denotes the dimension of the parameter space and $\textbf{x}$ is a
D-dimensional vector containing the coordinates in each dimension.
Similarly to other `Trainer` classes, `PolynomialRegressionTrainer` accesses this matrix
from a `Sampler` object. Of course, the trainer has to know the values of the QoI at
these coordinates as well:

\textbf{y} =
\begin{bmatrix}
y_{1} \\
y_{2} \\
\vdots\\
y_{N}
\end{bmatrix}
.

This data is accessed through a `VectorPostprocessor`. Now that all data is available,
$\textbf{y}=f(\textbf{x})$ unknown function is approximated using a polynomial expression of the following form:

\textbf{y} \approx \hat{\textbf{y}} = \sum \limits_{k=1}^{N_p}P(\textbf{x}, \textbf{i}_{k})c_k=\textbf{P}(\textbf{x})\textbf{c},

where $N_p$ is the number of polynomial terms in the approximation, $\textbf{c}=[c_1,...,c_{N_p}]^T$ are the
unknown coefficients and $\textbf{P}(\textbf{x})=[P(\textbf{x}, \textbf{i}_{1}),...,P(\textbf{x}, \textbf{i}_{N_p})]$.
The used polynomials in this case can be defined as

P(\textbf{x}, \textbf{i}) = \textbf{x}^\textbf{i} = \prod \limits_{j=1}^D x_j^{i_j},

where $x_j$ denotes the $j$-th coordinate of parameter vector $\textbf{x}$,
while $\textbf{i}=(i_1,...,i_D)$ is a $D$-dimensional tuple containing the powers
for each coordinate. This tuple is the same as described in [PolynomialChaos.md].
To determine these tuples, the trainer needs an additional input parameter, namely
the maximum degree of the polynomial. This limits the number of polynomial terms in
[poly_exp]. If this number is fixed, the only unknown parameters are the elements of
$\textbf{c}$.

To determine these, a regression matrix can be defined as:

\textbf{R} =
\begin{bmatrix}
\textbf{P}(\textbf{x}_1) \\
\textbf{P}(\textbf{x}_2) \\
\vdots  \\
\textbf{P}(\textbf{x}_{N})
\end{bmatrix}.

#### Ordinary Least Squares (OLS) regression

Using regression matrix $\textbf{R}$ and Ordinary Least Squares (OLS) approach described on
[Wikipedia](https://en.wikipedia.org/wiki/Polynomial_regression) in detail, the unknown
coefficients can be determined as follows:

\textbf{c}=\left(\textbf{R}^T\textbf{R}\right)^{-1}\textbf{R}^T\textbf{y}.

Finally, it must be mentioned that this method is only applicable if $N_p \leq N$
and keeping $N_p << N$ is recommended.

#### Ridge regression

Unfortunately, the OLS approach is known to have some issues like:
- It is prone to overfit the data,
- It yields inaccurate results if the input variables are correlated,
- It is sensitive to outliers.

To tackle the problem, an $L^2$ regularization (or
[Tikhonov regularization](https://en.wikipedia.org/wiki/Regularized_least_squares) is adopted
to make sure that the coefficients of the expansion do have uncontrollably high values.
This extended least squares regression is often referred to as Ridge Regression.
In this scenario the coefficients can be determined by solving:

\textbf{c}=\left(\textbf{R}^T\textbf{R}+\lambda I\right)^{-1}\textbf{R}^T\textbf{y},

where $\lambda$ is a penalty parameter which penalizes coefficients with large
magnitudes. As $\lambda \rightarrow 0$, Ridge regression converges to OLS.

#### Example Input File Syntax

To get the necessary data, two essential blocks have to be included in the master input file.
The first, the sampler defined in `Samplers`, creates the coordinates in matrix $\textbf{X}$, while
the objects in `VectorPostprocessors` create, fill and store the result vector $\textbf{y}$.



Similarly to [NearestPointTrainer.md], a `GFunction` vector postprocessor from [SobolStatistics.md] is
used to emulate a full-order model. This simply evaluates a function at sample points.

Using this data and the maximum degree setting (`max_degree` in the input file),
the trainer computes the model coefficients $\textbf{c}$. To control the type of regression,
the user has to set `regression_type` to either 'ols' or 'ridge' in the input file:





## transfers

### PODResidualTransfer

This object is responsible for transferring residual vectors from [PODFullSolveMultiApp.md]
to [PODReducedBasisTrainer.md].

#### Example Syntax

This objects type needs to know about the trainer and the multi-app objects.
This can be achieved by specifying the [!param](/Transfers/PODResidualTransfer/trainer_name) and
[!param](/Transfers/PODResidualTransfer/to_multi_app) parameters in the
input file.





### PODSamplerSolutionTransfer

This object is responsible for transferring solution vectors from [PODFullSolveMultiApp.md]
to [PODReducedBasisTrainer.md] and back.

#### Example Syntax

This objects type needs to know about the trainer and the multi-app objects.
This can be achieved by specifying the [!param](/Transfers/PODSamplerSolutionTransfer/trainer_name) and
[!param](/Transfers/PODSamplerSolutionTransfer/to_multi_app) parameters in the
input file.






### SamplerParameterTransfer

The SamplerParameterTransfer works in union with the [Samplers] and [Controls] systems to transfer data to
sub-applications to perform stochastic simulations.

The use of this object is explained in detail in stochastic_tools module
example: [Monte Carlo Example](stochastic_tools/examples/monte_carlo.md).




### SamplerPostprocessorTransfer


#### Overview

This object is designed to transfer data from a [Postprocessor](/Postprocessors/index.md)
to a [VectorPostprocessor](/VectorPostprocessors/index.md) on the parent application. This
object +must+ transfer data to a [StochasticResults](/StochasticResults.md)
object.

#### Dealing with Failed Solves

When performing stochastic analysis with many perturbations of a sub-application,
it is sometimes the case where the app receives a set of parameters that makes the
solve difficult to converge. With the default configuration of this object, if one
of sub-applications' solve fails, the main application will abort. If it is expected
that some solves might not converge and aborting the main application is not the
desired behavior, the parameter [!param](/MultiApps/SamplerFullSolveMultiApp/ignore_solve_not_converge)
+must+ be set to true in the `MultiApps` block (see [SamplerFullSolveMultiApp.md]
for more details). There are two options for how to transfer results from failed
sub-applications: 1) [!param](/Transfers/SamplerPostprocessorTransfer/keep_solve_fail_value)
is set to false (default) will transfer a NaN to [StochasticResults](/StochasticResults.md)
and 2) [!param](/Transfers/SamplerPostprocessorTransfer/keep_solve_fail_value)
is set to true will transfer whatever the last computed value of the postprocessor was before the solve failed.

#### Example Syntax





### SamplerReporterTransfer


#### Overview

This object is designed to transfer data from [postprocessors](/Postprocessors/index.md), [vectorpostprocessors](/VectorPostprocessors/index.md), and [reporters](Reporters/index.md) on the sub-application to the main application. This object +must+ transfer data to a [StochasticReporter](/StochasticReporter.md) object.

#### How It Works

This transfer works similar to [MultiAppCloneReporterTransfer](MultiAppCloneReporterTransfer.md) whereby creating vector reporter values whose type is based on the type of value being transferred. The name of the reporter values are `<stochastic_reporter name>/<transfer name or prefix>:<sub-app reporter object name>:<sub-app reporter value name>`. In parallel, the vector that the values are being transferred into are distributed by default. For instance, [main_out.json](sampler_reporter/gold/main_out.json) is the output in serial showing all the transferred data; while [main_parallel.json](sampler_reporter/gold/main_parallel.json), [main_parallel.json.1](sampler_reporter/gold/main_parallel.json.1), [main_parallel.json.2](sampler_reporter/gold/main_parallel.json.2), and [main_parallel.json.3](sampler_reporter/gold/main_parallel.json.3) are the combined data from running on 4 processors. However, this split in files can be avoided if [!param](/Reporters/StochasticReporter/parallel_type) in the reporter object is set to `ROOT`. This will gather all the data to the root processor, beware using this option can cause memory issues with very very large stochastic runs.

#### Dealing with Failed Solves

When performing stochastic analysis with many perturbations of a sub-application, it is sometimes the case where the app receives a set of parameters that makes the solve difficult to converge. With the default configuration of this object, if one of sub-applications' solve fails, the main application will abort. If it is expected that some solves might not converge and aborting the main application is not the desired behavior, the parameter [!param](/MultiApps/SamplerFullSolveMultiApp/ignore_solve_not_converge) +must+ be set to true in the `MultiApps` block (see [SamplerFullSolveMultiApp.md] for more details). With this parameter set to true in the multiapp, this object will transfer whatever the last compute values are. To keep track of whether the solve converged or not, the reporter value `<stochastic_reporter name>/multiapp_converged` is created. See [main_out.json](sampler_reporter/gold/main_out.json) as an example.

#### Example Syntax





### SerializedSolutionTransfer


#### Overview

This object is responsible to transfer solution fields stored in a [SolutionContainer.md] in
a sub-application to a [ParallelSolutionStorage.md]. The user can specify these objects using
[!param](/Transfers/SerializedSolutionTransfer/parallel_storage) and [!param](/Transfers/SerializedSolutionTransfer/solution_container)
parameters. The solutions in [SolutionContainer.md] are distributed vectors
using the communicator of the sub-application. Based on the value of the [!param](/Transfers/SerializedSolutionTransfer/serialize_on_root) parameter, this object transfers these solution fields in the following ways:

- +If [!param](/Transfers/SerializedSolutionTransfer/serialize_on_root) is disabled+: It distributes the samples between every rank of the sub-application
  and serializes the solution vector on the rank which is supposed to own the sample. This approach results in more balanced
  workloads but requires additional effort due to misalignment with the design of Sampler-based reporters. This might result in significantly increased communication costs.

- +If [!param](/Transfers/SerializedSolutionTransfer/serialize_on_root) is enabled+:
  The solution vectors are serialized and stored on the rank which
  corresponds to root processor of the subapp. This aligns more with the design of the Sampler-based
  reporters, but can cause significant imbalances in the workload if multiple processors are used for the
  sub-applications.

#### Example Syntax

The following input file snippet shows how to use the serialized solution transfer to
extract variables `u` and `v` from the data stored on the apps within MultiApp `worker` into a
parallel storage reporter with a name of `parallel_storage`.


#### Syntax




## userobjects

### InverseMapping


#### Overview

This object is responsible for mapping the solution coordinates in a low-dimensional
latent space into high-dimensional MOOSE solution vectors. For this, we need a mapping object which can be
defined using the [!param](/UserObjects/InverseMapping/mapping) input parameter.
The method populates `AuxVariables` or `Variables` with the approximated high-order solution vectors. The user can specify
these using [!param](/UserObjects/InverseMapping/variable_to_fill). At the same time, to be able to identify
the [!ac](DOF) connections between the basis functions in the mapping and the variable,
this object expects the user to input the real (nonlinear) variable name as well using the
[!param](/UserObjects/InverseMapping/variable_to_reconstruct) parameter. This object can function in two distinct ways:

1. If [!param](/UserObjects/InverseMapping/surrogate) is supplied, we use a surrogate model to
   generate the coordinates in the latent space (e.g. [PolynomialRegressionSurrogate.md]). In this case
   the [!param](/UserObjects/InverseMapping/parameters) input parameter refers to the model parameters
   (created using a [Sampler](Samplers/index.md) or manually). One can define different surrogates for different variables.
2. If no surrogate is supplied, we assume that the user supplies the coordinates in the low-dimensional space using
   the [!param](/UserObjects/InverseMapping/parameters) input parameter.


#### Example Input File Syntax

The following example showcases the syntax for using a polynomial regression surrogate
for the determination of the coordinates in the latent space.


These coordinates are then used to reconstruct approximate solution fields at a new parameter
sample.


#### Syntax




## utils

### GaussianProcess

#### Overview

The GaussianProcess is designed to incorporate structures (data) and
functions commonly used by every object that needs to use/modify Gaussian Processes
such as [GaussianProcessTrainer.md], [GaussianProcessSurrogate.md], or
Gaussian Process-based active learning objects. It contains accesses
to the covariance function, stores covariance matrices
and their corresponding decomposition and inverse action.

##### Initializing

The object which requires access to Gaussian Process-related functionalities shall
have it as a member variable, which is important to enable restarting capabilities:


An important step is the initialization of the covariance function, which can
either be done using the `initialize` function as in [GaussianProcessTrainer.md]:

                                  end=}

Or by linking it directly as in [GaussianProcessSurrogate.md]:


##### Creating a covariance matrix

Once the covariance function has been added to the handler, one can use it to
create a covariance matrix by either using `setupCovarianceMatrix` as in
[GaussianProcessTrainer.md]:

                                  end=}

Or by simply calling the covariance matrix builder as in [GaussianProcessSurrogate.md]:


##### Optimizing hyper parameters

As described in [GaussianProcessTrainer.md], the covariance function might
have hyper parameters that need to be optimized to be able to get accurate
predictions from the corresponding Gaussian Processes. We can optimize these
parameters during the generation of the Covariance matrix:


Or by simply calling the optimizer with Adam (stochastic algorithm):



## variablemappings

### PODMapping


#### Overview

A mapping which uses a Proper Orthogonal Decomposition (POD) to establish mapping between
(high-dimensional) solution vectors coming from numerical simulations and corresponding coefficients
in lower-dimensional spaces (latent spaces). For the use cases in MOOSE, this method is equivalent to
linear Principal Component Analysis (PCA) or Singular Value Decomposition (SVD).

The process for building the mapping is the following:

1. Collection of snapshots of the solution fields. This can be done by running the full-order models
   with different model parameters and saving the solution fields along the simulations. This
   process is established in [SolutionContainer.md], [SerializedSolutionTransfer.md] and
   [ParallelSolutionStorage.md].

2. Once the snapshots are at our disposal, we organize them into a snapshot matrix ($\boldsymbol{S}$) as follows:

   \boldsymbol{S}_{v} = \left[\boldsymbol{s}_{v,\mu_1,t_1}~\boldsymbol{s}_{v,\mu_1,t_2}~\boldsymbol{s}_{v,\mu_1,t_3}~ ... ~\boldsymbol{s}_{v,\mu_1,t_{N_{T_{\mu_1}}}}~ \boldsymbol{s}_{v,\mu_2,t_1}~ \boldsymbol{s}_{v,\mu_2,t_2}~ ...~ \boldsymbol{s}_{v,\mu_{N_\mu},t_{N-1}}~ \boldsymbol{s}_{v,\mu_{N_\mu},t_{N_{T_{\mu_{N_\mu}}}}} \right]~,

   where $N_\mu$ is the number of different model parameter samples, $N_{T_{\mu_i}}$ is the number of snapshots per transient simulation
   with parameter sample $\mu_i$, while $\boldsymbol{s}_{v,\mu_i,t_j}$ denotes the solution vector for variable $v$ with parameter sample $\mu_i$ at time step $t_j$. Note that the number of time steps might depend on the model parameters. The current implementation supports variable-based POD only.

3. As the next step, we extract the common features in the snapshots. In other words, we compute the POD or SVD of the
   snapshot matrix:

   \boldsymbol{S}_v = \boldsymbol{U}_v \boldsymbol{\Sigma}_v \boldsymbol{V}_v^T~,

   where $\boldsymbol{U}$ and $\boldsymbol{V}$ are the unitary left and right singular vector matrices, respectively.
   Matrix $\boldsymbol{\Sigma}$ contains the singular values on its diagonal. Given that the size of the snapshot matrix
   is high, we use the parallel SVD solver available in SLEPc with a Lánczos method to solve the underlying
   eigenvalue problem and get only the requested number of singular values. Additional parameters for SLEPc to fine tune
   the solution algorithm can be supplied using input parameter [!param](/VariableMappings/PODMapping/extra_slepc_options).

   The number of needed singular triplets
   ($\boldsymbol{u}_{v,i}, \sigma_{v,i}, \boldsymbol{v}_{v,i}$) for each variable can be prescribed using
   the [!param](/VariableMappings/PODMapping/num_modes_to_compute) parameter. The algorithm will select the minimum of these numbers and the
   number of converged singular triplets. Let's denote these numbers by $r_v$.

   For this mapping object the transition from high-dimensional to low-dimensional and back is determined by the left
   singular vector computed in the decomposition. We assume that the solution vector ($\boldsymbol{s}_v$)
   of the system for variable $v$ can be approximated as

   \boldsymbol{s}_v \approx \boldsymbol{U}_v \boldsymbol{c}_v~,

   where vector $\boldsymbol{c}_v$ contains the reduced-order coefficients (or coordinates in the latent) space
   in the low-dimensional space. Considering that the left singular vector vector matrix is unitary, we can
   express the mapping from high to low dimensional spaces as:

   \boldsymbol{c}_v = \boldsymbol{U}^T_v \boldsymbol{s}_v~.

4. The last step in this process consists of filtering out singular triplets which do not contribute to the
   description of variation in the variable fields. For this, we utilize the singular values as follows:

   \begin{array}{lr}
        \text{keep basis vector $I$}, & \text{if\quad} \left(1 - \frac{\sum\limits_{i=1}^{I} \sigma^2_{v,i}}{\sum\limits_{i=1}^{r_v} \sigma_{v,i}^2}\right) < \tau_v\\ & \\
        \text{discard}, & \text{otherwise.}
   \end{array}

   The filtering parameter $\tau_v$ van be specified for every variable using input parameter [!param](/VariableMappings/PODMapping/energy_threshold).

Once a mapping is trained, one can save it into a binary file using [MappingOutput.md] and load it by specifying
the [!param](/VariableMappings/PODMapping/filename) parameter in the object.

This object is only compatible with PETSc versions above 3.14 with SLEPc support.

#### Example Input File Syntax

Creating a mapping object:


Loading a mapping object:


#### Syntax




## vectorpostprocessors

### GaussianProcessData

The GaussianProcessData object simply coverts a the covariance function hyperparameters into a VectorPostprocessor for post regression analysis of hyperparameters.

#### Example Syntax





### SamplerData

The SamplerData object simply coverts a generated samples from a Sampler into a VectorPostprocessor
vector. One vector is created for each distribution of the sampler and named using the
distribution name.

This object is primarily designed to test the Sampler output.

#### Example Syntax





### SobolStatistics

The `SobolStatistics` objects has been replaced by [reporters/SobolReporter.md].

### Statistics

The `Statistics` objects has been replaced by [reporters/StatisticsReporter.md].

### StochasticResults

This object is designed to work with the [SamplerPostprocessorTransfer](/SamplerPostprocessorTransfer.md) object for
transferring data from a [Postprocessor](/Postprocessors/index.md) to a
[VectorPostprocessor](/VectorPostprocessors/index.md) on the parent application.

#### Example Syntax





tensor_mechanics


# THM: The MOOSE Thermal Hydraulics Module class=center style=font-size:300%


### Features Highlights class=center style=font-weight:400

- [Components/index.md]: Piecewise system assembly.
- [ControlLogic/index.md]: A flexible extension to [Controls/index.md].
- [Closures/index.md]: Closure relations specification.
- Physics:

  - Single-phase, variable-area, inviscid, compressible flow.
  - 2-D and 3-D heat conduction.

See [this paper](https://joss.theoj.org/papers/10.21105/joss.06146) for an overview of this module.



### Documentation class=center style=font-weight:400

- [Theory manual](modules/thermal_hydraulics/theory_manual/index.md)
- [Getting started](modules/thermal_hydraulics/getting_started.md)
- Tutorials:

  - [tutorials/basics/index.md]: THM execution, input, and output.
  - [tutorials/single_phase_flow/index.md]: Single-phase flow components.

- [Examples](modules/thermal_hydraulics/examples/index.md)
- [Test problems](modules/thermal_hydraulics/test_problems/index.md)
- [Syntax index](modules/thermal_hydraulics/syntax.md)
- [Utilities](modules/thermal_hydraulics/utilities.md)
- [Deprecations](modules/thermal_hydraulics/deprecations/index.md)



## actions

### AddClosuresAction




### AddComponentAction


The `AddComponentAction` is a [MooseObjectAction.md] that creates the specified
[Components](syntax/Components/index.md) object for
each sub-block of the `Components` block of an input file, then adds them to the
[THMProblem.md].


### AddHeatStructureMaterialAction


The `AddHeatStructureMaterialAction` is a [MooseObjectAction.md] that creates the specified
[HeatStructureMaterial](syntax/HeatStructureMaterials/index.md) object for
each sub-block of the `[HeatStructureMaterials]` block of an input file, then adds them to the
[Problem](syntax/Problem/index.md).




### AddIterationCountPostprocessorsAction


This action adds a [!param](/Debug/AddIterationCountPostprocessorsAction/count_iterations)
parameter to the [`[Debug]`](syntax/Debug/index.md) block to print the number, current and cumulative, of linear and nonlinear
iterations using [Postprocessors](syntax/Postprocessors/index.md) named:

- num_linear_iterations_per_step
- num_nonlinear_iterations_per_step
- num_linear_iterations
- num_nonlinear_iterations




### CoupledHeatTransferAction

#### Description

This action creates many of the low-level objects needed to perform a convective
heat transfer multiphysics coupling with a [1-D flow channel](component_groups/flow_channel.md).
It assumes that the domain external to the flow channel is the master-app,
and the application(s) containing the flow channel(s) are the sub-apps.
Hereafter the external domain is referred to as the "solid side", and the flow
channel is referred to as the "fluid side".

This action is suitable for coupling to either single-phase or multi-phase
flow channels. The general formulation it uses for the heat fluxes *to* the solid
side is

q = \sum\limits_k \kappa_k \mathcal{H}_k (T_k - T) \eqc

where $k$ is the fluid phase index, $T$ is the solid-side temperature, $T_k$ is the
temperature of phase $k$, $\mathcal{H}_k$ is the heat transfer coefficient of
phase $k$, and $\kappa_k$ is the wall contact fraction of phase $k$.

The action creates the following MOOSE objects:

- A [/CoupledConvectiveHeatFluxBC.md] on the boundaries provided in the
  [!param](/CoupledHeatTransfers/CoupledHeatTransferAction/boundary) parameter,
  which implements the heat flux boundary condition described by [solid_side_heat_flux].
- A [/NearestPointLayeredSideAverage.md] user object to compute the average of
  the solid-side temperature variable (specified by the
  [!param](/CoupledHeatTransfers/CoupledHeatTransferAction/T) parameter) for
  each axial layer, corresponding to each of the elements in the flow channel.
  The layers are determined by the parameters
  [!param](/CoupledHeatTransfers/CoupledHeatTransferAction/position),
  [!param](/CoupledHeatTransfers/CoupledHeatTransferAction/orientation),
  [!param](/CoupledHeatTransfers/CoupledHeatTransferAction/rotation),
  [!param](/CoupledHeatTransfers/CoupledHeatTransferAction/length), and
  [!param](/CoupledHeatTransfers/CoupledHeatTransferAction/n_elems),
  which correspond to the parameters of the same names in the coupled flow
  channel. These parameters should be copied from the sub input file.
- A [/MultiAppUserObjectTransfer.md] to transfer the solid-side temperature
  layer averages into the sub-app variable provided via the
  [!param](/CoupledHeatTransfers/CoupledHeatTransferAction/T_wall) parameter.
- A [/MultiAppUserObjectTransfer.md] to transfer each of the phase temperature
  layer averages, provided by the user object(s) specified in the
  [!param](/CoupledHeatTransfers/CoupledHeatTransferAction/T_fluid_user_objects)
  parameter, into the master-app variables specified by the
  [!param](/CoupledHeatTransfers/CoupledHeatTransferAction/T_fluid) parameter.
- A [/MultiAppUserObjectTransfer.md] to transfer each of the phase heat transfer coefficient
  layer averages, provided by the user object(s) specified in the
  [!param](/CoupledHeatTransfers/CoupledHeatTransferAction/htc_user_objects)
  parameter, into the master-app variables specified by the
  [!param](/CoupledHeatTransfers/CoupledHeatTransferAction/htc) parameter.
- If multi-phase, a [/MultiAppUserObjectTransfer.md] to transfer each of the phase wall contact fraction
  layer averages, provided by the user object(s) specified in the
  [!param](/CoupledHeatTransfers/CoupledHeatTransferAction/kappa_user_objects)
  parameter, into the master-app variables specified by the
  [!param](/CoupledHeatTransfers/CoupledHeatTransferAction/kappa) parameter.

#### Instructions for the Master Input File

The following must be defined in the master-app input file:

- `AuxVariables` for the fluid temperature(s), heat transfer coefficient(s), and
  wall contact fractions (if multi-phase). For example,

           block=AuxVariables
           link=False

  It is recommended that the FE type match that of the corresponding variables
  in the coupled flow channel.

- `MultiApps` for the flow-channel sub-app(s). For example,

           block=MultiApps
           link=False

#### Instructions for the Sub Input File

The following must be defined in the sub-app input file:

- `AuxVariables` for the fluid temperature(s), heat transfer coefficient(s), and
  wall contact fractions (if multi-phase). For example, for THM's single-phase
  flow model, the fluid temperature is already available as an aux variable, but
  the wall heat transfer coefficient is an AD material property. Thus a [/MaterialRealAux.md]
  must be created:

           block=AuxVariables
           link=False

           block=AuxKernels
           link=False

- [/LayeredAverage.md] user objects for the fluid temperature(s), heat transfer coefficient(s),
  and wall contact fractions (if multi-phase). For example,

           block=UserObjects
           link=False

- A component to implement the flow channel heat source corresponding to [solid_side_heat_flux].
  For example, for THM's single-phase flow model, the [/HeatTransferFromExternalAppTemperature1Phase.md]
  component is used.



#### Example

Heat conduction input file:


Flow channel input file:


### PostprocessorAsControlAction


This conversion is performed for every postprocessor by every application that registers the
`ThermalHydraulicsApp` syntax.

This [Action](source/actions/Action.md) relies on creating a [CopyPostprocessorValueControl.md]
with the postprocessor as the [!param](/ControlLogic/CopyPostprocessorValueControl/postprocessor) parameter.




### THMAddControlAction


The `THMAddControlAction` is a [MooseObjectAction.md] that creates the specified
[ControlLogic](syntax/ControlLogic/index.md) object for
each sub-block of the `[ControlLogic]` block of an input file, then adds them to the
[Problem](syntax/Problem/index.md).




### THMCreateMeshAction


If created by this action, the mesh created is a [THMMesh.md]. If created by this action,
the problem created is a [THMProblem.md].

This enables input files to not contain a `[Mesh]` block and have a default, empty,
mesh created to satisfy objects that require the presence of a mesh.


### THMDebugAction


Currently, the only specific [Debug](syntax/Debug/index.md) option added is
to request the [THMProblem.md] to check the Jacobian, using the [!param](/Debug/THMDebugAction/check_jacobian)
parameter.




### THMOutputVectorVelocityAction

This action creates a user parameter [!param](/Outputs/velocity_as_vector) in the `[Outputs]` block.
This parameter can be used to output the velocity variable as a vector-valued or scalar-valued field.
The vector-valued option is on by default.



### THMPrintComponentLoopsAction


This action adds a [!param](/Debug/THMPrintComponentLoopsAction/print_component_loops)
parameter to the [`[Debug]`](syntax/Debug/index.md) block to print component loops to help
debug their disposition.
The component loops are printed from the [THMProblem.md].




### THMSetupOutputAction

This action creates a parameter [!param](/Outputs/disable_scalars_in_console) in the `[Outputs]` block,
which when set to `TRUE`, sets [!param](/Outputs/Console/execute_scalars_on) to be `NONE`
for all [Console.md] objects, overriding the user-specified value, which has a
default of `INITIAL TIMESTEP_END`. This parameter effectively changes the default
for the [!param](/Outputs/Console/execute_scalars_on) parameter for THM-based
applications. Disabling scalar variables output is often desirable in THM due
to the potentially large number of scalar variables in systems simulations.


## auxkernels

### ADConvectiveHeatFlux1PhaseAux


Version of [ConvectiveHeatFlux1PhaseAux.md] that uses [automatic differentiation (AD)](automatic_differentiation/index.md)
for the material properties, to be able to use AD material properties.




### ADVectorVelocityComponentAux


The direction is of the velocity is obtained from providing a component index into the
[!param](/AuxKernels/ADVectorVelocityComponentAux/direction) material property parameter.

The velocity component is computed as:

velocity = direction(component) * \dfrac{\alpha * \rho * u * A}{\alpha * \rho * A}

where $\alpha$ is the phase fraction, $\rho$ the density, $A$ the local area and $u$ the 1D velocity.

This auxkernel may not be used with a local zero phase fraction.

$\rho u A$, $\rho A$ and $\alpha$ are variables usually defined by the [Components](syntax/Components/index.md).




### ConvectiveHeatFlux1PhaseAux


If the heat transfer coefficient, wall temperature or fluid temperature are not defined in your simulation
as a  material property, variable and material property respectively, you may consider using
a [ParsedAux.md] to compute the convective heat flux.




### MachNumberAux


The Mach number is computed as:

\text{Mach number} = \dfrac{\text{velocity}}{\text{speed of sound}}

#### Example usage:


The variables `v`, `e`, `vel` are created when a single phase component is present in the
input file. If not using the component syntax, the user is responsible for creating the variables
and computing them.




### PrandtlNumberAux


The Prandtl number $Pr$ is computed as:

Pr = \dfrac{c_p * \mu}{k}

where $c_p$ is the specific heat capacity, $\mu$ the dynamic viscosity and $k$ the thermal conductivity.

The fluid properties are evaluated using the conserved variable set of specific volume and specific internal energy.
To use pressure and temperature, you may consider using a [FluidPropertiesMaterialPT.md] along with a
[ParsedMaterial.md] to define a Prandtl number material property.




### ReynoldsNumberAux


The Reynolds number $Re$ is computed as:

Re = \dfrac{ \alpha * \rho * |vel| \text{hydraulic diameter}}{\mu}

where $\alpha$ is the phase volume fraction, $\rho$ the density, $|vel|$ the absolute value of
the component of the phase velocity that is aligned with the flow and $\mu$ the dynamic viscosity.

This object is for use with the conserved variable set. To use temperature and pressure,
consider using the [ReynoldsNumberFunctorAux.md].

$v$, $e$, $vel$ and $\rho$ are variables declared when using a single-phase component.




### SoundSpeedAux


The speed of sound is evaluated for the single-phase fluid of interest using the conserved
variables, specific volume and specific internal energy.




### SpecificTotalEnthalpyAux


The specific total enthalpy $h$ is computed as

h = \dfrac{ \rho E A + \alpha P A }{\rho A}

where $\rho$ the fluid density, $A$ the local component area, $P$ the pressure and
$\rho E A$ the product of the internal energy by the density by the local component area.

$\rho E A$, $\rho A$ and $\rho$ are variables usually defined by the [Components](syntax/Components/index.md).




### SumAux


If you need a weighted sum, please consider using a [ParsedAux.md].




### THMSpecificInternalEnergyAux


The specific internal energy $e$ is computed as

e = \dfrac{ \rho E - 0.5 * \rho u * \rho u}{\rho \rho}

where $\rho$ the fluid density, $\rho u$ the momentum and
$\rho E$ the product of the internal energy by the density.

$\rho E$, $\rho u$ and $\rho$ are variables usually defined by the [Components](syntax/Components/index.md).




### THMSpecificVolumeAux


The phase specific volume $v$ is computed as

v = \dfrac{\alpha A}{\rho A}

where $A$ is the local component area, $\rho$ the fluid density and $\alpha$ the phase fraction.

$A$, $\rho A$ and $\alpha$ are variables usually defined by the [Components](syntax/Components/index.md).




### VariableValueTransferAux


The variable values can only be set on one boundary at a time and may only
be received from a single boundary as well.

This class assumes a first order mesh.

The source variable must be a nonlinear variable and must have its degrees of freedom on nodes, as
do Lagrange variables.




### VectorVelocityComponentAux

This object computes a component of a vector-valued velocity field.

The vector velocity is computed as:
\begin{equation}
\vec{u} = \frac{\rho u A}{\rho A} \vec{d}
\end{equation}
$\vec{u}$ is velocity vector, $\vec{d}$ is the direction of the element, $\rho A$ is density multiplied by cross-sectional area (also called conserved density), and $\rho u A$ is momentum density multiplied by cross-sectional area (also called conserved momentum).

$\rho u A$ and $\rho A$ are variables usually defined by the [Components](syntax/Components/index.md).




### WeightedAverageAux


The weighted average, $W$, of variables $\phi_i$ with weights $\omega_i$ is computed as:

W = \dfrac{\sum_i \phi_i \omega_i }{\sum_i \omega_i }

If you need a more complex average, please consider using a [ParsedAux.md].




## auxscalarkernels

### ShaftConnectedCompressor1PhaseScalarAux

This class computes pressure difference, isentropic torque, dissipation torque,
friction torque, and moment of inertia for a [ShaftConnectedCompressor1Phase.md] component.
See [ADShaftConnectedCompressor1PhaseUserObject.md] for details on their computation.
[ShaftConnectedCompressor1Phase.md] creates an instance of this class for each of these
quantities.




### ShaftConnectedPump1PhaseScalarAux

This class computes pump head, hydraulic torque, friction torque, or moment
of inertia for a [ShaftConnectedPump1Phase.md] component.
See [ADShaftConnectedPump1PhaseUserObject.md] for details on their computation.
[ShaftConnectedPump1Phase.md] creates an instance of this class for each of these
quantities.




### ShaftConnectedTurbine1PhaseScalarAux

This class computes pressure difference, driving torque, flow coefficient,
friction torque, moment of inertia, and power for a [ShaftConnectedTurbine1Phase.md] component.
See [ADShaftConnectedTurbine1PhaseUserObject.md] for details on their computation.
[ShaftConnectedTurbine1Phase.md] creates an instance of this class for each of these
quantities.




### SimpleTurbinePowerScalarAux


If the [!param](/AuxScalarKernels/SimpleTurbinePowerScalarAux/on) parameter is true, the power is
equal to [!param](/AuxScalarKernels/SimpleTurbinePowerScalarAux/value), else it is 0.

The [!param](/AuxScalarKernels/SimpleTurbinePowerScalarAux/on) parameter is controllable,
meaning that its value can be changed dynamically during a simulation using the [Controls system](syntax/Controls/index.md).




### VolumeJunction1PhaseScalarAux

This class computes pressure, temperature, or speed for a [VolumeJunction1Phase.md] component.
[VolumeJunction1Phase.md] creates an instance of this class for each of these
quantities.




## base

### FlowModelSinglePhase

The `FlowModelSinglePhase` creates the following for [FlowChannel1Phase.md] components using the 3-equation model:

- variables
- initial conditions
- kernels and DGKernels
- auxiliary kernels to compute density, velocity etc
- material properties needed for the kernels
- flux objects for HLLC

The full list of the objects created is listed in the [FlowChannel1Phase documentation](FlowChannel1Phase.md).

The `FlowModelSinglePhase` is created by [FlowChannel1Phase.md] components. It is not specified directly
in the input file.

### HeatConductionModel

#### Overview

The heat conduction model is a THM utility in charge of adding the heat conduction
equations to heat structure boundary components.

It creates:

- the temperature variable. It currently defaults to first-order Lagrange.
- an initial conduction for temperature based on the interface temperature.
- kernels for the heat conduction equations in either XYZ or RZ coordinates, with
  the time derivative if solving a transient.

### RZSymmetry

This interface class provides correct behavior for RZ-symmetric problems used by THM objects.
The reason why this class is needed is because MOOSE does not support RZ-symmetric problems with arbitrarily oriented axis of symmetry.
Note that because of that the coordinate system set by THM must be Cartesian (`Moose::XYZ`) to avoid the double coordinate transformation.
Using any other coordinate system with any object using this interface is invalid.

### Simulation

Simulation is one of the two base classes of a [THMProblem.md]. It implements a number of the specificities
of a thermal hydraulics solve, notably the reliance on [Components](syntax/Components/index.md) to form the problem.

It is in charge of :

- building the mesh, each part being created by each [Component](syntax/Components/index.md)
- creating the variables
- setting up initial conditions for the variables, whether from file or from user input
- setting up the quadrature

It also has APIs, that are called by various actions when parsing the input file, to:

- add components
- initialize components
- add MOOSE objects created by components
- identify component loops
- set up the coordinate system


It also performs integrity checks for:

- the coupling matrix, making sure it sufficiently captures inter-variable dependencies
  for convergence
- the components, making sure they all have a single inlet and a single outlet, and calling
  their own integrity checks
- control data, from [ControlLogic](syntax/ControlLogic/index.md) objects, making sure all the request control data
  does exist, and adding the proper dependencies

### THMMesh


The `THMMesh` is created by combining the meshes of all the components.
It provides APIs to add edge (1D) and quadrilateral (2D) elements which the components call
to build the mesh.

The `THMMesh` can be set to second-order by setting the `Problem` parameter [!param](/Problem/THMProblem/2nd_order_mesh) to true.
This is performed automatically for second order variables.

The THMMesh is created automatically by the [Simulation.md]. The user does not need to create it in their input
file.




## bcs

### ADBoundaryFlux3EqnBC


The boundary conditions retrieves the flux from an `ADBoundaryFluxBase`-derived user object,
such as the [ADBoundaryFlux3EqnFreeOutflow.md].

The heat flux contribution to the residual $R_i$ for the weak form of the energy equation is computed as:

\begin{equation}
R_i = (\psi_i, \Phi_{eqn} * \vec{n}) \quad \forall \psi_i,
\end{equation}

where $\psi_i$ are the test functions, $\Phi_{eqn}$ the flux for the equation considered, and $\vec{n}$ the local normal.

In THM, most boundary conditions are added automatically by components. This boundary condition is created by
`FlowBoundary1Phase`-derived components, such as the [InletDensityVelocity1Phase.md] boundary component.




### ADConvectionHeatTransfer3DBC


This BC is used with the [/HeatTransferFromHeatStructure3D1Phase.md] component. It applies the convective
heat transfer on the coupled boundary of a 3D heat structure.





### ADConvectionHeatTransferBC


The heat flux contribution to the residual $R_i$ for the weak form of the energy equation is computed as:

\begin{equation}
R_i = (\psi_i, S_{pp} S_{fn}(t, \vec{x}) h_{ambient}(t, \vec{x})
         (T - T_{ambient}(t, \vec{x}) ) ) \quad \forall \psi_i,
\end{equation}

where $\psi_i$ are the test functions, $S_{pp}$ a postprocessor scaling factor, $S_{fn}$ a scaling
function, $h_{ambient}$ the ambient convection heat transfer coefficient, $T$ the temperature nonlinear
variable, $T_{ambient}$ the ambient temperature.

In THM, most boundary conditions are added automatically by components. This boundary condition is created by the
[HSBoundaryAmbientConvection.md] boundary heat structure.




### ADConvectionHeatTransferRZBC


This boundary condition is meant to be used in XY coordinates that are interpreted as general cylindrical coordinates.
With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general RZ-coordinate objects.
Stay tuned!

In THM, most boundary conditions are added automatically by components. This boundary condition is created by the
[HSBoundaryAmbientConvection.md] boundary heat structure.




### ADExternalAppConvectionHeatTransferBC


The contribution to the residual $R_i$ for the weak form of the energy equation is computed as:

\begin{equation}
R_i = (\psi_i, S_{pp} S_{fn}(t, \vec{x}) h_{ext} (T - T_{ext}) ) \quad \forall \psi_i,
\end{equation}

where $\psi_i$ are the test functions, $S_{pp}$ a postprocessor scaling factor, $S_{fn}$ a scaling
function, $h_{ext}$ is the heat transfer coefficient variable provided by the external application,
$T$ is the temperature variable on the heat structure, and $T_{ext}$ the temperature variable provided by the
external application

In THM, most boundary conditions are added automatically by components. This boundary condition is created by the
[HSBoundaryExternalAppConvection.md] to place a convective heat flux boundary condition on a heat structure with the
temperature and heat transfer coefficients provided by an external application.




### ADExternalAppConvectionHeatTransferRZBC


This boundary condition is meant to be used in XY coordinates that are interpreted as general cylindrical coordinates.
With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general RZ-coordinate objects.
Stay tuned!

In THM, most boundary conditions are added automatically by components. This boundary condition is created by the
[HSBoundaryExternalAppConvection.md] to place a convective heat flux boundary condition on a cylindrical heat structure with the
temperature and heat transfer coefficients provided by an external application.




### ADGateValve1PhaseBC


This BC is used with the [/GateValve1Phase.md] component in 1-phase flow. It indexes into
the flux vectors that are computed in [/ADGateValve1PhaseUserObject.md].




### ADHeatFlux3EqnBC


The heat flux contribution to the residual $R_i$ for the weak form of the energy equation is computed as:

\begin{equation}
R_i = (\psi_i, -S q_{wall} P_{hf}) \quad \forall \psi_i,
\end{equation}
where $\psi_i$ are the test functions and $q_{wall}$ is the local heat flux, $S$ a scaling factor
and $P_{hf}$ the heated perimeter.

In THM, most boundary conditions are added automatically by components. This boundary condition is created by the
[HeatTransferFromHeatStructure1Phase.md] on the heat structure boundary.




### ADHSHeatFluxBC


The heat flux contribution to the residual $R_i$ for the weak form of the energy equation is computed as:

\begin{equation}
R_i = (\psi_i, - S_{pp} S_{fn}(t, \vec{x}) F(t, \vec{x})) \quad \forall \psi_i,
\end{equation}

where $\psi_i$ are the test functions, $S_{pp}$ a postprocessor scaling factor, $S_{fn}$ a scaling
function, $F(t, \vec{x})$ a function providing the heat flux.

In THM, most boundary conditions are added automatically by components. This boundary condition is created by the
[HSBoundaryHeatFlux.md] boundary heat structure.




### ADHSHeatFluxRZBC


This boundary condition is meant to be used in XY coordinates that are interpreted as general cylindrical coordinates.
With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general RZ-coordinate objects.
Stay tuned!

In THM, most boundary conditions are added automatically by components. This boundary condition is created by the
[HSBoundaryHeatFlux.md] boundary heat structure.




### ADJunctionOneToOne1PhaseBC


This BC is used with the [/JunctionOneToOne1Phase.md] component in 1-phase flow. It indexes into
the flux vectors that are computed in [/ADJunctionOneToOne1PhaseUserObject.md].




### ADRadiativeHeatFluxBC

This boundary condition is used to supply a radiative heat flux:
\begin{equation}
  q = \sigma \epsilon G (T^4 - T^4_\text{amb}) \,,
\end{equation}
where

- $\sigma$ is the Stefan-Boltzmann constant,
- $\epsilon$ is the emissivity of the surface,
- $G$ is the view factor function,
- $T$ is the temperature of the surface, and
- $T_\text{amb}$ is the temperature of the environment.

In THM, most boundary conditions are added automatically by components. This boundary condition is created by the
[HSBoundaryRadiation.md] to place a radiative heat flux boundary condition on a heat structure.




### ADRadiativeHeatFluxRZBC


This boundary condition is meant to be used in XY coordinates that are interpreted as general cylindrical coordinates.
With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general RZ-coordinate objects.
Stay tuned!

In THM, most boundary conditions are added automatically by components. This boundary condition is created by the
[HSBoundaryRadiation.md] to place a radiative heat flux boundary condition on a cylindrical heat structure.




### ADVolumeJunction1PhaseBC


This BC is used with the [/VolumeJunction1Phase.md] component. It indexes into
the flux vectors that are computed in [/ADVolumeJunction1PhaseUserObject.md].




### BoundaryFlux3EqnBC


This implements a general boundary condition for the 1-D, 1-phase, variable-area Euler
equations, using a boundary flux user object, which computes the boundary flux
$F_b$ used in the boundary integral:
\begin{equation}
  \int\limits_\Gamma F_b(\mathbf{U}) \phi_i n_x d\Gamma \,.
\end{equation}

For RDG spatial discretization, the solution in the boundary cells is not
reconstructed, so the cell-average solution is used. However, the cross-sectional
area used is the piecewise linear area $A_b$, not the cell-average area. In implementation,
only the cell-average area $A_i$ is passed into the boundary flux function, so the
linear cross-sectional area is used externally as follows:
\begin{equation}
  \int\limits_\Gamma F_b(\mathbf{U}) \frac{A_b}{A_i} \phi_i n_x d\Gamma \,.
\end{equation}




### ConvectionHeatTransferBC


The heat flux contribution to the residual $R_i$ for the weak form of the energy equation is computed as:

\begin{equation}
R_i = (\psi_i, h_{ambient}(t, \vec{x}) (T - T_{ambient}(t, \vec{x}) ) ) \quad \forall \psi_i,
\end{equation}

where $\psi_i$ are the test functions, $h_{ambient}$ the ambient convection heat transfer coefficient, $T$ the temperature nonlinear
variable, $T_{ambient}$ the ambient temperature.

In THM, most boundary conditions are added automatically by components. This boundary condition is no-longer in use, having
been replaced by its [AD](automatic_differentiation/index.md) counterpart [ADConvectionHeatTransferBC.md],
designed to provide numerically exact contributions to the Jacobian.




### ConvectionHeatTransferRZBC


This boundary condition is meant to be used in XY coordinates that are interpreted as general cylindrical coordinates.
With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general RZ-coordinate objects.
Stay tuned!

In THM, most boundary conditions are added automatically by components. This boundary condition is no-longer in use, having
been replaced by its [AD](automatic_differentiation/index.md) counterpart [ADConvectionHeatTransferRZBC.md],
designed to provide numerically exact contributions to the Jacobian.




### ExternalAppConvectionHeatTransferBC


The contribution to the residual $R_i$ for the weak form of the energy equation is computed as:

\begin{equation}
R_i = (\psi_i, S_{pp} S_{fn}(t, \vec{x}) h_{ext} (T - T_{ext}) ) \quad \forall \psi_i,
\end{equation}

where $\psi_i$ are the test functions, $S_{pp}$ a postprocessor scaling factor, $S_{fn}$ a scaling
function, $h_{ext}$ is the heat transfer coefficient variable provided by the external application,
$T$ is the temperature variable on the heat structure, and $T_{ext}$ the temperature variable provided by the
external application

In THM, most boundary conditions are added automatically by components. This boundary condition is no-longer in use, having
been replaced by its [AD](automatic_differentiation/index.md) counterpart [ADExternalAppConvectionHeatTransferBC.md],
designed to provide numerically exact contributions to the Jacobian.




### ExternalAppConvectionHeatTransferRZBC


This boundary condition is meant to be used in XY coordinates that are interpreted as general cylindrical coordinates.
With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general RZ-coordinate objects.
Stay tuned!

In THM, most boundary conditions are added automatically by components. This boundary condition is no-longer in use, having
been replaced by its [AD](automatic_differentiation/index.md) counterpart [ADExternalAppConvectionHeatTransferRZBC.md],
designed to provide numerically exact contributions to the Jacobian.




### HeatStructure2DCouplerBC


The contribution to the residual $R_i$ for the weak form of the energy equation is computed as:

\begin{equation}
R_i = (\psi_i, h(t, \vec{x}) (T - T_{coupled} ) A_{fraction} ) \quad \forall \psi_i,
\end{equation}

where $\psi_i$ are the test functions, $h$ is the heat transfer coefficient provided by a [Function](syntax/Functions/index.md),
$T$ is the temperature variable on one of the components, $T_{coupled}$ the temperature variable on the other
component, and $A_{fraction}$ the area of contact between the two components.

In THM, most boundary conditions are added automatically by components. This boundary condition is created by the
[HeatStructure2DCoupler.md] to couple the temperature variable on both sides of the boundaries between the heat structure
components. It is added once for each heat structure involved.




### HeatStructure2DCouplerRZBC


This boundary condition is meant to be used in XY coordinates that are interpreted as general cylindrical coordinates.
With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general RZ-coordinate objects.
Stay tuned!

In THM, most boundary conditions are added automatically by components. This boundary condition is created by the
[HeatStructure2DCoupler.md] to couple the temperature variable on both sides of the boundaries between the heat structure
components. It is added once for each heat structure involved.




### HeatStructure2DRadiationCouplerRZBC


The heat flux contribution to the residual $R_i$ for the weak form of the energy equation is computed as:

\begin{equation}
R_i = (\psi_i, _sigma * \dfrac{T^4 - T_{coupled}^4}{R} C \quad \forall \psi_i,
\end{equation}

where $\psi_i$ are the test functions, $\sigma$ is the Stefan-Boltzmann constant, $T$ is one heat structure temperature
variable, $T_{coupled}$ the other heat structure temperature variable, $R$ the radiation resistance, and $C$ the
circumference of the heat structure boundary considered.

The radiation resistance is computed as:

R = \dfrac{1.0 - \epsilon}{\epsilon} + \dfrac{1.0}{V} +
    \dfrac{1.0 - \epsilon_{coupled}}{\epsilon_{coupled}}  \dfrac{A}{A_{coupled}}

where $\epsilon$ is the emissivity of one heat structure boundary, $\epsilon_{coupled}$ the surface emissivity
of the other heat structure's boundary, $V$ the view factor between the two boundaries, $A$ the surface area,
and $A_{coupled}$ the surface area of the coupled heat structure's boundary.

This boundary condition is meant to be used in XY coordinates that are interpreted as general cylindrical coordinates.
With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general RZ-coordinate objects.
Stay tuned!

In THM, most boundary conditions are added automatically by components. This boundary condition is created by the
[HeatStructure2DRadiationCouplerRZ.md] to couple boundaries of two 2D cylindrical heat structures via radiation.
The boundary condition is added once for each cylindrical heat structure.




### HSCoupler2D2DRadiationRZBC

This BC applies the heat fluxes for cylindrical heat structures
in a [HSCoupler2D2DRadiation.md], where the heat fluxes are computed using
[HSCoupler2D2DRadiationUserObject.md].




### HSCoupler2D3DBC

This BC applies the heat fluxes for either the 2D boundary or the 3D boundary
in a [HSCoupler2D3D.md], where the heat fluxes are computed using
[HSCoupler2D3DUserObject.md].




### RadiativeHeatFluxBC

This boundary condition is used to supply a radiative heat flux:
\begin{equation}
  q = \sigma \epsilon G (T^4 - T^4_\text{amb}) \,,
\end{equation}
where

- $\sigma$ is the Stefan-Boltzmann constant,
- $\epsilon$ is the emissivity of the surface,
- $G$ is the view factor function,
- $T$ is the temperature of the surface, and
- $T_\text{amb}$ is the temperature of the environment.




### RadiativeHeatFluxRZBC

This boundary condition is the same as [/RadiativeHeatFluxBC.md] but for 2-D
RZ geometry.




## closures

### Closures1PhaseNone

This class is used for providing no closures for a single-phase flow channel,
which allows all closures to be created directly in the input file.




### Closures1PhaseSimple


The closures added are:

- a wall friction factor model using [ADWallFrictionFunctionMaterial.md]
- a wall heat transfer coefficient as a [ADWeightedAverageMaterial.md] of the heat transfer coefficients
  defined by the flow channel (deriving from [FlowChannel1Phase.md]) weighted by the heated perimeters of each section.

Additionally, this object defines:

- a wall temperature material, to be able to retrieve the wall temperature as a material property, using either [ADAverageWallTemperature3EqnMaterial.md], AD[CoupledVariableValueMaterial.md] or [ADTemperatureWall3EqnMaterial.md] depending on the temperature mode of the flow channel (deriving from [FlowChannel1Phase.md])





### Closures1PhaseTHM


The closures added are:

- a wall friction factor for the pressure drop,
- a wall heat transfer coefficient for heat transfer.

The user can choose between a range of correlations for the heat transfer coefficient and friction factor that covers  pipes to rod-bundles. The available correlations for the heat transfer coefficient are listed in [HTC-correlations].

| Name           | Coolant       | Geometry    | Reference                                                   |
| -------------- | ------------- | ----------- | ----------------------------------------------------------- |
| Dittus-Boelter | Liquid/Gases  | Pipes       | [ADWallHeatTransferCoefficient3EqnDittusBoelterMaterial.md] |
| Gnielinski     | Liquid/Gases  | Pipes       | [ADWallHeatTransferCoefficientGnielinskiMaterial.md]        |
| Wolf-McCarthy  | Gases         | Pipes       | [ADWallHeatTransferCoefficientWolfMcCarthyMaterial.md]      |
| Lyon           | Liquid Sodium | Pipes       | [ADWallHeatTransferCoefficientLyonMaterial.md]              |
| Weisman        | Water         | Rod-bundles | [ADWallHeatTransferCoefficientWeismanMaterial.md]           |
| Kazimi-Carelli | Liquid Sodium | Rod-bundles | [ADWallHeatTransferCoefficientKazimiMaterial.md]            |
| Mikityuk       | Liquid Sodium | Rod-bundles | [ADWallHeatTransferCoefficientMikityukMaterial.md]          |
| Schad          | Liquid Sodium | Rod-bundles | [ADWallHeatTransferCoefficientSchadMaterial.md]             |

The available correlations for the friction factor are listed in [FF-correlations].

| Name          | Geometry    | Reference                            |
| ------------- | ----------- | ------------------------------------ |
| Churchill     | Pipes       | [ADWallFrictionChurchillMaterial.md] |
| Cheng-Todreas | Rod-bundles | [ADWallFrictionChengMaterial.md]     |


The user can also define the friction factor directly in the component block, overwriting the value given by the [Closures1PhaseTHM.md], for example:

```
[Components]
  [pipe_1]
    type = FlowChannel1Phase
    fp = water
    position = '0 0 0'
    orientation = '1 0 0'
    length = 1
    n_elems = 10
    f = 0.01
  []
  [pipe_2]
    type = FlowChannel1Phase
    fp = water
    position = '1 0 0'
    orientation = '1 0 0'
    length = 1
    n_elems = 10
  []
[]
```

In this case, the friction factor for the `Pipe_1` component will be equal to the value defined in the parameter `f`, while for `Pipe_2` the friction factor will given by the correlation chosen in the [Closures1PhaseTHM.md].

Additionally, this object defines:

- a wall temperature material, to be able to retrieve the wall temperature as a material property for each heat transfer.




### FunctorClosures

This closures object is used to provide arbitrary closures via [functors](/Functors/index.md).




### WallTemperature1PhaseClosures

This class is used to provide the wall temperature material property for
single-phase flow channels, depending on how many heat transfers are connected.
Note that this only activates if there is at least one heat transfer of
"temperature type" (i.e., not a specified heat flux) connected to the channel.





## components

### ComponentGroup

This is a helper object that allows nesting of components into groups.  Users never instantiate it
directly in an input file, but indirectly via input file syntax like so:

```
[Components]
  [./compA]
  [../]

  [./group]
    [./comp1]
    [../]
    [./comp2]
    [../]
  [../]
[]
```

This input file will build 3 components: `compA`, `group/comp1`, `group/comp2`. No matter the location
in the input file, components are always referred to with their full name, i.e. in our example above,
one cannot refer to `comp1` with name `comp1` inside the group `group` - it must be referred to
as `group/comp1`.




### ElbowPipe1Phase


This component creates a bent 1-phase [flow channel](component_groups/flow_channel.md),
with a bending angle supplied by the user.
The component does not have straight sections, only the bend is modelled.

The underlying flow model is a [FlowChannel1Phase.md].




### FileMeshComponent

This component loads a mesh from an ExodusII file. This class can be used directly
in the input file, which will load a mesh into a component without adding any
physics, or it can be used as a base class for other components that do add
physics.

#### Usage

The parameter [!param](/Components/FileMeshComponent/file) is used to specify the
name of the ExodusII file containing a mesh. When loading this mesh into the
component, the component name is prepended to the block and boundary names:

- Blocks become `component_name:block_name`, where `component_name` is the name
  of the component and `block_name` is the original block name.
- Boundaries become `component_name:boundary_name`, where `component_name` is the name
  of the component and `boundary_name` is the original boundary name.

The parameter [!param](/Components/FileMeshComponent/position) specifies a
translation vector $\mathbf{p}$ for the points in the mesh file; the node positions for this component
are computed as

\mathbf{r} = \mathbf{r}_\text{file} + \mathbf{p} \,,

where $\mathbf{r}_\text{file}$ is a point in the loaded mesh file.




### FileMeshPhysicsComponent

This component first loads a mesh from an ExodusII file. It is equivalent to the [FileMeshGenerator.md]
but can be used within a simulation with the geometry described with [Components](Components/index.md) instead of a [Mesh](Mesh/index.md)
block.

This component then adds its block to the domain of definition of [Physics](Physics/index.md) actions.
The `Physics` must have implemented the `::addBlocks` routine.

#### Loading the mesh file

See the [FileMeshComponent.md] for explanations on how to load the mesh.

#### Defining Physics

The `Physics` active on the mesh loaded by this component are specified with the [!param](/Components/FileMeshPhysicsComponent/physics) parameter.




### FlowChannel1Phase

This component is a single-phase [flow channel](component_groups/flow_channel.md).

#### Usage


[!param](/Components/FlowChannel1Phase/orientation) can only be used to specify a single
direction and thus cannot be used to specify bends in a flow channel.

Each end of a flow channel must be connected to either a
[boundary](component_groups/flow_boundary.md) or a
[junction](component_groups/flow_junction.md)
(see [#mesh_blocks] for the boundary naming conventions).


Initial conditions are specified for pressure, temperature, and velocity with
the following parameters:

- [!param](/Components/FlowChannel1Phase/initial_p)
- [!param](/Components/FlowChannel1Phase/initial_T)
- [!param](/Components/FlowChannel1Phase/initial_vel)


#### Mesh id=mesh

##### Axial Discretization id=mesh_axial


##### Blocks and Boundaries id=mesh_blocks


#### Variables

The following solution variables are created on the flow channel:

| Variable | Symbol | Description |
| :- | :- | :- |
| `rhoA` | $\rho A$ | Mass per unit length \[kg/m\] |
| `rhouA` | $\rho u A$ | Momentum per unit length; mass flow rate \[kg/s\] |
| `rhoEA` | $\rho E A$ | Energy per unit length \[J/m\] |

The following auxiliary variables are created on the flow channel:

| Variable | Symbol | Description |
| :- | :- | :- |
| `A` | $A$ | Cross-sectional area \[m$^2$\] (piecewise constant) |
| `A_linear` | $A$ | Cross-sectional area \[m$^2$\] (piecewise linear) |
| `P_hf` | $P_\text{heat}$ | Heated perimeter \[m\] |
| `vel_x` | $u_x$ | Velocity component along the x-axis \[m/s\] (if specified to output vector-valued velocity) |
| `vel_y` | $u_y$ | Velocity component along the y-axis \[m/s\] (if specified to output vector-valued velocity) |
| `vel_z` | $u_z$ | Velocity component along the z-axis \[m/s\] (if specified to output vector-valued velocity) |
| `vel` | $u$ | Velocity component along flow channel direction \[m/s\] (if specified not to output vector-valued velocity) |
| `rho` | $\rho$ | Density \[kg/m$^3$\] |
| `p` | $p$ | Pressure \[Pa\] |
| `T` | $T$ | Temperature \[K\] |
| `v` | $v$ | Specific volume \[m$^3$/kg\] |
| `e` | $e$ | Specific internal energy \[J/kg\] |
| `H` | $H$ | Specific total enthalpy \[J/kg\] |

#### Material Properties

The following material properties are created on the flow channel:

| Material Property | Symbol | Description |
| :- | :- | :- |
| `direction` | $\mathbf{d}$ | Flow channel direction vector \[-\] |
| `rhoA` | $\rho A$ | Mass per unit length \[kg/m\] (slope-reconstructed) |
| `rhouA` | $\rho u A$ | Momentum per unit length; mass flow rate \[kg/s\] (slope-reconstructed) |
| `rhoEA` | $\rho E A$ | Energy per unit length \[J/m\] (slope-reconstructed) |
| `vel` | $u$ | Velocity component along flow channel direction \[m/s\] |
| `rho` | $\rho$ | Density \[kg/m$^3$\] |
| `p` | $p$ | Pressure \[Pa\] |
| `T` | $T$ | Temperature \[K\] |
| `v` | $v$ | Specific volume \[m$^3$/kg\] |
| `e` | $e$ | Specific internal energy \[J/kg\] |
| `h` | $h$ | Specific enthalpy \[J/kg\] |
| `H` | $H$ | Specific total enthalpy \[J/kg\] |
| `c` | $c$ | Sound speed \[m/s\] |
| `cp` | $c_p$ | Isobaric specific heat capacity \[J/(kg-K)\] |
| `cv` | $c_v$ | Isochoric specific heat capacity \[J/(kg-K)\] |
| `k` | $k$ | Thermal conductivity \[W/(m-K)\] |
| `mu` | $\mu$ | Dynamic viscosity \[Pa-s\] |
| `f_D` | $f_D$ | Darcy friction factor \[-\] |
| `D_h` | $D_h$ | Hydraulic diameter \[m\] |
| `q_wall` | $q_\text{wall}$ | Wall heat flux \[W/m$^2$\] (if no connected heat transfer) |

#### Formulation

See [!cite](relap7theory) for a description of the single-phase flow formulation.




### FormLoss1PhaseBase

This is a base class for prescribing a form loss over a 1-phase flow channel.

The form loss is created by adding a [ADOneD3EqnMomentumFormLoss.md] kernel. This
creates a momentum loss term in the equation for $\rho u A$, that is applied over the full length of
the [FlowChannel1Phase.md] component.

### FormLossFromExternalApp1Phase


This form loss follows the model used in [FormLoss1PhaseBase.md],
it simply defines the loss coefficient as being `K_prime`, a first order
Lagrange variable defined over the component block that will be populated from
an external application. This variable will then be converted to a material property
using an [CoupledVariableValueMaterial.md], to be used by the kernel added by [FormLoss1PhaseBase.md]. 




### FormLossFromFunction1Phase


This form loss follows the model used in [FormLoss1PhaseBase.md];
it simply defines the loss coefficient as being the function passed to the [!param](/Components/FormLossFromFunction1Phase/K_prime). This `Function` will then be converted to a material property using an
[GenericFunctionMaterial.md], to be used by the kernel added by [FormLoss1PhaseBase.md].




### FreeBoundary

This component is deprecated. Use FreeBoundary1Phase or FreeBoundary2Phase instead.

### FreeBoundary1Phase

This is a single-phase [1-D flow boundary component](component_groups/flow_boundary.md)
in which no boundary data is supplied by the user. This component should be used
only if the boundary is a supersonic exit, since this is the only situation in
which no external characteristics enter the domain.

#### Usage

This component must be connected to a [/FlowChannel1Phase.md]. See
[how to connect a flow boundary component](component_groups/flow_boundary.md#usage).




#### Formulation

In this formulation, no boundary data is supplied; thus, the boundary flux is evaluated
entirely using the interior solution:

\begin{equation}
  \mathbf{F}_\text{b} = \mathcal{f}(\mathbf{U}_i) \eqp
\end{equation}

### GateValve

This component is deprecated. Use GateValve1Phase or GateValve2Phase instead.

### GateValve1Phase

This component implements a gate valve, which is controlled via a function that
represents the fraction of the possible flow area that is actually open to flow,
given the status of the valve.




### HeatGeneration

This component is deprecated. Use 'HeatSourceFromTotalPower' or 'HeatSourceFromPowerDensity' instead.

### HeatSourceFromPowerDensity

This component is a
[heat structure heat source](thermal_hydraulics/component_groups/heat_structure_heat_source.md)
from a power density variable $q'''$.

#### Usage


The user provides a power density variable using the parameter
[!param](/Components/HeatSourceFromPowerDensity/power_density).


#### Formulation




### HeatSourceFromTotalPower

This component is a
[heat structure heat source](thermal_hydraulics/component_groups/heat_structure_heat_source.md)
from a total power $Q$, provided by a
[power component](thermal_hydraulics/component_groups/power.md). A fraction $f$
of this total power may be specified, as well as a shape function
$a(\mathbf{x})$ if a non-uniform distribution is desired.

#### Usage


The user is required to specify the name of a
[power component](thermal_hydraulics/component_groups/power.md) via the
[!param](/Components/HeatSourceFromTotalPower/power)
parameter. This power can be scaled with the parameter
[!param](/Components/HeatSourceFromTotalPower/power_fraction).
If a non-uniform power distribution is desired, the parameter
[!param](/Components/HeatSourceFromTotalPower/power_shape_function)
may be used to specify a spatial shape function, which gets normalized internally.


#### Formulation


The power density from this component is the following:

q'''(\mathbf{x}) = f Q \frac{a(\mathbf{x})}{\tilde{A}} \eqc

where $\tilde{A}$ denotes the discrete approximation to

A \equiv \int\limits_\Omega a(\mathbf{x}) d\Omega \eqc

where $\Omega$ is the heat source domain.
Note that the discrete integral of the power density over $\Omega$
is exactly equal to $f Q$.



### HeatSourceVolumetric

This component is deprecated. Use HeatSourceVolumetric1Phase or HeatSourceVolumetric2Phase instead.

### HeatSourceVolumetric1Phase


The volumetric heat source is applied to the [1-phase flow channel](FlowChannel1Phase.md)
volume using a [OneD3EqnEnergyHeatSource.md] kernel, added to the energy equation (with the
$\rho E A$ variable).




### HeatStructure2DCoupler

This component couples two [2D heat structures](component_groups/heat_structure_2d.md)
via a heat transfer coefficient.

#### Usage

This component has the following restrictions:

- The coupled heat structures must be [2D heat structures](component_groups/heat_structure_2d.md).
- The coupled heat structures must be of the same type.
- Only one boundary name may be provided in each of the
  [!param](/Components/HeatStructure2DCoupler/primary_boundary) and
  [!param](/Components/HeatStructure2DCoupler/secondary_boundary) parameters.
- The meshes along the coupled boundaries must be aligned. Each element on a
  boundary is paired with the nearest element on the coupled boundary. The
  alignment check requires that each element on a boundary has exactly one
  element from the coupled boundary paired to it.


#### Formulation



For the heat structure $k$, the incoming boundary heat flux $q_b$ is computed as

\begin{equation}
  q_b = \mathcal{H} (T_j - T_k) F_k \eqc
\end{equation}
where

- $\mathcal{H}$ is the heat transfer coefficient,
- $T_k$ is the surface temperature of the heat structure $k$,
- $T_j$ is the surface temperature of the coupled heat structure $j$, and
- $F_k$ is the area scaling factor of the heat structure $k$:

F_k = \left\{\begin{array}{l l}
  1 & A_k \leq A_j\\
  \frac{A_j}{A_k} & A_k > A_j\\
  \end{array}\right. \eqc

where $A_k$ is the area of the heat structure boundary $k$.



### HeatStructure2DRadiationCouplerRZ

This component couples two cylindrical, [2D heat structures](component_groups/heat_structure_2d.md)
via opaque, gray, diffuse radiation.

#### Usage

This component has the following restrictions:

- The coupled heat structures must derive from `HeatStructureCylindricalBase`,
  for example, [HeatStructureCylindrical.md].
- Only one boundary name may be provided in each of the
  [!param](/Components/HeatStructure2DRadiationCouplerRZ/primary_boundary) and
  [!param](/Components/HeatStructure2DRadiationCouplerRZ/secondary_boundary) parameters.
- The meshes along the coupled boundaries must be aligned. Each element on a
  boundary is paired with the nearest element on the coupled boundary. The
  alignment check requires that each element on a boundary has exactly one
  element from the coupled boundary paired to it.
- The boundaries must be radial, i.e., on either the inner or outer cylindrical
  surfaces, not the flat surfaces.


#### Formulation



This component computes and applies the boundary flux $q_b$ for each boundary.
For two opaque, gray, diffuse surfaces in an enclosure, the heat flux $q_i$ to
surface $i$ is the following [!citep](incropera2002):

q_i = \frac{\sigma (T_j^4 - T_i^4)}{\mathcal{R}_i} \eqc

where $\mathcal{R}_i$ is sometimes described as a radiation resistance:

\mathcal{R}_i = \frac{1 - \epsilon_i}{\epsilon_i} + \frac{1}{F_{i,j}}
  + \frac{1 - \epsilon_j}{\epsilon_j}\frac{A_i}{A_j} \eqc

where

- $\epsilon_i$ is the emissivity of surface $i$,
- $\sigma$ is the Stefan-Boltzmann constant,
- $F_{i,j}$ is the view factor from surface $i$ to surface $j$,
- $T_i$ is the temperature of surface $i$, and
- $A_i$ is the area of surface $i$.

The surface $i$ that is enclosed by the other surface has its view factor
set to unity:

F_{i,j} = 1 \eqc

whereas the other is computed using the reciprocity rule:

F_{j,i} = \frac{A_i}{A_j} \eqp



### HeatStructureCylindrical

This component is a [2D heat structure](component_groups/heat_structure_2d.md)
that has axisymmetry; thus it is either a cylinder or cylindrical shell.

#### Usage




If the domain has some inner radius, then this is specified with
[!param](/Components/HeatStructureCylindrical/inner_radius); otherwise, it is
assumed to be a solid cylinder.


#### Mesh id=mesh

##### Axial Discretization id=mesh_axial


##### Radial Discretization id=mesh_radial


##### Blocks and Boundaries id=mesh_blocks


#### Variables


#### Formulation




### HeatStructureFromFile3D

This component allows users to load a 3D mesh from a file into a
[heat structure](thermal_hydraulics/component_groups/heat_structure.md).

The block, sideset, and nodeset names are preserved, but are prepended with a component name. For example,
if the component name is `hs` and the mesh has a block called `body`, users can refer to this block
using the `hs:body` name, and similarly for sidesets and nodesets.

#### Usage


The following parameters need to be specified:

- [!param](/Components/HeatStructureFromFile3D/position): The location in 3D
  space where the origin of the mesh will be placed. This can be used to move
  the mesh from its original location specified in the file.
- [!param](/Components/HeatStructureFromFile3D/file): the ExodusII file name
  with the mesh to load. Note that ExodusII is the only supported format at the
  moment.

To define the material properties used by the heat conduction model, users must
create materials that define the following AD material properties on all of
their blocks (see [#mesh]):

| Material Property | Symbol | Description |
| :- | :- | :- |
| `density` | $\rho$ | Density \[kg/m$^3$\] |
| `specific_heat` | $c_p$ | Specific heat capacity \[J/(kg-K)\] |
| `thermal_conductivity` | $k$ | Thermal conductivity \[W/(m-K)\] |


#### Mesh id=mesh

The block and sideset names in the loaded mesh file are prepended with the name
of the component. For example if the heat structure component name is `myhs`
and the mesh file has the block `myblock`, then the block `myhs:myblock` is
created.

#### Variables


#### Formulation




### HeatStructurePlate

This component is a [2D heat structure](component_groups/heat_structure_2d.md)
that has a plate/brick/box shape.

#### Usage




The component is 2D but has a finite depth in the third dimension, which is
specified via [!param](/Components/HeatStructurePlate/depth).


#### Mesh id=mesh

##### Axial Discretization id=mesh_axial


##### Radial Discretization id=mesh_radial


##### Blocks and Boundaries id=mesh_blocks


#### Variables


#### Formulation




### HeatTransferFromExternalAppHeatFlux1Phase


This component is a
[single-phase heat transfer component](thermal_hydraulics/component_groups/heat_transfer_1phase.md).

It adds a [ADOneDEnergyWallHeatFlux.md] kernel to the energy equation. The
heat source is gathered from a constant monomial variable named "q_wall" plus a suffix dependent on
the index of the connected heat transfer component. This variable should
be set using transferred data from an external application.

The variable is provided to the [ADOneDEnergyWallHeatFlux.md] kernel as a material property.
The conversion is done using a [CoupledVariableValueMaterial.md].

#### Formulation

Please refer to [ADOneDEnergyWallHeatFlux.md] for the heat flux formulation.




### HeatTransferFromExternalAppTemperature1Phase


This component is a [single-phase heat transfer component](thermal_hydraulics/component_groups/heat_transfer_1phase.md).

It adds a [ADOneDEnergyWallHeating.md] kernel to the energy equation.
The wall temperature is added as either a constant monomial or a linear Lagrange variable, depending
on the [!param](/Components/HeatTransferFromExternalAppTemperature1Phase/var_type) parameter.
It is named after the [!param](/Components/HeatTransferFromExternalAppTemperature1Phase/T_ext) parameter.
This variable should be set using transferred data from an external application.

#### Formulation

Please refer to [ADOneDEnergyWallHeating.md] for the heat flux formulation.




### HeatTransferFromHeatFlux1Phase

This component is a
[single-phase heat transfer component](thermal_hydraulics/component_groups/heat_transfer_1phase.md)
that uses a wall heat flux from a user-provided function.

#### Usage



The parameter [!param](/Components/HeatTransferFromHeatFlux1Phase/q_wall)
specifies the wall heat flux function $q_\text{wall}$.


#### Formulation




### HeatTransferFromHeatStructure1Phase

This component is both a
[single-phase heat transfer component](thermal_hydraulics/component_groups/heat_transfer_1phase.md)
and a [heat structure boundary](thermal_hydraulics/component_groups/heat_structure_boundary.md).
It specifies a convective heat exchange between a
[FlowChannel1Phase.md] and a [2D heat structure](thermal_hydraulics/component_groups/heat_structure_2d.md).

#### Usage



The parameter [!param](/Components/HeatTransferFromHeatStructure1Phase/hs) specifies
the name of the connected heat structure, and
[!param](/Components/HeatTransferFromHeatStructure1Phase/hs_side) specifies the
side of the connected heat structure that is coupled to the flow channel.

The flow channel axis must be parallel to the heat structure axis and have
the same discretization along their axes.

The parameter [!param](/Components/HeatTransferFromHeatStructure1Phase/scale) specifies
the name of a [functor](Functors/index.md) $f$ that can scale the heat flux, for
example, a functor material property created with [FinEnhancementFactorFunctorMaterial.md]
for heat transfer enhancement due to fins.


#### Formulation

This component implements a convective heat exchange between the flow channel
and heat structure, with the flow channel receiving the following wall heat
flux:

q_\text{wall} = f \mathcal{H}(T_s - T) \eqc

where $\mathcal{H}$ is the heat transfer coefficient, $T_s$ is the heat
structure surface temperature, $T$ is the fluid temperature, and $f$ is an optional scaling factor. On the heat
structure side, the incoming boundary flux is the opposite of that going into
the flow channel:

q_b = -q_\text{wall} = f \mathcal{H}(T - T_s) \eqp



### HeatTransferFromHeatStructure3D1Phase

This component is both a
[single-phase heat transfer component](thermal_hydraulics/component_groups/heat_transfer_1phase.md)
and a [heat structure boundary](thermal_hydraulics/component_groups/heat_structure_boundary.md).
It specifies a convective heat exchange between a [HeatStructureFromFile3D.md]
and one or more [FlowChannel1Phase.md] components.

#### Usage

The parameter [!param](/Components/HeatTransferFromHeatStructure3D1Phase/flow_channels)
specifies the flow channels to connect. These flow channels must be aligned with
one of the axes (x, y, or z). The number of elements of the heat structure in
the direction of the flow channels must match the number of elements of the flow
channels, and the axial locations of the element centroids must match. The user
should check the flow channel and heat structure elements are properly aligned
to ensure the coupling is properly executed. No internal check is performed.

The parameter [!param](/Components/HeatTransferFromHeatStructure3D1Phase/hs)
specifies the name of the 3D heat structure, and the parameter
[!param](/Components/HeatTransferFromHeatStructure3D1Phase/boundary) specifies
the heat structure boundaries to connect to the flow channels.


The parameter [!param](/Components/HeatTransferFromHeatStructure3D1Phase/P_hf)
is optional and specifies the heated perimeter $P_\text{heat}$; if unspecified,
this is computed from the cross-sectional area assuming a circular cross
section. To ensure energy conservation, the heated perimeter should be
calculated on the discretized heat structure boundary.


#### Formulation

This component implements a convective heat exchange between the flow channel
and heat structure, with the flow channel receiving the following wall heat
flux:

q_\text{wall} = \mathcal{H}(T_s - T) \eqc

where $\mathcal{H}$ is the heat transfer coefficient, $T_s$ is the heat
structure surface temperature, and $T$ is the fluid temperature. On the heat
structure side, the incoming boundary flux is the opposite of that going into
the flow channel:

q_b = -q_\text{wall} = \mathcal{H}(T - T_s) \eqp



### HeatTransferFromSpecifiedTemperature1Phase

This component is a
[single-phase heat transfer component](thermal_hydraulics/component_groups/heat_transfer_1phase.md)
that specifies a convective heating condition via a provided wall temperature.

#### Usage



The parameter [!param](/Components/HeatTransferFromSpecifiedTemperature1Phase/T_wall)
specifies the wall temperature function $T_\text{wall}$.


#### Formulation


This component computes the wall heat flux as follows:

q_\text{wall} = \mathcal{H}(T_\text{wall} - T) \eqp



### HSBoundaryAmbientConvection

This component is a
[heat structure boundary](thermal_hydraulics/component_groups/heat_structure_boundary.md)
that applies convective heat transfer boundary conditions.

#### Usage


The parameter [!param](/Components/HSBoundaryAmbientConvection/T_ambient) gives the ambient temperature $T_\infty$, and
[!param](/Components/HSBoundaryAmbientConvection/htc_ambient) gives the heat transfer coefficient $\mathcal{H}$.

The parameter [!param](/Components/HSBoundaryAmbientConvection/scale) specifies
the name of a [functor](Functors/index.md) $f$ that can scale the boundary conditions, for
example, a functor material property created with [FinEnhancementFactorFunctorMaterial.md]
for heat transfer enhancement due to fins.


If this component is used with a cylindrical heat structure, the post-processor
*name*`_integral` is added, which gives the heat rate found by integrating this
heat flux over the boundary.

#### Formulation



For convection boundary conditions, the incoming boundary heat flux $q_b$ is computed as

q_b = f \mathcal{H} (T_\infty - T) \eqc

where

- $\mathcal{H}$ is the heat transfer coefficient,
- $T$ is the temperature of the surface,
- $T_\infty$ is the ambient temperature, and
- $f$ is an optional scaling factor.



### HSBoundaryExternalAppConvection

This component is the same as [HSBoundaryAmbientConvection.md] but uses
temperatures and heat transfer coefficients transferred from an external
application into auxiliary variables.

If this component is used with a cylindrical heat structure, the post-processor
*name*`_integral` is added, which gives the heat rate found by integrating this
heat flux over the boundary.





### HSBoundaryExternalAppHeatFlux

This component is a [heat structure boundary](thermal_hydraulics/component_groups/heat_structure_boundary.md)
that is used to apply a heat flux variable transferred from another application
in a Neumann boundary condition.
Currently, this component may only be used with 2D, cylindrical heat structures,
such as [HeatStructureCylindrical.md].

#### Usage

This component creates a heat flux variable with the name given by
[!param](/Components/HSBoundaryExternalAppHeatFlux/heat_flux_name). The other
application is responsible for transferring into this variable, and this name
will need to be supplied to the other application's input file. If
[!param](/Components/HSBoundaryExternalAppHeatFlux/heat_flux_is_monomial) is set
to `true`, then the finite element type of the variable will be `CONSTANT MONOMIAL`;
otherwise, it will be `FIRST LAGRANGE`. The former is recommended whenever the
other application uses a layered-average user object like [NearestPointLayeredSideAverageFunctor.md] to compute the heat flux,
since in each axial division, there is only one value; there is not a value for
each *node*. The latter is recommended whenever some kind of nodal transfer is
used.

The parameter [!param](/Components/HSBoundaryExternalAppHeatFlux/heat_flux_is_inward)
indicates whether the transferred heat flux corresponds to the *inward* direction,
with respect to the heat structure boundary, i.e., if `true`, a *positive* value
indicates heat is moving *into* the heat structure.

This component creates a [Receiver.md] post-processor to receive the discrete
perimeter of the boundary from the other application, with the name given by the parameter
[!param](/Components/HSBoundaryExternalAppHeatFlux/perimeter_ext). This perimeter
is necessary to normalize the heat flux to achieve energy conservation. The
other application is responsible for transferring into this post-processor using
a [MultiAppPostprocessorTransfer.md], or the perimeter may be simply specified as a constant if it is so.

This component creates the post-processor `<heat_structure_boundary_name>_integral`, which gives the
heat rate found by integrating this heat flux over the boundary. This should be used to verify the conservation of the heat flux.

#### Formulation



This incoming boundary flux is computed from the transferred heat flux variable
$q$, the sign $\pm$ determined by [!param](/Components/HSBoundaryExternalAppHeatFlux/heat_flux_is_inward),
the external discrete perimeter $P_\text{ext}$, and the heat structure boundary
perimeter $P$:

q_b = \pm q \frac{P_\text{ext}}{P} \eqp




### HSBoundaryExternalAppTemperature


This component is the same as [HSBoundarySpecifiedTemperature.md] but uses
a temperature transferred from an external application into an auxiliary variable.

The temperature variable is added by this component on the subdomains of the heat structure with a variable type
defined by the [HeatConductionModel.md].

The boundary temperature is imposed weakly on the boundary defined by the
[!param](/Components/HSBoundaryExternalAppTemperature/boundary) parameter
using an [ADMatchedValueBC.md] nodal boundary condition.




### HSBoundaryHeatFlux

This component is a
[heat structure boundary](thermal_hydraulics/component_groups/heat_structure_boundary.md)
that applies a specified heat flux function on the boundary.

#### Usage


The parameter [!param](/Components/HSBoundaryHeatFlux/q) gives the incoming
boundary heat flux function $q$.

The parameter [!param](/Components/HSBoundaryHeatFlux/scale_pp) specifies
the name of a post-processor $f$ that can scale the boundary conditions.


If this component is used with a cylindrical heat structure, the post-processor
*name*`_integral` is added, which gives the heat rate found by integrating this
heat flux over the boundary.

#### Formulation



This incoming boundary flux is the product of the user-specified incoming
boundary flux function $q$ and the optional scaling factor $f$:

q_b = f q \eqp



### HSBoundaryRadiation

This component is a
[heat structure boundary](thermal_hydraulics/component_groups/heat_structure_boundary.md)
that applies radiative heat transfer boundary conditions.

#### Usage


The parameter [!param](/Components/HSBoundaryRadiation/T_ambient) gives the ambient temperature $T_\infty$,
[!param](/Components/HSBoundaryRadiation/emissivity) gives the surface emissivity $\epsilon$, and
[!param](/Components/HSBoundaryRadiation/view_factor) gives the view factor $F$.

The parameter [!param](/Components/HSBoundaryRadiation/scale_pp) specifies
the name of a post-processor $f$ that can scale the boundary conditions.


If this component is used with a cylindrical heat structure, the post-processor
*name*`_integral` is added, which gives the heat rate found by integrating this
heat flux over the boundary.

#### Formulation



For radiation boundary conditions, the incoming boundary heat flux $q_b$ is computed as

\begin{equation}
  q_b = f \sigma \epsilon F (T^4_\infty - T^4) \eqc
\end{equation}
where

- $\sigma$ is the Stefan-Boltzmann constant,
- $\epsilon$ is the emissivity of the surface,
- $F$ is the view factor function,
- $T$ is the temperature of the surface,
- $T_\infty$ is the ambient temperature, and
- $f$ is an optional scaling factor.



### HSBoundarySpecifiedTemperature

This component is a
[heat structure boundary](thermal_hydraulics/component_groups/heat_structure_boundary.md)
that applies Dirichlet boundary conditions.

#### Usage


The parameter [!param](/Components/HSBoundarySpecifiedTemperature/T) specifies
the temperature function $T_b$ to strongly impose on the boundary.


#### Formulation




### HSCoupler2D2DRadiation

This component is used to apply radiative heat transfer between 2D heat structures
with the following physical assumptions and approximations:

- Surfaces are opaque, gray, and diffuse.
- The infinite-length assumption is applied to simplify the formulation such that
  surfaces are only coupled at the same axial location.

This component couples $N_\text{hs}$ heat structure surfaces, with an optional coupling to
an enclosing environment surface. The total number of surfaces in the exchange is denoted by $N$;
without an enclosing enironment surface, $N = N_\text{hs}$ and with an enclosing enironment
surface, $N = N_\text{hs} + 1$.

As derived in [modules/heat_transfer/index.md#gray_diffuse_radiative_exchange],
radiation exchange between opaque, gray, diffuse surfaces is described by the following
equations:

\sum\limits^{N}_{j=1} \left[\delta_{i,j} - (1 - \epsilon_i) F_{i,j}\right] J_j = E_i \,,

where

- $\epsilon_i$ is the emissivity of surface $i$,
- $F_{i,j}$ is the view factor from surface $i$ to surface $j$,
- $J_i$ is the radiosity of surface $i$, and
- $E_i$ is the emittance of surface $i$:

E_i = \epsilon_i \sigma T_i^4 \,,

with $\sigma$ being the Stefan-Boltzmann constant and $T_i$ the temperature of
the surface $i$.

Enclosing surfaces with areas much greater than the other surfaces, such
as the environment, are equivalent to blackbodies:

J_i = E_{b,i} = \sigma T_i^4 \,.

Together, these equations form a linear system:

\mathbf{A} \mathbf{J} = \mathbf{b} \,,

A_{i,j} = \left\{\begin{array}{l l}
  \delta_{i,j} - (1 - \epsilon_i) F_{i,j} & i=1,\ldots,N_\text{hs} \quad j=1,\ldots,N \\
  1 & i = N_\text{hs} + 1 \quad j = N_\text{hs} + 1 \\
  0 & i = N_\text{hs} + 1 \quad j \neq N_\text{hs} + 1 \\
\end{array}\right.

b_i = \left\{\begin{array}{l l}
  E_i & i=1,\ldots,N_\text{hs} \\
  E_{b,i} & i = N_\text{hs} + 1 \\
\end{array}\right.

Solving this system gives each radiosity $i$, which is then used to compute the heat
flux in the outward normal direction, $q_i$:

q_i = \frac{\epsilon_i}{1 - \epsilon_i}\left(\sigma T_i^4 - J_i\right) \qquad i=1,\ldots,N_\text{hs} \,.

By employing the infinite-length assumption, these relations hold at each axial
quadrature point, so this solve is performed for each axial quadrature point.

#### Usage

The following restrictions apply for this component:

- Only cylindrical heat structures such as [HeatStructureCylindrical.md] are supported.
- The axial discretizations of the coupled heat structures must match exactly.
- Exactly one boundary must be provided for each heat structure.

The heat structures are provided via [!param](/Components/HSCoupler2D2DRadiation/heat_structures),
and their boundaries are provided via [!param](/Components/HSCoupler2D2DRadiation/boundaries),
with their emissivities provided via [!param](/Components/HSCoupler2D2DRadiation/emissivities).
If the heat structure surfaces form an enclosure, then [!param](/Components/HSCoupler2D2DRadiation/include_environment)
should be set to `false` and otherwise to `true`, with the environment temperature
set by [!param](/Components/HSCoupler2D2DRadiation/T_environment). The view factors
between all of the surfaces are provided via [!param](/Components/HSCoupler2D2DRadiation/view_factors),
which is provided in a matrix format. For example to give $F_{1,1}=0$, $F_{1,2}=1$,
$F_{2,1}=0.3$, $F_{2,2}=0.7$, the following should be specified:

```
view_factors = '0 1; 0.3 0.7'
```

Each row/column corresponds to the ordering
in the heat-structure-related parameters, with an additional last row/column if
[!param](/Components/HSCoupler2D2DRadiation/include_environment) is `true`.
The sum of each row should equal one:

\sum\limits_j F_{i,j} = 1 \qquad \forall i \,.

Also note that $F_{i,i}=0$ for any *convex* surface $i$, e.g., the outer surface
of a cylinder.

To help with derivation of view factors, use the rule of reciprocity:

A_i F_{i,j} = A_j F_{j,i} \,.




#### Implementation

The implementation strategy for this component is as follows. The component
first builds a mapping between the boundaries using [MeshAlignment2D2D.md],
where each element/face on the first 2D boundary is mapped to one element/face
on each of the other 2D boundaries. Then for each iteration, a [StoreVariableByElemIDSideUserObject.md]
is executed on all of the 2D boundaries to create a map of element IDs to the
temperature values at each quadrature point on that element/face. Then a
[HSCoupler2D2DRadiationUserObject.md] (a side user object) executes on the
primary boundary and uses the `MeshAlignment2D2D`
object to get the coupled 2D boundary elements/faces and the `StoreVariableByElemIDSideUserObject`
to get the corresponding temperature values on the coupled elements. The heat
fluxes are computed and stored by element ID. Finally, [HSCoupler2D2DRadiationRZBC.md] is
used to apply the heat fluxes computed by `HSCoupler2D2DRadiationUserObject` to each
boundary.


### HSCoupler2D3D

This component is used to couple a [HeatStructureCylindrical.md] and a
[HeatStructureFromFile3D.md] via gap conduction, radiation, and convection.

#### Formulation

##### Overview

Heat fluxes are computed at each quadrature point of each face on the 3D heat
structure boundary. These heat fluxes then make contributions to the 2D heat structure side:

q_z = -\frac{1}{A_z} \sum\limits_\theta q_{z,\theta} A_{z,\theta} \,,

where

- $q_z$ is the heat flux on the 2D heat structure boundary at the
  quadrature point at the axial level $z$,
- $q_{z,\theta}$ is the heat flux on the 3D heat structure boundary at
  a quadrature point at the same axial level $z$ and having an azimuthal position
  $\theta$,
- $A_z$ is the area corresponding to the 2D quadrature point:

  A_z = J_z w_z \xi_z \,,

  with $J_z$, $w_z$, and $\xi_z$ respectively being the quadrature Jacobian,
  quadrature weight, and coordinate transformation, and
- $A_{z,\theta}$ is the area corresponding to the 3D quadrature point:

  A_{z,\theta} = J_{z,\theta} w_{z,\theta} \xi_{z,\theta} \,.

This approach guarantees energy conservation of this heat exchange.

The heat flux is composed of three pieces, corresponding to conduction, radiation, and convection:

q_{z,\theta} = q^\text{cond}_{z,\theta} + q^\text{rad}_{z,\theta} + q^\text{conv}_{r,\theta} \,.

Before describing these pieces, we describe some preliminaries.

##### Gap Thickness

The radius of the 2D heat structure boundary, $r_\text{2D}$, is provided directly as a constant
from the corresponding heat structure component. The radius on the 3D heat structure
boundary in general varies with position. However, these radii are not determined
from the actual geometric positions. Rather, a gap thickness function $\delta(T_\text{gap})$
is provided, and this is used to determine the radii on the 3D heat structure
boundary. The gap thickness function is evaluated for each quadrature point on
the 3D heat structure boundary at that point's *gap* temperature $T_\text{gap}$:

\delta_{z,\theta} = \delta(T^\text{gap}_{z,\theta}) \,,

T^\text{gap}_{z,\theta} = \frac{1}{2} \left( T_z + T_{z,\theta} \right) \,,

where

- $T_z$ is the temperature on the 2D heat structure boundary at the
  quadrature point at the axial level $z$, and
- $T_{z,\theta}$ is the temperature on the 3D heat structure boundary at a quadrature
  point at the same axial level $z$ and having an azimuthal position $\theta$.

This gap thickness is then added to the 2D heat structure boundary radius to
get the 3D heat structure boundary radius for a quadrature point:

r_{z,\theta} = r_\text{2D} + \delta_{z,\theta} \,.

There is also a *gap* radius for each quadrature point:

r^\text{gap}_{z,\theta} = \frac{1}{2}(r_\text{2D} + r_{z,\theta}) \,.

##### Conduction Heat Flux

The conduction heat flux is computed using the model described in
[utils/HeatTransferModels.md#cylindrical_gap_conduction_heat_flux];
the conduction heat flux *to* the 3D heat structure side is

q^\text{cond}_{z,\theta} = (T_z - T_{z,\theta}) \frac{k^\text{gap}_{z,\theta}}
{r^\text{gap}_{z,\theta} \ln(r_{z,\theta} / r_\text{2D})} \,,

where the gap thermal conductivity is evaluated at the gap temperature:

k^\text{gap}_{z,\theta} = k_\text{gap}(T^\text{gap}_{z,\theta}) \,.

##### Radiation Heat Flux

The radiation heat flux is computed using the model described in
[utils/HeatTransferModels.md#cylindrical_gap_radiation_heat_flux];
For each quadrature point on the 3D heat structure boundary, view factors are
effectively computed between two surfaces, corresponding to infinitely long,
concentric cylinders at the radii $r_\text{2D}$ and $r_{z,\theta}$ [!citep](incropera2002).
This implies there is no heat transfer between a quadrature point on the 3D heat structure
boundary and any other quadrature point on the 3D heat structure boundary. Putting
this together,

q^\text{rad}_{z,\theta} = \frac{\sigma (T_z^4 - T_{z,\theta}^4)}{\mathcal{R}_{z,\theta}} \,,

\mathcal{R}_{z,\theta} = \frac{1}{\epsilon_z} + \frac{r_\text{2D}}{r_{z,\theta}}
\left( \frac{1 - \epsilon_{z,\theta}}{\epsilon_{z,\theta}} \right) \,,

\epsilon_z = \epsilon_\text{2D}(T_z) \,,

\epsilon_{z,\theta} = \epsilon_\text{3D}(T_{z,\theta}) \,,

where $\sigma$ is the Stefan-Boltzmann constant.

##### Convection Heat Flux

The convection heat flux is computed as

q^\text{conv}_{z,\theta} = h^\text{gap}_{z,\theta} (T_z - T_{z,\theta}) \,,

where the gap heat transfer coefficient is evaluated at the gap temperature:

h^\text{gap}_{z,\theta} = h_\text{gap}(T^\text{gap}_{z,\theta}) \,.

#### Restrictions and Assumptions

- Currently, no contact ($\delta = 0$) is permitted, but this restriction is
  planned to be removed in the future.
- The meshes must be aligned, with each face on the 2D heat structure boundary
  pairing to multiple faces on the 3D heat structure boundary with the exact
  same axial coordinate. This alignment requirement includes quadrature
  point locations on each of these faces.

#### Usage

The parameters [!param](/Components/HSCoupler2D3D/heat_structure_2d) and
[!param](/Components/HSCoupler2D3D/heat_structure_3d) specify the names of the
2D and 3D heat structures, respectively. [!param](/Components/HSCoupler2D3D/boundary_2d)
and [!param](/Components/HSCoupler2D3D/boundary_3d) specify a single boundary
corresponding to each heat structure, at which the heat exchange occurs.

The parameters [!param](/Components/HSCoupler2D3D/emissivity_2d),
[!param](/Components/HSCoupler2D3D/emissivity_3d),
[!param](/Components/HSCoupler2D3D/gap_thickness),
[!param](/Components/HSCoupler2D3D/gap_thermal_conductivity), and
[!param](/Components/HSCoupler2D3D/gap_htc) correspond
to [Functions](Functions/index.md) of the relevant temperature; respectively,
these correspond to

- $\epsilon_\text{2D}(T_\text{2D})$,
- $\epsilon_\text{3D}(T_\text{3D})$,
- $\delta(T_\text{gap})$,
- $k_\text{gap}(T_\text{gap})$, and
- $h_\text{gap}(T_\text{gap})$.

The temperature values are substituted in place of the time coordinate for
these `Function`s.

The radiation component of the heat flux can be disabled by setting
[!param](/Components/HSCoupler2D3D/include_radiation) to `false`, and in this
case the parameters [!param](/Components/HSCoupler2D3D/emissivity_2d) and
[!param](/Components/HSCoupler2D3D/emissivity_3d) should not be specified.

##### MOOSE Configuration

Because a 2D surface is being coupled to a 3D surface, there is potentially
a large number of degrees of freedom from the 3D surface coupled to degrees
of freedom on the 2D surface. This coupling increases with azimuthal refinement
of the 3D surface. This component uses [automatic differentiation](automatic_differentiation/index.md) (AD)
to compute the Jacobian matrix contributions used in Newton's method for solving
the nonlinear system. For performance flexibility, MOOSE has a maximum AD container size,
which currently by default is set to 53, which means that if a term like the
2D boundary heat flux $q_z$ depends on more than 53 degrees of freedom, then
an error occurs. This maximum AD container size can be increased by configuring
MOOSE and recompiling your application. See [automatic_differentiation/index.md#max_container_size]
for more information.

For this component, the required size $N_\text{min}$ can be estimated as follows:

N_\text{min} = 4 n_\theta + 6 \,,

where $n_\theta$ is the maximum number of azimuthal divisions at any axial level.
The factor of 4 is due to the 4 adjacent nodes for a quadrature point on a
quadrilateral face, and the additional 6 is because of the normal coupling for a boundary
node on the 2D side.




#### Implementation

The implementation strategy for this component is as follows. The component
first builds a mapping between the boundaries using [MeshAlignment2D3D.md],
where each element/face on the 2D boundary is mapped to several elements/faces
on the 3D boundary. Then for each iteration, a [StoreVariableByElemIDSideUserObject.md]
is executed on the 2D boundary to create a map of the 2D element IDs to the
temperature values at each quadrature point on that element/face. Then a
[HSCoupler2D3DUserObject.md] executes on the 3D boundary and uses the `MeshAlignment2D3D`
object to get the paired 2D boundary element/face and the `StoreVariableByElemIDSideUserObject`
to get the corresponding temperature values on the paired element. The heat
fluxes are computed and stored by element ID. Finally, [HSCoupler2D3DBC.md] is
used to apply the heat fluxes computed by `HSCoupler2D3DUserObject` to each
boundary (2D and 3D).


### InletDensityVelocity1Phase

This is a single-phase [1-D flow boundary component](component_groups/flow_boundary.md)
in which the density and velocity are specified.

#### Usage

This component must be connected to a [/FlowChannel1Phase.md]. See
[how to connect a flow boundary component](component_groups/flow_boundary.md#usage).

The user specifies the following parameters:

- [!param](/Components/InletDensityVelocity1Phase/rho): the density, and
- [!param](/Components/InletDensityVelocity1Phase/vel): the velocity.

The formulation of this boundary condition assumes flow +entering+ the flow
channel at this boundary.

+Reversible flow+: If +exit+ conditions are encountered,
then the boundary condition is automatically changed to an outlet formulation.
This behavior can be disabled by setting the
[!param](/Components/InletDensityVelocity1Phase/reversible)
parameter to `false`.




#### Formulation

This boundary condition uses a [ghost cell formulation](component_groups/flow_boundary.md#ghostcell_flux),
where the ghost cell solution $\mathbf{U}_\text{ghost}$ is computed from the following
quantities:

- $\rho_\text{ext}$, the provided exterior density,
- $u_\text{ext}$, the provided exterior velocity, and
- $p_i$, the interior pressure.

If the boundary is specified to be reversible
([!param](/Components/InletDensityVelocity1Phase/reversible) set to `true`) and
the flow is +exiting+, the ghost cell is instead computed with the following
quantities:

- $u_\text{ext}$, the provided exterior velocity,
- $\rho_i$, the interior density, and
- $E_i$, the interior specific total energy.

### InletMassFlowRateTemperature1Phase

This is a single-phase [1-D flow boundary component](component_groups/flow_boundary.md)
in which the mass flow rate and temperature are specified. This boundary is
typically used when fluid is expected to flow from an infinitely large tank where the pressure
and temperature are known.

#### Usage

This component must be connected to a [/FlowChannel1Phase.md]. See
[how to connect a flow boundary component](component_groups/flow_boundary.md#usage).

The user specifies the following parameters:

- [!param](/Components/InletMassFlowRateTemperature1Phase/m_dot): the mass flow rate, and
- [!param](/Components/InletMassFlowRateTemperature1Phase/T): the temperature.

The formulation of this boundary condition assumes flow +entering+ the flow
channel at this boundary.

+Reversible flow+: If +exit+ conditions are encountered,
then the boundary condition is automatically changed to an outlet formulation.
This behavior can be disabled by setting the
[!param](/Components/InletMassFlowRateTemperature1Phase/reversible)
parameter to `false`.




#### Formulation

This boundary condition uses a [ghost cell formulation](component_groups/flow_boundary.md#ghostcell_flux),
where the ghost cell solution $\mathbf{U}_\text{ghost}$ is computed from the following
quantities:

- $\dot{m}_\text{ext}$, the provided exterior mass flow rate,
- $T_\text{ext}$, the provided exterior temperature, and
- $p_i$, the interior pressure.

If the boundary is specified to be reversible
([!param](/Components/InletDensityVelocity1Phase/reversible) set to `true`) and
the flow is +exiting+, the ghost cell is instead computed with the following
quantities:

- $\dot{m}_\text{ext}$, the provided exterior mass flow rate,
- $\rho_i$, the interior density, and
- $E_i$, the interior specific total energy.

### InletStagnationEnthalpyMomentum1Phase


This component is a placeholder. It has not been implemented yet. Attempting to use it
will cause an error.




### InletStagnationPressureTemperature1Phase

This is a single-phase [1-D flow boundary component](component_groups/flow_boundary.md)
in which the stagnation pressure and temperature are specified. This boundary is
typically used when fluid is expected to flow from an infinitely large tank where the pressure
and temperature are known.

#### Usage

This component must be connected to a [/FlowChannel1Phase.md]. See
[how to connect a flow boundary component](component_groups/flow_boundary.md#usage).

The user specifies the following parameters:

- [!param](/Components/InletStagnationPressureTemperature1Phase/p0): the stagnation pressure, and
- [!param](/Components/InletStagnationPressureTemperature1Phase/T0): the stagnation temperature.

The formulation of this boundary condition assumes flow +entering+ the flow
channel at this boundary.

+Reversible flow+: If +exit+ conditions are encountered,
then the boundary condition is automatically changed to an outlet formulation.
This behavior can be disabled by setting the
[!param](/Components/InletStagnationPressureTemperature1Phase/reversible)
parameter to `false`.




#### Formulation

This boundary condition uses a [ghost cell formulation](component_groups/flow_boundary.md#ghostcell_flux),
where the ghost cell solution $\mathbf{U}_\text{ghost}$ is computed from the following
quantities:

- $p_{0,\text{ext}}$, the provided exterior stagnation pressure,
- $T_{0,\text{ext}}$, the provided exterior stagnation temperature, and
- $u_i$, the interior velocity.

If the boundary is specified to be reversible
([!param](/Components/InletDensityVelocity1Phase/reversible) set to `true`) and
the flow is +exiting+, the ghost cell is instead computed with the following
quantities:

- $p_{\text{ext}}$, the exterior pressure, assumed to be equal to the provided exterior stagnation pressure $p_{0,\text{ext}}$,
- $\rho_i$, the interior density, and
- $u_i$, the interior velocity.

### InletVelocityTemperature1Phase

This is a single-phase [1-D flow boundary component](component_groups/flow_boundary.md)
in which the velocity and temperature are specified.

#### Usage

This component must be connected to a [/FlowChannel1Phase.md]. See
[how to connect a flow boundary component](component_groups/flow_boundary.md#usage).

The user specifies the following parameters:

- [!param](/Components/InletVelocityTemperature1Phase/vel): the velocity, and
- [!param](/Components/InletVelocityTemperature1Phase/T): the temperature.

The formulation of this boundary condition assumes flow +entering+ the flow
channel at this boundary.

+Reversible flow+: If +exit+ conditions are encountered,
then the boundary condition is automatically changed to an outlet formulation.
This behavior can be disabled by setting the [!param](/Components/InletVelocityTemperature1Phase/reversible)
parameter to `false`.




#### Formulation

This boundary condition uses a [ghost cell formulation](component_groups/flow_boundary.md#ghostcell_flux),
where the ghost cell solution $\mathbf{U}_\text{ghost}$ is computed from the following
quantities:

- $u_{\text{ext}}$, the provided exterior velocity,
- $T_{\text{ext}}$, the provided exterior temperature, and
- $p_i$, the interior pressure.

If the boundary is specified to be reversible
([!param](/Components/InletDensityVelocity1Phase/reversible) set to `true`) and
the flow is +exiting+, the ghost cell is instead computed with the following
quantities:

- $u_{\text{ext}}$, the provided exterior velocity,
- $\rho_i$, the interior density, and
- $E_i$, the interior specific total energy.

### JunctionOneToOne

This component is deprecated. Use JunctionOneToOne1Phase or JunctionOneToOne2Phase instead.

### JunctionOneToOne1Phase

This is a [flow junction](component_groups/flow_junction.md) that connects 2
[FlowChannel1Phase.md] components and assumes that there is no loss of momentum,
even if the connected flow channels are not parallel.

Using this junction between 2 flow channels should be numerically equivalent to having
the 2 connected flow channels merged into 1 large flow channel. This junction is useful
for cases where a separation in a flow channel is required. One particular example is
when a heat structure is connected to a section of an otherwise
single flow channel.

#### Formulation

This junction is treated just like any interface between two elements in the mesh.

#### Usage





### JunctionParallelChannels1Phase

This is a [volume junction](component_groups/volume_junction.md) that
connects an arbitrary number of parallel channels. If modeling elbows or
tees, [VolumeJunction1Phase.md] must be used instead.

This component can be used to model an abrupt flow area change, a plenum that is
divided into several channels, or a plenum that combines several channels into
one. [abrupt_dA] shows the channel configuration appropriate for this junction.

       id=abrupt_dA
       caption= Junction with parallel flow channels.
       style=width:50%;padding:20px;margin-left:auto;margin-right:auto

#### Usage id=usage



Several quantities in the form loss source terms given by [formloss_momentum] and [formloss_energy]
are taken from the first connection in [!param](/Components/JunctionParallelChannels1Phase/connections),
so using different connections in the first entry gives different results.

The parameter [!param](/Components/JunctionParallelChannels1Phase/A_ref) is the reference
cross-sectional area $A_\text{ref}$ used in [formloss_momentum] and [formloss_energy]. If it is
not provided, the cross-sectional area of the first connection in
[!param](/Components/JunctionParallelChannels1Phase/connections) is used.

A form loss coefficient $K$ may be specified using the parameter
[!param](/Components/JunctionParallelChannels1Phase/K).



#### Formulation

The junction equations are derived by integrating the conservation equations
over the junction volume. This formulation assumes that all connected channels
have the same flow direction. For the momentum equation, the term
$\int_{\Gamma_{\text{wall}}}{p\bf{n}}{d\Gamma}$ must be evaluated. For this
junction, it is assumed that there is an abrupt flow area change within the
junction. For the case where the inlet flow area is smaller than the outlet flow
area, the geometry of the junction is shown below.

       style=width:40%;display:block;margin-left:auto;margin-right:auto

It is assumed that the wall pressure is:

- constant and equal to the inlet pressure upstream of the area change.
- constant and equal to the outlet pressure downstream the area change.

Then the term $\int_{\Gamma_{\text{wall}}}{p\bf{n}}{d\Gamma}$
is reduced to the surface that is in red in the above diagram.

If the outlet flow area is +greater+ than the inlet flow area, the wall pressure
 integral projected in the flow direction is:

\int_{\Gamma_{\text{wall}}}{p n_{\text{flow}}}{d\Gamma} = - p_{\text{wall}} A_{\text{wall}} =-p_{\text{out}} \left(A_{\text{out}}-A_{\text{in}}\right)

If the outlet flow area is +smaller+ than the inlet flow area,
the wall pressure integral projected in the flow direction is:

\int_{\Gamma_{\text{wall}}}{p n_{\text{flow}}}{d\Gamma} =  p_{\text{wall}} A_{\text{wall}} =p_{\text{in}} \left(A_{\text{in}}-A_{\text{out}}\right)

##### Form Loss




### Outlet1Phase

This is a single-phase [1-D flow boundary component](component_groups/flow_boundary.md)
in which the pressure is specified. This boundary is typically used when the
boundary is anticipated to be an outlet.

#### Usage

This component must be connected to a [/FlowChannel1Phase.md]. See
[how to connect a flow boundary component](component_groups/flow_boundary.md#usage).

The user specifies the following parameters:

- [!param](/Components/Outlet1Phase/p): the pressure.

The formulation of this boundary condition assumes flow +exiting+ the flow
channel at this boundary.




#### Formulation

This boundary condition uses a [ghost cell formulation](component_groups/flow_boundary.md#ghostcell_flux),
where the ghost cell solution $\mathbf{U}_\text{ghost}$ is computed from the following
quantities:

- $p_{\text{ext}}$, the provided exterior pressure,
- $\rho_i$, the interior density, and
- $u_i$, the interior velocity.

### PrescribedReactorPower

This component is deprecated. Use TotalPower instead.

### Pump1Phase


This component implements a pump model for 1-phase flow that has a volume,
which is directly supplied by the user. This component is heavily based off of
VolumeJunction1Phase. The main difference is that there is only one momentum
conservation equation (the ones for rhovV and rhowV were removed) since the pump
inlet and outlet are aligned in the rhouV direction. Also there are new pump
head terms added to the momentum and energy equations.





### Shaft

This component implements a shaft used to connect components such as a turbine,
pump, and motor. The shaft provides a rigid connection between connected
components, thus there is only one rotational speed shared by all connections.
The shaft receives torque and inertia coupled variables from the components
connected to it. The angular speed of the shaft and connected components is
dictated by the torque-inertia balance,

\begin{equation}
  \sum_{k=1}^{n} I_{k} \frac{d \omega}{dt} = \sum_{k=1}^{n} \tau_{k} \,,
\end{equation}
where

- $\omega$ is the angular speed of the shaft and all connected components,
- $I_{k}$ is the moment of inertia for the $k^{th}$ connection,
- $\tau_{k}$ is the net torque for the $k^{th}$ connection, and
- $n$ is the number of components connected to the shaft.


#### Variables

This component creates a scalar variable for the shaft angular speed $\omega$,
where `<shaft_name>` is the user-given name of the component:

| Variable | Symbol | Description |
| :- | :- | :- |
| `<shaft_name>:omega` | $\omega$ | Shaft angular speed \[rad/s\] |



### ShaftConnectedCompressor1Phase

This component models a compressor that is connected to a [Shaft.md] for the single-phase flow model.
The compressor formulation is based off the model described in [!cite](CompressorR5).
The user supplies performance curves that give the pressure ratio and isentropic
efficiency as functions of shaft speed and mass flow rate. The compressor then
applies a pressure rise and work to the working fluid, according to the current
flow conditions.

#### Usage id=usage



This component must be must be connected to a [Shaft](Shaft.md) component, which
controls the compressor rotational speed. The user must specify which flow
channel boundaries are connected to the compressor with the
[!param](/Components/ShaftConnectedCompressor1Phase/inlet) and
[!param](/Components/ShaftConnectedCompressor1Phase/outlet) parameters.

The user assigns values for several compressor rated conditions:
[!param](/Components/ShaftConnectedCompressor1Phase/omega_rated),
[!param](/Components/ShaftConnectedCompressor1Phase/mdot_rated),
[!param](/Components/ShaftConnectedCompressor1Phase/rho0_rated), and
[!param](/Components/ShaftConnectedCompressor1Phase/c0_rated). These rated
conditions, along with the user-supplied data
[!param](/Components/ShaftConnectedCompressor1Phase/Rp_functions),
[!param](/Components/ShaftConnectedCompressor1Phase/eff_functions),
[!param](/Components/ShaftConnectedCompressor1Phase/speeds), define the
compressor performance model.

The parameter `speeds` is a list of relative corrected speeds $\alpha$ (see
[speed_rel_corr]) in increasing order. The parameters parameters `Rp_functions`
and `eff_functions` define curves for the pressure ratio $r_p$ (see [Rp]) and
isentropic efficiency $\eta$ (see [eff]), respectively, as
[Functions](Functions/index.md) for each entry in `speeds`, where the time value
in the function corresponds to the relative corrected mass flow rate $\nu$ (see
[flow_rel_corr]). Further discussion on these equations and the input data used
in them is found in [#perfdata].

The user inputs values for
[!param](/Components/ShaftConnectedCompressor1Phase/tau_fr_coeff),
[!param](/Components/ShaftConnectedCompressor1Phase/tau_fr_const), and
[!param](/Components/ShaftConnectedCompressor1Phase/speed_cr_fr) that are used
to compute friction torque as defined in [#friction].

The compressor moment of inertia contributes to the total moment of inertia of
the shaft, which represents the resistance to acceleration of the shaft speed.
The user inputs values for
[!param](/Components/ShaftConnectedCompressor1Phase/inertia_coeff),
[!param](/Components/ShaftConnectedCompressor1Phase/inertia_const), and
[!param](/Components/ShaftConnectedCompressor1Phase/speed_cr_I) that are used to
compute the compressor moment of inertia as defined in [#moi].

The parameter [!param](/Components/ShaftConnectedCompressor1Phase/A_ref)
corresponds to the reference area $A_\text{ref}$ (see [momentum]). It
should generally be assigned a value between the inlet area and outlet area.
`A_ref` can act as a means to scale the compressor head and can also be used in
combination with [!param](/Components/ShaftConnectedCompressor1Phase/K) to apply
a pressure drop due to form loss.




#### Formulation

The compressor is modeled as a 0-D volume based on the [VolumeJunction1Phase.md]
component, which has conservation of mass, momentum, and energy equations in the
volume, but with the addition of source terms to the momentum and energy equations:

\ddt{\rho V} = \dot{m}_\text{in} - \dot{m}_\text{out} \eqc

\ddt{\rho u V}
  = \pr{(\rho u^2 + p) A}_\text{in}
  - \pr{(\rho u^2 + p) A}_\text{out}
  + \Delta p_0 A_\text{ref} \eqc

\ddt{\rho E V} = \pr{\dot{m} H}_\text{in} - \pr{\dot{m} H}_\text{out} + \dot{W} \eqc

where

- $\Delta p_0$ is the change in stagnation pressure,
- $A_{\text{ref}}$ is the reference cross-sectional area, and
- $\dot{W}$ is the work rate.

The pressure ratio $r_p$, which is given by user-defined performance data (see
[#perfdata]), is defined as the ratio of the outlet stagnation pressure to the
inlet stagnation pressure:

r_p \equiv \frac{p_{\text{0, out}}} {p_{\text{0, in}}} \eqp

The stagnation pressure change can then be computed as

\Delta p_0 = p_{\text{0, in}} (r_p - 1) \eqp

The isentropic efficiency $\eta$, which is given by user-defined performance
data (see [#perfdata]), is defined as the ratio of the isentropic work rate
$\dot{W}_s$ to the actual work rate $\dot{W}$:

\eta \equiv \frac{\dot{W}_s}{\dot{W}} \eqc

\dot{W}_s = \dot{m} (H_{\text{out},s} - H_\text{in}) \eqc

\dot{W} = \dot{m} (H_\text{out} - H_\text{in}) = \frac{\dot{W}_s}{\eta} \eqp

The connected [Shaft.md] receives a corresponding torque $\tau_\text{compressor}$,
computed using the work rate and shaft speed $\omega$,
and also a friction torque $\tau_\text{friction}$ (discussed in [#friction]):

\tau_\text{shaft,compressor} = \tau_\text{compressor} + \tau_\text{friction} \eqc

\tau_\text{compressor} = -\frac{\dot{W}}{\omega} \eqp

##### Compressor performance data id=perfdata

Users specify performance curves that give the pressure ratio $r_p$ and isentropic
efficiency $\eta$ as functions of the mass flow rate and shaft speed. Specifically,
the mass flow rate used is a quantity normalized by rated conditions, often referred to as the
"relative corrected mass flow rate", given the symbol $\nu$:

\nu \equiv \frac{ (\frac{\dot{m}}{\rho_{\text{0, in}} c_{\text{0, in}}}) }
  { (\frac{\dot{m}}{\rho_{\text{0, in}} c_{\text{0, in}}})_{\text{rated}} } \eqc

where $\rho_0$ and $c_0$ are stagnation density and sound speed, respectively.
Similarly, the shaft speed used is also normalized by rated conditions, often referred to as
the "relative corrected shaft speed", given the symbol $\alpha$:

\alpha \equiv \frac{ (\frac{\omega}{c_{\text{0, in}}}) }
  { (\frac{\omega}{c_{\text{0, in}}})_{\text{rated}} } \eqp

The user provides an ordered list of relative corrected shaft speeds, which
correspond to ordered lists of pressure ratio and isentropic efficiency functions:

\left\{\alpha_1, \alpha_2, \ldots, \alpha_n\right\} \eqc

\left\{r_{p,1}(\nu), r_{p,2}(\nu), \ldots, r_{p,n}(\nu)\right\} \eqc

\left\{\eta_1(\nu), \eta_2(\nu), \ldots, \eta_n(\nu)\right\} \eqc

Linear interpolation and extrapolation is used to get the dependence on $\alpha$
between and outside of the provided $\alpha_i$ values:

r_p(\nu, \alpha) = r_{p,i}(\nu) + \frac{r_{p,i+1}(\nu) - r_{p,i}(\nu)}{\alpha_{i+1} - \alpha_i}(\alpha - \alpha_i) \eqc

\eta(\nu, \alpha) = \eta_i(\nu) + \frac{\eta_{i+1}(\nu) - \eta_i(\nu)}{\alpha_{i+1} - \alpha_i}(\alpha - \alpha_i) \eqp

Lastly, bounds are applied to the pressure ratio, since extrapolation outside of
limited performance data may yield unphysical values.

r_p^- \leq r_p \leq r_p^+ \eqp

##### Friction torque id=friction

Friction torque always resists the direction of motion, so the sign of the
compressor friction torque depends on the sign of the connected shaft speed.
Positive shaft speed results in negative friction torque while negative shaft
speed results in positive friction torque.

The friction torque magnitude, $\tau_{\text{friction}}$, is a function of shaft
speed, $\omega$, and four input parameters. If the ratio of shaft speed to
[!param](/Components/ShaftConnectedCompressor1Phase/omega_rated), $\alpha$, is
less than [!param](/Components/ShaftConnectedCompressor1Phase/speed_cr_fr),
friction torque magnitude equals
[!param](/Components/ShaftConnectedCompressor1Phase/tau_fr_const),

\tau_{\text{friction}} = \tau_{\text{fr,const}},


otherwise, $\tau_{\text{friction}}$ is a function of shaft speed and friction
torque coefficients,
[!param](/Components/ShaftConnectedCompressor1Phase/tau_fr_coeff),

\tau_{\text{friction}} = \tau_{\text{fr,coeff}}[0] + \tau_{\text{fr,coeff}}[1] \mid \alpha \mid
  + \tau_{\text{fr,coeff}}[2] \mid\alpha \mid^{2} + \tau_{\text{fr,coeff}}[3] \mid \alpha \mid^{3}.

##### Moment of inertia id=moi

The compressor moment of inertia, $I_{\text{compressor}}$, is a function of
shaft speed, $\omega$, and four input parameters. If the ratio of shaft speed to
[!param](/Components/ShaftConnectedCompressor1Phase/omega_rated), $\alpha$, is
less than [!param](/Components/ShaftConnectedCompressor1Phase/speed_cr_I),
compressor inertia equals
[!param](/Components/ShaftConnectedCompressor1Phase/inertia_const),

I_{\text{compressor}} = I_{\text{const}},


otherwise, $I_{\text{compressor}}$ is a function of shaft speed and inertia coefficients, [!param](/Components/ShaftConnectedCompressor1Phase/inertia_coeff),

I_{\text{compressor}} = I_{\text{coeff}}[0] + I_{\text{coeff}}[1] \mid \alpha \mid + I_{\text{coeff}}[2] \mid\alpha \mid^{2} + I_{\text{coeff}}[3] \mid \alpha \mid^{3}.

##### Form Loss


#### Output

In addition to the junction variables, this component creates the following post-processors and auxiliary scalar variables:

| Post-processor/variable name | Description |Notation |Unit|
| - | :- | - | -|
| `comp_name:delta_p` | Pressure difference across the compressor component  | $\Delta p_0$ | \[Pa\] |
| `comp_name:dissipation_torque` | Dissipation torque  | - | \[Nm\]
| `comp_name:isentropic_torque` | Isentropic torque  | - | \[Nm\]
| `comp_name:friction_torque` | Friction torque | $\tau_{\text{friction}}$ | \[Nm\]
| `comp_name:moment_of_inertia` | Moment of inertia |  $I_{\text{compressor}}$ | \[kg-m^2\]
| `comp_name:efficiency` | Efficiency  | $\eta$ | \[-\]
| `comp_name:pressure_ratio` | Pressure ratio | $r_p$  | \[-\]
| `comp_name:rel_corrected_flow` | Relative corrected mass flow rate | $\alpha$ | \[-\]
| `comp_name:rel_corrected_speed` | Relative corrected shaft speed | $\nu$ | \[-\]


### ShaftConnectedMotor

This component connects to a [Shaft.md] and applies a torque $\tau$ and moment
of inertia $I$ from user-supplied functions. While this is named as a "motor"
component, its applications are more generic; for example, it can be used to
apply friction or other losses (such as the work applied to a generator) by
applying negative torque.

#### Usage

The parameters [!param](/Components/ShaftConnectedMotor/torque) and
[!param](/Components/ShaftConnectedMotor/inertia) take the names of
[Functions](Functions/index.md). The shaft speed $\omega$ is used in place of
the time variable $t$ in these functions (and the space variables are
discarded); therefore, the user is actually specifying the functions
$\tau(\omega)$ and $I(\omega)$, not $\tau(t,x,y,z)$ and $I(t,x,y,z)$.

If dependence on time is desired, the [ControlLogic/index.md] can be used. To
do this, supply an arbitrary constant value instead of a function name. Then
use a [TimeFunctionComponentControl.md]. See the `motor` component in
[open_brayton_cycle.i](test/tests/problems/brayton_cycle/open_brayton_cycle.i)
for an example.




### ShaftConnectedPump1Phase

The 1-phase shaft-connected pump component is modeled as a volume junction with source terms added to the momentum and energy equations due to the pump's head and torque.

The pump model relies on input parameters, flow conditions, and rotational speed to calculate the pump head, hydraulic torque, friction torque, and moment of inertia. Pump head and hydraulic torque are used in source terms to affect flow conditions coming out of the pump. Net torque (sum of hydraulic and friction torques) and moment of inertia are sent to the connected `Shaft` component and affect the rotational speed.

#### Usage

A `ShaftConnectedPump1Phase` component must be connected to a [Shaft](Shaft.md) component, which controls the pump rotational speed. The user must specify which flow channel boundaries are connected to the pump with the [!param](/Components/ShaftConnectedPump1Phase/inlet) and [!param](/Components/ShaftConnectedPump1Phase/outlet) parameters.

[!param](/Components/ShaftConnectedPump1Phase/A_ref) should generally be assigned a value in between the [!param](/Components/FlowChannel1Phase/A) values of the connected `inlet` or `outlet`. `A_ref` can act as a means to scale the pump head. `A_ref` can also be used in combination with [!param](/Components/ShaftConnectedPump1Phase/K) to apply a pressure drop due to form loss.  The pump volume, [!param](/Components/ShaftConnectedPump1Phase/volume), should be a reasonable estimate of the inlet to outlet fluid volume of the modeled pump.

The user assigns values for several pump rated conditions: [!param](/Components/ShaftConnectedPump1Phase/omega_rated), [!param](/Components/ShaftConnectedPump1Phase/volumetric_rated), [!param](/Components/ShaftConnectedPump1Phase/head_rated), and [!param](/Components/ShaftConnectedPump1Phase/torque_rated). These rated conditions, along with the user-supplied functions [!param](/Components/ShaftConnectedPump1Phase/head) and [!param](/Components/ShaftConnectedPump1Phase/torque_hydraulic), define the pump performance model. The inputs `head` and `torque` should be functions with independent and dependent variables as defined in [#polar]. Pump manufacturers often supply performance data in eight XY sets according to conventional homologous pump variables, as defined in [conventional_curve]. The relationship between the conventional homologous variables ($X$, $Y_{H}$, and $Y_{T}$) and the polar homologous variables ($\theta$, $W_{H}$, and $W_{T}$) is shown in [relationship_head] and [relationship_torque]. Variables used in these equations are defined in [#headntorque].

W_{H} = \frac{h}{\alpha^{2} + \nu^{2}} = \frac{Y_{H}}{1 + X^{2}}

W_{T} = \frac{\beta}{\alpha^{2} + \nu^{2}} = \frac{Y_{T}}{1 + X^{2}}

The friction torque determines the pump efficiency. The user inputs values for [!param](/Components/ShaftConnectedPump1Phase/tau_fr_coeff), [!param](/Components/ShaftConnectedPump1Phase/tau_fr_const), and [!param](/Components/ShaftConnectedPump1Phase/speed_cr_fr) that are used to compute friction torque as defined in [#friction].

The pump moment of inertia affects how the pump accelerates. The user inputs values for [!param](/Components/ShaftConnectedPump1Phase/inertia_coeff), [!param](/Components/ShaftConnectedPump1Phase/inertia_const), and [!param](/Components/ShaftConnectedPump1Phase/speed_cr_I) that are used to compute the pump moment of inertia as defined in [#moi].




#### Formulation

The conservation of mass, momentum, and energy equations for the pump volume are similar to the equations used by [VolumeJunction1Phase](VolumeJunction1Phase.md) but add the pump momentum and energy source terms,

S^{\text{momentum}} = \rho_{\text{in}} \left \| \vec{g} \right \| H A_{\text{ref}} \cdot \hat{n}_{out},

and

S^{\text{energy}} = - \tau_{\text{hydraulic}} \omega,


where

- $\rho_{\text{in}}$ is the density of the fluid at the pump inlet,
- $\left \| \vec{g} \right \|$ is the magnitude of the gravity vector,
- $H$ is the pump head,
- $A_{\text{ref}}$ is the cross-sectional area of the pump,
- $\hat{n}_{out}$ is the orientation of the flow channel connected to the pump outlet,
- $\tau_{\text{hydraulic}}$ is the hydraulic torque, and
- $\omega$ is the shaft speed.

##### Head and hydraulic torque id=headntorque

$H$ and $\tau_{\text{hydraulic}}$, are defined by means of an empirical homologous pump performance model [!cite](CentrifugalPump). Pump performance data must be generated experimentally. The basic parameters that characterize the pump performance are the rotational speed, $\omega$, the volumetric flow rate, $Q$, the head rise, $H$, and the hydraulic torque, $\tau_{\text{hydraulic}}$. Non-dimensional homologous curves which relate experimental data for these basic pump parameters are used to condense the input. The following rated  parameters are used to normalize the pump operation:

| Quantity | Input file parameter |
| - | - |
| $\omega_{R}$ | [!param](/Components/ShaftConnectedPump1Phase/omega_rated) |
| $Q_{R}$ | [!param](/Components/ShaftConnectedPump1Phase/volumetric_rated) |
| $H_{R}$ | [!param](/Components/ShaftConnectedPump1Phase/head_rated) |
| $\tau_{R}$ | [!param](/Components/ShaftConnectedPump1Phase/torque_rated) |
| $\rho_{R}$ | [!param](/Components/ShaftConnectedPump1Phase/density_rated) |

Parameters for the homologous pump curves are defined as:

- speed ratio, $\alpha = \frac{\omega}{\omega_{R}}$,
- flow ratio, $\nu=\frac{Q}{Q_{R}}$,
- head ratio, $h=\frac{H}{H_{R}}$, and
- torque ratio, $\beta =\frac{\tau_{\text{hydraulic}}}{\tau_{R}}$.

The pump performance is first divided into four quadrants, as seen in [mode].

| Non-dimensional Speed/Capacity | Mode Identifier |
| - | - |
| $\alpha >= 0$ and $\nu >= 0$ | Normal (N) |
| $\alpha > 0$ and $\nu < 0$ | Dissipation (D) |
| $\alpha <= 0$ and $\nu <= 0$ | Turbine (T) |
| $\alpha < 0$ and $\nu > 0$ | Reversal (R) |

Then the four quadrants are further divided into the following two ranges:

- A range, $|\nu / \alpha| <= 1$, and
- V range, $|\alpha / \nu| < 1$.

###### Conventional homologous pump data

Pump performance is typically characterized using conventional homologous pump data pairs. The independent ($X$) and dependent ($Y_{H}$, $Y_{T}$) variables for conventional homologous pump curves are defined in [conventional_curve].  This table spans four pump operating modes and two ranges, for a total of eight separate data pairs each for head ($X$, $Y_{H}$) and hydraulic torque ($X$, $Y_{T}$).

| | Independent Variable | Head Dependent Variable | Torque Dependent Variable |
| - | - | - | - |
| A range: | $X = \nu / \alpha$ | $Y_{H} = h / \alpha^{2}$ | $Y_{T} = \beta / \alpha^{2}$ |
| V range: | $X = \alpha / \nu$ | $Y_{H} = h / \nu^{2}$ | $Y_{T} = \beta / \nu^{2}$ |

###### Polar homologous pump data id=polar

A polar homologous representation has been used such that the independent variable is always positive and bounded on $[0, 2\pi]$. The variable transformation allows all octants to be ordered in monotonically-increasing fashion with respect to a single independent variable. The independent ($\theta$) and dependent ($W_{H}$, $W_{T}$) variables for polar homologous pump curves are defined in [polar_curve].

| | Independent Variable | Head Dependent Variable | Torque Dependent Variable |
| - | - | - | - |
| A and V ranges: | $\theta = C + \arctan(\alpha / \nu)$ | $W_{H} = h / (\alpha^{2} +\nu^{2})$ | $W_{T} = \beta / (\alpha^{2} +\nu^{2})$ |

The constant $C$ assumes different values depending upon the mode of pump operation. The homologous octants, under this definition of $\theta$, are arranged in a predictable way on
$[0,2\pi]$ as summarized in [polar_octants].

| Octant Identifier | $C$ Value | Portion of Domain on $[0,2\pi]$ |
| - | - | - |
| VN | $0$ | $[0,\pi/4]$ |
| AN | $0$ | $[\pi/4,\pi/2]$ |
| AD | $\pi$ | $[\pi/2,3\pi/4]$ |
| VD | $\pi$ | $[3\pi/4,\pi]$ |
| VT | $\pi$ | $[\pi,5\pi/4]$ |
| AT | $\pi$ | $[5\pi/4,3\pi/2]$ |
| AR | $2\pi$ | $[3\pi/2,7\pi/4]$ |
| VR | $2\pi$ | $[7\pi/4,2\pi]$ |

The input parameters [!param](/Components/ShaftConnectedPump1Phase/head) and [!param](/Components/ShaftConnectedPump1Phase/torque_hydraulic) are functions which relate the polar dependent variables ($W_{H}$, $W_{T}$) to the independent variables ($\theta$). Actual head $[m]$ and torque $[N-m]$ values are computed using the two equations below.

H = (\alpha^{2} + \nu^{2}) * W_{H} * H_{R}

\tau_{\text{hydraulic}} = (\alpha^{2} + \nu^{2}) * W_{T} * \tau_{R} * \frac{\rho_{\text{in}}}{\rho_{R}}

##### Friction torque id=friction

Friction torque always resists the direction of motion, so the sign of the pump friction torque depends on the sign of the connected shaft speed. Positive shaft speed results in negative friction torque while negative shaft speed results in positive friction torque.

The friction torque magnitude, $\tau_{\text{friction}}$, is a function of shaft speed, $\omega$, and four input parameters. If the ratio of shaft speed to [!param](/Components/ShaftConnectedPump1Phase/omega_rated), $\alpha$, is less than [!param](/Components/ShaftConnectedPump1Phase/speed_cr_fr), friction torque magnitude equals [!param](/Components/ShaftConnectedPump1Phase/tau_fr_const),

\tau_{\text{friction}} = \tau_{fr,const},


otherwise, $\tau_{\text{friction}}$ is a function of shaft speed and friction torque coefficients, [!param](/Components/ShaftConnectedPump1Phase/tau_fr_coeff),

\tau_{\text{friction}} = \tau_{\text{fr,coeff}}[0] + \tau_{\text{fr,coeff}}[1] \mid \alpha \mid + \tau_{\text{fr,coeff}}[2] \mid\alpha \mid^{2} + \tau_{\text{fr,coeff}}[3] \mid \alpha \mid^{3}.



##### Moment of inertia id=moi

The pump moment of inertia, $I_{\text{pump}}$, is a function of shaft speed, $\omega$, and four input parameters. If the ratio of shaft speed to [!param](/Components/ShaftConnectedPump1Phase/omega_rated), $\alpha$, is less than [!param](/Components/ShaftConnectedPump1Phase/speed_cr_I), pump inertia equals [!param](/Components/ShaftConnectedPump1Phase/inertia_const),

I_{\text{pump}} = I_{\text{const}},


otherwise, $I_{\text{pump}}$ is a function of shaft speed and inertia coefficients, [!param](/Components/ShaftConnectedPump1Phase/inertia_coeff),

I_{\text{pump}} = I_{\text{coeff}}[0] + I_{\text{coeff}}[1] \mid \alpha \mid + I_{\text{coeff}}[2] \mid\alpha \mid^{2} + I_{\text{coeff}}[3] \mid \alpha \mid^{3}.



### ShaftConnectedTurbine1Phase

The 1-phase shaft-connected turbine component is modeled as a volume junction
with source terms added to the momentum and energy equations due to the
turbine's torque and pressure drop.

The turbine model relies on input parameters, upstream flow conditions, and
rotational speed to calculate the turbine pressure drop, driving torque,
friction torque, power, and moment of inertia. Turbine pressure drop and net
torque (sum of driving and friction torques) are used in source terms to affect
flow conditions coming out of the turbine. Net torque and moment of inertia are
sent to the connected `Shaft` component and affect the rotational speed.

#### Usage

A `ShaftConnectedTurbine1Phase` component must be connected to a
[Shaft](Shaft.md) component, which controls the turbine rotational speed. The
user must specify which flow channel boundaries are connected to the turbine
with the [!param](/Components/ShaftConnectedTurbine1Phase/inlet) and
[!param](/Components/ShaftConnectedTurbine1Phase/outlet) parameters.

[!param](/Components/ShaftConnectedTurbine1Phase/A_ref) should generally be
assigned a value in between the [!param](/Components/FlowChannel1Phase/A) values
of the connected `inlet` or `outlet`. `A_ref` can act as a means to scale the
turbine pressure drop. `A_ref` can also be used in combination with
[!param](/Components/ShaftConnectedTurbine1Phase/K) to apply an additional
pressure drop due to form loss. The turbine volume,
[!param](/Components/ShaftConnectedTurbine1Phase/volume), should be a reasonable
estimate of the inlet to outlet fluid volume of the modeled turbine.

The user assigns values for the rated turbine speed,
[!param](/Components/ShaftConnectedTurbine1Phase/omega_rated), and the turbine
wheel diameter, [!param](/Components/ShaftConnectedTurbine1Phase/D_wheel).
`D_wheel` can be any physical dimension of the turbine as a measure of the
turbine's size, usually the rotor diameter. These rated values, along with the
user-supplied functions
[!param](/Components/ShaftConnectedTurbine1Phase/head_coefficient) and
[!param](/Components/ShaftConnectedTurbine1Phase/power_coefficient), define the
turbine performance model. Further discussion on these parameters, their
defining equations, and the input data used in them is found in [#data].

The user inputs values for
[!param](/Components/ShaftConnectedTurbine1Phase/tau_fr_coeff),
[!param](/Components/ShaftConnectedTurbine1Phase/tau_fr_const), and
[!param](/Components/ShaftConnectedTurbine1Phase/speed_cr_fr) that are used to
compute friction torque as defined in [#friction].

The turbine moment of inertia affects how the turbine accelerates. The user
inputs values for
[!param](/Components/ShaftConnectedTurbine1Phase/inertia_coeff),
[!param](/Components/ShaftConnectedTurbine1Phase/inertia_const), and
[!param](/Components/ShaftConnectedTurbine1Phase/speed_cr_I) that are used to
compute the turbine moment of inertia as defined in [#moi].




#### Formulation

The conservation of mass, momentum, and energy equations for the turbine volume
are similar to the equations used by
[VolumeJunction1Phase](VolumeJunction1Phase.md) but add the turbine momentum and
energy source terms,

S^{\text{momentum}} = -\Delta p A_{\text{ref}} \cdot \hat{n}_{\text{out}},

and

S^{\text{energy}} = -(\tau_{\text{driving}} + \tau_{\text{friction}}) \omega,

where

- $\Delta p$ is the pressure drop from turbine inlet to outlet,
- $A_{\text{ref}}$ is the cross-sectional area of the turbine,
- $\hat{n}_{out}$ is the orientation of the flow channel connected to the turbine outlet,
- $\tau_{\text{driving}}$ is the driving torque,
- $\tau_{\text{friction}}$ is the friction torque, and
- $\omega$ is the shaft speed.

###### Turbine performance data id=data

The turbine model is based on dimensional analysis using Buckingham's Pi Theorem
[!cite](TurbineLecture). "The Affinity Laws were derived using the dimensional
analysis methods developed by Buckingham to reduce the complex performance map
into distinct dimensionless curves which are more useful output parameters. For
a single-phase gas turbine, the turbine's performance parameters are
non-dimensionalized to evaluate the effects of flow rate (represented by the
flow coefficient, $\Phi$), fluid density ($\rho$), rotational speed ($\omega$)
and turbine wheel diameter ($D_{\text{wheel}}$) on the power input represented
by the head coefficient ($\Psi$) and on useful turbine work represented by the
power output coefficient ($\Pi$) [!cite](TurbineCharacterization)."

Values are obtained by means of an empirical turbine performance map. The
independent variables are flow coefficient ($\Phi$) and shaft speed ($\omega$).
The dependent variables are the head coefficient ($\Psi$) and power coefficient
($\Pi$).

The flow coefficient is computed as

\Phi = \frac{ Q_{\text{in}} } { \omega D_{\text{wheel}}^{3} },

where $Q_{\text{in}}$ is volumetric flow rate at the turbine inlet.

The head coefficient is computed as

\Psi = \frac{ g H } { D_{\text{wheel}}^{2} \omega^{2} }.

The power coefficient is computed as

\Pi = \frac{ \tau_{\text{driving}} } { \rho_{\text{turbine}} \omega^{2}
D_{\text{wheel}}^{5} },

where $\rho_{\text{turbine}}$ is the fluid density within the turbine volume.

Pressure drop ($\Delta p$) and driving torque ($\tau_{\text{driving}}$) are
calculated using the input turbine performance data, dimensional coefficients
defined above, and the two equations below.

\Delta p = \rho_{\text{turbine}} g H

\tau_{\text{driving}} = \Pi \rho_{\text{turbine}} \omega^{2} D_{\text{wheel}}^{5}


##### Friction torque id=friction

Friction torque always resists the direction of motion, so the sign of the
turbine friction torque depends on the sign of the connected shaft speed.
Positive shaft speed results in negative friction torque while negative shaft
speed results in positive friction torque.

The friction torque magnitude, $\tau_{\text{friction}}$, is a function of shaft
speed, $\omega$, and four input parameters. If the ratio of shaft speed to
[!param](/Components/ShaftConnectedTurbine1Phase/omega_rated), $\alpha$, is less
than [!param](/Components/ShaftConnectedTurbine1Phase/speed_cr_fr), friction
torque magnitude equals
[!param](/Components/ShaftConnectedTurbine1Phase/tau_fr_const),

\tau_{\text{friction}} = \tau_{\text{fr,const}},


otherwise, $\tau_{\text{friction}}$ is a function of shaft speed and friction
torque coefficients,
[!param](/Components/ShaftConnectedTurbine1Phase/tau_fr_coeff),

\tau_{\text{friction}} = \tau_{\text{fr,coeff}}[0] + \tau_{\text{fr,coeff}}[1]
\mid \alpha \mid + \tau_{\text{fr,coeff}}[2] \mid\alpha \mid^{2} +
\tau_{\text{fr,coeff}}[3] \mid \alpha \mid^{3}.


##### Moment of inertia id=moi

The turbine moment of inertia, $I_{\text{turbine}}$, is a function of shaft
speed, $\omega$, and four input parameters. If the ratio of shaft speed to
[!param](/Components/ShaftConnectedTurbine1Phase/omega_rated), $\alpha$, is less
than [!param](/Components/ShaftConnectedTurbine1Phase/speed_cr_I), turbine
inertia equals [!param](/Components/ShaftConnectedTurbine1Phase/inertia_const),

I_{\text{turbine}} = I_{\text{const}},

otherwise, $I_{\text{turbine}}$ is a function of shaft speed and inertia
coefficients, [!param](/Components/ShaftConnectedTurbine1Phase/inertia_coeff),

I_{\text{turbine}} = I_{\text{coeff}}[0] + I_{\text{coeff}}[1] \mid \alpha \mid
+ I_{\text{coeff}}[2] \mid\alpha \mid^{2} + I_{\text{coeff}}[3] \mid \alpha
\mid^{3}.



### SimpleTurbine1Phase

The 1-phase simple turbine component is modeled as a volume junction
with source terms added to the momentum and energy equations due to the energy
extraction and pressure drop.


#### Usage

A `SimpleTurbine1Phase` component must be connected to two [FlowChannel1Phase](FlowChannel1Phase.md)
boundaries. The first boundary specified in  [!param](/Components/SimpleTurbine1Phase/connections)
is assumed to be the inlet of the turbine and the second one is the outlet. The connected flow channels
must have the same direction.


The user specifies  the power to be extracted by the turbine using the parameter [!param](/Components/SimpleTurbine1Phase/power).
Power will be extracted if the parameter [!param](/Components/SimpleTurbine1Phase/on)  is set to true.
Both parameters are controllable.




#### Formulation

The conservation of mass, momentum, and energy equations for the turbine volume
are similar to the equations used by
[JunctionParallelChannels1Phase](JunctionParallelChannels1Phase.md) but add the turbine momentum and
energy source terms,

S^{\text{momentum}} = -\Delta p A ~ \hat{n}_{\text{out}},

and

S^{\text{energy}} = - \dot{Q} ,

where

- $\Delta p$ is the turbine pressure drop,
- $A$ is the cross-sectional area of the inlet flow channel,
- $\hat{n}_{out}$ is the orientation of the flow channel connected to the turbine outlet, and
- $\dot{Q}$ is the power extracted.

Assuming that the process inside the turbine is isentropic, the pressure drop is

\Delta p = p_{\text{in}} \left( 1 - \left(1 - \frac{\dot{Q}}{\dot{m}h} \right)^{\frac{\gamma}{\gamma-1}}\right) ,

 where

- $p_{\text{in}}$ is the pressure at the inlet of the turbine,
- $\dot{m}$ is the mass flow rate entering the turbine,
- $h$ in the specific enthalpy at the inlet of the turbine, and
- $\gamma$ is the heat capacity ratio.

### SolidWall

This component is deprecated. Use SolidWall1Phase or SolidWall2Phase instead.

### SolidWall1Phase

This is a single-phase [1-D flow boundary component](component_groups/flow_boundary.md)
corresponding to a solid wall. This component should be used where a flow channel
ends with no inlet or outlet.

#### Usage

This component must be connected to a [/FlowChannel1Phase.md]. See
[how to connect a flow boundary component](component_groups/flow_boundary.md#usage).




#### Formulation

This boundary condition uses a [ghost cell formulation](component_groups/flow_boundary.md#ghostcell_flux),
where the ghost cell solution $\mathbf{U}_\text{ghost}$ is the same as the interior
solution but with opposite velocity:

\begin{equation}
  u_\text{ghost} = -u_i \,.
\end{equation}

This produces a zero velocity in the boundary flux computation.

### SupersonicInlet


This component is deprecated and was not replaced. Do not use it.




### TotalPower

This component is a [power component](thermal_hydraulics/component_groups/power.md)
that specifies the power as a constant value via a user parameter.

#### Usage

The user provides a power value via the parameter
[!param](/Components/TotalPower/power). This parameter may be controlled via the
[ControlLogic system](ControlLogic/index.md).


#### Variables

This component creates the following auxiliary scalar variable, where `<cname>`
is the name of the component:

| Variable | Description |
| :- | :- | :- |
| `<cname>:power` | Power \[W\] |



### VolumeJunction1Phase

This is a [flow junction](component_groups/flow_junction.md) that has a volume
and can connect 2 or more [FlowChannel1Phase.md] components in any orientation.

#### Formulation

See [modules/thermal_hydraulics/theory_manual/vace_model/volume_junction.md] for
the theoretical formulation.

##### Form Losses


#### Usage id=usage


A form loss coefficient $K$ may be specified using the parameter
[!param](/Components/VolumeJunction1Phase/K).
The parameter [!param](/Components/VolumeJunction1Phase/A_ref) is the reference
cross-sectional area $A_\text{ref}$ used in [formloss_momentum] and [formloss_energy]. If it is
not provided, the cross-sectional area of the first connection in
[!param](/Components/VolumeJunction1Phase/connections) is used.

The order of connections in [!param](/Components/VolumeJunction1Phase/connections)
has an impact when using form loss, since some quantities in [formloss_momentum] and [formloss_energy]
are taken from the *first* connection.






## constraints

### MassFreeConstraint


While a penalty formulation may be selected, no penalty parameters can be specified.




## controllogic

### ControlData

ControlData is produced and consumed by [ControlLogic](syntax/ControlLogic/index.md) objects.
The producer usually declares it and sets it value, while the consumer uses the value to make control
decisions during the simulation.

ControlData has an internal container, `ControlDataValue`, which can hold standard C++ types. It is
often used with boolean or `Real` values. It also keeps track of its value at the previous time step.

ControlData is naturally restored during simulation restart and recover.

### CopyPostprocessorValueControl


This is useful for the numerous [ControlLogic](ControlLogic/index.md) objects that rely on [ControlData.md]. Using this
object, we can forward the value of the postprocessor so it can be used by these objects.




### DelayControl

This control takes one input and produces one output value.  The output value is the input value
delayed in time by a time period, $\tau$.  The constant cannot be changed during the simulation.

The formula used for computing the output value is:

\begin{equation}
\mathrm{output}(t) = \mathrm{input}(t - \tau)
\end{equation}




### GetFunctionValueControl


This is useful for the numerous [ControlLogic](syntax/ControlLogic/index.md) objects that rely on [ControlData.md]. Using this
object, we can forward the value of the function so it can be used by these objects.
The function is evaluated at the current simulation time and at the (0,0,0) point.




### ParsedFunctionControl

The ParsedFunctionControl class provides the ability to take a formula as a parameter and evaluate
it as a function.  The quantities that can be used are (a) functions, (b) post-processors, (c) scalar
variables, (d) real-valued [ControlData.md], and (e) bool-valued [ControlData.md].

The functions are evaluated at the current simulation time and at the (0,0,0) point.

[ControlData.md] is only declared by [ControlLogic](syntax/ControlLogic/index.md) in the thermal hydraulics module.
To use the `ParsedFunctionControl` in other applications, do not specify any parameters for the [ControlData.md].




### PIDControl


The reference or target value is set by the [!param](/ControlLogic/PIDControl/set_point) parameter [ControlData.md].
The value of the `output` data is set by:

\text{error} = \text{set point} - \text{value} \\
\text{error integral} = \text{error integral} + K_i * \text{error} * dt \\
\text{output} = K_p * \text{error} + \text{error integral} + K_d * \dfrac{\text{error} - \text{error}_{old}}{dt};

where $K_p$, $K_i$ and $K_d$ are the proportional, integral and derivative constant parameters of the PID logic,
the `set point` and the `value` are user-selected [ControlData.md].

To control a controllable value directly instead of a [ControlData.md], use the [PIDTransientControl.md]




### SetBoolValueControl


[ControlData.md] is only defined by the thermal hydraulics module control logic.

#### Example input syntax

In this example, the `value` parameter of the `AuxKernel` called `aux_kernel`
using the `state` [ControlData.md] of the `threshold_ctrl` ControlLogic.





### SetComponentBoolValueControl


[ControlData.md] is only defined by the thermal hydraulics module control logic.

#### Example input syntax

In this example, the `on` parameter of the `turbine` component
using the `state` [ControlData.md] of the `trip_ctrl` ControlLogic.





### SetComponentRealValueControl


[ControlData.md] is only defined by the thermal hydraulics module control logic.

#### Example input syntax

In this example, the `T0` parameter of the `inlet` component
using the `value` [ControlData.md] of the `T_inlet_fn` ControlLogic.





### SetRealValueControl


[ControlData.md] is only defined by the thermal hydraulics module control logic.

#### Example input syntax

In this example, the `value` parameter of the `AuxKernel` called `aux_kernel`
using the `value` [ControlData.md] of the `T_inlet_fn` ControlLogic.





### SmootherControl

The `SmootherControl` is a controller that smooths the input signal using a moving average technique.

It receives an [!param](/ControlLogic/SmootherControl/input) value  and stores it into a vector of size [!param](/ControlLogic/SmootherControl/n_points). When the vector reaches its maximum capacity (`n_points`), the oldest value (first element) is removed, and the current input is added to the end of the vector.
Then it calculates the average of the values stored in the vector. The value of the `output` data is computed as:

output = \frac{1}{s(v)} \Sigma^{s(v)}_{i=1} v_i\\  \\
s(v) \leq N

where $v$ is the vector containing the input values, $s(v)$ is the current size of the vector, and $N$ is the maximum size of the vector, defined by [!param](/ControlLogic/SmootherControl/n_points).




### TerminateControl


The boolean that determines when to terminate is a [ControlData.md]. This is only used in the
THM control logic to keep track of states of control objects.

The boolean can be examined in the console using a [BoolControlDataValuePostprocessor.md].

Another way to control when to terminate a simulation is to use the [Terminator.md] user object.
The [Terminator.md] works with postprocessors for the criterion instead of a controlled boolean.

#### Example input

In this example, the `TerminateControl` examines the state of the `UnitTripControl`. Once its state is nonzero, it
stop the simulation and prints `Threshold exceeded`.





### THMSolvePostprocessorControl

This component controls the solve based on a postprocessor value.
If the postprocessor indicates zero, no solve is being done.
Otherwise, the solve is performed.

#### Example input syntax

In this example, the problem is only solved between time 0.4 and 0.6s, when the value of
the postprocessor in non-zero.





### TimeFunctionComponentControl


The function is evaluated at the current simulation time and at the (0,0,0) point.




### UnitTripControl


This object defines a control logic boolean `state` that is set to true if the
condition is true, and false if the condition is false.
Using the [!param](/ControlLogic/UnitTripControl/latch) parameter, the `state` can always remain true
after a trip, or go back to false if the expression no longer evaluates to true.

#### Example input syntax

In this example, the value of the postprocessor `a` controls the trip of the ControlLogic `trip_ctrl`,
when its value becomes larger than 0.6.





## dgkernels

### ADNumericalFlux3EqnDGKernel


This DGKernel is the [automatic differentiation](automatic_differentiation/index.md) version
of the [NumericalFlux3EqnDGKernel.md]. Please refer to the non-AD version for additional documentation.




### NumericalFlux3EqnDGKernel


This DG kernel implements the side flux contributions for the 1-D, 1-phase, variable-area
Euler equations. It uses a provided numerical flux user object, which computes the
side flux given the left and right states:
\begin{equation}
  \mathbf{F}_{i+1/2} = \mathcal{F}(\mathbf{U}_i, \mathbf{U}_{i+1}, \mathbf{n}_{i+1/2}) \,,
\end{equation}
where the solution vectors here are the reconstructed solutions from the
adjacent cells.




## fluidproperties

### LinearFluidProperties


All other fluid properties are either constant, such as:

- dynamic viscosity
- thermal conductivity
- specific heat
- speed of sound
- Prandtl number

or dependent on pressure and temperature through density's dependence:

- specific energy
- specific enthalpy




## functions

### CircularAreaHydraulicDiameterFunction






### CosineHumpFunction


This function is a hump generated by one period of a cosine function, with a
user-defined minimum, maximum, location, and width. It is useful for generating
smoothly varying functions, for instance, for initial conditions.





### CosineTransitionFunction


This function uses [WeightedTransition.md] to smoothly transition
between two functions either in time or along a spatial axis.





### CubicTransitionFunction


This function uses [CubicTransition.md] to smoothly transition
between two functions in time or along a spatial axis.




### GeneralizedCircumference


The expression for the generalized circumference is:

circumference = \sqrt{4 \pi A + (\dfrac{dA}{dx})^2}

with $A$ the local area variable, usually defined by the [Components](syntax/Components/index.md).

The function providing the area must have the gradient routine implemented.




### PiecewiseFunction


This function pieces other functions together at user-defined points on the
$t$, $x$, $y$, or $z$ axis.





### TimeRampFunction






## ics

### FunctionNodalAverageIC


This IC is typically used when a variable exists both as an elemental variable
and a nodal variable, where the following relation is desired to hold:
\begin{equation}
 y^{elem}_0 = \frac{1}{N_{node}}\sum\limits_i^{N_{node}} y_0(x_i) ,
\end{equation}
where $y_0(x)$ is the initial condition function,
$y^{elem}_0$ is the computed elemental value,
$x_i$ is the location of node $i$, and
$N_{node}$ is the number of nodes for the element.





### RhoEAFromPressureTemperatureFunctionVelocityIC

This object computes the value of $\rho E A$, the conserved total energy, given pressure and temperature as variables and velocity as a function.

The cross-sectional area variable, [!param](/ICs/SpecificTotalEnthalpyIC/A),
is usually set by the [Component](syntax/Components/index.md).
The function is evaluated at the `start_time` of the simulation, set in the
[Executioner](syntax/Executioner/index.md) or [Executor](syntax/Executors/index.md).

This initial condition is usually added to the `Simulation` by the `FlowModel`, based on the parameters
passed to each [Component](syntax/Components/index.md).




### RhoEAFromPressureTemperatureVelocityIC


The cross-sectional area variable, [!param](/ICs/SpecificTotalEnthalpyIC/A),
is usually set by the [Component](syntax/Components/index.md).

This initial condition is usually added to the `Simulation` by the `FlowModel`, based on the parameters
passed to each [Component](syntax/Components/index.md).




### SpecificInternalEnergyIC


The cross-sectional area variable, [!param](/ICs/SpecificTotalEnthalpyIC/A),
is usually set by the [Component](syntax/Components/index.md).
For single-phase single-fluid thermal-hydraulics, the volume fraction,
[!param](/ICs/SpecificTotalEnthalpyIC/alpha), should remain
equal to one.

This initial condition is usually added to the `Simulation` by the `FlowModel`, based on the parameters
passed to each [Component](syntax/Components/index.md).




### SpecificTotalEnthalpyIC


The cross-sectional area variable, [!param](/ICs/SpecificTotalEnthalpyIC/A),
is usually set by the [Component](syntax/Components/index.md).
For single-phase single-fluid thermal-hydraulics, the volume fraction,
[!param](/ICs/SpecificTotalEnthalpyIC/alpha), should remain
equal to one.

This initial condition is usually added to the `Simulation` by the `FlowModel`, based on the parameters
passed to each [Component](syntax/Components/index.md).




### SpecificVolumeIC


The cross-sectional area variable, [!param](/ICs/SpecificVolumeIC/A), is usually set by the [Component](syntax/Components/index.md).
For single-phase single-fluid thermal-hydraulics, the volume fraction, [!param](/ICs/SpecificVolumeIC/alpha), should remain
equal to one.

This initial condition is usually added to the `Simulation` by the `FlowModel`, depending on the parameters
passed to each [Component](syntax/Components/index.md).




### SumIC


The value of the other variables in the sum is naturally equal to their initial conditions,
as initial conditions are only run once at the beginning of the simulation.




### VariableFunctionProductIC


The value of the variable in the product is naturally equal to its initial condition,
as initial conditions are only run once at the beginning of the simulation.

The function is evaluated at the `start_time` of the simulation, set in the
[Executioner](syntax/Executioner/index.md) or [Executor](syntax/Executors/index.md).




### VariableProductIC


The value of the other variables in the product is naturally equal to their initial conditions,
as initial conditions are only run once at the beginning of the simulation.

This is typically used to set the initial condition for `rho*A`, the specific density and `rho*u*A`, the specific
momentum.

For `rho*A` or `rho*u*A`, this initial condition is usually added to the `Simulation` by the `FlowModel`, depending on the parameters
passed to each [Component](syntax/Components/index.md).




### VectorVelocityIC

This object computes a component of a vector-valued velocity in the direction of a 1-D element from a scalar velocity function.

It computes:
\begin{equation}
u_i = u_d d_i
\end{equation}
where $u$ is the velocity vector, $\mathbf{d}$ is the unit direction vector
of the element where this IC is being applied,
and $u_d$ is a user-provided function for the component of velocity in the direction $\mathbf{d}$.




## interfaces

### DiscreteLineSegmentInterface

This interface is used to define mesh along a line segment in 3D space.
The line segment is defined with a "start" point $\mathbf{x}_\text{start}$,
corresponding to either end, the direction $\mathbf{d}$ to the other end, and
the distance in that direction, $L$. Thus the other end of the line segment is

\mathbf{x}_\text{end} = \mathbf{x}_\text{start} + L \mathbf{d} \eqp

These quantities are defined using the following parameters:

- `position`: the "start" point $\mathbf{x}_\text{start}$,
- `orientation`: the direction $\mathbf{d}$ (which gets automatically normalized), and
- `length`: the length(s) that sum to $L$.

The most basic mesh specification is given by a single value for the parameters
`length` and `n_elems`, which correspond to the length of the
component and number of uniformly-sized elements to use. For example, the
following parameters would specify a total length $L = 50$ m, divided
into 100 elements (each with width 0.5 m):

```
length = 50
n_elems = 100
```

The `length` and `n_elems` parameters can also be supplied with
multiple values. Multiple values correspond to splitting the length into
segments that can have different element sizes. However, within each segment,
the discretization is assumed uniform. The numbers of elements in each segment
are specified with the parameter `n_elems`, with
entries corresponding to the entries in `length`.
For example, the following would also specify a total length $L = 50$
m with 100 total elements, but in this case the first 10 m have 40 elements of
size 0.25 m, whereas the last 40 m have 60 elements of size $0.\bar{6}$ m.

```
length = '10 40'
n_elems = '40 60'
```

## kernels

### ADHeatConductionRZ


The equation term added is the same as for the [HeatConduction.md] kernel,
except that the residual and Jacobian contributions are integrated with cylindrical coordinates, the axis and origin
of which are being defined through input parameters.

This kernel is meant to be used in XY coordinates that are interpreted as general cylindrical coordinates.
With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general RZ-coordinate objects.
Stay tuned!

In THM, most kernels are added automatically by components. This kernel is created by the
[HeatConductionModel.md] which is used in boundary heat structures.




### ADHeatConductionTimeDerivativeRZ


The equation term added is the same as for the [HeatConductionTimeDerivative.md] kernel,
except that the residual and Jacobian contributions are integrated with cylindrical coordinates, the axis and origin
of which are being defined through input parameters.

This kernel is meant to be used in XY coordinates that are interpreted as general cylindrical coordinates.
With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general RZ-coordinate objects.
Stay tuned!

In THM, most kernels are added automatically by components. This kernel is created by the
[HeatConductionModel.md] which is used in boundary heat structures.




### ADHeatStructureHeatSource


The equation term modeled by this kernel is:

\text{scale} \dfrac{\text{power} * \text{power shape}(x,t)}{N_{units} \text{power shape integral}}

where `power` is a scalar variable set using the [!param](/Kernels/ADHeatStructureHeatSource/total_power) parameter,
`power shape` is function set using the [!param](/Kernels/ADHeatStructureHeatSource/power_shape_function) parameter,
`scale` is a controllable scaling factor and $N_{units}$ is the number of heat structures modeled.

This kernel offers several options (scalar, scalar variable, function) to specify the value of the power. To use only one,
set all the others to `1`.

If the function spatial shape is not integrated exactly by the quadrature, specifying the
[!param](/Kernels/ADHeatStructureHeatSource/power_shape_integral_pp) parameter will ensure that
power is conserved.

In THM, most kernels are added automatically by components. This kernel is created by the
[HeatSourceFromTotalPower.md] component which is used to add heat sources to heat structures.




### ADHeatStructureHeatSourceRZ


The equation term added is the same as for the [ADHeatStructureHeatSource.md] kernel,
except that the residual and Jacobian contributions are integrated with cylindrical coordinates, the axis and origin
of which are being defined through input parameters.

This kernel is meant to be used in XY coordinates that are interpreted as general cylindrical coordinates.
With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general RZ-coordinate objects.
Stay tuned!

In THM, most kernels are added automatically by components. This kernel is created by the
[HeatSourceFromTotalPower.md] component which is used to add heat sources to heat structures.




### ADOneD3EqnEnergyGravity


The local work term from the action of gravity in the energy equation strong form is:

\rho u A \vec{g} \cdot \vec{d}

where $\rho$ is the density, $u$ the one-dimensional velocity, $A$ the area of the component, $\vec{g}$ the gravity vector
and $\vec{d}$ the direction of the flow component.

In THM, most kernels are added automatically by components or flow models. This kernel is created by the
[FlowModelSinglePhase.md] to act inside components with single-phase fluid flow.




### ADOneD3EqnEnergyHeatFlux


\begin{equation}
R_i = (\psi_i, -q_{wall} P_{hf}) \quad \forall \psi_i,
\end{equation}
where $\psi_i$ are the test functions and $q_{wall}$ is the local heat flux, and $P_{hf}$ the
heated perimeter.

In THM, most kernels are added automatically by components. This kernel is created by the
[HeatTransferFromHeatStructure1Phase.md] component to model a surface heat flux from the heat structure.




### ADOneD3EqnEnergyHeatFluxFromHeatStructure3D


The heat flux to the flow channel is calculated using the average temperature on
the corresponding layer of the coupled boundary of a 3D heat structure.

The wall heating is expressed as a convection term in the energy equation strong form:

H_w P_{hf} (T_{fluid} - T_{wall})

where $H_w$ is the convective heat transfer coefficient, $P_{hf}$ is the heated perimeter,
$T_{fluid}$ is the single-phase fluid temperature and $T_{wall}$ is the wall temperature.
The wall temperature is computed by a [LayeredAverage.md] user object.

In THM, most kernels are added automatically by components. This kernel is created by the
[ADOneD3EqnEnergyHeatFluxFromHeatStructure3D.md] for modeling the heat flux from the 3D heat structure.





### ADOneD3EqnMomentumAreaGradient


The area gradient term, a form loss, in the momentum equation strong form is:

-P \nabla A \cdot \vec{d}

where $\nabla A$ the area of the component, $P$ the pressure and $\vec{d}$ the direction of the flow
channel.

In THM, most kernels are added automatically by components or flow models. This kernel is created by the
[FlowModelSinglePhase.md] to act inside components with single-phase fluid flow.




### ADOneD3EqnMomentumFormLoss


The form loss term in the momentum equation strong form is:

\dfrac{1}{2} K' \rho u |u| A

where $\rho$ is the density, $A$ the area of the component, $u$ the one-dimensional velocity and
$K'$ a form loss factor.

In THM, most kernels are added automatically by components or flow models. This kernel is created by components
derived from the [FormLoss1PhaseBase.md] component to add form loss terms in components with single-phase fluid flow.




### ADOneD3EqnMomentumFriction


The friction loss term in the momentum equation strong form is:

\dfrac{1}{2 D_h} f_D \rho u |u| A

where $\rho$ is the density, $A$ the area of the component, $u$ the one-dimensional velocity, $D_h$
the hydraulic diameter and $f_D$ the Darcy friction factor.

In THM, most kernels are added automatically by components or flow models. This kernel is created by the
[FlowModelSinglePhase.md] to act inside components with single-phase fluid flow.




### ADOneD3EqnMomentumGravity


The force term from gravity in the momentum equation strong form is:

\rho A \vec{g} \cdot \vec{d}

where $\rho$ is the density, $A$ the area of the component, $\vec{g}$ the gravity vector and $\vec{d}$ the
direction of the flow component.

In THM, most kernels are added automatically by components or flow models. This kernel is created by the
[FlowModelSinglePhase.md] to act inside components with single-phase fluid flow.




### ADOneDEnergyWallHeatFlux


The heat flux contribution to the residual $R_i$ for the weak form is computed as:

\begin{equation}
R_i = (\psi_i, -q_{wall} P_{hf}) \quad \forall \psi_i,
\end{equation}

where $\psi_i$ are the test functions, $q_{wall}$ is the local heat flux, and $P_{hf}$ is the
heated perimeter.

In THM, most kernels are added automatically by components. This kernel is created by the
heat transfer components such as the [HeatTransferFromHeatFlux1Phase.md].




### ADOneDEnergyWallHeating


The wall heating is expressed as a convection term in the energy equation strong form:

H_w P_{hf} (T_{fluid} - T_{wall})

where $H_w$ is the convective heat transfer coefficient, $P_{hf}$ is the heated perimeter,
$T_{fluid}$ is the single-phase fluid temperature and $T_{wall}$ is the wall temperature.
The wall temperature is provided as a field variable.

In THM, most kernels are added automatically by components. This kernel is created by components derived from
`HeatTransferFromTemperature1Phase`, such as [HeatTransferFromSpecifiedTemperature1Phase.md], for modeling
wall heating in a 1-phase flow channel component.




### CoupledForceRZ


`CoupledForceRZ` implements a source term
within a cylindrical domain $\Omega$ (represented in 2D XY) proportional to a coupled variable:

\begin{equation}
\underbrace{-\sigma v}_{\textrm{CoupledForce}} + \sum_{i=1}^n \beta_i = 0 \in \Omega,
\end{equation}

where $\sigma$ is a known scalar coefficient, $v$ is a coupled unknown value, and the second term on
the left hand side corresponds to the strong forms of other kernels.

This kernel is meant to be used in XY coordinates that are interpreted as general cylindrical coordinates.
With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general RZ-coordinate objects.
Stay tuned!

In THM, most kernels are added automatically by components. This kernel is created by the
[HeatSourceFromPowerDensity.md] heat structure in the context of cylindrical geometries.




### OneD3EqnEnergyFlux


This kernel implements an internal and kinetic energy advection term and a pressure work term after an integration by
parts.
The contribution to the residual $R_i$ for the weak form of the energy equation is computed as:

\begin{equation}
R_i = (\nabla \psi_i, -u \vec{d} (\rho * (e + \dfrac{u^2}{2}) + p) A) \quad \forall \psi_i,
\end{equation}
where $\nabla \psi_i$ is the gradient of each test function, $\rho$ is the density,
$e$ the specific internal energy, $u$ the one-dimensional velocity, $p$ the pressure,
$A$ the area of the component and $\vec{d}$ the direction of the flow channel.

In THM, most kernels are added automatically by components. This kernel is no-longer in use.




### OneD3EqnEnergyGravity


The local work term from the action of gravity in the energy equation strong form is:

\rho u A \vec{g} \cdot \vec{d}

where $\rho$ is the density, $u$ the one-dimensional velocity, $A$ the area of the component, $\vec{g}$ the gravity vector
and $\vec{d}$ the direction of the flow component.

In THM, most kernels are added automatically by components. This kernel is no-longer in use, having
been replaced by its [AD](automatic_differentiation/index.md) counterpart [ADOneD3EqnEnergyGravity.md],
designed to provide numerically exact contributions to the Jacobian.




### OneD3EqnEnergyHeatSource


The local heat source in the energy equation strong form is:

q(\vec{x}, t) A

where $q$ is a volumetric heat source, a [Function](syntax/Functions/index.md) of space and time and $A$ is the local area of the component.

If the heat source function spatial shape is not integrated exactly by the quadrature, this will lead
to non-conservation of energy.

In THM, most kernels are added automatically by components. This kernel is created to add volumetric heat sources
by the [HeatSourceVolumetric1Phase.md].




### OneD3EqnMomentumAreaGradient


The area gradient term, a form loss, in the momentum equation strong form is:

-P \nabla A \cdot \vec{d}

where $\nabla A$ the area of the component, $P$ the pressure and $\vec{d}$ the direction of the flow
channel.

In THM, most kernels are added automatically by components. This kernel is no-longer in use, having
been replaced by its [AD](automatic_differentiation/index.md) counterpart [ADOneD3EqnMomentumAreaGradient.md],
designed to provide numerically exact contributions to the Jacobian.




### OneD3EqnMomentumFlux


This kernel implements a momentum advection and pressure gradient flux after an integration by
parts.
The contribution to the residual $R_i$ for the weak form of the momentum equation is computed as:

\begin{equation}
R_i = (\nabla \psi_i, -(\rho u^2 + p) A \vec{d}) \quad \forall \psi_i,
\end{equation}
where $\nabla \psi_i$ is the gradient of each test function, $\rho$ is the density,
$A$ the area of the component, $u$ the one-dimensional velocity, $p$ the pressure, and
$\vec{d}$ the direction of the flow channel.




### OneD3EqnMomentumFormLoss


The form loss term in the momentum equation strong form is:

\dfrac{1}{2} K' \rho u |u| A

where $\rho$ is the density, $A$ the area of the component, $u$ the one-dimensional velocity and
$K'$ a form loss factor.

In THM, most kernels are added automatically by components. This kernel is no-longer in use, having
been replaced by its [AD](automatic_differentiation/index.md) counterpart [ADOneD3EqnMomentumFormLoss.md],
designed to provide numerically exact contributions to the Jacobian.




### OneD3EqnMomentumFriction


The friction loss term in the momentum equation strong form is:

\dfrac{1}{2 D_h} f_D \rho u |u| A

where $\rho$ is the density, $A$ the area of the component, $u$ the one-dimensional velocity, $D_h$
the hydraulic diameter and $f_D$ the Darcy friction factor.

In THM, most kernels are added automatically by components. This kernel is no-longer in use, having
been replaced by its [AD](automatic_differentiation/index.md) counterpart [ADOneD3EqnMomentumFriction.md],
designed to provide numerically exact contributions to the Jacobian.




### OneD3EqnMomentumGravity


The force term from gravity in the momentum equation strong form is:

\rho A \vec{g} \cdot \vec{d}

where $\rho$ is the density, $A$ the area of the component, $\vec{g}$ the gravity vector and $\vec{d}$ the
direction of the flow component.

In THM, most kernels are added automatically by components. This kernel is no-longer in use, having
been replaced by its [AD](automatic_differentiation/index.md) counterpart [ADOneD3EqnMomentumGravity.md],
designed to provide numerically exact contributions to the Jacobian.




### OneDEnergyWallHeatFlux


The heat flux contribution to the residual $R_i$ for the weak form is computed as:

\begin{equation}
R_i = (\psi_i, -q_{wall} P_{hf}) \quad \forall \psi_i,
\end{equation}
where $\psi_i$ are the test functions and $q_{wall}$ is the local heat flux, and $P_{hf}$ the
heated perimeter.

The dependence of the heat flux on any non-linear variable is not considered by this kernel, as such, there
is no contribution to the Jacobian.

In THM, most kernels are added automatically by components. This kernel is no-longer in use, having
been replaced by its [AD](automatic_differentiation/index.md) counterpart [ADOneD3EqnEnergyHeatFlux.md],
designed to provide numerically exact contributions to the Jacobian.




### OneDEnergyWallHeating


The wall heating is expressed as a convection term:

H_w P_{hf} (T_{fluid} - T_{wall})

where $H_w$ is the convective heat transfer coefficient, $P_{hf}$ is the heated perimeter,
$T_{fluid}$ is the fluid temperature and $T_{wall}$ is the wall temperature.

The dependence of the fluid temperature on the conserved variables $\rhoA$, $\rho uA$ and $\rho EA$
is modeled by retrieving the derivatives of the temperature as material properties, and using them to
contribute to the Jacobian.

In THM, most kernels are added automatically by components. This kernel is no-longer in use, having
been replaced by its [AD](automatic_differentiation/index.md) counterpart [ADOneDEnergyWallHeating.md],
designed to provide numerically exact contributions to the Jacobian.




## materials

### ADAverageWallTemperature3EqnMaterial


This is the [automatic differentiation (AD)](automatic_differentiation/index.md) version of the
[AverageWallTemperature3EqnMaterial.md]. Please refer to the regular version for additional documentation.




### ADConstantMaterial


This is the [automatic differentiation (AD)](automatic_differentiation/index.md) version of the [ConstantMaterial.md].
Please refer to the regular version for additional documentation.
Because it uses AD, it does not require setting additional material properties to define the 0 derivatives.




### ADConvectionHeatFluxHSMaterial





### ADConvectionHeatFluxMaterial


The heat flux $q$ is computed as:

q = \kappa h_{wall} (T_{wall} - T)

with $\kappa$ the fluid phase wall contact fraction, $h_{wall}$ the wall heat transfer coefficient,
$T_{wall}$ the wall temperature, and $T$ the fluid temperature.




### ADConvectiveHeatTransferCoefficientMaterial


This is the [automatic differentiation](automatic_differentiation/index.md) version of the [ConvectiveHeatTransferCoefficientMaterial.md].
Please refer to the regular version for additional documentation.




### ADDynamicViscosityMaterial


This is the [automatic differentiation](automatic_differentiation/index.md) version of the [DynamicViscosityMaterial.md].
Please refer to the regular version for additional documentation.
Because it uses AD, it does not require setting additional material properties to define the derivatives.





### ADFluidProperties3EqnMaterial


This is the [automatic differentiation (AD)](automatic_differentiation/index.md) version of the
[FluidProperties3EqnMaterial.md]. Please refer to the regular version for additional documentation.
Because it uses AD, it does not declare additional material properties for the derivatives.




### ADHydraulicDiameterCircularMaterial


This is the [automatic differentiation](automatic_differentiation/index.md) version of the [HydraulicDiameterCircularMaterial.md].
Please refer to the regular version for additional documentation.

This material is added automatically for every `FlowChannel1Phase`-derived component if the hydraulic
diameter has not been set in the parameters of the component.




### ADMaterialFunctionProductMaterial


For a more general capability than simply storing the value of a variable in a
material property, please consider the [ADParsedMaterial](ParsedMaterial.md).




### ADPrandtlNumberMaterial


This is the [automatic differentiation (AD)](automatic_differentiation/index.md) version of the
[PrandtlNumberMaterial.md]. Please refer to the regular version for additional documentation.




### ADRDG3EqnMaterial


This material is responsible for computing the reconstructed solution values.
First, slopes are computed for the primitive variables $\mathbf{W}$,
limited with a slope limiter, if specified, and then used to compute the extrapolated values
at the cell interfaces:
\begin{equation}
  \mathbf{W}_{i+1/2} = \mathbf{W}_i + (x_{i+1/2} - x_i)\Delta\mathbf{W}_i \,.
\end{equation}
Then, the solution values at the interfaces are computed from these values:
\begin{equation}
  \mathbf{U}_{i+1/2} = \mathbf{U}(\mathbf{W}_{i+1/2}) \,.
\end{equation}




### ADReynoldsNumberMaterial


This is the [automatic differentiation](automatic_differentiation/index.md) version of the [ReynoldsNumberMaterial.md].
Please refer to the regular version for additional documentation.
Because it uses AD, it does not require setting additional material properties to define the derivatives.




### ADSolidMaterial


It defines material properties for:

- density
- specific heat
- thermal conductivity

This material is a THM duplicate of the SolidProperties module [ThermalSolidPropertiesMaterial.md].
The major difference is that the material properties are declared with the names expected by consuming
objects in THM.




### ADTemperatureWall3EqnMaterial


This is the [automatic differentiation (AD)](automatic_differentiation/index.md) version of the
[TemperatureWall3EqnMaterial.md]. Please refer to the regular version for additional documentation.




### ADWallFrictionChengMaterial

The material computes the friction factor using the Cheng-Todreas correlation.

Equations (9.105a), (9.105b), (9.109a), and (9.109b), and tables (9.5a) and (9.5b) from [!cite](todreas2021nuclear) are used.

The Cheng-Todreas correlation gives the friction factor for each subchannel type: interior, edge, or corner. The correlation is a function of the Pitch-to-Diameter ratio, $P/D$, for interior channels, or the Wall-to-Diameter ratio, $W/D$, for edge and corner subchannels. [fig-sub] shows the three subchannel types for square and hexagonal rod bundles, where $P$ is the pitch between the fuel rods, $W$ is the distance between the fuel rod centerline and the bundle wall, and $D$ is the rod diameter.

       style=width:95%;float:center;
       caption=Different subchannel types for a square and hexagonal array rod bundles.
       id=fig-sub

The friction factor is given by:

\begin{equation}
      f_{i} = \frac{C_{i}}{(Re_{i})^n},
\end{equation}

where the subscript $i$ indicates the subchannel type, and the constant $n$ is equal to 1 for laminar flows and 0.18 for turbulent flows. The Reynolds number is calculated as

\begin{equation}
  Re_i = \frac{\rho v D_{h,i}}{\mu},
\end{equation}

where the hydraulic diameter will be a function of the flow area and the wetted perimeter for each subchannel type. The friction factor constant $C_i$ can be obtained from:

\begin{equation}
      C_i = \begin{cases}
      a + b_1\left(\frac{P}{D} - 1\right) + b_2\left(\frac{P}{D} - 1\right)^2 & \text{for interior subchannels}\\
      \\
      a + b_1\left(\frac{W}{D} - 1\right) + b_2\left(\frac{W}{D} - 1\right)^2 & \text{for edge or corner subchannels}\\
    \end{cases}
\end{equation}

The values for the constants $a$, $b_1$, and $b_2$ are given in tables (9.5a) and (9.5b) from [!cite](todreas2021nuclear).




### ADWallFrictionChurchillMaterial


This is the [automatic differentiation (AD)](automatic_differentiation/index.md) version of the [WallFrictionChurchillMaterial.md].
Please refer to the regular version for additional documentation.
Because it uses AD, it does not declare additional material properties for the derivatives.




### ADWallFrictionFunctionMaterial


This is the [automatic differentiation (AD)](automatic_differentiation/index.md) version of the
[WallFrictionFunctionMaterial.md]. Please refer to the regular version for additional documentation.
Because it uses AD, it does not declare additional material properties for the derivatives.




### ADWallHeatTransferCoefficient3EqnDittusBoelterMaterial


This is the [automatic differentiation (AD)](automatic_differentiation/index.md) version of the
[WallHeatTransferCoefficient3EqnDittusBoelterMaterial.md].
Please refer to the regular version for additional documentation.
Because it uses AD, it does not declare additional material properties for the derivatives.




### ADWallHeatTransferCoefficientGnielinskiMaterial

The material computes the convective heat transfer coefficient using the Gnielinski correlation. Equations (9.93) and (10.96) from [!cite](todreas2021nuclear) are used.

The Nusselt number is calculated as:

\begin{equation}
  \text{Nu} = \frac{(\text{f}/8)(\text{Re}-1000)\text{Pr}}{1+12.7\sqrt{(\text{f}/8)}\left(\text{Pr}^{2/3}-1\right)}
\end{equation}

with friction factor, f, given by:

\begin{equation}
  \text{f} = \frac{1}{\left(1.82\text{log}_{10}(\text{Re}) - 1.64\right)^2}
\end{equation}

The Reynolds, Re, and Prandtl, Pr, numbers are:

\begin{equation}
  \text{Re} = \frac{\rho v D_h}{\mu},\text{ and } \text{Pr} = \frac{c_p \mu}{k}
\end{equation}

where $c_p$ is the heat capacity, $\rho$ is the density, $\mu$ is the viscosity, $k$ is the fluid thermal conductivity, $v$ is the flow velocity, and $D_h$ is the hydraulic diameter. Gnielinski's correlation is valid for $2300\leq\text{Re}\leq 5 \times 10^{6}$, and for $0.5<\text{Pr}<200$ for 6% accuracy, or $200<\text{Pr}<2000$ for 10% accuracy.

The heat transfer coefficient, h, will be given by:

\begin{equation}
  h = \frac{\text{Nu}k}{D_h}
\end{equation}




### ADWallHeatTransferCoefficientKazimiMaterial

The material computes the convective heat transfer coefficient for liquid sodium in a rod bundle using the Kazimi and Carelli correlation. Equation (10.129) from [!cite](todreas2021nuclear) is used.

The Nusselt number is calculated as:

\begin{equation}
  \text{Nu} = 4.0 + 0.33\left(\frac{\text{P}}{\text{D}}\right)^{3.8}\left(\frac{\text{Pe}}{100}\right)^{0.86} + 0.16\left(\frac{\text{P}}{\text{D}}\right)^{5.0}
\end{equation}

with Pe given by

\begin{equation}
  \text{Pe} = \text{RePr} = \frac{{c_p}\rho D_h}{\mu}
\end{equation}

where P/D is the pitch-to-diameter ratio, $c_p$ is the heat capacity, $\rho$ is the density, $\mu$ is the viscosity, and $D_h$ is the hydraulic diameter.

The Kazimi and Carelli correlation is valid for $1.1\leq \text{P/D} \leq 1.4$ and $10\leq \text{Pe} \leq 5000$. The convective heat transfer coefficient, $h$, is calculated as:

\begin{equation}
  h = \frac{\text{Nu}k}{D_h}
\end{equation}

where $k$ is the fluid thermal conductivity.




### ADWallHeatTransferCoefficientLyonMaterial

The material computes the convective heat transfer coefficient for liquid sodium in a circular tube
with constant heat flux along and around the tube using the Lyon correlation. Equation (10.126a) from [!cite](todreas2021nuclear) is used.

The Nusselt number is calculated as:

\begin{equation}
  \text{Nu} = 7 + 0.025\text{Pe}^{0.8}
\end{equation}

with Pe given by

\begin{equation}
  \text{Pe} = \text{RePr} = \frac{{c_p}\rho D_h}{\mu}
\end{equation}

where $c_p$ is the heat capacity, $\rho$ is the density, $\mu$ is the viscosity, and $D_h$ is the hydraulic diameter. The convective heat transfer coefficient, $h$, is calculated as:

\begin{equation}
  h = \frac{\text{Nu}k}{D_h}
\end{equation}

where $k$ is the fluid thermal conductivity.




### ADWallHeatTransferCoefficientMikityukMaterial

The material computes the convective heat transfer coefficient for liquid sodium in a rod bundle using the Mikityuk correlation.

Equation (10.133) from [!cite](todreas2021nuclear) is used.

The Nusselt number is calculated as:

\begin{equation}
  \text{Nu} = 0.047 \left[ 1 - exp\left(\frac{\text{P}}{\text{D}} -1 \right)\right](\text{Pe}^{0.77} + 250)
\end{equation}

with Pe given by

\begin{equation}
  \text{Pe} = \text{RePr} = \frac{{c_p}\rho D_h}{\mu}
\end{equation}

where P/D is the pitch-to-diameter ratio, $c_p$ is the heat capacity, $\rho$ is the density, $\mu$ is the viscosity, and $D_h$ is the hydraulic diameter.

The Mikityuk correlation is valid for $1.1\leq \text{P/D} \leq 1.5$ and $30\leq \text{Pe} \leq 5000$. The convective heat transfer coefficient, $h$, is calculated as:

\begin{equation}
  h = \frac{\text{Nu}k}{D_h}
\end{equation}

where $k$ is the fluid thermal conductivity.




### ADWallHeatTransferCoefficientSchadMaterial

The material computes the convective heat transfer coefficient for liquid sodium in a rod bundle using the Schad-modified correlation.

Equation (10.130) from [!cite](todreas2021nuclear) is used.

The Nusselt number is calculated as:

\begin{equation}
  \text{Nu} = \begin{cases}
      \left[-16.15 + 24.96\left(\frac{\text{P}}{\text{D}}\right) - 8.55\left(\frac{\text{P}}{\text{D}}\right)^2 \right]\text{Pe}^{0.3} & \text{if $150 \leq \text{Pe} \leq 1000$}\\
      \\
      4.496 \left[-16.15 + 24.96\left(\frac{\text{P}}{\text{D}}\right) - 8.55\left(\frac{\text{P}}{\text{D}}\right)^2 \right] & \text{if $\text{Pe}<150$}\\
    \end{cases}
\end{equation}

with Pe given by

\begin{equation}
  \text{Pe} = \text{RePr} = \frac{{c_p}\rho D_h}{\mu}
\end{equation}

where P/D is the pitch-to-diameter ratio, $c_p$ is the heat capacity, $\rho$ is the density, $\mu$ is the viscosity, and $D_h$ is the hydraulic diameter.

The Schad correlation is valid for $1.1\leq \text{P/D} \leq 1.5$. The convective heat transfer coefficient, $h$, is calculated as:

\begin{equation}
  h = \frac{\text{Nu}k}{D_h}
\end{equation}

where $k$ is the fluid thermal conductivity.




### ADWallHeatTransferCoefficientWeismanMaterial

The material computes the convective heat transfer coefficient for water in a rod bundle using the Weisman correlation.

Equations (10.92b), (10.104a), and (10.104b)  from [!cite](todreas2021nuclear) are used.

The Nusselt number is calculated as:

\begin{equation}
  \text{Nu} = \begin{cases}
      0.023(\text{Re}^{0.8} \text{Pr}^n)\left[1.826 \left(\frac{\text{P}}{\text{D}}\right) - 1.0430 \right] & \text{for a square array rod bundle}\\
      \\
      0.023(\text{Re}^{0.8} \text{Pr}^n)\left[1.130 \left(\frac{\text{P}}{\text{D}}\right) - 0.2609 \right] & \text{for a triangular array rod bundle}\\
    \end{cases}
\end{equation}

with the Reynolds, Re, and Prandtl, Pr, numbers given by:

\begin{equation}
  \text{Re} = \frac{\rho v D_h}{\mu},\text{ and } \text{Pr} = \frac{c_p \mu}{k}
\end{equation}

where P/D is the pitch-to-diameter ratio, $c_p$ is the heat capacity, $\rho$ is the density, $\mu$ is the viscosity, $k$ is the fluid thermal conductivity, and $D_h$ is the hydraulic diameter. The constant $n$ is equal to $0.4$ for heating problems, and $0.3$ for cooling problems.

Weisman's correlation is valid for $0.7<\text{Pr}<100$ and $\text{Re}>10000$ for both bundle configurations. For a square array rod bundle, the Weisman correlation is valid for $1.1\leq \text{P/D} \leq 1.3$, while for a triangular array rod bundle it is valid for $1.1\leq \text{P/D} \leq 1.5$.


\begin{equation}
  h = \frac{\text{Nu}k}{D_h}
\end{equation}




### ADWallHeatTransferCoefficientWolfMcCarthyMaterial

The material computes the convective heat transfer coefficient using the Wolf-McCarthy correlation.
Equation (25) from [!cite](wolf_mccarthy1960)) is used. Note that in the equation of the report, $T_{wall}$ and
$T_{fluid}$ are inverted. This is believed to be a typo as it is not consistent with the rest of the report.

The Nusselt number is calculated as:

\begin{equation}
  Nu= 0.025 Re^{0.8} Pr^{0.4} \left(\frac{T_{wall}}{T_{fluid}}\right)^{-0.55}
\end{equation}




### ADWallHTCGnielinskiAnnularMaterial

The material computes the convective heat transfer coefficient using the Gnielinski correlation
for turbulent flow in annular ducts [!citep](gnielinski2010).

The Nusselt number is calculated as follows:

\text{Nu} = \frac{(f_\text{ann}/8) \text{Re} \text{Pr}}{k_1 + 12.7\sqrt{f_\text{ann}/8}(\text{Pr}^{2/3} - 1)}
  \left[1 + \left(\frac{D_h}{L}\right)^{2/3}\right] F_\text{ann} K \,,

k_1 = 1.07 + \frac{900}{\text{Re}} - \frac{0.63}{1 + 10\text{Pr}} \,,

f_\text{ann} = (1.8 \log_{10}\text{Re}^* - 1.5)^{-2} \,,

\text{Re}^* = \text{Re} \frac{(1 + a^2)\ln a + (1 - a^2)}{(1 - a)^2 \ln a} \,,

K = \left\{\begin{array}{l l}
  \left(\frac{T}{T_w}\right)^n & \text{Fluid is gas} \\
  \left(\frac{\text{Pr}}{\text{Pr}_w}\right)^{0.11} & \text{Fluid is liquid}
  \end{array}\right.  \,,

F_\text{ann} = \left\{\begin{array}{l l}
  0.75 a^{-0.17} & \text{Heat transfer at inner wall} \\
  0.9 - 0.15 a^{0.6} & \text{Heat transfer at outer wall}
  \end{array}\right. \,,

D_h = D_o - D_i \,,

a = \frac{D_i}{D_o} \,,

where:

- $\text{Re}$ is the Reynolds number,
- $\text{Pr}$ is the Prandtl number,
- $\text{Pr}_w$ is the Prandtl number obtained by evaluating properties at the wall temperature,
- $L$ is the channel length,
- $T$ is the fluid temperature,
- $T_w$ is the wall temperature, and
- $n$ is the gas exponent, which varies by gas and situation.

Lastly, the heat transfer coefficient is calculated as

h = \frac{\text{Nu} k}{D_h} \,.




### ADWeightedAverageMaterial


This is the [automatic differentiation (AD)](automatic_differentiation/index.md) version of the [WeightedAverageMaterial.md].
Please refer to the regular version for additional documentation.




### AverageWallTemperature3EqnMaterial


This material enables defining a wall temperature with multiple heat sources and/or heat transfer coefficient
definitions.

T_w = T_{fluid} + \dfrac{\sum_i (T_{\text{wall source i}} - T_{fluid} h_{\text{source i}} P_{\text{source i}}}{h_{average}P_{\text{heated sources}}}

with $T_w$ the average wall temperature, $T_{fluid}$ the fluid temperature, $T_{\text{wall source i}}$ the
wall temperature of a heat source, $h_{\text{source i}}$ the heat transfer coefficient associated with the wall
for that heat source, $P_{\text{source i}}$ the heated perimeter for that heat source, $h_{average}$
the average heat transfer coefficient
and $P_{\text{heated sources}}$ the total heated perimeter for all source.

For a zero heat transfer coefficient (abnormal situation), the average wall temperature instead falls back to:

T_w = \dfrac{\sum_i T_{\text{wall source i}} P_{\text{source i}}}{P_{\text{heated sources}}}




### ConstantMaterial


The ConstantMaterial is part of the THM module. The [GenericConstantMaterial.md] is available in the framework.
The equivalent syntax will define `d<prop_name>_d<variable_name>` in the [!param](/Materials/GenericConstantMaterial/prop_names)
parameter with `0` as the [!param](/Materials/GenericConstantMaterial/prop_values).




### ConvectiveHeatTransferCoefficientMaterial


The heat transfer coefficient $h$ is simply derived from the definition of the Nusselt number $Nu$:

h = \dfrac{Nu k}{D_h}

with $k$ the thermal conductivity and $D_h$ the hydraulic diameter.




### CoupledVariableValueMaterial


The value of the material property, named using the
[!param](/Materials/CoupledVariableValueMaterial/prop_name) parameter, is then simply:

p = v

at every quadrature point, with $p$ the material property and $v$ the field variable.

The AD version of this object is the `ADCoupledVariableValueMaterial`.

For a more general capability than simply storing the value of a variable in a
material property, please consider the [ParsedMaterial.md].




### DirectionMaterial


This material declares the "direction" material property.

This material is added automatically for every `FlowChannelBase` derived component, which includes most
flow components.

#### Example input syntax

In this example, the `DirectionMaterial` is used to compute the direction of the elements,
and the "direction" is passed as a parameter to the `energy_flux` kernel.





### DynamicViscosityMaterial


This material also defines material properties for the derivatives of dynamic viscosity with regards to:

- $alpha rho A$
- $alpha rho u A$
- $alpha rho E A$
- $beta$ if the [!param](/Materials/DynamicViscosityMaterial/beta) parameter is set by the user





### FluidProperties3EqnMaterial


Both fluid properties and several physical quantities are defined as material
properties.
The material properties defined (declared and computed) are:

- density $\rho$
- specific volume $v$
- 1D velocity $u$
- specific internal energy $e$
- pressure $p$
- temperature $T$
- specific enthalpy $h$
- specific total enthalpy $H$
- speed of sound $c$
- specific isobaric heat capacity $c_p$
- specific isochoric heat capacity $c_v$
- thermal conductivity $k$

Additionally, several derivative of material properties with regards to the conserved variables;
the conserved density $\rho A$, the conserved momentum $\rho uA$ and the conserved total energy
$\rho E A$ are defined:

- $\dfrac{d\rho}{d\rho A}$
- $\dfrac{dv}{d\rho A}$
- $\dfrac{du}{d\rho A}$
- $\dfrac{du}{d\rho u A}$
- $\dfrac{de}{d\rho A}$
- $\dfrac{de}{d\rho u A}$
- $\dfrac{de}{d\rho E A}$
- $\dfrac{dp}{d\rho A}$
- $\dfrac{dp}{d\rho u A}$
- $\dfrac{dp}{d\rho E A}$
- $\dfrac{dT}{d\rho A}$
- $\dfrac{dT}{d\rho u A}$
- $\dfrac{dT}{d\rho E A}$
- $\dfrac{dh}{d\rho A}$
- $\dfrac{dh}{d\rho u A}$
- $\dfrac{dh}{d\rho E A}$
- $\dfrac{dH}{d\rho A}$
- $\dfrac{dH}{d\rho u A}$
- $\dfrac{dH}{d\rho E A}$




### HydraulicDiameterCircularMaterial


Based on an equivalence with a circle, the hydraulic diameter $D_h$ is defined from the area $A$ as:

D_h = \sqrt{\dfrac{4 A}{\pi}}




### MeshAlignmentVariableTransferMaterial

This material is used to create an AD material property for a variable from a
coupled subdomain/boundary via [MeshAlignment.md].

It currently assumes:

- The variable is from the nonlinear system (is a solution variable).
- The variable uses 1st-order Lagrange finite elements.




### PrandtlNumberMaterial


The Prandtl number $Pr$ is computed as:

Pr = \dfrac{c_p \mu}{k}

with $c_p$ the specific isobaric heat capacity, $\mu$ the dynamic viscosity, and $k$ the thermal
conductivity.




### RDG3EqnMaterial


This material is responsible for computing the reconstructed solution values.
First, slopes are computed for the primitive variables $\mathbf{W}$,
limited with a slope limiter, if specified, and then used to compute the extrapolated values
at the cell interfaces:
\begin{equation}
  \mathbf{W}_{i+1/2} = \mathbf{W}_i + (x_{i+1/2} - x_i)\Delta\mathbf{W}_i \,.
\end{equation}
Then, the solution values at the interfaces are computed from these values:
\begin{equation}
  \mathbf{U}_{i+1/2} = \mathbf{U}(\mathbf{W}_{i+1/2}) \,.
\end{equation}




### ReynoldsNumberMaterial


The Reynolds number $Re$ is computed as:

Re = \dfrac{\rho u D_h}{\mu}

with $\rho$ the fluid phase density, $u$ the velocity of the phase, $D_h$ the hydraulic diameter
and $\mu$ the dynamic viscosity.

This material also defines material properties for the derivatives of the Reynolds number with regards to:

- $\alpha rho A$
- $\alpha rho u A$
- $\alpha rho E A$
- $beta$ if the [!param](/Materials/ReynoldsNumberMaterial/beta) parameter is set by the user




### TemperatureWall3EqnMaterial


The wall temperature $T_{wall}$ is computed as:

T_{wall} = T_{fluid} + \dfrac{q}{h}

with $T_{fluid}$ the fluid temperature, $q$ the local heat flux and $h$ the wall heat transfer coefficient.




### WallFrictionChurchillMaterial


The Churchill friction factor material is computed with the following equations:

First the Reynold number is computed, then limited to a minimum value of 10.

\tilde{Re} = max(Re, 10.0)

Then two intermediate quantities are computed as:

a = \left(2.457 \log\left(\dfrac{1.0}{(7.0 / \tilde{Re})^{0.9}} + 0.27 \dfrac{roughness}{D_h}\right)\right)^{16}

equation
b = \dfrac{3.753e4}{\tilde{Re}}^{16}

with $D_h$ the hydraulic diameter and the roughness of the pipe being a user input.

Finally the Darcy friction factor $D_C$ for the Churchill model is computed as:

D_C = 8.0 \left( (8.0 / \tilde{Re})^{12} + \dfrac{1.0}{ (a + b)^{1.5}} \right)^{\dfrac{1.0}{12.0}}

This material also defines material properties for the derivatives of the friction factor with regards to:

- $\alpha \rho A$
- $\alpha \rho u A$
- $\alpha \rho E A$




### WallFrictionFunctionMaterial


The Darcy friction factor $f_D$ is directly computed from the spatial and temporal value of the user-input function $f$:

f_D = f(x,y,z,t)

with $x,y,z$ the spatial coordinates and $t$ the current simulation time.
As the function is not supposed to (and should not) depend on any variable,
this material also defines +zero+ material properties for the derivatives of the friction factor with regards to:

- $\alpha \rho A$
- $\alpha \rho u A$
- $\alpha \rho E A$
- $\beta$ if the [!param](/Materials/WallFrictionFunctionMaterial/beta) parameter is set by the user




### WallHeatTransferCoefficient3EqnDittusBoelterMaterial


The Dittus-Boelter heat transfer coefficient $h$ is computed as:

h = \dfrac{Nu k}{D_h}

with $D_h$ the local hydraulic diameter, $k$ the thermal conductivity and $Nu$ the Nusselt number.
The Nusselt number in this correlation is:

Nu = 0.023 Re^{\dfrac{4}{5}} Pr^n;

with $n$ = 0.4 if the fluid temperature is lower than the wall temperature and 0.3 otherwise,
$Re$ the Reynolds number and $Pr$ the Prandtl number.




### WeightedAverageMaterial


The output material property $p$ is equal to:

p = \dfrac{\sum_i v_i m_i}{\sum_i v_i}

where $v_i$ are the variables passed in the [!param](/Materials/WeightedAverageMaterial/weights) parameter and
$m_i$ are the material properties passed in the [!param](/Materials/WeightedAverageMaterial/values) parameter.




## outputs

### ParaviewComponentAnnotationMap

Use this outputter to produce an annotated color map for paraview (works with version 5.8+)

#### Usage

Add the following block into the `[Outputs]` block in your input file:

```
[map]
  type = ParaviewComponentAnnotationMap
[]
```

This will produce a file named `<input_file>_map.json`.

Import this file into paraview via the +Color Map Editor+ window for the `vtkBlockColors` variable.
You should see a component name associated with each color. See example below:

       id=paraview-annotated-color-map
       style=width:80%;margin-right:auto;margin-left:auto;
       caption=Example of annotated color map for component blocks




## postprocessors

### ADElementIntegralMaterialPropertyRZ

This post-processor integrates a material property over a 2D RZ domain. This
class derives from [ADElementIntegralMaterialProperty](ElementIntegralMaterialProperty.md)
and [RZSymmetry.md] and multiplies `ADElementIntegralMaterialProperty::computeQpIntegral()`
by the local circumference to achieve the desired RZ integral.




### ADFlowBoundaryFlux1Phase


This object can be used to get the flux for either of the mass, momentum and energy equations.
The flux is computed by an AD boundary flux user object.
The boundary user object is retrieved using the boundary name specified in the
[!param](/Postprocessors/ADFlowBoundaryFlux1Phase/boundary) parameter.




### ADFlowJunctionFlux1Phase

This post-processor is used to query an entry in the flux vector for a 1-phase
flow junction. The user specifies the boundary of the flow channel connected
to the junction via `boundary`, along with the name of the junction component
with the `junction` parameter. The parameter `connection_index` corresponds to
the index of the given boundary within the `connections` parameter of the
junction component (starting with index 0). Lastly, the queried entry within
the flux vector is chosen via the `equation` parameter.

#### Troubleshooting

Note that if you get an error message like the following:

```
*** ERROR ***
Unable to find user object with name 'my_junction:junction_uo'
```

then this means that the supplied `junction` parameter is not valid, either
because the component does not exist or is not a valid junction. In the latter
case, please contact the THM team for assistance.




### ADHeatRateConvection1Phase


The heat convective heat rate $R$ is the integral of the convective heat flux over the flow channel / subdomains
specified in the [!param](/Postprocessors/ADHeatRateConvection1Phase/block) parameter.

R = \int_\Omega H_{wall} P_w (T - T_{wall}) d\Omega

where $H_w$ is the wall heat transfer coefficient, $P_w$ is the wetted perimeter,
$T$ is the fluid temperature and $T_{wall}$ is the wall temperature.




### ADHeatStructureEnergy


The energy stored in these heat structures is calculated as:

E = \int_\Omega \rho c_p (T - T_{ref}) n_{units} d d\Omega

where $E$ is the stored energy, $\rho$ the medium density, $c_p$ the medium specific heat capacity,
$T$ the medium temperature, $T_{ref}$ the reference temperature (reference for the enthalpy)
and $n_{units}$ the number of units this heat structure represents, and $d$ is the plate depth, i.e., the
size of uni-dimensional heat structures modeled.

This volumetric integral is computed numerically using the [local quadrature](syntax/Executioner/Quadrature/index.md)




### ADHeatStructureEnergy3D


The energy stored in the heat structure is calculated as:

E = \int_\Omega \rho c_p (T - T_{ref}) d\Omega

where $E$ is the stored energy, $\rho$ the medium density, $c_p$ the medium specific heat capacity,
$T$ the medium temperature and $T_{ref}$ the reference temperature (reference for the enthalpy).
Only a single unit of the heat structure is considered.

This volumetric integral is computed numerically using the [local quadrature](syntax/Executioner/Quadrature/index.md).




### ADHeatStructureEnergyRZ


The energy stored in these heat structures is calculated as:

E = \int_\Omega \rho c_p (T - T_{ref}) n_{units} r d\Omega

where $E$ is the stored energy, $\rho$ the medium density, $c_p$ the medium specific heat capacity,
$T$ the medium temperature, $T_{ref}$ the reference temperature (reference for the enthalpy)
and $n_{units}$ the number of units this heat structure represents and $r$ the local circumference.

This volumetric integral is computed numerically using the [local quadrature](syntax/Executioner/Quadrature/index.md).

With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general 2D objects used in general RZ coordinates.
Stay tuned!




### ADSideFluxIntegralRZ


The diffusive flux $I$ over the cylindrical surface is computed as:

I = \int_{\partial \Omega} \nabla v \cdot \vec{n} r(\vec{M}) d\partial \Omega

where $v$ is the variable of interest, $\vec{n}$ the normal to the surface and $r(\vec{M})$ is
the local circumference.

With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general 2D objects used in general RZ coordinates.
Stay tuned!




### ADSpecificImpulse1Phase


The flux on the boundary is first computed using the boundary user object for the boundary
of interest. Then we assume the process is isentropic and compute the inlet entropy $s_{in}$
from the inlet specific volume $v$ and specific internal energy $e$:

s_{in} = s(v_{in}, e_{in})

We know the outlet pressure, and we use the bisection method to compute the outlet
temperature considering the process is isentropic. From the outlet pressure and temperature, we can
compute the outlet enthalpy:

h_{out} = p(p_{out}, T_{out})

then compute the thrust from the outlet velocity and the mass flow rate $\dot{m}$ for the quadrature point as:

thrust_{qp} = |\sqrt(2 (h_{in} - h_{out})) \dot{m}|

The specific impulse $I_{sp}$ is finally returned from the boundary thrust as:

I_{sp} = \dfrac{thrust}{\dot{m} g}




### BoolComponentParameterValuePostprocessor


This is mostly used to debug inputs using the [ControlLogic](syntax/ControlLogic/index.md) system.




### BoolControlDataValuePostprocessor


The value of the postprocessor is 1 when the [ControlData.md] is true and 0 when false.

This can only be used with a [THMProblem.md], usually within a THM simulation.




### EnergyFluxIntegral


The integral of the energy flux $I_E$ over boundary $\partial \Omega$ is:

I_E = \int_{\partial \Omega} \alpha \rho u A h d\partial \Omega

with $\alpha \rho u A$ the conserved phase momentum and $h$ the specific total enthalpy of the fluid at the boundary.




### FunctionElementIntegralRZ


The integral is computed as:

I = \int_\Omega f(t, \vec{M}) r(\vec{M}) d\Omega

where $I$ is the integral, $f$ is the function evaluated at the current time $t$ and position $\vec{M}$,
and $r$ is the local circumference.
This volumetric integral is computed numerically using the system's quadrature.

With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general 2D objects used in general RZ coordinates.
Stay tuned!




### FunctionSideIntegralRZ

This post-processor computes the integral $F$ of a function $f$ along a
cylindrical boundary of a cylindrical heat structure:
\begin{equation}
  F = \int\limits_A f dA \,.
\end{equation}




### HeatRateConductionRZ

This post-processor computes the conduction heat rate $\dot{Q}$ across a radial
surface of 2D RZ domain (this post-processor inherits from [RZSymmetry.md]).

The conduction heat rate across a surface $S$ is computed as

\dot{Q} = \int\limits_S -f_\text{dir} k \nabla T \cdot \mathbf{n} \, dA \,,

where

- $f_\text{dir}$ is the "direction factor", equal to 1 if computing the *outward*
  heat rate and -1 if computing the *inward* heat rate,
- $k$ is the thermal conductivity,
- $T$ is the temperature, and
- $\mathbf{n}$ is the outward normal unit vector of $S$.




### HeatRateConvection

This post-processor computes the heat rate $\dot{Q}$ of a boundary convective heat flux
applied to a plate or 3D heat structure via the [HSBoundaryAmbientConvection.md]
component:
\begin{equation}
  \dot{Q} = \int\limits_A h (T_{amb} - T) dA \,,
\end{equation}
where

- $h$ is the convective heat transfer coefficient,
- $T_{amb}$ is the ambient temperature, and
- $T$ is the temperature of the surface.

If the boundary corresponds to a [HeatStructurePlate.md], then the parameter
[!param](/Postprocessors/HeatRateConvection/scale) should be set to the value used for the
[!param](/Components/HeatStructurePlate/depth) parameter in the [HeatStructurePlate.md].
If the boundary corresponds to a [HeatStructureFromFile3D.md], then
[!param](/Postprocessors/HeatRateConvection/scale) should be omitted, which defaults
to a value of 1.




### HeatRateConvection1Phase

This post-processor computes the total heat rate due to convection on a
1-phase flow channel:
\begin{equation}
  \dot{Q} = \int \mathcal{H} (T_\text{wall} - T) P_\text{hf} dx \,.
\end{equation}




### HeatRateConvectionRZ

This post-processor computes the heat rate $\dot{Q}$ of a boundary convective heat flux
applied to a cylindrical heat structure via the [HSBoundaryAmbientConvection.md]
component:
\begin{equation}
  \dot{Q} = \int\limits_A h (T_{amb} - T) dA \,,
\end{equation}
where

- $h$ is the convective heat transfer coefficient,
- $T_{amb}$ is the ambient temperature, and
- $T$ is the temperature of the surface.




### HeatRateDirectFlowChannel

This post-processor computes the heat rate to a flow channel from a heat flux
material property:
\begin{equation}
  \dot{Q} = \int q P_\text{hf} dx \,.
\end{equation}




### HeatRateExternalAppConvectionRZ

This post-processor is the same as [HeatRateConvectionRZ.md] but takes the
ambient temperature and heat transfer coefficient from an external application
that transfers these quantities into auxiliary variables.




### HeatRateHeatFlux

This post-processor computes the heat rate $\dot{Q}$ of a boundary heat flux
function applied to a plate or 3D heat structure via the [HSBoundaryHeatFlux.md]
component:

\dot{Q} = \int\limits_A q dA \,,

where $q$ is the user-provided heat flux function.

If the boundary corresponds to a [HeatStructurePlate.md], then the parameter
[!param](/Postprocessors/HeatRateHeatFlux/scale) should be set to the value used for the
[!param](/Components/HeatStructurePlate/depth) parameter in the [HeatStructurePlate.md].
If the boundary corresponds to a [HeatStructureFromFile3D.md], then
[!param](/Postprocessors/HeatRateHeatFlux/scale) should be omitted, which defaults
to a value of 1.




### HeatRateHeatFluxRZ

This post-processor computes the heat rate $\dot{Q}$ of a boundary heat flux function
applied to a cylindrical heat structure via the [HSBoundaryHeatFlux.md]
component:

\dot{Q} = \int\limits_A q dA \,,

where $q$ is the user-provided heat flux function.




### HeatRateRadiation

This post-processor computes the heat rate $\dot{Q}$ of a boundary radiative heat flux
applied to a plate or 3D heat structure via the [HSBoundaryRadiation.md]
component:
\begin{equation}
  \dot{Q} = \int\limits_A \sigma \epsilon (T_{amb}^4 - T^4) F dA \,,
\end{equation}
where

- $\sigma$ is the Stefan-Boltzmann constant,
- $\epsilon$ is the emissivity,
- $T_{amb}$ is the ambient temperature,
- $T$ is the temperature of the surface, and
- $F$ is the view factor function.

If the boundary corresponds to a [HeatStructurePlate.md], then the parameter
[!param](/Postprocessors/HeatRateRadiation/scale) should be set to the value used for the
[!param](/Components/HeatStructurePlate/depth) parameter in the [HeatStructurePlate.md].
If the boundary corresponds to a [HeatStructureFromFile3D.md], then
[!param](/Postprocessors/HeatRateRadiation/scale) should be omitted, which defaults
to a value of 1.




### HeatRateRadiationRZ

This post-processor computes the heat rate $\dot{Q}$ of a boundary radiative heat flux
applied to a cylindrical heat structure via the [HSBoundaryRadiation.md]
component:
\begin{equation}
  \dot{Q} = \int\limits_A \sigma \epsilon (T_{amb}^4 - T^4) f dA \,,
\end{equation}
where

- $\sigma$ is the Stefan-Boltzmann constant,
- $\epsilon$ is the emissivity,
- $T_{amb}$ is the ambient temperature,
- $T$ is the temperature of the surface, and
- $f$ is the view factor function.




### HeatStructureEnergy


This post-processor derives from [HeatStructureEnergyBase](/HeatStructureEnergyBase.md)
and performs a volume integral over a plate heat structure.




### HeatStructureEnergy3D


This post-processor derives from [HeatStructureEnergyBase](/HeatStructureEnergyBase.md)
and performs a volume integral over a 3D heat structure.




### HeatStructureEnergyBase

Post-processors deriving from `HeatStructureEnergyBase` compute the total energy
$E_{tot}$ stored in a heat structure:
\begin{equation}\label{eq:hs_total_energy}
  E_{tot} = \sum\limits_i^N \int\limits_{V_i} \rho c_p T dV \,,
\end{equation}
where $N$ is the number of regions in the heat structure that are considered
(i.e., the size of the parameter `block`), $\rho$ is the density, $c_p$ is the isobaric
specific heat capacity, $T$ is the temperature, and $V_i$ is the spatial domain of region $i$.

Optionally, one can supply a reference temperature $T_0$ (which is zero by
default, yielding [eq:hs_total_energy]) to compute the energy *change*:
\begin{equation}\label{eq:hs_energy_change}
  \Delta E_{tot} = \sum\limits_i^N \int\limits_{V_i} \rho c_p (T - T_0) dV \,.
\end{equation}

### HeatStructureEnergyRZ


This post-processor derives from [HeatStructureEnergyBase](/HeatStructureEnergyBase.md)
and performs a volume integral over a cylindrical heat structure.





### MassFluxIntegral


The integral of the mass flux $I_M$ over boundary $\partial \Omega$ is:

I_M = \int_{\partial \Omega} \alpha \rho u A d\partial \Omega

with $\alpha \rho u A$ the conserved phase momentum at the boundary.




### MomentumFluxIntegral


The integral of the momentum flux $I_M$ over boundary $\partial \Omega$ is:

I_M = \int_{\partial \Omega} \alpha \rho u^2 A + \alpha p A d\partial \Omega

with $\alpha \rho u A$ the conserved phase momentum, $u$ the boundary 1D velocity,
$\alpha$ the phase fraction, $p$ the pressure and $A$ the channel area at the boundary.




### NodalEnergyFluxPostprocessor


The energy flux $\Phi$ through nodes is computed as:

\Phi = \sum_{nodes} \alpha \rho u A H

where $\alpha$ is the phase fraction, $\rho$ is the phase density, $u$ is the phase velocity,
$A$ the local area, and $H$ the specific total enthalpy.




### RealComponentParameterValuePostprocessor


This is mostly used to debug inputs using the [ControlLogic](syntax/ControlLogic/index.md) system.




### RealControlDataValuePostprocessor


This can only be used with a [THMProblem.md], usually within a THM simulation.

#### Example input syntax

In this example, the value of the function is captured by the `T_inlet_fn` [ControlLogic](syntax/ControlLogic/index.md)
and output as a postprocessor using the `T_ctrl` `RealControlDataValuePostprocessor`.





### ShaftConnectedComponentPostprocessor

This post-processor gets either the torque $\tau$ or the moment of inertia $I$
of a component connected to a [Shaft.md].





### ShaftConnectedCompressor1PhasePostprocessor

This post-processor gets either the pressure ratio $r_p$ or the isentropic efficiency $\eta$
of a [ShaftConnectedCompressor1Phase.md].





### SideFluxIntegralRZ

This post-processor does the same as [SideFluxIntegral.md] but for a boundary
on a 2D RZ domain.




### SpecificImpulse1Phase


### Discussion

Specific impulse is a measure of how much thrust is produced by an exhaust gas
per mass flow rate. Specific impulse is denoted by $I_{sp}$ and defined as:

\begin{equation}
  I_{sp} = \frac{F}{g \dot{m}},
\end{equation}

where $g = 9.81 \text{m}/\text{s}^2$, $F$ is thrust, and $\dot{m}$ is the mass flow rate.
Specific impulse has units of seconds. This equation can be generalized to an averaged $I_{sp}$
over a transient burn where the quantities on the right hand side may depend on time.

\begin{equation}
  I_{sp} = \frac{\int_0^T F(t) dt}{g \int_0^T \dot{m}(t) dt}.
\end{equation}

The postprocessor allows to switch between instantaneous and averaged $I_{sp}$ using the `accumulative` parameter.

The postprocessor computes $I_{sp}$ by assuming an isentropic change of state from the conditions on the boundary
to outlet conditions. The outlet pressure must be provided to parameter `p_exit`. It is assumed that the expansion
is perfect:

1. The outlet area expands the gas exactly to `p_exit`. If the ambient pressure is not equal to the resulting pressure from the
   expansion characteristics of the nozzle, a real nozzle would experience a shock that reduces its efficiency. The possible occurrence of a shock is neglected.

2. Losses and heat transfer are neglected.





### SumPostprocessor


For a more complex operation than a sum, please consider the [ParsedPostprocessor.md].




## problems

### THMProblem


The `THMProblem` is composed of a regular [FEProblem.md] and a [Simulation.md] class.
When the `THMProblem` advances state, this advances the `FEProblem` and then the `Simulation` state.




## scalarkernels

### ADShaftComponentTorqueScalarKernel


This scalar kernel adds the value of the shaft torque $\tau(t)$ as a source term for an ODE:
\begin{equation}
  \frac{du}{dt} = \tau(t) \,
\end{equation}

In THM, most kernels are added automatically by components. This scalar kernel is created by the
[Shaft.md] component.

This is the [automatic differentiation (AD)](automatic_differentiation/index.md) version of [ShaftComponentTorqueScalarKernel.md].
AD is used in THM to compute numerically exact Jacobians.




### ADShaftTimeDerivativeScalarKernel


The momentum equation time derivative term is expressed in terms of the sum of the moment of inertia of the
connected shafts $L_{sum}$ :

L_{sum} \dfrac{du}{dt}

The time integration scheme will be shared with the other non-linear variables,
as specified in the [TimeIntegrator](syntax/Executioner/TimeIntegrator/index.md).
To use a different time integrating scheme, this scalar kernel should be replaced with a custom implementation.

In THM, most kernels are added automatically by components. This scalar kernel is created by the
[Shaft.md] component.

This is the [automatic differentiation (AD)](automatic_differentiation/index.md) version of [ShaftTimeDerivativeScalarKernel.md].
AD is used in THM to compute numerically exact Jacobians.




### ADVolumeJunctionAdvectionScalarKernel


This scalar kernel is used with the [/VolumeJunction1Phase.md] component. It is
used on all of the scalar degrees of freedom associated with the junction model.
All of these residuals are computed in [/ADVolumeJunction1PhaseUserObject.md] and
then retrieved in this scalar kernel.





### ODECoefTimeDerivative


A scalar variable can be set to the solution of an ordinary differential equation (ODE), as specified in [the Scalar Kernels syntax page](syntax/ScalarKernels/index.md). This kernel adds a time derivative term. The time integration scheme will be shared with the other non-linear variables, as specified in the [TimeIntegrator](syntax/Executioner/TimeIntegrator/index.md).
To use a different time integrating scheme, the `ODECoefTimeDerivative` scalar kernel should be replaced with a custom implementation.




### PostprocessorSourceScalarKernel


This scalar kernel adds a post-processor value $q(t)$ as a source term for an ODE:
\begin{equation}
  \frac{du}{dt} = q(t) \,.
\end{equation}




### ShaftComponentTorqueScalarKernel


This scalar kernel adds the value of the shaft torque $\tau(t)$ as a source term for an ODE:
\begin{equation}
  \frac{du}{dt} = \tau(t) \,
\end{equation}

In THM, most kernels are added automatically by components. This scalar kernel is created by the
[Shaft.md] component.




### ShaftTimeDerivativeScalarKernel


The momentum equation time derivative term is expressed in terms of the sum of the moment of inertia of the
connected shafts $L_{sum}$ :

L_{sum} \dfrac{du}{dt}

The time integration scheme will be shared with the other non-linear variables,
as specified in the [TimeIntegrator](syntax/Executioner/TimeIntegrator/index.md).
To use a different time integrating scheme, this scalar kernel should be replaced with a custom implementation.

In THM, most kernels are added automatically by components. This scalar kernel is created by the
[Shaft.md] component.




## userobjects

### ADBoundaryFlux3EqnFreeOutflow


This class implements a boundary flux corresponding to the free outflow boundary
condition, in which the boundary flux is computed solely from interior solution
values:
\begin{equation}
  \mathbf{F}_b = \mathbf{F}(\mathbf{U}_i) \,.
\end{equation}




### ADBoundaryFlux3EqnGhostDensityVelocity





### ADBoundaryFlux3EqnGhostMassFlowRateTemperature



This computes the boundary flux from a specified mass flow rate $\dot{m}=\rho u A$
and temperature $T$, with pressure $p_i$ coming from the interior solution:
\begin{equation}
  \mathbf{U}_b = \mathbf{U}(\dot{m}, T, p_i) \,.
\end{equation}




### ADBoundaryFlux3EqnGhostPressure



This computes the boundary flux from a specified pressure $p_b$, with density
$\rho_i$ and velocity $u_i$ coming from the solution:
\begin{equation}
  \mathbf{U}_b = \mathbf{U}(\rho_i, u_i, p_b) \,,
\end{equation}
\begin{equation}
  \mathbf{F}_b = \mathbf{F}(\mathbf{U}_b) \,.
\end{equation}




### ADBoundaryFlux3EqnGhostStagnationPressureTemperature



This computes the boundary flux from a specified stagnation pressure $p_{0,b}$
and stagnation temperature $T_{0,b}$, with velocity $u_i$ coming from the
solution:
\begin{equation}
  \mathbf{U}_b = \mathbf{U}(p_{0,b}, T_{0,b}, u_i) \,,
\end{equation}
\begin{equation}
  \mathbf{F}_b = \mathbf{F}(\mathbf{U}_b) \,.
\end{equation}




### ADBoundaryFlux3EqnGhostVelocityTemperature



This computes the boundary flux from a specified velocity $vel$
and temperature $T$, with pressure $p_i$ coming from the interior solution:
\begin{equation}
  \mathbf{U}_b = \mathbf{U}(vel, T, p_i) \,.
\end{equation}




### ADBoundaryFlux3EqnGhostWall



For the wall boundary condition, the velocity in the ghost cell has the
opposite sign as the interior velocity, but the thermodynamic state is the
same:
\begin{equation}
  \mathbf{U}_b = \begin{bmatrix}
    \rho_i A_i\\
    -\rho_i u_i A_i\\
    \rho_i E_i A_i\\
  \end{bmatrix} \,.
\end{equation}




### ADGateValve1PhaseUserObject


This user object is used with the [/GateValve1Phase.md] component. It
computes the fluxes that are used in [/ADGateValve1PhaseBC.md] for each of
the connected flow channels.





### ADHeatFluxFromHeatStructure3EqnUserObject


The heat flux $q$ is computed as:

q = H_{wall} (T_{wall} - T)

where $H_{wall}$ is the wall heat transfer coefficient, $T_{wall}$ is the wall temperature on the
heat structure side, and $T$ is the fluid temperature.

This user object is created automatically by the [HeatTransferFromHeatStructure1Phase.md]
component, users do not need to add it to an input file.




### ADHeatTransferFromHeatStructure3D1PhaseUserObject


The user object takes care of retrieving / computing the properties and has getter APIs to
provide the values to downstream objects.

This user object is created automatically by the [HeatTransferFromHeatStructure3D1Phase.md]
component, users do not need to add it to an input file.




### ADJunctionOneToOne1PhaseUserObject


This user object is used with the [/JunctionOneToOne1Phase.md] component. It
computes the fluxes that are used in [/ADJunctionOneToOne1PhaseBC.md] for each of
the connected flow channels.





### ADJunctionParallelChannels1PhaseUserObject


This user object is used with the [/JunctionParallelChannels1Phase.md] component. It
computes the fluxes that are used in [/ADVolumeJunction1PhaseBC.md] for each of
the connected flow channels and the residuals that are used in
[/ADVolumeJunctionAdvectionScalarKernel.md] for each of the junction's
scalar degrees of freedom.





### ADNumericalFlux3EqnCentered


This class implements a centered numerical flux for the 1-D, 1-phase, variable-area Euler
equations:
\begin{equation}
  \mathcal{F}(\mathbf{U}_1, \mathbf{U}_2, \mathbf{n})
    = \frac{1}{2} \left(\mathbf{F}(\mathbf{U}_1) + \mathbf{F}(\mathbf{U}_2)\right) \,.
\end{equation}
This flux is known to not be linearly stable, but it can be useful in some
cases, such as debugging.




### ADNumericalFlux3EqnHLLC


This class implements the HLLC Riemann solver for the 1-D, variable-area Euler
equations, which computes a numerical flux from two solution values:
\begin{equation}
  \mathbf{F} = \mathcal{F}(\mathbf{U}_1, \mathbf{U}_2, \mathbf{n}) \,,
\end{equation}
where $\mathbf{n}$ is the normal unit vector in the direction of cell 2 from
cell 1. This implementation is based on the work by Batten et al.
[!cite](batten1997average), but the equation of state is generalized instead of
assuming ideal gas.





### ADPump1PhaseUserObject


This user object is used with the [/Pump1Phase.md] component. It
computes the fluxes that are used in [/ADVolumeJunction1PhaseBC.md] for the two
connected flow channels and the residuals that are used in
[/ADVolumeJunctionAdvectionScalarKernel.md] for each of the pump's
scalar degrees of freedom. It also adds both a momentum and energy source term
due to the user supplied pump head.





### ADShaftConnectedCompressor1PhaseUserObject


A compressor is a type of volume junction, a [ADVolumeJunction1PhaseUserObject.md].
As such its base contribution to the residual and Jacobian is set by this class. An additional contribution to
the residual (and Jacobian) is described below:

The additional contribution to the residual of the energy equation is simply the power dissipated in the component:

R_e += (T_{friction} + T_{dissipation}) \omega

where $T_{friction}$ is the friction torque, $T_{dissipation}$ is the dissipation torque and $\omega$ is the rotation speed of
the compressor.

The additional contribution to the residual of the momentum equation in each direction is:

\vec{R} = \Delta p A \vec{d}_{out}

where $\Delta p$ is the pressure increase across the compressor, $A$ is the flow area and $\vec{d}_{out}$ the outlet direction.

The pressure increase in the compressor is:

\Delta p = p0_{in} * (Rp_{comp} - 1.0)

where $p0_{in}$ is inlet pressure, and $Rp_{comp}$ is the pressure ratio, or the inverse of the pressure ratio if treating the compressor
as a turbine.


The user object also provides APIs to retrieve the compressor's:

- isentropic torque
- dissipation torque
- friction torque
- pressure drop
- pressure ratio
- efficiency
- correct mass flow rate
- corrected speed

This user object is created automatically by the [ShaftConnectedCompressor1Phase.md]
component, users do not need to add it to an input file.




### ADShaftConnectedMotorUserObject


The torque and moment of inertia are specified as [Functions](syntax/Functions/index.md),
that only depend on the shaft speed variable.

The `time` argument of the Functions is used to evaluate the `Functions` at the shaft speed.

This user object is created automatically by the [ShaftConnectedMotor.md]
component (if its [!param](/Components/ShaftConnectedMotor/ad) parameter is set to true),
users do not need to add it to an input file.




### ADShaftConnectedPump1PhaseUserObject


A pump is a type of volume junction, a [ADVolumeJunction1PhaseUserObject.md].
As such its base contribution to the residual and Jacobian is set by this class. An additional contribution to
the residual (and Jacobian) is described below:


The additional contribution to the residual of the energy equation is simply the power of the pump:

R_e += (T_{hydraulic} + T_{dissipation}) \omega

where $T_{hydraulic}$ is the friction torque, and $\omega$ is the rotation speed of
the pump.

The additional contribution to the residual of the momentum equation is:

\vec{R} = \dfrac{\rho A}{A} \vec{g} H A_{ref} \vec{d}_{out}

where $\rho A$ is the conserved density, $A$ the local flow area, $A_{ref}$ is the reference flow area, $\vec{g}$ is the gravity vector,
$H$ the pump head, and $\vec{d}_{out}$ the outlet direction.

The pump head is computed as:

H_{pump} =  ( (\dfrac{\omega}{\omega_{rated}})^2 + (\dfrac{\dfrac{\rho u A A}{\rho A}}{Q_{rated}})^2 ) H_{function} H_{rated}

where $\omega_{rated}$ is the rated rotation speed of the pump, $\rho$ the fluid density, $u$ the fluid velocity, $A$ the local area,
$Q_{rated}$ is the rated flow rate, $H_{function}$ an adimensional pump head function and $H_{rated}$ is the rated head of the pump.

The user object also provides APIs to retrieve the pump's:

- hydraulic torque
- friction torque
- pump head

This user object is created automatically by the [ShaftConnectedPump1Phase.md]
component, users do not need to add it to an input file.




### ADShaftConnectedTurbine1PhaseUserObject


A turbine is a volume junction, derived from 
[ADVolumeJunction1PhaseUserObject.md]. As such its base contribution to the residual and Jacobian is set by this parent class.

The additional residual for the momentum equation in each direction are:

\vec{R} = \Delta p A \vec{d}_{out}

where $\Delta p$ is the pressure drop across the turbine, as computed below, $A$ the flow area and $\vec{d}$ the direction of
the turbine outlet.

\Delta p =  (\rho V / volume) g_H;

where $\rho V$ is a variable, $volume$ the volume of the junction and $g_H$ is defined below:

g_H = head D_{wheel}^2 \omega^2

where $head$ is the head coefficient, $D_{wheel}$ is the diameter of the turbine, and $\omega$ is the inlet rotation speed.

For the energy equation, the additional residual $R_e$ is simply the power of the turbine $\dot{W}$.

\dot{W} = T \omega

with $T$ the torque of the turbine and $\omega$ its rotation speed.

The user object also provides APIs to retrieve the turbine's:

- driving torque
- friction torque
- flow coefficient
- pressure drop
- power

This user object is created automatically by the [ShaftConnectedTurbine1Phase.md]
component, users do not need to add it to an input file.




### ADSimpleTurbine1PhaseUserObject


A turbine is a parallel channel junction, a [ADJunctionParallelChannels1PhaseUserObject.md], a type of volume junction,
a [ADVolumeJunction1PhaseUserObject.md]. As such its base contribution to the residual and Jacobian is set by these classes.

The additional residual for the momentum equation in each direction are:

\vec{R} = \Delta p A \vec{d}

where $\Delta p$ is the pressure drop across the turbine, as computed below, $A$ the flow area and $\vec{d}$ the direction of
the turbine.

\Delta p = p_{in} * (1 - (1 - \dfrac{_W_dot}{\rho uA h_{in})^{\dfrac{\gamma}{\gamma -1}})

where $p_{in}$ is the inlet pressure, $\rho uA$ is the inlet conserved momentum variable, $h_in$ is the inlet
enthalpy and $\gamma$ is the ratio of the specific isobaric and isochoric heat capacities of the fluid.

For the energy equation, the residual $R_e$ is simply the work $\dot{W}$ the turbine:

R_e = \dot{W}

This user object is created automatically by the [SimpleTurbine1Phase.md]
component, users do not need to add it to an input file.




### ADVolumeJunction1PhaseUserObject


This user object is used with the [/VolumeJunction1Phase.md] component. It
computes the fluxes that are used in [/ADVolumeJunction1PhaseBC.md] for each of
the connected flow channels and the residuals that are used in
[/ADVolumeJunctionAdvectionScalarKernel.md] for each of the junction's
scalar degrees of freedom.





This boundary flux $\mathbf{F}_b$ is computed using a numerical flux function $\mathcal{F}$ with the interior solution $\mathbf{U}_i$ and the ghost cell
solution $\mathbf{U}_b$:
\begin{equation}
  \mathbf{F}_b = \mathcal{F}(\mathbf{U}_i, \mathbf{U}_b, \mathbf{n}) \,,
\end{equation}
where $\mathbf{n}$ is the outward-facing normal vector.

### FunctionElementLoopIntegralUserObject


This object is a [GeneralUserObject.md] specialized to work on meshes used by the
thermal hydraulics modules.




### HSCoupler2D2DRadiationUserObject

This user object is used by [HSCoupler2D2DRadiation.md] to compute the heat fluxes
that get applied by [HSCoupler2D2DRadiationRZBC.md].




### HSCoupler2D3DUserObject

This user object is used by [HSCoupler2D3D.md] to compute the heat fluxes
that get applied by [HSCoupler2D3DBC.md]. It executes on the 3D heat structure
boundary.




### LayeredAverageRZ


Documentation on how to use the `LayeredAverageRZ` may be found in the [LayeredAverage.md] documentation.

This boundary condition is meant to be used in XY coordinates that are interpreted as general cylindrical coordinates.
With the recent development of general RZ coordinates, this object along with all THM's "RZ"-specific
objects will soon be deprecated in favor of more general RZ-coordinate objects.
Stay tuned!




### LayeredFlowAreaChange


On each layer $l$, the flow area change is computed as:

\int_l - \vec{n} \cdot \vec{d} d\Omega

where $\vec{n}$ is the local normal, and $\vec{d}$ is the displacement vector.




### ShaftConnectedMotorUserObject


The torque and moment of inertia are specified as [Functions](syntax/Functions/index.md),
that only depend on the shaft speed variable.

The `time` argument of the Functions is used to evaluate the `Functions` at the shaft speed.

This user object is created automatically by the [ShaftConnectedMotor.md]
component (if its [!param](/Components/ShaftConnectedMotor/ad) parameter is set to false),
users do not need to add it to an input file.




### SolidMaterialProperties


The material properties defined serve for heat transfer simulations:

- specific heat capacity
- density
- thermal conductivity

`SolidMaterialProperties` will be deprecated in the future to use the `SolidProperties` module instead.
Its equivalent in the module is the [ThermalFunctionSolidProperties.md].




### StoreVariableByElemIDSideUserObject

This user object stores a variable's values (for each face quadrature point)
by element ID along a boundary. These values can then be retrieved with

```
const auto & var_values = getVariableValues(elem_id);
```

This user object is used by [HSCoupler2D3D.md].




## utils

### CubicTransition

This class is similar to [WeightedTransition.md], except that it computes a
cubic polynomial fit in the transition region instead of weighting the two
functions:
\begin{equation}
  f(x) = A x^3 + B x^2 + C x + D \,,
\end{equation}
where the polynomial coefficients are fitted to satisfy the properties listed
for [WeightedTransition.md], which gives 4 equations:

- $f(x_1) = f_1(x_1)$
- $f(x_2) = f_2(x_2)$
- $f'(x_1) = f_1'(x_1)$
- $f'(x_2) = f_2'(x_2)$

As noted for [WeightedTransition.md], this transition is recommended over
[WeightedTransition.md] when the transition occurs at the intersection of two
functions.

### Logger

This class is used for queueing up error and warning messages so that they can
be emitted all at once, instead of stopping execution for each error.

### MeshAlignment

This class builds a mapping between one of the following:

- 1D-to-2D: A 1D subdomain and a 2D boundary
- 2D-to-2D: A 2D boundary and other 2D boundary

These "meshes" must be *aligned*, i.e., each element/side on the primary mesh
must correspond to a unique element/side on the secondary mesh. The pairing is
determined by checking the centroids of the elements/sides and finding the
nearest match on the other mesh.

### MeshAlignment1D3D

This class inherits from [MeshAlignmentOneToMany.md] and builds a mapping between
elements/faces between a 1D subdomain and a 3D boundary.

### MeshAlignment2D2D

This class inherits from [MeshAlignmentOneToMany.md] and builds a mapping between
elements/faces between multiple 2D boundaries. The first entry in the `boundary_infos`
argument of the

```
void initialize(boundary_infos, axis_point, axis_direction)
```

method is taken to be the "primary" boundary. Each element on this boundary is
mapped to the corresponding element in each of the other boundaries. The coupled
secondary element IDs for a primary element ID `primary_elem_id` are obtained via

```
const std::vector<dof_id_type> & getCoupledSecondaryElemIDs(primary_elem_id)
```

The boundaries must be *aligned*; the axis is defined by `axis_point` and `axis_direction`,
and the axial coordinates of the primary side element and the coupled secondary
elements must be exactly the same.

### MeshAlignment2D3D

This class inherits from [MeshAlignmentOneToMany.md] and builds a mapping between
elements/faces between a 2D boundary and a 3D boundary.

Each element on the primary side maps to multiple elements on the secondary side.
These "meshes" must be *aligned*; the 2D boundary is associated
with an arbitrary axis, and the axial coordinates of the paired elements must
match.

### MeshAlignmentOneToMany

This is a base class for [MeshAlignment1D3D.md] and [MeshAlignment2D3D.md].
It builds a mapping between elements/faces for one of the following cases:

- 1D-to-3D: A 1D subdomain and a 3D boundary
- 2D-to-3D: A 2D boundary and a 3D boundary

Each element on the primary side maps to multiple elements on the secondary side.

### WeightedTransition

This class is used for objects that perform smooth transitions between two
functions of one variable. Denoting the transition begin and end points by
$x_1$ and $x_2$, respectively, and the "left" and "right" functions by $f_1(x)$
and $f_2(x)$, respectively, the transition function $f(x)$ is the following:
\begin{equation}
  f(x) = w(x) f_1(x) + (1 - w(x)) f_2(x) \,,
\end{equation}
where the weight $w_x(x)$ is between 0 and 1 and is computed with a cosine
function:
\begin{equation}
  w(x) = \left\{\begin{array}{l l}
    1 & x \le x_1\\
    0 & x \ge x_2\\
    \frac{1}{2}\left(\cos\left(\frac{\pi}{x_2 - x_1}(x - x_1)\right) + 1\right) & \text{otherwise}\\
    \end{array}\right. \,.
\end{equation}
The transitioned function $f(x)$ has the following desirable properties:

- $f(x)$ is continuous throughout the interval $[x_1, x_2]$ (including at the end points),
  so long as $f_1(x)$ and $f_2(x)$ are also continuous on this interval.
- $f'(x)$ is continuous throughout the interval $[x_1, x_2]$ (including at the end points),
  so long as $f_1'(x)$ and $f_2'(x)$ are also continuous on this interval.

An example of the transition is illustrated in [WeightedTransition_discontinuous],
where is transition is created in the region $x\in(1,5)$ at a discontinuity:

       id=WeightedTransition_discontinuous
       caption=Weighted transition at a discontinuity
       style=width:100%;display:block;margin-left:auto;margin-right:auto;

Note that the transition can exit the bounds of the non-transitioned piecewise
function, which can be undesirable. This is illustrated in [WeightedTransition_continuous],
where compares this weighted approach with the approach of [CubicTransition.md]:

       id=WeightedTransition_continuous
       caption=Transition at the intersection of two functions
       style=width:100%;display:block;margin-left:auto;margin-right:auto;

Thus when the transition occurs at the intersection of two functions, it may be
advantageous to use [CubicTransition.md] instead of `WeightedTransition`,
whereas transitions at a discontinuity may be handled well with
`WeightedTransition`.

## vectorpostprocessors

### Sampler1DReal


This object has similar capabilities to the [ElementMaterialSampler.md], but is
implemented differently. It creates its own standalone loop on elements in the mesh
to gather the material properties.

To sample AD material properties, use `ADSampler1DReal`.





### Sampler1DVector


The index must be smaller than the size of the array material property, and indexing
starts at 0.

There is no AD version currently implemented.




# XFEM Module

The XFEM module implements the extended finite element method (XFEM) in the MOOSE framework. It can
be used in conjunction with any number of other physics modules to enrich the solutions to partial
differential equations (PDEs) with some form of discontinuity. XFEM theory and implementation are
detailed in the theory manual:

- [XFEM Theory Manual](xfem/theory/theory.md)
- [Embedded Interface](xfem/theory/embedded_interface.md)

Tables provided in the [Objects, Actions, and Syntax](#objects-actions-and-syntax) section list
objects contained within the XFEM module followed by short explanations of the objects' purposes.
Links on the objects' names navigate to an individual detailed page for the object.

       style=width:100%;float:right;padding-top:2.7%;
       caption=Crack propagation on a circular mesh as a result of hoop strain relief.


       caption=Side view of the deformation of a cylinder with a cut prescribed by XFEM.

       caption=Top view of the deformation of a cylinder with a cut prescribed by XFEM.


## Applications

XFEM is ideally suited to problems involving local discontinuities. Typically these types of
problems fall into one of two categories: strong or weak discontinuities. Strong discontinuities
are characterized by a jump in the value of a solution field across an interface, whereas weak
discontinuities involve a jump in the first derivative (slope) of a solution field across an
interface. Examples of the types of problems XFEM can solve include:

- Cracking

  - Stationary cracks
  - Cracks that propagate in a manner directly prescribed by the user
  - Cracks that propagate based on the solution (stress, stress intensity factor, etc.)

- Interfaces

  - Open (glued) or closed (inclusion) interfaces on the domain
  - Static and dynamic movement options

    - Stationary (prescribed location) interfaces
    - Interfaces that move in a manner directly prescribed by the user (provided level set function)
    - Interfaces that move based on the solution (temperature, displacement, etc.)

The locations of the interface used to define solution discontinuities can be prescribed in various
ways, including by user-defined cutting planes and using level set functions. The evolution of level
set functions can optionally be computed using the
[level set module](level_set/index.md optional=True), which is recommended for interfaces that move
based on calculated growth rates rather than prescribed functions.

## Software Quality

The XFEM module follows strict software quality guidelines. Please refer to
[XFEM Software Quality Assurance](xfem/sqa/index.md) for additional information.

## Objects, Actions, and Syntax


## actions

### XFEMAction


#### Description

XFEMAction is a MOOSE action that constructs objects needed for using XFEM. This is invoked by including
the [XFEM](syntax/XFEM/index.md) block at the top level in a MOOSE input file. See the page documenting
the syntax for that block for a description, example usage, and parameters.

## auxkernels

### CutSubdomainIDAux


#### Overview

To allow using XFEM to model interfaces between materials, the XFEM system uses cut subdomain IDs to denote the subset of a standard MOOSE subdomain (element block) that a material point belongs to. `CutSubdomainIDAux` outputs the value of the cut subdomain ID for each element.

`Cut subdomain ID`s are special IDs used only for XFEM that are different from the libMesh subdomain IDs. Although [`CutElementSubdomainModifier`](/userobjects/CutElementSubdomainModifier.md) could be used to assign cut subdomain IDs as element subdomain IDs.

#### Example Input File Syntax




### MeshCutLevelSetAux


#### Description

The `MeshCutLevelSetAux` calculates level set values for an interface that is defined by a cutter mesh([InterfaceMeshCut2DUserObject](InterfaceMeshCut2DUserObject.md) or [InterfaceMeshCut3DUserObject](InterfaceMeshCut3DUserObject.md)). The value of level set at a given point is calculated as a signed distance of this point from the surface of the interface, with the sign determined by whether this point is inside the closed interface contour.   

#### Example Input File Syntax






### XFEMCutPlaneAux


### Description

The MOOSE XFEM implementation uses the phantom node technique, in which elements traversed by a discontinuity are split into two partial elements, each containing physical and non-physical material. The `XFEMCutPlaneAux` output is used in [XFEM Paraview Plugin](https://github.com/idaholab/XFEMParaviewPlugin) (`MooseXfemClip`) to define a cutting plane to cut off the non-physical portions of partial elements. It can be automatically added when `output_cut_plane` = `true` in [XFEM](syntax/XFEM/index.md) block.

### XFEMMarkerAux


### Description

The `XFEMMarkerAux` returns one for crack tip elements, zero otherwise.

### XFEMVolFracAux


### Description

The MOOSE XFEM implementation uses the phantom node technique, in which elements traversed by a discontinuity are split into two partial elements, each containing physical and non-physical material. The `XFEMVolFracAux` is used to compute the volume fraction of physical portions of each partial element.

## bcs

### CrackTipEnrichmentCutOffBC

MOOSE permits variables to be restricted to specific blocks, but currently does not provide a straightforward way to add variables to just the enriched region near the crack tip. An inefficient workaround is to add new variables associated with the enrichment shape functions for the whole mesh and then to simply fix DOFs to zero for those nodes with basis function supports that are far away from any crack tip.

#### Example Input Syntax





## constraints

### XFEMEqualValueAtInterface


#### Description

The `XFEMEqualValueAtInterface` enforces $u_{\Gamma^+} = u_{\Gamma^-}= a$ at the interface using a penalty approach.

#### Example Input File Syntax






### XFEMSingleVariableConstraint


#### Overview

Without any other intervention, the phantom node method used by MOOSE's XFEM system results in
Heaviside enrichment of all solution fields at the locations of interfaces, with zero flux
conditions. In many cases, there is a need to impose constraints across the interface on one or more
of the solutions fields in a multiphysics XFEM simulation, which is the purpose of
`XFEMSingleVariableConstraint`. The object takes in jumps in solutions and fluxes for a single
variable and enforces prescribed jumps as a constraint between element fragments.

The variable to be constrained and the UserObject defining the interface upon which the constraint
is occurring must both be specified. Next, any jumps in the variable's value or flux at the
interface are provided. Lastly, the method by which the constraint is to be enacted is defined in
the `use_penalty` parameter and a parameter dependent upon choice of enforcement method is given in
`alpha`.

Currently, there are two choices of enforcement method: Nitsche's formulation and the penalty
method. Nitsche's method has the advantage of providing consistent results but does require the
stabilization parameter (`alpha`) to be as small as possible to maintain solution stability and is
only applicable to simple diffusion problems. The penalty method, while stable, does not give
results as consistent as Nitsche but can be applied to a wider variety of problems. When using the
penalty method, the `alpha` parameter should be quite large relative to the Jacobian entries for
the physics to which the penalty method is being applied.

#### Example Input File Syntax





## dirackernels

### XFEMPressure


#### Overview

`XFEMPressure` applies a force to an interface cut by XFEM in the magnitude specified by the user. This is implemented with DiracKernel. A `component` of the normal vector to the interface (0, 1, or 2 corresponding
to the $\hat{x}$, $\hat{y}$, and $\hat{z}$ vector components) is used to determine
the direction in which to apply the traction.

- For the variable `disp_x`, the parameter `component` sets to be 0
- For the variable `disp_y`, the parameter `component` sets to be 1
- For the variable `disp_z`, the parameter `component` sets to be 2

The magnitude of the `Pressure` boundary condition can be specified as either a
scalar (use the input parameter `factor`) or a `function` parameter.

#### Example Input Syntax





## kernels

### CrackTipEnrichmentStressDivergenceTensors

The displacement field consists of the summation of the standard displacements and the near-tip enrichment (when near-tip enrichment is enabled). The `CrackTipEnrichmentStressDivergenceTensors` Kernel computes the contribution of the enrichment variables to the residual and Jacobian. This is only applicable for small-strain calculations.

#### Example Input Syntax





## materials

### ComputeCrackTipEnrichmentSmallStrain


### Description

The displacement field contains both the standard and the enrichment solution. The
`ComputeCrackTipEnrichmentSmallStrain` Material calculates the strains from the total displacement
field, including the contributions from both the standard and enrichment solution. This is a drop-in
replacement for the standard strain calculators, and is applicable only to small-strain problems.




### LevelSetBiMaterialRankFour


#### Description

This material, `LevelSetBiMaterialRankFour` determines the global material
property by switching the two Rank-4 tensor material properties with different
base_name based on the level set values. See
[LevelSetBiMaterialReal](LevelSetBiMaterialReal.md) for more information.

The non-AD version of this class is required to compute the contribution of the
stress to the off-Jacobian entries. In an AD simulation, this term is not
required.

The non-AD version of this class can be used to select between the Jacobian
($\frac{\partial\sigma}{\partial\epsilon}$) computed by two ComputeStress
materials that are defined for the level set positive domain and negative domain
respectively, based on the sign of the level set field. The AD version of this
class can be used to determine other Rank-4 quantities, such as the elasticity
tensor (C$_{ijkl}$)

#### Example Input File Syntax





### LevelSetBiMaterialRankTwo


#### Description

This material, `LevelSetBiMaterialRankTwo` determines the global material property by switching the two Rank-2 tensor material properties with different base_name based on the level set values. It can be used to select between the stresses computed by two ComputeStress materials that are defined for the level set positive domain and negative domain respectively, based on the sign of the level set field. Those two ComputeStress materials can use completely different constitutive laws. See [LevelSetBiMaterialReal](LevelSetBiMaterialReal.md) for more information.

#### Example Input File Syntax






### LevelSetBiMaterialReal


#### Description

A level set function can represent the location of the interface between two material domains, which in general could have different material properties. A system has been developed to evaluate the proper models for a given material in such a system. This system operates by evaluating the material properties for both materials at every point, and then selecting the property appropriate for a given point.

This switching between material properties is done based on the `LevelSetBiMaterialBase` model, which selects between the material properties that are defined for the level set positive domain and negative domain respectively, based on the sign of the level set field. This material, `LevelSetBiMaterialReal`, is used to switch two Real material properties. The switching of Rank-2 and Rank-4 tensors material properties are implemented as [LevelSetBiMaterialRankTwo](LevelSetBiMaterialRankTwo.md) and [LevelSetBiMaterialRankFour](LevelSetBiMaterialRankFour.md), respectively.   

#### Example Input File Syntax






### XFEMCutSwitchingMaterial


To allow using XFEM to model interfaces between materials, the XFEM system uses cut subdomain IDs to denote the subset of a standard MOOSE subdomain (element block) that a material point belongs to. Based on these cut subdomains, `XFEMCutSwitchingMaterial` switches between material properties depending on which cut subdomain a point is located within. This class reads in multiple versions of a material property, all with different values of `base_name`, and sets the value of the material property without that base name to the name of the property that applies to the current cut subdomain.

This class has four instantiations described below that are used to switch between properties with specific types:

#### XFEMCutSwitchingMaterialReal

`XFEMCutSwitchingMaterialReal` switches between two material properties of type `Real` that coexist on the same element with different base_names.

#### Example Input File Syntax



#### XFEMCutSwitchingMaterialRankTwoTensor

`XFEMCutSwitchingMaterialRankTwoTensor` switches between two material properties of type `RankTwoTensor` that coexist on the same element with different base_names.

#### Example Input File Syntax


#### XFEMCutSwitchingMaterialRankThreeTensor

`XFEMCutSwitchingMaterialRankThreeTensor` switches between two material properties of type `RankThreeTensor` that coexist on the same element with different base_names.

#### Example Input File Syntax


#### XFEMCutSwitchingMaterialRankFourTensor

`XFEMCutSwitchingMaterialRankFourTensor` switches between two material properties of type `RankFourTensor` that coexist on the same element with different base_names.

#### Example Input File Syntax


## outputs

### XFEMCutMeshOutput.md


#### Overview

This class outputs the lower-dimensional mesh used to define cuts with XFEM.  It outputs the mesh in the Exodus format and outputs it in the original (undeformed) configuration.  The `XFEMCutMeshOutput` creates a file using the naming convention [!param](/Outputs/XFEMCutMeshOutput/file_base)_XFEMCutMeshOutput.e.  This class outputs a new Exodus file at every timestep with an extension that matches the convention used by MOOSE for other modified meshes (i.e. *.e-s0001, *.e-s0002, etc.),  because it assumes that the cutting mesh is always adding new nodes and elements as the crack grows.  This class is currently only implemented to be operable with the [MeshCut2DFractureUserObject.md] and [MeshCut2DFunctionUserObject.md] user objects but will eventually include all cutter user objects deriving off a GeometricCutUserObject.

#### Example Input Syntax





## postprocessors

### ParisLaw

#### Description

The ParisLaw Postprocessor computes the crack extension size at all active crack front points in a fatigue crack growth scenario. The code is based on the Paris law and requires Paris law parameters as the input. The amounts of crack extension at the crack front nodes are scaled such that the point with the largest effective K will have an extension equal to the input maximum extension size.

#### Example Syntax





## userobjects

### CircleCutUserObject


#### Overview

The `CircleCutUserObject` defines the boundary of a circular cut for XFEM to
make on a 3 dimensional mesh. The user enters three points in the cut_data
parameter in x, y, and z coordinates: first the center point of the circle,
followed by two points on the boundary of the circle. The object calculates
the radius and angle of the circle (with respect to the x-y plane), verifies
that the points define a circle (rather than an ellipse), and has logic to
determine if a given point is inside the cut plane.

#### Example Input Syntax





### ComboCutUserObject


#### Overview

The `ComboCutUserObject` combines multiple `GeometricCutUserObject`s to create a composite cut. Currently, all `GeometricCutUserObject`s are assumed to be non-overlapping, i.e. each element can only be cut by one geometric cut.

Each `GeometricCutUserObject` may have defined its own set of `CutSubdomainID`s, and the `ComboCutUserObject` follows the key-value dictionary provided by the user to assign a `CutSubdomainID` to each of the cut subdomains.

#### Example Input File Syntax




### CrackMeshCut3DUserObject


#### Overview

This class: (1) reads in a mesh describing the crack surface, (2) uses the mesh to do initial cutting of 3D elements, and (3) grows the mesh incrementally based on prescribed growth functions. The code is interfaced with domain integral methods to allow nonplanar crack growth based on empirical propagation direction and speed laws.

#### Example Input Syntax





### CutElementSubdomainModifier


#### Overview

`CutElementSubdomainModifier` switches the element subdomain ID based on the `CutSubdomainID` marked by geometric cut userobjects. This object extends the capabilities described in [`CoupledVarThresholdElementSubdomainModifier`](meshmodifiers/CoupledVarThresholdElementSubdomainModifier.md) to allow subdomains to be defined based on XFEM interfaces.

#### Example Input File Syntax





### EllipseCutUserObject


#### Overview

The `EllipseCutUserObject` defines the boundary of an elliptical cut for XFEM
to make on a 3 dimensional mesh. The user enters three points in the cut_data
parameter in x, y, z coordinates: the center point of the ellipse (must be
specified first), followed by points on the edge of the ellipse at the
longest and shortest axes (in any order). The object calculates the two radii,
verifies that the points provided are located within the same plane, and has
logic to determine whether a given point is located inside the cut plane.

#### Example Input Syntax





### InterfaceMeshCut2DUserObject


#### Overview

The `InterfaceMeshCut2DUserObject` is used to cut the 2D mesh with a 1D cutter mesh. The element type of the 1D cutter mesh must be `EDGE2`. The nodes on the cutter mesh move at a velocity that is given by a function or `XFEMMovingInterfaceVelocity` UserObject.

#### Example Input File Syntax





### InterfaceMeshCut3DUserObject


#### Overview

The `InterfaceMeshCut3DUserObject` is used to cut the 3D mesh with a 2D cutter mesh. The nodes on the cutter mesh move at a velocity that is given by a function or `XFEMMovingInterfaceVelocityBase` derived UserObject.

#### Example Input File Syntax





### LevelSetCutUserObject


#### Overview

This userobject, `LevelSetCutUserObject` uses a level set field to cut the finite element mesh. The zero level set contour represents the interface.

#### Example Input File Syntax





### LineSegmentCutSetUserObject


#### Overview

The `LineSegmentCutSetUserObject` defines a set of line segment cuts for XFEM
to make on a 2 dimensional mesh. The cut_data parameter consists of $n$ entries
each with a length of six Real values (the $n$ entries are not separate but
rather the length of the cut_data vector must be a multiple of six). Each set
of six values in cut_data prescribes a line segment cut: start point x, start
point y, end point x, end point y, start cut time, end cut time. The object
checks to ensure that the length of cut_data is a multiple of six. Provided
that the start cut time and end cut time values are different, the cut will
lengthen by $r_{total} \cdot \frac{t_{current} - t_{start}}{t_{end} -
t_{start}}$ at each timestep from start cut time until the specified end cut
time. As in the `LineSegmentCutUserObject`, scaling and translation are
available via optional parameters and apply to all applicable components of
cut_data.

#### Example Input Syntax





### LineSegmentCutUserObject


#### Overview

The `LineSegmentCutUserObject` defines a line segment cut for XFEM to make on a
2 dimensional mesh. The start and end points of the line segment are defined in
cut_data as a vector of four Real values: start point x, start point y, end
point x, end point y. By default, the entire cut specified is performed at
$t=0$. Propagation of the cut may be prescribed along the line
segment by specifying the time_start_cut and time_end_cut parameters in
simulation time. The cut will lengthen by $r_{total} \cdot \frac{t_{current} -
t_{start}}{t_{end} - t_{start}}$ at each timestep from time_start_cut until
time_end_cut. There are also options to scale and translate the points given in
cut data. The scale and translation of the x and y coordinates must be
specified separately, and if specified, the scale and translation are applied
to both start and end points.

#### Example Input Syntax





### MeshCut2DFractureUserObject


#### Overview

This class is used to define an evolving cutting plane for 2D XFEM simulations based on a mesh that defines the initial crack and uses fracture integrals or maximum stress to grow that crack. It (1) reads in a mesh describing the crack surface or uses nucleated cracks, (2) uses the mesh to do initial cutting of 2D elements, and (3) grows the mesh incrementally based on fracture domain integrals to allow nonplanar crack growth based on propagation directions determined by fracture integrals.  A maximum stress criterion can also be used to drive crack growth.

The crack propagates if the failure criterion is met, given by:

\begin{equation}
K_c \le \sqrt{K^2_I+K^2_{II}}
\end{equation}

where $K_I$ and $K_{II}$ are the mode I and II stress intensity factors provided by the fracture integral and the material property $K_c$ is defined in the input file with a constant value for the entire domain using [!param](/UserObjects/MeshCut2DFractureUserObject/k_critical) or from a [CrackFrontNonlocalScalarMaterial.md] VectorPostprocessor that samples a material property at each crack front point and is specified by [!param](/UserObjects/MeshCut2DFractureUserObject/k_critical_vectorpostprocessor) and [!param](/UserObjects/MeshCut2DFractureUserObject/k_critical_vector_name).  The crack growth direction is given by the direction that maximizes the crack-tip hoop stress, given by Equation 5 in [!cite](jiang2020).  The growth increment is a user provided input given by [!param](/UserObjects/MeshCut2DFractureUserObject/growth_increment).  The fracture integrals $K_I$ and $K_{II}$ are obtained from the [InteractionIntegral.md] vectorpostprocessor specified in the input file by [!param](/UserObjects/MeshCut2DFractureUserObject/ki_vectorpostprocessor) and [!param](/UserObjects/MeshCut2DFractureUserObject/kii_vectorpostprocessor).  Defaults for [!param](/UserObjects/MeshCut2DFractureUserObject/ki_vectorpostprocessor) and [!param](/UserObjects/MeshCut2DFractureUserObject/kii_vectorpostprocessor) use the names produced by the [/DomainIntegralAction.md] which is the standard way to set-up the [InteractionIntegral.md].

Near a free surface, the integration volumes of the rings used to compute the `InteractionIntegral` will intersect the surface, leading to a reduction in the fracture integral values.  This can lead to cracks becoming unable to farther propagate as they approach free surfaces.  For these cases, a maximum stress criterion computed using [CrackFrontNonlocalStress.md] vectorpostprocessor can be used for crack growth using an additional failure criterion given by:

\begin{equation}
\sigma_c \le \sigma_{nn}
\end{equation}

where $\sigma_c$ is a critcal stress normal to the crack face specified by [!param](/UserObjects/MeshCut2DFractureUserObject/stress_threshold) and $\sigma_{nn}$ is the average scalar stress measure normal to the crack face specified by [!param](/UserObjects/MeshCut2DFractureUserObject/stress_vectorpostprocessor).  The crack front normal stress will only extend the crack in the direction it is already going and will not cause the crack to curve.

Quasistatic behavior is assumed, and an iterative approach is taken to repeatedly solve the equilibrium equations, evaluate the fracture integrals, and as indicated by the failure criterion, incrementally advance the crack until the failure criterion is no longer met. To iteratively repeat the solution in this manner for each step, [!param](/Executioner/Steady/max_xfem_update) must be set in the `Executioner` block, and should be large enough to allow a sufficient number of iterations for crack growth to cease during each timestep.

#### Example Input Syntax

The following input file provides an example of a `MeshCut2DFractureUserObject` that uses fracture integrals to propagate the crack.  In this example, crack growth stops before the crack grows through the right boundary due to the fracture integral q-function intersecting the boundary.  A stress based crack growth criterion is used in conjunction with the fracture integrals by uncommenting the two lines containing `stress_vectorpostprocessor` and `stress_threshold` in the `MeshCut2DFractureUserObject`.  The stress based growth criterion causes the crack to continue to grow through the right boundary, as expected.





### MeshCut2DFunctionUserObject


#### Overview

This class is used to define an evolving cutting plane for 2D XFEM simulations based on a mesh that defines an initial crack, and a user-defined function for growth of that crack. It (1) reads in a mesh describing the crack surface, (2) uses the mesh to do initial cutting of 2D elements, and (3) grows the mesh incrementally based on prescribed growth functions defining the direction and growth rate.

#### Example Input Syntax





### MeshCut2DRankTwoTensorNucleation


#### Overview

The XFEM nucleation UserObject `MeshCut2DRankTwoTensorNucleation` defines new cracks that are added to the cutter
mesh used by [MeshCut2DFractureUserObject.md] when a user-defined nucleation criterion is met.
The nucleation criterion is based on the [!param](/UserObjects/MeshCut2DRankTwoTensorNucleation/scalar_type) extracted from a `RankTwoTensor` specified by [!param](/UserObjects/MeshCut2DRankTwoTensorNucleation/tensor) (used to store stresses and strains in SolidMechanics),
such as a principal stress or a component of stress.

If the scalar exceeds a threshold specified by [!param](/UserObjects/MeshCut2DRankTwoTensorNucleation/nucleation_threshold), a line segment with a length specified by [!param](/UserObjects/MeshCut2DRankTwoTensorNucleation/nucleation_length) will be inserted
into the [MeshCut2DFractureUserObject.md] cutter mesh.
Cracks will nucleate on the domain interior or boundary.  Crack nucleation can be limited to elements on boundaries specified by [!param](/UserObjects/MeshCut2DRankTwoTensorNucleation/initiate_on_boundary).
Once the nucleation criterion is reached, a line segment of the specified length is inserted into the cutter mesh,
centered on the element centroid it nucleates from.
The direction of the nucleated crack is normal to the direction returned by the `RankTwoTensor` scalar.
For example, `MaxInPlanePrincipal` returns the direction of the maximum in-plane principal component and the crack direction is normal to this.
It is an error for [!param](/UserObjects/MeshCut2DRankTwoTensorNucleation/nucleation_length) to be smaller than the length of the element the crack nucleates in, unless the user sets `nucleate_across_full_element=true`.
A crack will only be nucleated if it is at least a distance specified by [!param](/UserObjects/MeshCut2DRankTwoTensorNucleation/nucleation_radius) away from existing or nucleated cracks.
If multiple cracks nucleate in the same xfem update and are within the specified `nucleation_radius`, the crack nucleated from the element with the lowest id will be retained and no other cracks within the `nucleation_radius` will be nucleated.  The `nucleation_radius` is a good way to limit the number of cracks that nucleate within a region, which can help limit problems related to excessive numbers of XFEM cuts in a single element.

`MeshCut2DRankTwoTensorNucleation` copies several features available in the [XFEMRankTwoTensorMarkerUserObject.md].
These include the nucleation threshold being provided as a coupled variable and the computation of the maximum value of the scalar
quantity used for nucleation.
By providing the nucleation threshold as a coupled variable, it can be specified as either a constant or variable value.
Coupled variable input is useful for introducing randomness in the strength by using an AuxVariable that has been initialized
with a random initial condition. For example, the [VolumeWeightedWeibull.md] initial condition is well-suited for this purpose.
The determination of crack nucleation is based on the average value of the scalar quantity over all the quadrature points in an element.

#### Example Input File Syntax





### NodeValueAtXFEMInterface


#### Overview

The values of field variables on either side of a moving interface are often needed to define the interface velocity. These variables and their gradients might be discontinuous across the interface. The fact that the interface does not lie on the standard quadrature points makes it difficult to get the quantities on the interface using existing functions in MOOSE.

`NodeValueAtXFEMInterface` provides functions to return the value of a field variable and its gradient on both the positive and negative sides of the interface. It is run on the nodes of the cutting mesh. Typically a node in the cut mesh lies within an element of the finite element mesh, and its location is determined by `PointLocator`. The value of a field variable at the node location will be obtained by an interpolation of element's (and the overlapping element's) node values and shape functions. The `NodeValueAtXFEMInterface` object is used by the `XFEMMovingInterfaceVelocityBase` derived class to calculate the velocity of the interface for moving interface problems.

#### Example Input File Syntax





### RectangleCutUserObject


#### Overview

The `RectangleCutUserObject` defines the boundary of a rectangular cut for XFEM
to make on a 3 dimensional mesh. The cut_data parameter is a vector of length
twelve that defines the x, y , and z Real values of the four vertices that form
the rectangular cut. The object calculates the midpoint of the rectangular cut
and normal, and includes logic to determine if a given point is located within
the cut plane.

#### Example Input Syntax





### XFEMPhaseTransitionMovingInterfaceVelocity


#### Overview

The `XFEMPhaseTransitionMovingInterfaceVelocity` calculates an interface velocity that is given as $v = \frac{[[ {D}\nabla {u}\cdot\text{n}]]}{[[ {u}]] + u_0}$.

#### Example Input File Syntax





### XFEMRankTwoTensorMarkerUserObject


#### Overview

This object is used to mark elements to be cut by XFEM based on a scalar extracted from a specified RankTwoTensor (used to store stresses and strains in SolidMechanics), such as a principal stress or a component of stress. All of the standard scalar types that can be extracted from RankTwoTensors are available. If the scalar exceeds a user-specified threshold, the crack extends into the current element. 

The threshold is provided as a coupled variable. This can be specified as either a constant value or as the name of that variable. This is useful for introducing randomness in the strength, by using an AuxVariable that has been initialized with a random initial condition.

The determination of whether an element cracks is based either on the maximum value of the scalar quantity at all of the quadrature points in an element, or on the average value. Cracks are allowed to propagate into new elements that exceed the criterion, or to initiate on specified boundaries.

#### Example Input File Syntax





